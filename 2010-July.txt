From grumbel at mail.berlios.de  Mon Jul 19 18:22:54 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Mon, 19 Jul 2010 18:22:54 +0200
Subject: [Windstille-commit] r3312 - trunk/windstille/src/sound
Message-ID: <20100719162255.0D0DF480AD1@sheep.berlios.de>

Author: grumbel
Date: 2010-07-19 18:22:54 +0200 (Mon, 19 Jul 2010)
New Revision: 3312

Modified:
   trunk/windstille/src/sound/sound_file.hpp
   trunk/windstille/src/sound/sound_manager.cpp
   trunk/windstille/src/sound/sound_manager.hpp
   trunk/windstille/src/sound/sound_source.hpp
   trunk/windstille/src/sound/stream_sound_source.cpp
   trunk/windstille/src/sound/stream_sound_source.hpp
Log:
Removed some friend relationships

Modified: trunk/windstille/src/sound/sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/sound_file.hpp	2010-06-01 19:43:58 UTC (rev 3311)
+++ trunk/windstille/src/sound/sound_file.hpp	2010-07-19 16:22:54 UTC (rev 3312)
@@ -25,17 +25,23 @@
 class SoundFile
 {
 public:
-  SoundFile() 
-    : channels(),
-      rate(),
-      bits_per_sample(),
-      size()
+  SoundFile() :
+    channels(),
+    rate(),
+    bits_per_sample(),
+    size()
   {}
   virtual ~SoundFile() {}
 
   virtual size_t read(void* buffer, size_t buffer_size) = 0;
   virtual void reset() = 0;
 
+  int    get_bits_per_sample() const { return bits_per_sample; }
+  size_t get_size() const { return size; }
+  int    get_rate() const { return rate; }
+  int    get_channels() const { return channels; }
+  
+protected:
   int channels;
   int rate;
   int bits_per_sample;

Modified: trunk/windstille/src/sound/sound_manager.cpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.cpp	2010-06-01 19:43:58 UTC (rev 3311)
+++ trunk/windstille/src/sound/sound_manager.cpp	2010-07-19 16:22:54 UTC (rev 3312)
@@ -109,15 +109,15 @@
   alGenBuffers(1, &buffer);
   check_al_error("Couldn't create audio buffer: ");
 
-  boost::scoped_array<char> samples(new char[file->size]);
+  boost::scoped_array<char> samples(new char[file->get_size()]);
 
   try 
     {
-      file->read(samples.get(), file->size);
+      file->read(samples.get(), file->get_size());
 
       alBufferData(buffer, format, samples.get(),
-                   static_cast<ALsizei> (file->size),
-                   static_cast<ALsizei> (file->rate));
+                   static_cast<ALsizei> (file->get_size()),
+                   static_cast<ALsizei> (file->get_rate()));
 
       check_al_error("Couldn't fill audio buffer: ");
     }
@@ -154,7 +154,7 @@
   
       std::auto_ptr<SoundSource> source(new SoundSource());
 
-      alSourcei(source->source, AL_BUFFER, buffer);
+      alSourcei(source->get_id(), AL_BUFFER, buffer);
 
       return source;
     }
@@ -171,8 +171,8 @@
         {
           if (pos == Vector2f(-1, -1)) 
             {
-              alSourcef(source->source, AL_ROLLOFF_FACTOR, 0);
-            } 
+              alSourcef(source->get_id(), AL_ROLLOFF_FACTOR, 0);
+            }
           else
             {
               source->set_position(pos);
@@ -248,7 +248,7 @@
             {
               std::auto_ptr<StreamSoundSource> newmusic(new StreamSoundSource(SoundFile::load(filename)));
 
-              alSourcef(newmusic->source, AL_ROLLOFF_FACTOR, 0);
+              alSourcef(newmusic->get_id(), AL_ROLLOFF_FACTOR, 0);
  
               if (fade) 
                 {
@@ -351,13 +351,13 @@
 ALenum
 SoundManager::get_sample_format(SoundFile* file)
 {
-  if (file->channels == 2) 
+  if (file->get_channels() == 2) 
     {
-      if (file->bits_per_sample == 16) 
+      if (file->get_bits_per_sample() == 16) 
         {
           return AL_FORMAT_STEREO16;
         } 
-      else if (file->bits_per_sample == 8) 
+      else if (file->get_bits_per_sample() == 8) 
         {
           return AL_FORMAT_STEREO8;
         }
@@ -366,13 +366,13 @@
           throw std::runtime_error("Only 16 and 8 bit samples supported");
         }
     } 
-  else if (file->channels == 1) 
+  else if (file->get_channels() == 1) 
     {
-      if (file->bits_per_sample == 16) 
+      if (file->get_bits_per_sample() == 16) 
         {
           return AL_FORMAT_MONO16;
         }
-      else if (file->bits_per_sample == 8) 
+      else if (file->get_bits_per_sample() == 8) 
         {
           return AL_FORMAT_MONO8;
         }

Modified: trunk/windstille/src/sound/sound_manager.hpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.hpp	2010-06-01 19:43:58 UTC (rev 3311)
+++ trunk/windstille/src/sound/sound_manager.hpp	2010-07-19 16:22:54 UTC (rev 3312)
@@ -64,10 +64,11 @@
 
   void update();
 
-private:
-  friend class SoundSource;
-  friend class StreamSoundSource;
+public:
+  static void check_al_error(const char* message);
+  static ALenum get_sample_format(SoundFile* file);
 
+private:
   /**
    * Creates a new sound source object which plays the specified soundfile.
    * You are responsible for deleting the sound source later (this will stop the
@@ -78,11 +79,9 @@
   std::auto_ptr<SoundSource> create_sound_source(const std::string& filename);
 
   static ALuint load_file_into_buffer(const std::string& filename);
-  static ALenum get_sample_format(SoundFile* file);
 
   void print_openal_version();
   void check_alc_error(const char* message);
-  static void check_al_error(const char* message);
 
   ALCdevice*  device;
   ALCcontext* context;

Modified: trunk/windstille/src/sound/sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/sound_source.hpp	2010-06-01 19:43:58 UTC (rev 3311)
+++ trunk/windstille/src/sound/sound_source.hpp	2010-07-19 16:22:54 UTC (rev 3312)
@@ -40,9 +40,9 @@
   void set_velocity(const Vector2f& position);
   void set_reference_distance(float distance);
 
+  ALuint get_id() const { return source; }
+  
 protected:
-  friend class SoundManager;
-  
   ALuint source;
 };
 

Modified: trunk/windstille/src/sound/stream_sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.cpp	2010-06-01 19:43:58 UTC (rev 3311)
+++ trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-19 16:22:54 UTC (rev 3312)
@@ -145,7 +145,7 @@
     } 
   while(bytesread < STREAMFRAGMENTSIZE);
   
-  alBufferData(buffer, format, bufferdata.get(), STREAMFRAGMENTSIZE, file->rate);
+  alBufferData(buffer, format, bufferdata.get(), STREAMFRAGMENTSIZE, file->get_rate());
 
   SoundManager::check_al_error("Couldn't refill audio buffer: ");
 

Modified: trunk/windstille/src/sound/stream_sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.hpp	2010-06-01 19:43:58 UTC (rev 3311)
+++ trunk/windstille/src/sound/stream_sound_source.hpp	2010-07-19 16:22:54 UTC (rev 3312)
@@ -31,7 +31,18 @@
 public:
   enum FadeState { NoFading, FadingOn, FadingOff };
 
+public:
+  StreamSoundSource(std::auto_ptr<SoundFile> file);
+  virtual ~StreamSoundSource();
+
+  void setFading(FadeState state, float fadetime);
+  FadeState getFadeState() const { return fade_state; }
+  void update();
+  
 private:
+  void fillBufferAndQueue(ALuint buffer);
+
+private:
   static const size_t STREAMBUFFERSIZE   = 1024 * 500;
   static const size_t STREAMFRAGMENTS    = 5;
   static const size_t STREAMFRAGMENTSIZE = STREAMBUFFERSIZE / STREAMFRAGMENTS;
@@ -43,17 +54,6 @@
   FadeState fade_state;
   unsigned int fade_start_ticks;
   float fade_time;
-
-public:
-  StreamSoundSource(std::auto_ptr<SoundFile> file);
-  virtual ~StreamSoundSource();
-
-  void setFading(FadeState state, float fadetime);
-  FadeState getFadeState() const { return fade_state; }
-  void update();
-  
-private:
-  void fillBufferAndQueue(ALuint buffer);
 };
 
 #endif



From grumbel at mail.berlios.de  Mon Jul 19 19:53:58 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Mon, 19 Jul 2010 19:53:58 +0200
Subject: [Windstille-commit] r3313 - trunk/windstille/src/sound
Message-ID: <20100719175358.BDAD5480B05@sheep.berlios.de>

Author: grumbel
Date: 2010-07-19 19:53:58 +0200 (Mon, 19 Jul 2010)
New Revision: 3313

Modified:
   trunk/windstille/src/sound/ogg_sound_file.cpp
   trunk/windstille/src/sound/sound_file.cpp
   trunk/windstille/src/sound/sound_manager.cpp
   trunk/windstille/src/sound/stream_sound_source.cpp
   trunk/windstille/src/sound/wav_sound_file.cpp
Log:
Reindented to fit style guide

Modified: trunk/windstille/src/sound/ogg_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-19 16:22:54 UTC (rev 3312)
+++ trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-19 17:53:58 UTC (rev 3313)
@@ -47,7 +47,7 @@
   while(buffer_size>0){
     long bytesRead 
       = ov_read(&vorbis_file, buffer, static_cast<int> (buffer_size), 0, 2, 1,
-          &section);
+                &section);
     if(bytesRead==0){
       break;
     }
@@ -72,7 +72,7 @@
   
   PHYSFS_sint64 res 
     = PHYSFS_read(file, ptr, static_cast<PHYSFS_uint32> (size),
-        static_cast<PHYSFS_uint32> (nmemb));
+                  static_cast<PHYSFS_uint32> (nmemb));
   if(res <= 0)
     return 0;
 

Modified: trunk/windstille/src/sound/sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/sound_file.cpp	2010-07-19 16:22:54 UTC (rev 3312)
+++ trunk/windstille/src/sound/sound_file.cpp	2010-07-19 17:53:58 UTC (rev 3313)
@@ -31,46 +31,46 @@
   PHYSFS_file* file = PHYSFS_openRead(filename.c_str());
 
   if (!file) 
-    {
-      std::stringstream msg;
-      msg << "Couldn't open '" << filename << "': " << PHYSFS_getLastError();
-      throw std::runtime_error(msg.str());
-    }
+  {
+    std::stringstream msg;
+    msg << "Couldn't open '" << filename << "': " << PHYSFS_getLastError();
+    throw std::runtime_error(msg.str());
+  }
   else
+  {
+    try 
     {
-      try 
-        {
-          char magic[4];
+      char magic[4];
 
-          if (PHYSFS_read(file, magic, sizeof(magic), 1) != 1)
-            {
-              throw std::runtime_error("Couldn't read magic, file too short");
-            }
-          else
-            {
-              PHYSFS_seek(file, 0);
+      if (PHYSFS_read(file, magic, sizeof(magic), 1) != 1)
+      {
+        throw std::runtime_error("Couldn't read magic, file too short");
+      }
+      else
+      {
+        PHYSFS_seek(file, 0);
 
-              if (strncmp(magic, "RIFF", 4) == 0)
-                {
-                  return std::auto_ptr<SoundFile>(new WavSoundFile(file));
-                }
-              else if (strncmp(magic, "OggS", 4) == 0)
-                {
-                  return std::auto_ptr<SoundFile>(new OggSoundFile(file));
-                }
-              else
-                {
-                  throw std::runtime_error("Unknown file format");
-                }
-            }
-        } 
-      catch(std::exception& e) 
+        if (strncmp(magic, "RIFF", 4) == 0)
         {
-          std::stringstream msg;
-          msg << "Couldn't read '" << filename << "': " << e.what();
-          throw std::runtime_error(msg.str());
+          return std::auto_ptr<SoundFile>(new WavSoundFile(file));
         }
+        else if (strncmp(magic, "OggS", 4) == 0)
+        {
+          return std::auto_ptr<SoundFile>(new OggSoundFile(file));
+        }
+        else
+        {
+          throw std::runtime_error("Unknown file format");
+        }
+      }
+    } 
+    catch(std::exception& e) 
+    {
+      std::stringstream msg;
+      msg << "Couldn't read '" << filename << "': " << e.what();
+      throw std::runtime_error(msg.str());
     }
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/sound/sound_manager.cpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.cpp	2010-07-19 16:22:54 UTC (rev 3312)
+++ trunk/windstille/src/sound/sound_manager.cpp	2010-07-19 17:53:58 UTC (rev 3313)
@@ -39,39 +39,39 @@
     current_music()
 {
   try 
+  {
+    device = alcOpenDevice(0);
+
+    if (!device)
     {
-      device = alcOpenDevice(0);
+      print_openal_version();
+      throw std::runtime_error("Couldn't open audio device.");
+    }
+    else
+    {
+      int attributes[] = { 0 };
 
-      if (!device)
-        {
-          print_openal_version();
-          throw std::runtime_error("Couldn't open audio device.");
-        }
-      else
-        {
-          int attributes[] = { 0 };
+      context = alcCreateContext(device, attributes);
+      check_alc_error("Couldn't create audio context: ");
 
-          context = alcCreateContext(device, attributes);
-          check_alc_error("Couldn't create audio context: ");
+      alcMakeContextCurrent(context);
+      check_alc_error("Couldn't select audio context: ");
 
-          alcMakeContextCurrent(context);
-          check_alc_error("Couldn't select audio context: ");
-
-          check_al_error("Audio error after init: ");
-          sound_enabled = true;
-        }
-    } 
+      check_al_error("Audio error after init: ");
+      sound_enabled = true;
+    }
+  } 
   catch(std::exception& e) 
-    { // disable sound
-      device  = 0;
-      context = 0;
-      sound_enabled = false;
+  { // disable sound
+    device  = 0;
+    context = 0;
+    sound_enabled = false;
 
-      std::cerr << "Couldn't initialize audio device:" << e.what() << "\n";
-      print_openal_version();
+    std::cerr << "Couldn't initialize audio device:" << e.what() << "\n";
+    print_openal_version();
       
-      std::cout << "Disabling sound\n";
-    }
+    std::cout << "Disabling sound\n";
+  }
 }
 
 SoundManager::~SoundManager()
@@ -82,20 +82,20 @@
   sources.clear();
 
   for(SoundBuffers::iterator i = buffers.begin(); i != buffers.end(); ++i) 
-    {
-      ALuint buffer = i->second;
-      alDeleteBuffers(1, &buffer);
-    }
+  {
+    ALuint buffer = i->second;
+    alDeleteBuffers(1, &buffer);
+  }
 
   if (context != 0) 
-    {
-      alcDestroyContext(context);
-    }
+  {
+    alcDestroyContext(context);
+  }
 
   if (device != 0)
-    {
-      alcCloseDevice(device);
-    }
+  {
+    alcCloseDevice(device);
+  }
 }
 
 ALuint
@@ -112,19 +112,19 @@
   boost::scoped_array<char> samples(new char[file->get_size()]);
 
   try 
-    {
-      file->read(samples.get(), file->get_size());
+  {
+    file->read(samples.get(), file->get_size());
 
-      alBufferData(buffer, format, samples.get(),
-                   static_cast<ALsizei> (file->get_size()),
-                   static_cast<ALsizei> (file->get_rate()));
+    alBufferData(buffer, format, samples.get(),
+                 static_cast<ALsizei> (file->get_size()),
+                 static_cast<ALsizei> (file->get_rate()));
 
-      check_al_error("Couldn't fill audio buffer: ");
-    }
+    check_al_error("Couldn't fill audio buffer: ");
+  }
   catch(...) 
-    {
-      throw;
-    }
+  {
+    throw;
+  }
 
   return buffer;
 }
@@ -133,147 +133,147 @@
 SoundManager::create_sound_source(const std::string& filename)
 {
   if (!sound_enabled)
+  {
+    return std::auto_ptr<SoundSource>();
+  }
+  else
+  {
+    ALuint buffer;
+  
+    // reuse an existing static sound buffer            
+    SoundBuffers::iterator i = buffers.find(filename);
+    if (i != buffers.end()) 
     {
-      return std::auto_ptr<SoundSource>();
+      buffer = i->second;
+    } 
+    else 
+    {
+      buffer = load_file_into_buffer(filename);
+      buffers.insert(std::make_pair(filename, buffer));
     }
-  else
-    {
-      ALuint buffer;
   
-      // reuse an existing static sound buffer            
-      SoundBuffers::iterator i = buffers.find(filename);
-      if (i != buffers.end()) 
-        {
-          buffer = i->second;
-        } 
-      else 
-        {
-          buffer = load_file_into_buffer(filename);
-          buffers.insert(std::make_pair(filename, buffer));
-        }
-  
-      std::auto_ptr<SoundSource> source(new SoundSource());
+    std::auto_ptr<SoundSource> source(new SoundSource());
 
-      alSourcei(source->get_id(), AL_BUFFER, buffer);
+    alSourcei(source->get_id(), AL_BUFFER, buffer);
 
-      return source;
-    }
+    return source;
+  }
 }
 
 void
 SoundManager::play(const std::string& filename, const Vector2f& pos)
 {
   try
+  {
+    std::auto_ptr<SoundSource> source = create_sound_source(filename);
+
+    if (source.get())
     {
-      std::auto_ptr<SoundSource> source = create_sound_source(filename);
+      if (pos == Vector2f(-1, -1)) 
+      {
+        alSourcef(source->get_id(), AL_ROLLOFF_FACTOR, 0);
+      }
+      else
+      {
+        source->set_position(pos);
+      }
 
-      if (source.get())
-        {
-          if (pos == Vector2f(-1, -1)) 
-            {
-              alSourcef(source->get_id(), AL_ROLLOFF_FACTOR, 0);
-            }
-          else
-            {
-              source->set_position(pos);
-            }
-
-          source->play();
-          sources.push_back(boost::shared_ptr<SoundSource>(source.release()));
-        }
+      source->play();
+      sources.push_back(boost::shared_ptr<SoundSource>(source.release()));
     }
+  }
   catch(std::exception& e) 
-    {
-      std::cout << "Couldn't play sound " << filename << ": " << e.what() << "\n";
-    }
+  {
+    std::cout << "Couldn't play sound " << filename << ": " << e.what() << "\n";
+  }
 }
 
 void
 SoundManager::enable_sound(bool enable)
 {
   if (device)
-    {
-      sound_enabled = enable;
-    }
+  {
+    sound_enabled = enable;
+  }
 }
 
 void
 SoundManager::enable_music(bool enable)
 {
   if (device)
+  {
+    music_enabled = enable;
+
+    if (music_enabled) 
     {
-      music_enabled = enable;
-
-      if (music_enabled) 
-        {
-          play_music(current_music);
-        } 
-      else 
-        {
-          if (music_source.get())
-            {
-              music_source.reset();
-            }
-        }
+      play_music(current_music);
+    } 
+    else 
+    {
+      if (music_source.get())
+      {
+        music_source.reset();
+      }
     }
+  }
 }
 
 void
 SoundManager::stop_music(bool fade)
 {
   if (fade) 
+  {
+    if (music_source.get() &&
+        music_source->getFadeState() != StreamSoundSource::FadingOff)
     {
-      if (music_source.get() &&
-          music_source->getFadeState() != StreamSoundSource::FadingOff)
-        {
-          music_source->setFading(StreamSoundSource::FadingOff, .7f);
-        }
-    } 
+      music_source->setFading(StreamSoundSource::FadingOff, .7f);
+    }
+  } 
   else 
-    {
-      music_source.reset();
-    }
+  {
+    music_source.reset();
+  }
 }
 
 void
 SoundManager::play_music(const std::string& filename, bool fade)
 {
   if (filename != current_music)
+  {
+    current_music = filename;
+
+    if (music_enabled)
     {
-      current_music = filename;
+      try 
+      {
+        std::auto_ptr<StreamSoundSource> newmusic(new StreamSoundSource(SoundFile::load(filename)));
 
-      if (music_enabled)
+        alSourcef(newmusic->get_id(), AL_ROLLOFF_FACTOR, 0);
+ 
+        if (fade) 
         {
-          try 
-            {
-              std::auto_ptr<StreamSoundSource> newmusic(new StreamSoundSource(SoundFile::load(filename)));
+          if (music_source.get() &&
+              music_source->getFadeState() != StreamSoundSource::FadingOff)
+          {
+            music_source->setFading(StreamSoundSource::FadingOff, .7f);
+          }
 
-              alSourcef(newmusic->get_id(), AL_ROLLOFF_FACTOR, 0);
- 
-              if (fade) 
-                {
-                  if (music_source.get() &&
-                      music_source->getFadeState() != StreamSoundSource::FadingOff)
-                    {
-                      music_source->setFading(StreamSoundSource::FadingOff, .7f);
-                    }
-
-                  next_music_source = newmusic;
-                } 
-              else 
-                {
-                  music_source = newmusic;
-                  music_source->play();
-                  next_music_source.reset();
-                }
-            }
-          catch(std::exception& e) 
-            {
-              std::cerr << "Couldn't play music file '" << filename << "': "
-                        << e.what() << "\n";
-            }
+          next_music_source = newmusic;
+        } 
+        else 
+        {
+          music_source = newmusic;
+          music_source->play();
+          next_music_source.reset();
         }
+      }
+      catch(std::exception& e) 
+      {
+        std::cerr << "Couldn't play music file '" << filename << "': "
+                  << e.what() << "\n";
+      }
     }
+  }
 }
 
 void
@@ -316,75 +316,75 @@
 SoundManager::update()
 {
   if (sound_enabled)
+  {
+    // check for finished sound sources
+    for(SoundSources::iterator i = sources.begin(); i != sources.end(); ) 
     {
-      // check for finished sound sources
-      for(SoundSources::iterator i = sources.begin(); i != sources.end(); ) 
-        {
-          if (!(*i)->playing())
-            {
-              i = sources.erase(i);
-            } 
-          else 
-            {
-              ++i;
-            }
-        }
+      if (!(*i)->playing())
+      {
+        i = sources.erase(i);
+      } 
+      else 
+      {
+        ++i;
+      }
+    }
 
-      // check streaming sounds
-      if (music_source.get()) 
-        {
-          music_source->update();
-        }
+    // check streaming sounds
+    if (music_source.get()) 
+    {
+      music_source->update();
+    }
   
-      if (next_music_source.get() && (!music_source.get() || !music_source->playing())) 
-        {
-          music_source = next_music_source;
-          //music_source->setFading(StreamSoundSource::FadingOn, 1.0f);
-          music_source->play();
-        }
+    if (next_music_source.get() && (!music_source.get() || !music_source->playing())) 
+    {
+      music_source = next_music_source;
+      //music_source->setFading(StreamSoundSource::FadingOn, 1.0f);
+      music_source->play();
+    }
   
-      alcProcessContext(context);
-      check_alc_error("Error while processing audio context: ");
-    }
+    alcProcessContext(context);
+    check_alc_error("Error while processing audio context: ");
+  }
 }
 
 ALenum
 SoundManager::get_sample_format(SoundFile* file)
 {
   if (file->get_channels() == 2) 
+  {
+    if (file->get_bits_per_sample() == 16) 
     {
-      if (file->get_bits_per_sample() == 16) 
-        {
-          return AL_FORMAT_STEREO16;
-        } 
-      else if (file->get_bits_per_sample() == 8) 
-        {
-          return AL_FORMAT_STEREO8;
-        }
-      else 
-        {
-          throw std::runtime_error("Only 16 and 8 bit samples supported");
-        }
+      return AL_FORMAT_STEREO16;
     } 
+    else if (file->get_bits_per_sample() == 8) 
+    {
+      return AL_FORMAT_STEREO8;
+    }
+    else 
+    {
+      throw std::runtime_error("Only 16 and 8 bit samples supported");
+    }
+  } 
   else if (file->get_channels() == 1) 
+  {
+    if (file->get_bits_per_sample() == 16) 
     {
-      if (file->get_bits_per_sample() == 16) 
-        {
-          return AL_FORMAT_MONO16;
-        }
-      else if (file->get_bits_per_sample() == 8) 
-        {
-          return AL_FORMAT_MONO8;
-        }
-      else 
-        {
-          throw std::runtime_error("Only 16 and 8 bit samples supported");
-        }
+      return AL_FORMAT_MONO16;
     }
-  else 
+    else if (file->get_bits_per_sample() == 8) 
     {
-      throw std::runtime_error("Only 1 and 2 channel samples supported");
+      return AL_FORMAT_MONO8;
     }
+    else 
+    {
+      throw std::runtime_error("Only 16 and 8 bit samples supported");
+    }
+  }
+  else 
+  {
+    throw std::runtime_error("Only 1 and 2 channel samples supported");
+  }
 }
 
 void
@@ -402,11 +402,11 @@
   int err = alcGetError(device);
 
   if (err != ALC_NO_ERROR) 
-    {
-      std::stringstream msg;
-      msg << message << alcGetString(device, err);
-      throw std::runtime_error(msg.str());
-    }                
+  {
+    std::stringstream msg;
+    msg << message << alcGetString(device, err);
+    throw std::runtime_error(msg.str());
+  }                
 }
 
 void
@@ -415,11 +415,11 @@
   int err = alGetError();
 
   if (err != AL_NO_ERROR) 
-    {
-      std::stringstream msg;
-      msg << message << alGetString(err);
-      throw std::runtime_error(msg.str());
-    }  
+  {
+    std::stringstream msg;
+    msg << message << alGetString(err);
+    throw std::runtime_error(msg.str());
+  }  
 }
 
 /* EOF */

Modified: trunk/windstille/src/sound/stream_sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-19 16:22:54 UTC (rev 3312)
+++ trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-19 17:53:58 UTC (rev 3313)
@@ -63,59 +63,59 @@
 StreamSoundSource::update()
 {
   if (playing())
+  {
+    ALint processed = 0;
+    alGetSourcei(source, AL_BUFFERS_PROCESSED, &processed);
+
+    while (processed > 0) 
     {
-      ALint processed = 0;
-      alGetSourcei(source, AL_BUFFERS_PROCESSED, &processed);
+      processed--;
 
-      while (processed > 0) 
-        {
-          processed--;
+      ALuint buffer;
+      alSourceUnqueueBuffers(source, 1, &buffer);
+      SoundManager::check_al_error("Couldn't unqueu audio buffer: ");
 
-          ALuint buffer;
-          alSourceUnqueueBuffers(source, 1, &buffer);
-          SoundManager::check_al_error("Couldn't unqueu audio buffer: ");
-
-          fillBufferAndQueue(buffer);
-        }
+      fillBufferAndQueue(buffer);
+    }
   
-      // we might have to restart the source if we had a buffer underrun
-      if (!playing()) 
-        {
-          std::cerr << "Restarting audio source because of buffer underrun.\n";
-          alSourcePlay(source);
-          SoundManager::check_al_error("Couldn't restart audio source: ");
-        }
+    // we might have to restart the source if we had a buffer underrun
+    if (!playing()) 
+    {
+      std::cerr << "Restarting audio source because of buffer underrun.\n";
+      alSourcePlay(source);
+      SoundManager::check_al_error("Couldn't restart audio source: ");
+    }
 
-      if (fade_state == FadingOn) 
-        {
-          unsigned int ticks = SDL_GetTicks();
-          float time = static_cast<float>(ticks - fade_start_ticks) / 1000.0f;
-          if (time >= fade_time)
-            {
-              set_gain(1.0);
-              fade_state = NoFading;
-            } 
-          else 
-            {
-              set_gain(time / fade_time);
-            }
-        } 
-      else if (fade_state == FadingOff) 
-        {
-          unsigned int ticks = SDL_GetTicks();
-          float time = static_cast<float>(ticks - fade_start_ticks) / 1000.0f;
+    if (fade_state == FadingOn) 
+    {
+      unsigned int ticks = SDL_GetTicks();
+      float time = static_cast<float>(ticks - fade_start_ticks) / 1000.0f;
+      if (time >= fade_time)
+      {
+        set_gain(1.0);
+        fade_state = NoFading;
+      } 
+      else 
+      {
+        set_gain(time / fade_time);
+      }
+    } 
+    else if (fade_state == FadingOff) 
+    {
+      unsigned int ticks = SDL_GetTicks();
+      float time = static_cast<float>(ticks - fade_start_ticks) / 1000.0f;
 
-          if (time >= fade_time) 
-            {
-              stop();
-              fade_state = NoFading;
-            } 
-          else 
-            {
-              set_gain( (fade_time-time) / fade_time);
-            }
-        }
+      if (time >= fade_time) 
+      {
+        stop();
+        fade_state = NoFading;
+      } 
+      else 
+      {
+        set_gain( (fade_time-time) / fade_time);
+      }
     }
+  }
 }
 
 void
@@ -134,15 +134,15 @@
   size_t bytesread = 0;
 
   do 
+  {
+    bytesread += file->read(bufferdata.get() + bytesread,
+                            STREAMFRAGMENTSIZE - bytesread);
+      
+    if (bytesread < STREAMFRAGMENTSIZE) 
     {
-      bytesread += file->read(bufferdata.get() + bytesread,
-                              STREAMFRAGMENTSIZE - bytesread);
-      
-      if (bytesread < STREAMFRAGMENTSIZE) 
-        {
-          file->reset();
-        }
-    } 
+      file->reset();
+    }
+  } 
   while(bytesread < STREAMFRAGMENTSIZE);
   
   alBufferData(buffer, format, bufferdata.get(), STREAMFRAGMENTSIZE, file->get_rate());

Modified: trunk/windstille/src/sound/wav_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/wav_sound_file.cpp	2010-07-19 16:22:54 UTC (rev 3312)
+++ trunk/windstille/src/sound/wav_sound_file.cpp	2010-07-19 17:53:58 UTC (rev 3313)
@@ -74,7 +74,7 @@
       break;
 
     if(strncmp(chunkmagic, "fact", 4) == 0
-        || strncmp(chunkmagic, "LIST", 4) == 0) {
+       || strncmp(chunkmagic, "LIST", 4) == 0) {
       // skip chunk
       if(PHYSFS_seek(file, PHYSFS_tell(file) + chunklen) == 0)
         throw std::runtime_error("EOF while searching fmt chunk");



From grumbel at mail.berlios.de  Mon Jul 19 21:29:55 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Mon, 19 Jul 2010 21:29:55 +0200
Subject: [Windstille-commit] r3314 - trunk/windstille/src/sound
Message-ID: <20100719192955.536CB480B05@sheep.berlios.de>

Author: grumbel
Date: 2010-07-19 21:29:55 +0200 (Mon, 19 Jul 2010)
New Revision: 3314

Modified:
   trunk/windstille/src/sound/sound_manager.cpp
   trunk/windstille/src/sound/sound_manager.hpp
   trunk/windstille/src/sound/sound_source.cpp
   trunk/windstille/src/sound/sound_source.hpp
   trunk/windstille/src/sound/stream_sound_source.cpp
Log:
Some more style fixes

Modified: trunk/windstille/src/sound/sound_manager.cpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.cpp	2010-07-19 17:53:58 UTC (rev 3313)
+++ trunk/windstille/src/sound/sound_manager.cpp	2010-07-19 19:29:55 UTC (rev 3314)
@@ -27,45 +27,44 @@
 #include "sound/sound_manager.hpp"
 
 
-SoundManager::SoundManager()
-  : device(0), 
-    context(0), 
-    sound_enabled(false), 
-    buffers(),
-    sources(),
-    music_source(),
-    next_music_source(),
-    music_enabled(true),
-    current_music()
+SoundManager::SoundManager() :
+  m_device(0), 
+  m_context(0), 
+  m_sound_enabled(false), 
+  m_channel(*this),
+  m_buffers(),
+  m_sources(),
+  m_music_source(),
+  m_next_music_source(),
+  m_music_enabled(true),
+  m_current_music()
 {
   try 
   {
-    device = alcOpenDevice(0);
+    m_device = alcOpenDevice(NULL);
 
-    if (!device)
+    if (!m_device)
     {
       print_openal_version();
       throw std::runtime_error("Couldn't open audio device.");
     }
     else
     {
-      int attributes[] = { 0 };
-
-      context = alcCreateContext(device, attributes);
+      m_context = alcCreateContext(m_device, NULL);
       check_alc_error("Couldn't create audio context: ");
 
-      alcMakeContextCurrent(context);
+      alcMakeContextCurrent(m_context);
       check_alc_error("Couldn't select audio context: ");
 
       check_al_error("Audio error after init: ");
-      sound_enabled = true;
+      m_sound_enabled = true;
     }
   } 
   catch(std::exception& e) 
   { // disable sound
-    device  = 0;
-    context = 0;
-    sound_enabled = false;
+    m_device  = 0;
+    m_context = 0;
+    m_sound_enabled = false;
 
     std::cerr << "Couldn't initialize audio device:" << e.what() << "\n";
     print_openal_version();
@@ -76,25 +75,25 @@
 
 SoundManager::~SoundManager()
 {
-  music_source.reset();
-  next_music_source.reset();
+  m_music_source.reset();
+  m_next_music_source.reset();
 
-  sources.clear();
+  m_sources.clear();
 
-  for(SoundBuffers::iterator i = buffers.begin(); i != buffers.end(); ++i) 
+  for(SoundBuffers::iterator i = m_buffers.begin(); i != m_buffers.end(); ++i) 
   {
     ALuint buffer = i->second;
     alDeleteBuffers(1, &buffer);
   }
 
-  if (context != 0) 
+  if (m_context)
   {
-    alcDestroyContext(context);
+    alcDestroyContext(m_context);
   }
 
-  if (device != 0)
+  if (m_device)
   {
-    alcCloseDevice(device);
+    alcCloseDevice(m_device);
   }
 }
 
@@ -109,10 +108,10 @@
   alGenBuffers(1, &buffer);
   check_al_error("Couldn't create audio buffer: ");
 
-  boost::scoped_array<char> samples(new char[file->get_size()]);
-
   try 
   {
+    boost::scoped_array<char> samples(new char[file->get_size()]);
+    
     file->read(samples.get(), file->get_size());
 
     alBufferData(buffer, format, samples.get(),
@@ -132,7 +131,7 @@
 std::auto_ptr<SoundSource>
 SoundManager::create_sound_source(const std::string& filename)
 {
-  if (!sound_enabled)
+  if (!m_sound_enabled)
   {
     return std::auto_ptr<SoundSource>();
   }
@@ -141,15 +140,15 @@
     ALuint buffer;
   
     // reuse an existing static sound buffer            
-    SoundBuffers::iterator i = buffers.find(filename);
-    if (i != buffers.end()) 
+    SoundBuffers::iterator i = m_buffers.find(filename);
+    if (i != m_buffers.end()) 
     {
       buffer = i->second;
     } 
     else 
     {
       buffer = load_file_into_buffer(filename);
-      buffers.insert(std::make_pair(filename, buffer));
+      m_buffers.insert(std::make_pair(filename, buffer));
     }
   
     std::auto_ptr<SoundSource> source(new SoundSource());
@@ -179,7 +178,7 @@
       }
 
       source->play();
-      sources.push_back(boost::shared_ptr<SoundSource>(source.release()));
+      m_sources.push_back(boost::shared_ptr<SoundSource>(source.release()));
     }
   }
   catch(std::exception& e) 
@@ -191,28 +190,28 @@
 void
 SoundManager::enable_sound(bool enable)
 {
-  if (device)
+  if (m_device)
   {
-    sound_enabled = enable;
+    m_sound_enabled = enable;
   }
 }
 
 void
 SoundManager::enable_music(bool enable)
 {
-  if (device)
+  if (m_device)
   {
-    music_enabled = enable;
+    m_music_enabled = enable;
 
-    if (music_enabled) 
+    if (m_music_enabled) 
     {
-      play_music(current_music);
+      play_music(m_current_music);
     } 
     else 
     {
-      if (music_source.get())
+      if (m_music_source.get())
       {
-        music_source.reset();
+        m_music_source.reset();
       }
     }
   }
@@ -223,26 +222,26 @@
 {
   if (fade) 
   {
-    if (music_source.get() &&
-        music_source->getFadeState() != StreamSoundSource::FadingOff)
+    if (m_music_source.get() &&
+        m_music_source->getFadeState() != StreamSoundSource::FadingOff)
     {
-      music_source->setFading(StreamSoundSource::FadingOff, .7f);
+      m_music_source->setFading(StreamSoundSource::FadingOff, .7f);
     }
   } 
   else 
   {
-    music_source.reset();
+    m_music_source.reset();
   }
 }
 
 void
 SoundManager::play_music(const std::string& filename, bool fade)
 {
-  if (filename != current_music)
+  if (filename != m_current_music)
   {
-    current_music = filename;
+    m_current_music = filename;
 
-    if (music_enabled)
+    if (m_music_enabled)
     {
       try 
       {
@@ -252,19 +251,19 @@
  
         if (fade) 
         {
-          if (music_source.get() &&
-              music_source->getFadeState() != StreamSoundSource::FadingOff)
+          if (m_music_source.get() &&
+              m_music_source->getFadeState() != StreamSoundSource::FadingOff)
           {
-            music_source->setFading(StreamSoundSource::FadingOff, .7f);
+            m_music_source->setFading(StreamSoundSource::FadingOff, .7f);
           }
 
-          next_music_source = newmusic;
+          m_next_music_source = newmusic;
         } 
         else 
         {
-          music_source = newmusic;
-          music_source->play();
-          next_music_source.reset();
+          m_music_source = newmusic;
+          m_music_source->play();
+          m_next_music_source.reset();
         }
       }
       catch(std::exception& e) 
@@ -315,14 +314,14 @@
 void
 SoundManager::update()
 {
-  if (sound_enabled)
+  if (m_sound_enabled)
   {
     // check for finished sound sources
-    for(SoundSources::iterator i = sources.begin(); i != sources.end(); ) 
+    for(SoundSources::iterator i = m_sources.begin(); i != m_sources.end(); ) 
     {
       if (!(*i)->playing())
       {
-        i = sources.erase(i);
+        i = m_sources.erase(i);
       } 
       else 
       {
@@ -331,19 +330,19 @@
     }
 
     // check streaming sounds
-    if (music_source.get()) 
+    if (m_music_source.get()) 
     {
-      music_source->update();
+      m_music_source->update();
     }
   
-    if (next_music_source.get() && (!music_source.get() || !music_source->playing())) 
+    if (m_next_music_source.get() && (!m_music_source.get() || !m_music_source->playing())) 
     {
-      music_source = next_music_source;
+      m_music_source = m_next_music_source;
       //music_source->setFading(StreamSoundSource::FadingOn, 1.0f);
-      music_source->play();
+      m_music_source->play();
     }
   
-    alcProcessContext(context);
+    alcProcessContext(m_context);
     check_alc_error("Error while processing audio context: ");
   }
 }
@@ -393,18 +392,18 @@
   std::cout << "OpenAL Vendor: " << alGetString(AL_VENDOR) << "\n"
             << "OpenAL Version: " << alGetString(AL_VERSION) << "\n" 
             << "OpenAL Renderer: " << alGetString(AL_RENDERER) << "\n"
-            << "OpenAl Extensions: " << alGetString(AL_RENDERER) << "\n";
+            << "OpenAL Extensions: " << alGetString(AL_RENDERER) << "\n";
 }
 
 void
 SoundManager::check_alc_error(const char* message)
 {
-  int err = alcGetError(device);
+  int err = alcGetError(m_device);
 
   if (err != ALC_NO_ERROR) 
   {
     std::stringstream msg;
-    msg << message << alcGetString(device, err);
+    msg << message << alcGetString(m_device, err);
     throw std::runtime_error(msg.str());
   }                
 }
@@ -414,7 +413,7 @@
 {
   int err = alGetError();
 
-  if (err != AL_NO_ERROR) 
+  if (err != AL_NO_ERROR)
   {
     std::stringstream msg;
     msg << message << alGetString(err);

Modified: trunk/windstille/src/sound/sound_manager.hpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.hpp	2010-07-19 17:53:58 UTC (rev 3313)
+++ trunk/windstille/src/sound/sound_manager.hpp	2010-07-19 19:29:55 UTC (rev 3314)
@@ -31,6 +31,8 @@
 #include "math/vector2f.hpp"
 #include "util/currenton.hpp"
 
+#include "sound/sound_channel.hpp"
+
 typedef void* SoundHandle;
 
 class SoundFile;
@@ -68,7 +70,6 @@
   static void check_al_error(const char* message);
   static ALenum get_sample_format(SoundFile* file);
 
-private:
   /**
    * Creates a new sound source object which plays the specified soundfile.
    * You are responsible for deleting the sound source later (this will stop the
@@ -78,25 +79,28 @@
    */
   std::auto_ptr<SoundSource> create_sound_source(const std::string& filename);
 
+private:
   static ALuint load_file_into_buffer(const std::string& filename);
 
   void print_openal_version();
   void check_alc_error(const char* message);
 
-  ALCdevice*  device;
-  ALCcontext* context;
-  bool sound_enabled;
+  ALCdevice*  m_device;
+  ALCcontext* m_context;
+  bool m_sound_enabled;
 
+  SoundChannel m_channel;
+
   typedef std::map<std::string, ALuint> SoundBuffers;
-  SoundBuffers buffers;
+  SoundBuffers m_buffers;
   typedef std::vector<boost::shared_ptr<SoundSource> > SoundSources;
-  SoundSources sources;
+  SoundSources m_sources;
 
-  std::auto_ptr<StreamSoundSource> music_source;
-  std::auto_ptr<StreamSoundSource> next_music_source;
+  std::auto_ptr<StreamSoundSource> m_music_source;
+  std::auto_ptr<StreamSoundSource> m_next_music_source;
 
-  bool music_enabled;
-  std::string current_music;
+  bool m_music_enabled;
+  std::string m_current_music;
 
 private:
   SoundManager(const SoundManager&);

Modified: trunk/windstille/src/sound/sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/sound_source.cpp	2010-07-19 17:53:58 UTC (rev 3313)
+++ trunk/windstille/src/sound/sound_source.cpp	2010-07-19 19:29:55 UTC (rev 3314)
@@ -19,10 +19,10 @@
 #include "sound/sound_source.hpp"
 #include "sound/sound_manager.hpp"
 
-SoundSource::SoundSource()
-  : source()
+SoundSource::SoundSource() :
+  m_source()
 {
-  alGenSources(1, &source);
+  alGenSources(1, &m_source);
   SoundManager::check_al_error("Couldn't create audio source: ");
   set_reference_distance(128);
 }
@@ -30,21 +30,21 @@
 SoundSource::~SoundSource()
 {
   stop();
-  alDeleteSources(1, &source);
+  alDeleteSources(1, &m_source);
 }
 
 void
 SoundSource::stop()
 {
-  alSourceStop(source);
-  alSourcei(source, AL_BUFFER, AL_NONE);
+  alSourceStop(m_source);
+  alSourcei(m_source, AL_BUFFER, AL_NONE);
   SoundManager::check_al_error("Problem stopping audio source: ");
 }
 
 void
 SoundSource::play()
 {
-  alSourcePlay(source);
+  alSourcePlay(m_source);
   SoundManager::check_al_error("Couldn't start audio source: ");
 }
 
@@ -52,38 +52,44 @@
 SoundSource::playing()
 {
   ALint state = AL_PLAYING;
-  alGetSourcei(source, AL_SOURCE_STATE, &state);
+  alGetSourcei(m_source, AL_SOURCE_STATE, &state);
   return state != AL_STOPPED;
 }
 
 void
 SoundSource::set_looping(bool looping)
 {
-  alSourcei(source, AL_LOOPING, looping ? AL_TRUE : AL_FALSE);
+  alSourcei(m_source, AL_LOOPING, looping ? AL_TRUE : AL_FALSE);
 }
 
 void
 SoundSource::set_position(const Vector2f& position)
 {
-  alSource3f(source, AL_POSITION, position.x, position.y, 0);
+  alSource3f(m_source, AL_POSITION, position.x, position.y, 0);
 }
 
 void
 SoundSource::set_velocity(const Vector2f& velocity)
 {
-  alSource3f(source, AL_VELOCITY, velocity.x, velocity.y, 0);
+  alSource3f(m_source, AL_VELOCITY, velocity.x, velocity.y, 0);
 }
 
 void
 SoundSource::set_gain(float gain)
 {
-  alSourcef(source, AL_GAIN, gain);
+  alSourcef(m_source, AL_GAIN, gain);
 }
 
 void
 SoundSource::set_reference_distance(float distance)
 {
-  alSourcef(source, AL_REFERENCE_DISTANCE, distance);
+  alSourcef(m_source, AL_REFERENCE_DISTANCE, distance);
 }
 
+void
+SoundSource::update_volume() const
+{
+  // FIXME: alSourcef(m_source, AL_GAIN, m_channel->get_volume() * m_gain); 
+}
+
 /* EOF */

Modified: trunk/windstille/src/sound/sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/sound_source.hpp	2010-07-19 17:53:58 UTC (rev 3313)
+++ trunk/windstille/src/sound/sound_source.hpp	2010-07-19 19:29:55 UTC (rev 3314)
@@ -40,10 +40,13 @@
   void set_velocity(const Vector2f& position);
   void set_reference_distance(float distance);
 
-  ALuint get_id() const { return source; }
+  /** Needs to be called whenever the SoundChannels volume changes */
+  void update_volume() const;
+
+  ALuint get_id() const { return m_source; }
   
 protected:
-  ALuint source;
+  ALuint m_source;
 };
 
 #endif

Modified: trunk/windstille/src/sound/stream_sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-19 17:53:58 UTC (rev 3313)
+++ trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-19 19:29:55 UTC (rev 3314)
@@ -25,12 +25,12 @@
 #include "sound/sound_manager.hpp"
 #include "sound/sound_file.hpp"
 
-StreamSoundSource::StreamSoundSource(std::auto_ptr<SoundFile> file_)
-  : file(file_),
-    format(),
-    fade_state(),
-    fade_start_ticks(),
-    fade_time()
+StreamSoundSource::StreamSoundSource(std::auto_ptr<SoundFile> file_) :
+  file(file_),
+  format(),
+  fade_state(),
+  fade_start_ticks(),
+  fade_time()
 {
   alGenBuffers(STREAMFRAGMENTS, buffers);
   SoundManager::check_al_error("Couldn't allocate audio buffers: ");
@@ -65,14 +65,14 @@
   if (playing())
   {
     ALint processed = 0;
-    alGetSourcei(source, AL_BUFFERS_PROCESSED, &processed);
+    alGetSourcei(m_source, AL_BUFFERS_PROCESSED, &processed);
 
     while (processed > 0) 
     {
       processed--;
 
       ALuint buffer;
-      alSourceUnqueueBuffers(source, 1, &buffer);
+      alSourceUnqueueBuffers(m_source, 1, &buffer);
       SoundManager::check_al_error("Couldn't unqueu audio buffer: ");
 
       fillBufferAndQueue(buffer);
@@ -82,7 +82,7 @@
     if (!playing()) 
     {
       std::cerr << "Restarting audio source because of buffer underrun.\n";
-      alSourcePlay(source);
+      alSourcePlay(m_source);
       SoundManager::check_al_error("Couldn't restart audio source: ");
     }
 
@@ -149,7 +149,7 @@
 
   SoundManager::check_al_error("Couldn't refill audio buffer: ");
 
-  alSourceQueueBuffers(source, 1, &buffer);
+  alSourceQueueBuffers(m_source, 1, &buffer);
   SoundManager::check_al_error("Couldn't queue audio buffer: ");
 }
 



From grumbel at mail.berlios.de  Tue Jul 20 00:57:20 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Tue, 20 Jul 2010 00:57:20 +0200
Subject: [Windstille-commit] r3315 - trunk/windstille/src/sound
Message-ID: <20100719225720.9234A480B6F@sheep.berlios.de>

Author: grumbel
Date: 2010-07-20 00:57:20 +0200 (Tue, 20 Jul 2010)
New Revision: 3315

Added:
   trunk/windstille/src/sound/sound_channel.cpp
   trunk/windstille/src/sound/sound_channel.hpp
   trunk/windstille/src/sound/sound_source_ptr.hpp
Modified:
   trunk/windstille/src/sound/sound_file.hpp
   trunk/windstille/src/sound/sound_manager.cpp
   trunk/windstille/src/sound/sound_manager.hpp
   trunk/windstille/src/sound/sound_source.cpp
   trunk/windstille/src/sound/sound_source.hpp
   trunk/windstille/src/sound/stream_sound_source.cpp
   trunk/windstille/src/sound/stream_sound_source.hpp
Log:
Some further work on the sound stuff, splitting music, sound and voice into different channels


Added: trunk/windstille/src/sound/sound_channel.cpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.cpp	                        (rev 0)
+++ trunk/windstille/src/sound/sound_channel.cpp	2010-07-19 22:57:20 UTC (rev 3315)
@@ -0,0 +1,87 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "sound/sound_channel.hpp"
+
+#include <AL/al.h>
+#include <iostream>
+
+#include "math/vector2f.hpp"
+#include "sound/sound_manager.hpp"
+#include "sound/sound_source.hpp"
+
+SoundChannel::SoundChannel(SoundManager& sound_manager) :
+  m_sound_manager(sound_manager),
+  m_sound_sources(),
+  m_volume(1.0f)
+{
+}
+
+SoundSourcePtr
+SoundChannel::play(const SoundFile& sound_file)
+{ 
+  
+}
+
+SoundSourcePtr
+SoundChannel::play(const std::string& filename)
+{  
+  try
+  {
+    std::auto_ptr<SoundSource> source = m_sound_manager.create_sound_source(filename);
+
+    if (source.get())
+    {
+      source->play();
+      m_sound_sources.push_back(SoundSourcePtr(source.release()));
+    }
+  }
+  catch(std::exception& e) 
+  {
+    std::cout << "SoundChannel::play(): Couldn't play sound " << filename << ": " << e.what() << "\n";
+  }
+}
+
+void
+SoundChannel::set_volume(float volume)
+{
+  m_volume = volume;
+
+  for(std::vector<SoundSourcePtr>::iterator i = m_sound_sources.begin(); i != m_sound_sources.end(); ++i)
+  {
+    (*i)->update_volume();
+  }
+}
+
+float
+SoundChannel::get_volume() const
+{
+  return m_volume;
+}
+
+void
+SoundChannel::update(float delta)
+{
+  for(std::vector<SoundSourcePtr>::iterator i = m_sound_sources.begin(); i != m_sound_sources.end(); ++i)
+  {
+    // only needed for streamed sound sources
+    //FIXME: (*i)->update(delta);
+  }
+}
+
+/* EOF */


Property changes on: trunk/windstille/src/sound/sound_channel.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/src/sound/sound_channel.hpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.hpp	                        (rev 0)
+++ trunk/windstille/src/sound/sound_channel.hpp	2010-07-19 22:57:20 UTC (rev 3315)
@@ -0,0 +1,54 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_WINDSTILLE_SOUND_SOUND_CHANNEL_HPP
+#define HEADER_WINDSTILLE_SOUND_SOUND_CHANNEL_HPP
+
+#include <vector>
+
+#include "sound/sound_source_ptr.hpp"
+
+class SoundFile;
+class SoundManager;
+
+class SoundChannel
+{
+public:
+  SoundChannel(SoundManager& sound_manager);
+
+  SoundSourcePtr play(const SoundFile& sound_file);
+  SoundSourcePtr play(const std::string& filename);
+
+  void update(float delta);
+
+  void  set_volume(float volume);
+  float get_volume() const;
+
+private:
+  SoundManager& m_sound_manager;
+  std::vector<SoundSourcePtr> m_sound_sources;
+  float m_volume;
+
+private:
+  SoundChannel(const SoundChannel&);
+  SoundChannel& operator=(const SoundChannel&);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/src/sound/sound_channel.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: trunk/windstille/src/sound/sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/sound_file.hpp	2010-07-19 19:29:55 UTC (rev 3314)
+++ trunk/windstille/src/sound/sound_file.hpp	2010-07-19 22:57:20 UTC (rev 3315)
@@ -45,8 +45,7 @@
   int channels;
   int rate;
   int bits_per_sample;
-  /// size in bytes
-  size_t size;
+  size_t size; /// size in bytes
 
 public:
   static std::auto_ptr<SoundFile> load(const std::string& filename);

Modified: trunk/windstille/src/sound/sound_manager.cpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.cpp	2010-07-19 19:29:55 UTC (rev 3314)
+++ trunk/windstille/src/sound/sound_manager.cpp	2010-07-19 22:57:20 UTC (rev 3315)
@@ -31,7 +31,9 @@
   m_device(0), 
   m_context(0), 
   m_sound_enabled(false), 
-  m_channel(*this),
+  m_voice_channel(*this),
+  m_sound_channel(*this),
+  m_music_channel(*this),
   m_buffers(),
   m_sources(),
   m_music_source(),
@@ -151,7 +153,7 @@
       m_buffers.insert(std::make_pair(filename, buffer));
     }
   
-    std::auto_ptr<SoundSource> source(new SoundSource());
+    std::auto_ptr<SoundSource> source(new SoundSource(m_sound_channel));
 
     alSourcei(source->get_id(), AL_BUFFER, buffer);
 
@@ -168,14 +170,7 @@
 
     if (source.get())
     {
-      if (pos == Vector2f(-1, -1)) 
-      {
-        alSourcef(source->get_id(), AL_ROLLOFF_FACTOR, 0);
-      }
-      else
-      {
-        source->set_position(pos);
-      }
+      source->set_position(pos);
 
       source->play();
       m_sources.push_back(boost::shared_ptr<SoundSource>(source.release()));
@@ -245,7 +240,7 @@
     {
       try 
       {
-        std::auto_ptr<StreamSoundSource> newmusic(new StreamSoundSource(SoundFile::load(filename)));
+        std::auto_ptr<StreamSoundSource> newmusic(new StreamSoundSource(m_music_channel, SoundFile::load(filename)));
 
         alSourcef(newmusic->get_id(), AL_ROLLOFF_FACTOR, 0);
  
@@ -296,23 +291,23 @@
 void
 SoundManager::set_voice_volume(float volume)
 {
-  std::cout << "SoundManager::set_voice_volume(" << volume << "): unimplemented" << std::endl;
+  m_voice_channel.set_volume(volume);
 }
 
 void
-SoundManager::set_sfx_volume(float volume)
+SoundManager::set_sound_volume(float volume)
 {
-  std::cout << "SoundManager::set_sfx_volume(" << volume << "): unimplemented" << std::endl;
+  m_sound_channel.set_volume(volume);
 }
 
 void
 SoundManager::set_music_volume(float volume)
 {
-  std::cout << "SoundManager::set_music_volume(" << volume << "): unimplemented" << std::endl;
+  m_music_channel.set_volume(volume);
 }
 
 void
-SoundManager::update()
+SoundManager::update(float delta)
 {
   if (m_sound_enabled)
   {
@@ -332,7 +327,7 @@
     // check streaming sounds
     if (m_music_source.get()) 
     {
-      m_music_source->update();
+      m_music_source->update(delta);
     }
   
     if (m_next_music_source.get() && (!m_music_source.get() || !m_music_source->playing())) 

Modified: trunk/windstille/src/sound/sound_manager.hpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.hpp	2010-07-19 19:29:55 UTC (rev 3314)
+++ trunk/windstille/src/sound/sound_manager.hpp	2010-07-19 22:57:20 UTC (rev 3315)
@@ -53,7 +53,7 @@
 
   void set_master_volume(float volume);
   void set_voice_volume(float volume);
-  void set_sfx_volume(float volume);
+  void set_sound_volume(float volume);
   void set_music_volume(float volume);
 
   /**
@@ -64,7 +64,7 @@
   void play_music(const std::string& filename, bool fade = true);
   void stop_music(bool fade = true);
 
-  void update();
+  void update(float delta);
 
 public:
   static void check_al_error(const char* message);
@@ -89,7 +89,9 @@
   ALCcontext* m_context;
   bool m_sound_enabled;
 
-  SoundChannel m_channel;
+  SoundChannel m_voice_channel;
+  SoundChannel m_sound_channel;
+  SoundChannel m_music_channel;
 
   typedef std::map<std::string, ALuint> SoundBuffers;
   SoundBuffers m_buffers;

Modified: trunk/windstille/src/sound/sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/sound_source.cpp	2010-07-19 19:29:55 UTC (rev 3314)
+++ trunk/windstille/src/sound/sound_source.cpp	2010-07-19 22:57:20 UTC (rev 3315)
@@ -19,7 +19,8 @@
 #include "sound/sound_source.hpp"
 #include "sound/sound_manager.hpp"
 
-SoundSource::SoundSource() :
+SoundSource::SoundSource(SoundChannel& channel) :
+  m_channel(channel),
   m_source()
 {
   alGenSources(1, &m_source);
@@ -77,9 +78,17 @@
 void
 SoundSource::set_gain(float gain)
 {
-  alSourcef(m_source, AL_GAIN, gain);
+  alSourcef(m_source, AL_GAIN, m_channel.get_volume() * gain);
 }
 
+float
+SoundSource::get_gain() const
+{
+  float gain = 0.0f;
+  alGetSourcef(m_source, AL_GAIN, &gain);
+  return gain;
+}
+
 void
 SoundSource::set_reference_distance(float distance)
 {
@@ -87,9 +96,15 @@
 }
 
 void
+SoundSource::set_rolloff_factor(float factor)
+{
+  alSourcef(m_source, AL_ROLLOFF_FACTOR, factor);
+}
+
+void
 SoundSource::update_volume() const
 {
-  // FIXME: alSourcef(m_source, AL_GAIN, m_channel->get_volume() * m_gain); 
+  alSourcef(m_source, AL_GAIN, m_channel.get_volume() * get_gain());
 }
 
 /* EOF */

Modified: trunk/windstille/src/sound/sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/sound_source.hpp	2010-07-19 19:29:55 UTC (rev 3314)
+++ trunk/windstille/src/sound/sound_source.hpp	2010-07-19 22:57:20 UTC (rev 3315)
@@ -23,10 +23,12 @@
 
 #include "math/vector2f.hpp"
 
+class SoundChannel;
+
 class SoundSource
 {
 public:
-  SoundSource();
+  SoundSource(SoundChannel& channel);
   virtual ~SoundSource();
 
   void play();
@@ -34,11 +36,15 @@
   bool playing();
 
   void set_looping(bool looping);
+
   /// Set volume (0.0 is silent, 1.0 is normal)
-  void set_gain(float gain);
+  void  set_gain(float gain);
+  float get_gain() const;
+
   void set_position(const Vector2f& position);
   void set_velocity(const Vector2f& position);
   void set_reference_distance(float distance);
+  void set_rolloff_factor(float factor);
 
   /** Needs to be called whenever the SoundChannels volume changes */
   void update_volume() const;
@@ -46,7 +52,12 @@
   ALuint get_id() const { return m_source; }
   
 protected:
+  SoundChannel& m_channel;
   ALuint m_source;
+  
+private:
+  SoundSource(const SoundSource&);
+  SoundSource& operator=(const SoundSource&);
 };
 
 #endif

Added: trunk/windstille/src/sound/sound_source_ptr.hpp
===================================================================
--- trunk/windstille/src/sound/sound_source_ptr.hpp	                        (rev 0)
+++ trunk/windstille/src/sound/sound_source_ptr.hpp	2010-07-19 22:57:20 UTC (rev 3315)
@@ -0,0 +1,30 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_WINDSTILLE_SOUND_SOUND_SOURCE_PTR_HPP
+#define HEADER_WINDSTILLE_SOUND_SOUND_SOURCE_PTR_HPP
+
+#include <boost/shared_ptr.hpp>
+
+class SoundSource;
+
+typedef boost::shared_ptr<SoundSource> SoundSourcePtr;
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/src/sound/sound_source_ptr.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: trunk/windstille/src/sound/stream_sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-19 19:29:55 UTC (rev 3314)
+++ trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-19 22:57:20 UTC (rev 3315)
@@ -18,19 +18,20 @@
 
 #include "sound/stream_sound_source.hpp"
 
-#include <SDL.h>
 #include <iostream>
 #include <boost/scoped_array.hpp>
 
 #include "sound/sound_manager.hpp"
 #include "sound/sound_file.hpp"
 
-StreamSoundSource::StreamSoundSource(std::auto_ptr<SoundFile> file_) :
+StreamSoundSource::StreamSoundSource(SoundChannel& channel, std::auto_ptr<SoundFile> file_) :
+  SoundSource(channel),
   file(file_),
   format(),
   fade_state(),
   fade_start_ticks(),
-  fade_time()
+  fade_time(),
+  m_total_time(0.0f)
 {
   alGenBuffers(STREAMFRAGMENTS, buffers);
   SoundManager::check_al_error("Couldn't allocate audio buffers: ");
@@ -60,8 +61,10 @@
 }
 
 void
-StreamSoundSource::update()
+StreamSoundSource::update(float delta)
 {
+  m_total_time += delta;
+
   if (playing())
   {
     ALint processed = 0;
@@ -88,8 +91,7 @@
 
     if (fade_state == FadingOn) 
     {
-      unsigned int ticks = SDL_GetTicks();
-      float time = static_cast<float>(ticks - fade_start_ticks) / 1000.0f;
+      float time = fade_start_ticks - m_total_time;
       if (time >= fade_time)
       {
         set_gain(1.0);
@@ -102,8 +104,7 @@
     } 
     else if (fade_state == FadingOff) 
     {
-      unsigned int ticks = SDL_GetTicks();
-      float time = static_cast<float>(ticks - fade_start_ticks) / 1000.0f;
+      float time = fade_start_ticks - m_total_time;
 
       if (time >= fade_time) 
       {
@@ -123,7 +124,7 @@
 {
   fade_state       = state_;
   fade_time        = fade_time_;
-  fade_start_ticks = SDL_GetTicks();
+  fade_start_ticks = m_total_time;
 }
 
 void

Modified: trunk/windstille/src/sound/stream_sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.hpp	2010-07-19 19:29:55 UTC (rev 3314)
+++ trunk/windstille/src/sound/stream_sound_source.hpp	2010-07-19 22:57:20 UTC (rev 3315)
@@ -25,6 +25,7 @@
 #include "sound/sound_source.hpp"
 
 class SoundFile;
+class SoundChannel;
 
 class StreamSoundSource : public SoundSource
 {
@@ -32,12 +33,12 @@
   enum FadeState { NoFading, FadingOn, FadingOff };
 
 public:
-  StreamSoundSource(std::auto_ptr<SoundFile> file);
+  StreamSoundSource(SoundChannel& channel, std::auto_ptr<SoundFile> file);
   virtual ~StreamSoundSource();
 
   void setFading(FadeState state, float fadetime);
   FadeState getFadeState() const { return fade_state; }
-  void update();
+  void update(float delta);
   
 private:
   void fillBufferAndQueue(ALuint buffer);
@@ -54,6 +55,9 @@
   FadeState fade_state;
   unsigned int fade_start_ticks;
   float fade_time;
+
+  // FIXME: simple time counter that summarizes all deltas, could be done better
+  float m_total_time;
 };
 
 #endif



From grumbel at mail.berlios.de  Tue Jul 20 01:14:30 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Tue, 20 Jul 2010 01:14:30 +0200
Subject: [Windstille-commit] r3316 - trunk/windstille/src/sound
Message-ID: <20100719231430.83D59480B05@sheep.berlios.de>

Author: grumbel
Date: 2010-07-20 01:14:30 +0200 (Tue, 20 Jul 2010)
New Revision: 3316

Modified:
   trunk/windstille/src/sound/ogg_sound_file.cpp
   trunk/windstille/src/sound/ogg_sound_file.hpp
   trunk/windstille/src/sound/sound_file.hpp
   trunk/windstille/src/sound/wav_sound_file.hpp
Log:
Moved member variables out of SoundFile


Modified: trunk/windstille/src/sound/ogg_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-19 22:57:20 UTC (rev 3315)
+++ trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-19 23:14:30 UTC (rev 3316)
@@ -18,9 +18,9 @@
 
 #include "sound/ogg_sound_file.hpp"
 
-OggSoundFile::OggSoundFile(PHYSFS_file* file_)
-  : file(file_),
-    vorbis_file()
+OggSoundFile::OggSoundFile(PHYSFS_file* file_) :
+  file(file_),
+  vorbis_file()
 {
   ov_callbacks callbacks = { cb_read, cb_seek, cb_close, cb_tell };
   ov_open_callbacks(file, &vorbis_file, 0, 0, callbacks);

Modified: trunk/windstille/src/sound/ogg_sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/ogg_sound_file.hpp	2010-07-19 22:57:20 UTC (rev 3315)
+++ trunk/windstille/src/sound/ogg_sound_file.hpp	2010-07-19 23:14:30 UTC (rev 3316)
@@ -33,15 +33,26 @@
   size_t read(void* buffer, size_t buffer_size);
   void reset();
 
+  int    get_bits_per_sample() const { return bits_per_sample; }
+  size_t get_size() const { return size; }
+  int    get_rate() const { return rate; }
+  int    get_channels() const { return channels; }
+  
 private:
+  // I/O functions for ogg
   static size_t cb_read(void* ptr, size_t size, size_t nmemb, void* source);
-  static int cb_seek(void* source, ogg_int64_t offset, int whence);
-  static int cb_close(void* source);
-  static long cb_tell(void* source);
+  static int    cb_seek(void* source, ogg_int64_t offset, int whence);
+  static int    cb_close(void* source);
+  static long   cb_tell(void* source);
   
   PHYSFS_file* file;
   OggVorbis_File vorbis_file;
 
+  int channels;
+  int rate;
+  int bits_per_sample;
+  size_t size; /// size in bytes
+
 private:
   OggSoundFile(const OggSoundFile&);
   OggSoundFile& operator=(const OggSoundFile&);

Modified: trunk/windstille/src/sound/sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/sound_file.hpp	2010-07-19 22:57:20 UTC (rev 3315)
+++ trunk/windstille/src/sound/sound_file.hpp	2010-07-19 23:14:30 UTC (rev 3316)
@@ -22,31 +22,22 @@
 #include <memory>
 #include <string>
 
+class Pathname;
+
 class SoundFile
 {
 public:
-  SoundFile() :
-    channels(),
-    rate(),
-    bits_per_sample(),
-    size()
-  {}
+  SoundFile() {}
   virtual ~SoundFile() {}
 
   virtual size_t read(void* buffer, size_t buffer_size) = 0;
   virtual void reset() = 0;
 
-  int    get_bits_per_sample() const { return bits_per_sample; }
-  size_t get_size() const { return size; }
-  int    get_rate() const { return rate; }
-  int    get_channels() const { return channels; }
+  virtual int    get_bits_per_sample() const = 0;
+  virtual size_t get_size() const = 0;
+  virtual int    get_rate() const = 0;
+  virtual int    get_channels() const = 0;
   
-protected:
-  int channels;
-  int rate;
-  int bits_per_sample;
-  size_t size; /// size in bytes
-
 public:
   static std::auto_ptr<SoundFile> load(const std::string& filename);
 };

Modified: trunk/windstille/src/sound/wav_sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/wav_sound_file.hpp	2010-07-19 22:57:20 UTC (rev 3315)
+++ trunk/windstille/src/sound/wav_sound_file.hpp	2010-07-19 23:14:30 UTC (rev 3316)
@@ -33,10 +33,21 @@
   void reset();
 
 private:
-  PHYSFS_file* file;
-  
+  PHYSFS_file* file; 
   PHYSFS_sint64 datastart;
 
+public:
+  int    get_bits_per_sample() const { return bits_per_sample; }
+  size_t get_size() const { return size; }
+  int    get_rate() const { return rate; }
+  int    get_channels() const { return channels; }
+  
+protected:
+  int channels;
+  int rate;
+  int bits_per_sample;
+  size_t size; /// size in bytes
+
 private:
   WavSoundFile(const WavSoundFile&);
   WavSoundFile& operator=(const WavSoundFile&);



From grumbel at mail.berlios.de  Tue Jul 20 03:11:24 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Tue, 20 Jul 2010 03:11:24 +0200
Subject: [Windstille-commit] r3317 - in trunk/windstille/src: app editor
	engine gui screen scripting sound util
Message-ID: <20100720011124.794C9480B05@sheep.berlios.de>

Author: grumbel
Date: 2010-07-20 03:11:24 +0200 (Tue, 20 Jul 2010)
New Revision: 3317

Modified:
   trunk/windstille/src/app/config.cpp
   trunk/windstille/src/app/menu_manager.cpp
   trunk/windstille/src/app/menu_manager.hpp
   trunk/windstille/src/editor/timeline_commands.hpp
   trunk/windstille/src/engine/sector.cpp
   trunk/windstille/src/gui/menu_component.cpp
   trunk/windstille/src/gui/menu_item.cpp
   trunk/windstille/src/screen/screen_manager.cpp
   trunk/windstille/src/scripting/interface.cpp
   trunk/windstille/src/sound/ogg_sound_file.cpp
   trunk/windstille/src/sound/ogg_sound_file.hpp
   trunk/windstille/src/sound/sound_channel.cpp
   trunk/windstille/src/sound/sound_channel.hpp
   trunk/windstille/src/sound/sound_file.cpp
   trunk/windstille/src/sound/sound_file.hpp
   trunk/windstille/src/sound/sound_manager.cpp
   trunk/windstille/src/sound/sound_manager.hpp
   trunk/windstille/src/sound/wav_sound_file.cpp
   trunk/windstille/src/sound/wav_sound_file.hpp
   trunk/windstille/src/util/currenton.hpp
   trunk/windstille/src/util/pathname.cpp
   trunk/windstille/src/util/pathname.hpp
Log:
Further cleanup on the sound system


Modified: trunk/windstille/src/app/config.cpp
===================================================================
--- trunk/windstille/src/app/config.cpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/app/config.cpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -62,8 +62,8 @@
 
   add(new ConfigValue<int>("master-volume",  _("Master Volume"), true, 100));
   add(new ConfigValue<int>("music-volume",   _("Music Volume"),  true, 100));
+  add(new ConfigValue<int>("sound-volume",   _("Sound Volume"),  true, 100));
   add(new ConfigValue<int>("voice-volume",   _("Voice Volume"),  true, 100));
-  add(new ConfigValue<int>("sfx-volume",     _("SFX Volume"),    true, 100));
 
   add(new ConfigValue<bool>("wiimote", _("Try to connect to Wiimote on startup"), true, false));
 }

Modified: trunk/windstille/src/app/menu_manager.cpp
===================================================================
--- trunk/windstille/src/app/menu_manager.cpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/app/menu_manager.cpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -55,8 +55,8 @@
   menu.add_slider("Music Volume", config.get_int("music-volume"), 0, 100, 10,
                   boost::bind(&MenuManager::menu_music_volume, _1));
 
-  menu.add_slider("SFX Volume", config.get_int("sfx-volume"), 0, 100, 10, 
-                  boost::bind(&MenuManager::menu_sfx_volume, _1));
+  menu.add_slider("Sound Volume", config.get_int("sound-volume"), 0, 100, 10, 
+                  boost::bind(&MenuManager::menu_sound_volume, _1));
 
   menu.add_slider("Voice Volume", config.get_int("voice-volume"), 0, 100, 10, 
                   boost::bind(&MenuManager::menu_voice_volume, _1));
@@ -550,10 +550,10 @@
 }
 
 void
-MenuManager::menu_sfx_volume(int i)
+MenuManager::menu_sound_volume(int i)
 {
-  config.set_int("sfx-volume", i);
-  SoundManager::current()->set_sfx_volume(static_cast<float>(i)/100.0f);
+  config.set_int("sound-volume", i);
+  SoundManager::current()->set_sound_volume(static_cast<float>(i)/100.0f);
 }
 
 /* EOF */

Modified: trunk/windstille/src/app/menu_manager.hpp
===================================================================
--- trunk/windstille/src/app/menu_manager.hpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/app/menu_manager.hpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -62,7 +62,7 @@
 
   static void menu_master_volume(int i);
   static void menu_voice_volume(int i);
-  static void menu_sfx_volume(int i);
+  static void menu_sound_volume(int i);
   static void menu_music_volume(int i);
 
   static void menu_ambient_light(int i, int component);

Modified: trunk/windstille/src/editor/timeline_commands.hpp
===================================================================
--- trunk/windstille/src/editor/timeline_commands.hpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/editor/timeline_commands.hpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -44,6 +44,7 @@
     m_layer(),
     m_object(object),
     m_property(property),
+    m_keyframe(),
     m_add_layer(false)
   {
     m_layer = m_sector.get_timeline()->get_object_layer(m_object, m_property);

Modified: trunk/windstille/src/engine/sector.cpp
===================================================================
--- trunk/windstille/src/engine/sector.cpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/engine/sector.cpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -78,7 +78,7 @@
   commit_adds();
   commit_removes();
 
-  SoundManager::current()->play_music(music);
+  SoundManager::current()->play_music(Pathname(music, Pathname::kDataPath));
 
   if (!init_script.empty())
   {

Modified: trunk/windstille/src/gui/menu_component.cpp
===================================================================
--- trunk/windstille/src/gui/menu_component.cpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/gui/menu_component.cpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -120,7 +120,7 @@
             {
               if (allow_cancel) // FIXME: Could use a signal instead
                 {
-                  SoundManager::current()->play("sounds/menu_click.wav");
+                  SoundManager::current()->play(Pathname("sounds/menu_click.wav", Pathname::kDataPath));
                   set_active(false);
                 }
             }
@@ -134,7 +134,7 @@
             }          
           else if (i->button.name == MENU_UP_BUTTON)
             {
-              SoundManager::current()->play("sounds/menu_change.wav");
+              SoundManager::current()->play(Pathname("sounds/menu_change.wav", Pathname::kDataPath));
               
               current_item = current_item - 1;
               if (current_item < 0)
@@ -154,7 +154,7 @@
             }
           else if (i->button.name == MENU_DOWN_BUTTON)
             {
-              SoundManager::current()->play("sounds/menu_change.wav");
+              SoundManager::current()->play(Pathname("sounds/menu_change.wav", Pathname::kDataPath));
 
               if (dynamic_cast<TabComponent*>(parent))
                 {

Modified: trunk/windstille/src/gui/menu_item.cpp
===================================================================
--- trunk/windstille/src/gui/menu_item.cpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/gui/menu_item.cpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -97,7 +97,7 @@
 void
 EnumMenuItem::incr()
 {
-  SoundManager::current()->play("sounds/menu_click.wav");           
+  SoundManager::current()->play(Pathname("sounds/menu_click.wav", Pathname::kDataPath));
 
   index -= 1;
   if (index < 0)
@@ -108,7 +108,7 @@
 void
 EnumMenuItem::decr()
 {
-  SoundManager::current()->play("sounds/menu_click.wav");
+  SoundManager::current()->play(Pathname("sounds/menu_click.wav", Pathname::kDataPath));
 
   index += 1;
   if (index >= static_cast<int>(labels.size()))
@@ -152,7 +152,7 @@
 void
 SliderMenuItem::decr()
 {
-  SoundManager::current()->play("sounds/menu_click.wav");
+  SoundManager::current()->play(Pathname("sounds/menu_click.wav", Pathname::kDataPath));
 
   value += step;
   if (value > max_value)
@@ -163,7 +163,7 @@
 void
 SliderMenuItem::incr()
 {
-  SoundManager::current()->play("sounds/menu_click.wav");
+  SoundManager::current()->play(Pathname("sounds/menu_click.wav", Pathname::kDataPath));
 
   value -= step;
   if (value < min_value)
@@ -208,7 +208,7 @@
 void
 ButtonMenuItem::click()
 {
-  SoundManager::current()->play("sounds/menu_click.wav");
+  SoundManager::current()->play(Pathname("sounds/menu_click.wav", Pathname::kDataPath));
 
   on_click();
 }

Modified: trunk/windstille/src/screen/screen_manager.cpp
===================================================================
--- trunk/windstille/src/screen/screen_manager.cpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/screen/screen_manager.cpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -96,7 +96,7 @@
       
     overlap_delta = delta;
 
-    SoundManager::current()->update();
+    SoundManager::current()->update(delta);
 
     draw();
 

Modified: trunk/windstille/src/scripting/interface.cpp
===================================================================
--- trunk/windstille/src/scripting/interface.cpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/scripting/interface.cpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -45,7 +45,7 @@
 
 void play_music(const std::string& musicfile)
 {
-  SoundManager::current()->play_music(musicfile);
+  SoundManager::current()->play_music(Pathname(musicfile, Pathname::kDataPath));
 }
 
 void stop_music(bool fade)
@@ -55,7 +55,7 @@
 
 void play_sound(const std::string& soundfile)
 {
-  SoundManager::current()->play(soundfile);
+  SoundManager::current()->play(Pathname(soundfile, Pathname::kDataPath));
 }
 
 void caption_clear()

Modified: trunk/windstille/src/sound/ogg_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -18,8 +18,10 @@
 
 #include "sound/ogg_sound_file.hpp"
 
-OggSoundFile::OggSoundFile(PHYSFS_file* file_) :
-  file(file_),
+#include "util/pathname.hpp"
+
+OggSoundFile::OggSoundFile(const Pathname& filename) :
+  file(PHYSFS_openRead(filename.get_physfs_path().c_str())),
   vorbis_file()
 {
   ov_callbacks callbacks = { cb_read, cb_seek, cb_close, cb_tell };

Modified: trunk/windstille/src/sound/ogg_sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/ogg_sound_file.hpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/sound/ogg_sound_file.hpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -27,7 +27,7 @@
 class OggSoundFile : public SoundFile
 {
 public:
-  OggSoundFile(PHYSFS_file* file);
+  OggSoundFile(const Pathname& filename);
   ~OggSoundFile();
 
   size_t read(void* buffer, size_t buffer_size);

Modified: trunk/windstille/src/sound/sound_channel.cpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.cpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/sound/sound_channel.cpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -22,6 +22,7 @@
 #include <iostream>
 
 #include "math/vector2f.hpp"
+#include "util/pathname.hpp"
 #include "sound/sound_manager.hpp"
 #include "sound/sound_source.hpp"
 
@@ -39,7 +40,7 @@
 }
 
 SoundSourcePtr
-SoundChannel::play(const std::string& filename)
+SoundChannel::play(const Pathname& filename)
 {  
   try
   {

Modified: trunk/windstille/src/sound/sound_channel.hpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.hpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/sound/sound_channel.hpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -23,6 +23,7 @@
 
 #include "sound/sound_source_ptr.hpp"
 
+class Pathname;
 class SoundFile;
 class SoundManager;
 
@@ -32,7 +33,7 @@
   SoundChannel(SoundManager& sound_manager);
 
   SoundSourcePtr play(const SoundFile& sound_file);
-  SoundSourcePtr play(const std::string& filename);
+  SoundSourcePtr play(const Pathname& filename);
 
   void update(float delta);
 

Modified: trunk/windstille/src/sound/sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/sound_file.cpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/sound/sound_file.cpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -21,19 +21,21 @@
 #include <string.h>
 #include <stdexcept>
 #include <sstream>
+#include <fstream>
 
 #include "sound/ogg_sound_file.hpp"
 #include "sound/wav_sound_file.hpp"
+#include "util/pathname.hpp"
 
 std::auto_ptr<SoundFile>
-SoundFile::load(const std::string& filename)
+SoundFile::load(const Pathname& filename)
 {
-  PHYSFS_file* file = PHYSFS_openRead(filename.c_str());
+  std::ifstream in(filename.get_sys_path().c_str(), std::ios::binary);
 
-  if (!file) 
+  if (!in) 
   {
     std::stringstream msg;
-    msg << "Couldn't open '" << filename << "': " << PHYSFS_getLastError();
+    msg << "Couldn't open '" << filename << "'";
     throw std::runtime_error(msg.str());
   }
   else
@@ -42,21 +44,19 @@
     {
       char magic[4];
 
-      if (PHYSFS_read(file, magic, sizeof(magic), 1) != 1)
+      if (!in.read(magic, sizeof(magic)))
       {
         throw std::runtime_error("Couldn't read magic, file too short");
       }
       else
       {
-        PHYSFS_seek(file, 0);
-
         if (strncmp(magic, "RIFF", 4) == 0)
         {
-          return std::auto_ptr<SoundFile>(new WavSoundFile(file));
+          return std::auto_ptr<SoundFile>(new WavSoundFile(filename));
         }
         else if (strncmp(magic, "OggS", 4) == 0)
         {
-          return std::auto_ptr<SoundFile>(new OggSoundFile(file));
+          return std::auto_ptr<SoundFile>(new OggSoundFile(filename));
         }
         else
         {

Modified: trunk/windstille/src/sound/sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/sound_file.hpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/sound/sound_file.hpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -39,7 +39,7 @@
   virtual int    get_channels() const = 0;
   
 public:
-  static std::auto_ptr<SoundFile> load(const std::string& filename);
+  static std::auto_ptr<SoundFile> load(const Pathname& filename);
 };
 
 #endif

Modified: trunk/windstille/src/sound/sound_manager.cpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.cpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/sound/sound_manager.cpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -23,8 +23,8 @@
 
 #include "sound/sound_file.hpp"
 #include "sound/stream_sound_source.hpp"
-
 #include "sound/sound_manager.hpp"
+#include "util/pathname.hpp"
 
 
 SoundManager::SoundManager() :
@@ -100,7 +100,7 @@
 }
 
 ALuint
-SoundManager::load_file_into_buffer(const std::string& filename)
+SoundManager::load_file_into_buffer(const Pathname& filename)
 {
   // open sound file
   std::auto_ptr<SoundFile> file(SoundFile::load(filename));
@@ -131,7 +131,7 @@
 }
 
 std::auto_ptr<SoundSource>
-SoundManager::create_sound_source(const std::string& filename)
+SoundManager::create_sound_source(const Pathname& filename)
 {
   if (!m_sound_enabled)
   {
@@ -162,7 +162,7 @@
 }
 
 void
-SoundManager::play(const std::string& filename, const Vector2f& pos)
+SoundManager::play(const Pathname& filename, const Vector2f& pos)
 {
   try
   {
@@ -230,7 +230,7 @@
 }
 
 void
-SoundManager::play_music(const std::string& filename, bool fade)
+SoundManager::play_music(const Pathname& filename, bool fade)
 {
   if (filename != m_current_music)
   {

Modified: trunk/windstille/src/sound/sound_manager.hpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.hpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/sound/sound_manager.hpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -29,16 +29,17 @@
 #include <AL/al.h>
 
 #include "math/vector2f.hpp"
+#include "sound/sound_channel.hpp"
 #include "util/currenton.hpp"
+#include "util/pathname.hpp"
 
-#include "sound/sound_channel.hpp"
-
 typedef void* SoundHandle;
 
+class Pathname;
 class SoundFile;
 class SoundSource;
 class StreamSoundSource;
-
+
 class SoundManager : public Currenton<SoundManager>
 {
 public:
@@ -59,9 +60,9 @@
   /**
    * Convenience function to simply play a sound at a given position.
    */
-  void play(const std::string& name, const Vector2f& pos = Vector2f(-1, -1));
+  void play(const Pathname& name, const Vector2f& pos = Vector2f(-1, -1));
 
-  void play_music(const std::string& filename, bool fade = true);
+  void play_music(const Pathname& filename, bool fade = true);
   void stop_music(bool fade = true);
 
   void update(float delta);
@@ -77,10 +78,10 @@
    * This function might throw exceptions. It returns 0 if no audio device is
    * available.
    */
-  std::auto_ptr<SoundSource> create_sound_source(const std::string& filename);
+  std::auto_ptr<SoundSource> create_sound_source(const Pathname& filename);
 
 private:
-  static ALuint load_file_into_buffer(const std::string& filename);
+  static ALuint load_file_into_buffer(const Pathname& filename);
 
   void print_openal_version();
   void check_alc_error(const char* message);
@@ -93,7 +94,7 @@
   SoundChannel m_sound_channel;
   SoundChannel m_music_channel;
 
-  typedef std::map<std::string, ALuint> SoundBuffers;
+  typedef std::map<Pathname, ALuint> SoundBuffers;
   SoundBuffers m_buffers;
   typedef std::vector<boost::shared_ptr<SoundSource> > SoundSources;
   SoundSources m_sources;
@@ -102,13 +103,13 @@
   std::auto_ptr<StreamSoundSource> m_next_music_source;
 
   bool m_music_enabled;
-  std::string m_current_music;
+  Pathname m_current_music;
 
 private:
   SoundManager(const SoundManager&);
   SoundManager& operator=(const SoundManager&);
 };
-
+
 #endif
 
 /* EOF */

Modified: trunk/windstille/src/sound/wav_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/wav_sound_file.cpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/sound/wav_sound_file.cpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -22,6 +22,7 @@
 #include <stdint.h>
 
 #include "sound/wav_sound_file.hpp"
+#include "util/pathname.hpp"
 
 static inline uint32_t read32LE(PHYSFS_file* file)
 {
@@ -41,9 +42,9 @@
   return result;
 }
 
-WavSoundFile::WavSoundFile(PHYSFS_file* file_)
-  : file(file_),
-    datastart()
+WavSoundFile::WavSoundFile(const Pathname& filename) :
+  file(PHYSFS_openRead(filename.get_physfs_path().c_str())),
+  datastart()
 {
   char magic[4];
   if(PHYSFS_read(file, magic, sizeof(magic), 1) != 1)

Modified: trunk/windstille/src/sound/wav_sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/wav_sound_file.hpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/sound/wav_sound_file.hpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -26,7 +26,7 @@
 class WavSoundFile : public SoundFile
 {
 public:
-  WavSoundFile(PHYSFS_file* file);
+  WavSoundFile(const Pathname& filename);
   ~WavSoundFile();
 
   size_t read(void* buffer, size_t buffer_size);

Modified: trunk/windstille/src/util/currenton.hpp
===================================================================
--- trunk/windstille/src/util/currenton.hpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/util/currenton.hpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -39,7 +39,7 @@
   virtual ~Currenton() { s_current = 0; }
   
 public:
-  static C* current() { return s_current; }
+  static C* current() { /*assert(s_current);*/ return s_current; }
 };
 
 template<class C> C* Currenton<C>::s_current = 0;

Modified: trunk/windstille/src/util/pathname.cpp
===================================================================
--- trunk/windstille/src/util/pathname.cpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/util/pathname.cpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -262,6 +262,14 @@
     m_type == rhs.m_type;
 }
 
+bool
+Pathname::operator!=(const Pathname& rhs) const
+{
+  return
+    m_path != rhs.m_path ||
+    m_type != rhs.m_type;
+}
+
 std::ostream& operator<<(std::ostream& s, const Pathname& path)
 {
   switch(path.get_type())

Modified: trunk/windstille/src/util/pathname.hpp
===================================================================
--- trunk/windstille/src/util/pathname.hpp	2010-07-19 23:14:30 UTC (rev 3316)
+++ trunk/windstille/src/util/pathname.hpp	2010-07-20 01:11:24 UTC (rev 3317)
@@ -127,6 +127,7 @@
   bool operator<(const Pathname& rhs) const;
 
   bool operator==(const Pathname& rhs) const;
+  bool operator!=(const Pathname& rhs) const;
 
 private:
   std::string m_path;



From grumbel at mail.berlios.de  Tue Jul 20 03:39:14 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Tue, 20 Jul 2010 03:39:14 +0200
Subject: [Windstille-commit] r3318 - trunk/windstille/src/sound
Message-ID: <20100720013914.1D79E480B05@sheep.berlios.de>

Author: grumbel
Date: 2010-07-20 03:39:13 +0200 (Tue, 20 Jul 2010)
New Revision: 3318

Modified:
   trunk/windstille/src/sound/ogg_sound_file.cpp
   trunk/windstille/src/sound/ogg_sound_file.hpp
Log:
Switched OGG reading from PHYSFS to C++ stream


Modified: trunk/windstille/src/sound/ogg_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-20 01:11:24 UTC (rev 3317)
+++ trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-20 01:39:13 UTC (rev 3318)
@@ -21,11 +21,11 @@
 #include "util/pathname.hpp"
 
 OggSoundFile::OggSoundFile(const Pathname& filename) :
-  file(PHYSFS_openRead(filename.get_physfs_path().c_str())),
+  m_in(filename.get_sys_path().c_str(), std::ios::binary),
   vorbis_file()
 {
   ov_callbacks callbacks = { cb_read, cb_seek, cb_close, cb_tell };
-  ov_open_callbacks(file, &vorbis_file, 0, 0, callbacks);
+  ov_open_callbacks(&m_in, &vorbis_file, 0, 0, callbacks);
 
   vorbis_info* vi = ov_info(&vorbis_file, -1);
   channels = vi->channels;
@@ -70,36 +70,37 @@
 size_t
 OggSoundFile::cb_read(void* ptr, size_t size, size_t nmemb, void* source)
 {
-  PHYSFS_file* file = reinterpret_cast<PHYSFS_file*> (source);
-  
-  PHYSFS_sint64 res 
-    = PHYSFS_read(file, ptr, static_cast<PHYSFS_uint32> (size),
-                  static_cast<PHYSFS_uint32> (nmemb));
-  if(res <= 0)
-    return 0;
-
-  return static_cast<size_t> (res);
+  std::ifstream& in = *reinterpret_cast<std::ifstream*>(source);
+  if (!in.read(static_cast<char*>(ptr), size * nmemb))
+  {
+    return -1;
+  }
+  else
+  {
+    return in.gcount();
+  }
 }
 
 int
 OggSoundFile::cb_seek(void* source, ogg_int64_t offset, int whence)
 {
-  PHYSFS_file* file = reinterpret_cast<PHYSFS_file*> (source);
-
   switch(whence) 
   {
     case SEEK_SET:
-      if(PHYSFS_seek(file, static_cast<PHYSFS_uint64> (offset)) == 0)
+      if (!reinterpret_cast<std::ifstream*>(source)->seekg(offset, std::ios::beg))
         return -1;
       break;
+
     case SEEK_CUR:
-      if(PHYSFS_seek(file, PHYSFS_tell(file) + offset) == 0)
+      if (!reinterpret_cast<std::ifstream*>(source)->seekg(offset, std::ios::cur))
         return -1;
       break;
+
     case SEEK_END:
-      if(PHYSFS_seek(file, PHYSFS_fileLength(file) + offset) == 0)
+      if (!reinterpret_cast<std::ifstream*>(source)->seekg(offset, std::ios::end))
         return -1;
       break;
+
     default:
       return -1;
   }
@@ -109,16 +110,14 @@
 int
 OggSoundFile::cb_close(void* source)
 {
-  PHYSFS_file* file = reinterpret_cast<PHYSFS_file*> (source);
-  PHYSFS_close(file);
+  reinterpret_cast<std::ifstream*>(source)->close();
   return 0;
 }
 
 long
 OggSoundFile::cb_tell(void* source)
 {
-  PHYSFS_file* file = reinterpret_cast<PHYSFS_file*> (source);
-  return static_cast<long> (PHYSFS_tell(file));
+  return reinterpret_cast<std::ifstream*>(source)->tellg();
 }
 
 /* EOF */

Modified: trunk/windstille/src/sound/ogg_sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/ogg_sound_file.hpp	2010-07-20 01:11:24 UTC (rev 3317)
+++ trunk/windstille/src/sound/ogg_sound_file.hpp	2010-07-20 01:39:13 UTC (rev 3318)
@@ -21,6 +21,7 @@
 
 #include <vorbis/vorbisfile.h>
 #include <physfs.h>
+#include <fstream>
 
 #include "sound/sound_file.hpp"
 
@@ -45,7 +46,7 @@
   static int    cb_close(void* source);
   static long   cb_tell(void* source);
   
-  PHYSFS_file* file;
+  std::ifstream  m_in;
   OggVorbis_File vorbis_file;
 
   int channels;



From grumbel at mail.berlios.de  Tue Jul 20 13:43:37 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Tue, 20 Jul 2010 13:43:37 +0200
Subject: [Windstille-commit] r3319 - in trunk/windstille/src: sound sprite3d
	util
Message-ID: <20100720114337.72340480CBA@sheep.berlios.de>

Author: grumbel
Date: 2010-07-20 13:43:37 +0200 (Tue, 20 Jul 2010)
New Revision: 3319

Modified:
   trunk/windstille/src/sound/ogg_sound_file.cpp
   trunk/windstille/src/sound/ogg_sound_file.hpp
   trunk/windstille/src/sound/wav_sound_file.cpp
   trunk/windstille/src/sound/wav_sound_file.hpp
   trunk/windstille/src/sprite3d/data.cpp
   trunk/windstille/src/util/util.cpp
   trunk/windstille/src/util/util.hpp
Log:
Moved file reading helper functions into util/util.?pp
Removed PhysFS dependency in OggSoundFile


Modified: trunk/windstille/src/sound/ogg_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-20 01:39:13 UTC (rev 3318)
+++ trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-20 11:43:37 UTC (rev 3319)
@@ -18,15 +18,65 @@
 
 #include "sound/ogg_sound_file.hpp"
 
+#include <stdexcept>
+#include <sstream>
+
 #include "util/pathname.hpp"
 
 OggSoundFile::OggSoundFile(const Pathname& filename) :
   m_in(filename.get_sys_path().c_str(), std::ios::binary),
   vorbis_file()
 {
+  if (!m_in)
+  {
+    std::ostringstream str;
+    str << "OggSoundFile: Couldn't open: " << filename;
+    throw std::runtime_error(str.str());
+  }
+
+  // get the file size
+  m_in.seekg(0, std::ios::end);
+  m_file_size = m_in.tellg();
+  m_in.seekg(0, std::ios::beg);
+
   ov_callbacks callbacks = { cb_read, cb_seek, cb_close, cb_tell };
-  ov_open_callbacks(&m_in, &vorbis_file, 0, 0, callbacks);
 
+  int ret = ov_open_callbacks(this, &vorbis_file, 0, 0, callbacks);
+
+  if (ret != 0)
+  {
+    std::ostringstream str;
+
+    switch(ret)
+    {
+      case OV_EREAD:
+        str << "OV_EREAD error while opening ogg";
+        break;
+
+      case OV_ENOTVORBIS:
+        str << "OV_ENOTVORBIS error while opening ogg";
+        break;
+
+      case OV_EVERSION:
+        str << "OV_EVERSION error while opening ogg";
+        break;
+
+      case OV_EBADHEADER:
+        str << "OV_EBADHEADER error while opening ogg";
+        break;
+
+      case OV_EFAULT:
+        str << "OV_EFAULT error while opening ogg";
+        break;
+
+      default:
+        str << "Unknown error while opening ogg: " << ret;
+        break;
+    }
+
+    throw std::runtime_error(str.str());
+  }
+
   vorbis_info* vi = ov_info(&vorbis_file, -1);
   channels = vi->channels;
   rate = vi->rate;
@@ -68,36 +118,43 @@
 }
 
 size_t
-OggSoundFile::cb_read(void* ptr, size_t size, size_t nmemb, void* source)
+OggSoundFile::cb_read(void* ptr, size_t size, size_t nmemb, void* userdata)
 {
-  std::ifstream& in = *reinterpret_cast<std::ifstream*>(source);
-  if (!in.read(static_cast<char*>(ptr), size * nmemb))
-  {
-    return -1;
-  }
-  else
-  {
-    return in.gcount();
-  }
+  //std::cout << "OggSoundFile::cb_read: " << size * nmemb << std::endl;
+  OggSoundFile& ogg = *reinterpret_cast<OggSoundFile*>(userdata);
+
+  size_t read_len = size * nmemb;
+
+  // prevent std::istream from hitting eof(), needed as tellg() will
+  // return -1 in that case instead of the from cb_tell expected filesize
+  read_len = std::min(read_len, static_cast<size_t>(ogg.m_file_size - ogg.m_in.tellg()));
+
+  size_t len = ogg.m_in.read(static_cast<char*>(ptr), read_len).gcount();
+  return len;
 }
 
 int
-OggSoundFile::cb_seek(void* source, ogg_int64_t offset, int whence)
+OggSoundFile::cb_seek(void* userdata, ogg_int64_t offset, int whence)
 {
+  OggSoundFile& ogg = *reinterpret_cast<OggSoundFile*>(userdata);
+
   switch(whence) 
   {
     case SEEK_SET:
-      if (!reinterpret_cast<std::ifstream*>(source)->seekg(offset, std::ios::beg))
+      //std::cout << "OggSoundFile::cb_seek: " << offset << " BEG" << std::endl; 
+      if (!ogg.m_in.seekg(offset, std::ios::beg))
         return -1;
       break;
 
     case SEEK_CUR:
-      if (!reinterpret_cast<std::ifstream*>(source)->seekg(offset, std::ios::cur))
+      //std::cout << "OggSoundFile::cb_seek: " << offset << " CUR" << std::endl; 
+      if (!ogg.m_in.seekg(offset, std::ios::cur))
         return -1;
       break;
 
     case SEEK_END:
-      if (!reinterpret_cast<std::ifstream*>(source)->seekg(offset, std::ios::end))
+      //std::cout << "OggSoundFile::cb_seek: " << offset << " END" << std::endl; 
+      if (!ogg.m_in.seekg(offset, std::ios::end))
         return -1;
       break;
 
@@ -108,16 +165,21 @@
 }
   
 int
-OggSoundFile::cb_close(void* source)
+OggSoundFile::cb_close(void* userdata)
 {
-  reinterpret_cast<std::ifstream*>(source)->close();
+  //std::cout << "OggSoundFile::cb_close" << std::endl;
+  OggSoundFile& ogg = *reinterpret_cast<OggSoundFile*>(userdata);
+
+  ogg.m_in.close();
   return 0;
 }
 
 long
-OggSoundFile::cb_tell(void* source)
+OggSoundFile::cb_tell(void* userdata)
 {
-  return reinterpret_cast<std::ifstream*>(source)->tellg();
+  //std::cout << "OggSoundFile::cb_tell" << std::endl;
+  OggSoundFile& ogg = *reinterpret_cast<OggSoundFile*>(userdata);
+  return ogg.m_in.tellg();
 }
 
 /* EOF */

Modified: trunk/windstille/src/sound/ogg_sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/ogg_sound_file.hpp	2010-07-20 01:39:13 UTC (rev 3318)
+++ trunk/windstille/src/sound/ogg_sound_file.hpp	2010-07-20 11:43:37 UTC (rev 3319)
@@ -47,6 +47,7 @@
   static long   cb_tell(void* source);
   
   std::ifstream  m_in;
+  size_t m_file_size;
   OggVorbis_File vorbis_file;
 
   int channels;

Modified: trunk/windstille/src/sound/wav_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/wav_sound_file.cpp	2010-07-20 01:39:13 UTC (rev 3318)
+++ trunk/windstille/src/sound/wav_sound_file.cpp	2010-07-20 11:43:37 UTC (rev 3319)
@@ -23,128 +23,129 @@
 
 #include "sound/wav_sound_file.hpp"
 #include "util/pathname.hpp"
+#include "util/util.hpp"
 
-static inline uint32_t read32LE(PHYSFS_file* file)
-{
-  uint32_t result;
-  if(PHYSFS_readULE32(file, &result) == 0)
-    throw std::runtime_error("file too short");
-
-  return result;
-}
-
-static inline uint16_t read16LE(PHYSFS_file* file)
-{
-  uint16_t result;
-  if(PHYSFS_readULE16(file, &result) == 0)
-    throw std::runtime_error("file too short");
-
-  return result;
-}
-
 WavSoundFile::WavSoundFile(const Pathname& filename) :
-  file(PHYSFS_openRead(filename.get_physfs_path().c_str())),
+  file(filename.get_sys_path().c_str(), std::ios::binary),
   datastart()
-{
-  char magic[4];
-  if(PHYSFS_read(file, magic, sizeof(magic), 1) != 1)
-    throw std::runtime_error("Couldn't read file magic (not a wave file)");
-  if(strncmp(magic, "RIFF", 4) != 0) {
-    printf("MAGIC: %4s.\n", magic);
-    throw std::runtime_error("file is not a RIFF wav file");
-  }
+  {
+    char magic[4];
+    if (!file.read(magic, sizeof(magic)))
+    {
+      throw std::runtime_error("Couldn't read file magic (not a wave file)");
+    }
 
-  uint32_t wavelen = read32LE(file);
-  (void) wavelen;
+    if(strncmp(magic, "RIFF", 4) != 0) 
+    {
+      printf("MAGIC: %4s.\n", magic);
+      throw std::runtime_error("file is not a RIFF wav file");
+    }
+
+    uint32_t wavelen = read_uint32_t(file);
   
-  if(PHYSFS_read(file, magic, sizeof(magic), 1) != 1)
-    throw std::runtime_error("Couldn't read chunk header (not a wav file?)");
-  if(strncmp(magic, "WAVE", 4) != 0)
-    throw std::runtime_error("file is not a valid RIFF/WAVE file");
+    if (!file.read( magic, sizeof(magic)))
+    {
+      throw std::runtime_error("Couldn't read chunk header (not a wav file?)");
+    }
 
-  char chunkmagic[4];
-  uint32_t chunklen;
+    if(strncmp(magic, "WAVE", 4) != 0)
+    {
+      throw std::runtime_error("file is not a valid RIFF/WAVE file");
+    }
 
-  // search audio data format chunk
-  do {
-    if(PHYSFS_read(file, chunkmagic, sizeof(chunkmagic), 1) != 1)
-      throw std::runtime_error("EOF while searching format chunk");    
-    chunklen = read32LE(file);
+    char chunkmagic[4];
+    uint32_t chunklen;
+
+    // search audio data format chunk
+    do {
+      if (!file.read(chunkmagic, sizeof(chunkmagic)))
+      {
+        throw std::runtime_error("EOF while searching format chunk");    
+      }
+      chunklen = read_uint16_t(file);
     
-    if(strncmp(chunkmagic, "fmt ", 4) == 0)
-      break;
+      if (strncmp(chunkmagic, "fmt ", 4) == 0)
+        break;
 
-    if(strncmp(chunkmagic, "fact", 4) == 0
-       || strncmp(chunkmagic, "LIST", 4) == 0) {
-      // skip chunk
-      if(PHYSFS_seek(file, PHYSFS_tell(file) + chunklen) == 0)
-        throw std::runtime_error("EOF while searching fmt chunk");
-    } else {
-      throw std::runtime_error("complex WAVE files not supported");
-    }
-  } while(true); 
+      if (strncmp(chunkmagic, "fact", 4) == 0 ||
+          strncmp(chunkmagic, "LIST", 4) == 0) 
+      {
+        // skip chunk
 
-  if(chunklen < 16)
-    throw std::runtime_error("Format chunk too short");
+        if (!file.seekg(chunklen, std::ios::cur))
+        {
+          throw std::runtime_error("EOF while searching fmt chunk");
+        }
+      } 
+      else 
+      {
+        throw std::runtime_error("complex WAVE files not supported");
+      }
+    } while(true); 
+
+    if(chunklen < 16)
+      throw std::runtime_error("Format chunk too short");
  
-  // parse format
-  uint16_t encoding = read16LE(file);
-  if(encoding != 1)
-    throw std::runtime_error("only PCM encoding supported");
-  channels = read16LE(file);
-  rate = read32LE(file);
-  uint32_t byterate = read32LE(file);
-  (void) byterate;
-  uint16_t blockalign = read16LE(file);
-  (void) blockalign;
-  bits_per_sample = read16LE(file);
+    // parse format
+    uint16_t encoding = read_uint16_t(file);
+    if(encoding != 1)
+      throw std::runtime_error("only PCM encoding supported");
+    channels = read_uint16_t(file);
+    rate = read_uint32_t(file);
+    uint32_t byterate = read_uint32_t(file);
+    uint16_t blockalign = read_uint16_t(file);
+    bits_per_sample = read_uint16_t(file);
 
-  if(chunklen > 16) {
-    if(PHYSFS_seek(file, PHYSFS_tell(file) + (chunklen-16)) == 0)
-      throw std::runtime_error("EOF while reading reast of format chunk");
-  }
+    if(chunklen > 16) 
+    {
+      if(file.seekg(chunklen-16, std::ios::cur) == 0)
+        throw std::runtime_error("EOF while reading reast of format chunk");
+    }
 
-  // set file offset to DATA chunk data
-  do {
-    if(PHYSFS_read(file, chunkmagic, sizeof(chunkmagic), 1) != 1)
-      throw std::runtime_error("EOF while searching data chunk");    
-    chunklen = read32LE(file);
+    // set file offset to DATA chunk data
+    do {
+      if (!file.read(chunkmagic, sizeof(chunkmagic)))
+        throw std::runtime_error("EOF while searching data chunk");    
+      chunklen = read_uint32_t(file);
 
-    if(strncmp(chunkmagic, "data", 4) == 0)
-      break;
+      if(strncmp(chunkmagic, "data", 4) == 0)
+        break;
 
-    // skip chunk
-    if(PHYSFS_seek(file, PHYSFS_tell(file) + chunklen) == 0)
-      throw std::runtime_error("EOF while searching fmt chunk");
-  } while(true);
+      // skip chunk
+      if(file.seekg(chunklen, std::ios::cur) == 0)
+        throw std::runtime_error("EOF while searching fmt chunk");
+    } while(true);
 
-  datastart = PHYSFS_tell(file);
-  size = static_cast<size_t> (chunklen);
-}
+    datastart = file.tellg();
+    size = static_cast<size_t> (chunklen);
+  }
 
 WavSoundFile::~WavSoundFile()
 {
-  PHYSFS_close(file);
 }
 
 void
 WavSoundFile::reset()
 {
-  if(PHYSFS_seek(file, datastart) == 0)
+  if (!file.seekg(datastart))
     throw std::runtime_error("Couldn't seek to data start");
 }
 
 size_t
 WavSoundFile::read(void* buffer, size_t buffer_size)
 {
-  PHYSFS_sint64 end = datastart + size;
-  PHYSFS_sint64 cur = PHYSFS_tell(file);
-  if(cur >= end)
+  size_t end = datastart + size;
+  size_t cur = file.tellg();
+
+  if (cur >= end)
     return 0;
   
   size_t readsize = std::min(static_cast<size_t> (end - cur), buffer_size);
-  if(PHYSFS_read(file, buffer, readsize, 1) != 1)
+
+  if (!file.read(static_cast<char*>(buffer), readsize))
+  {
     throw std::runtime_error("read error while reading samples");
+  }
 
   return readsize;
 }

Modified: trunk/windstille/src/sound/wav_sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/wav_sound_file.hpp	2010-07-20 01:39:13 UTC (rev 3318)
+++ trunk/windstille/src/sound/wav_sound_file.hpp	2010-07-20 11:43:37 UTC (rev 3319)
@@ -19,7 +19,7 @@
 #ifndef HEADER_WINDSTILLE_SOUND_WAV_SOUND_FILE_HPP
 #define HEADER_WINDSTILLE_SOUND_WAV_SOUND_FILE_HPP
 
-#include <physfs.h>
+#include <fstream>
 
 #include "sound/sound_file.hpp"
 
@@ -33,8 +33,8 @@
   void reset();
 
 private:
-  PHYSFS_file* file; 
-  PHYSFS_sint64 datastart;
+  std::ifstream file; 
+  size_t datastart;
 
 public:
   int    get_bits_per_sample() const { return bits_per_sample; }

Modified: trunk/windstille/src/sprite3d/data.cpp
===================================================================
--- trunk/windstille/src/sprite3d/data.cpp	2010-07-20 01:39:13 UTC (rev 3318)
+++ trunk/windstille/src/sprite3d/data.cpp	2010-07-20 11:43:37 UTC (rev 3319)
@@ -31,59 +31,11 @@
 
 static const int FORMAT_VERSION = 2;
 
-static inline float read_float(std::istream& in)
+Data::Data(const Pathname& filename) :
+  meshs(),
+  attachment_points(),
+  actions()
 {
-  float result;
-  
-  if (!in.read(reinterpret_cast<char*>(&result), sizeof(result)))
-  {
-    std::ostringstream msg;
-    msg << "Problem reading float value: " << strerror(errno);
-    throw std::runtime_error(msg.str());
-  }
-  else
-  {
-    return result;
-  }
-}
-
-static inline uint16_t read_uint16_t(std::istream& in)
-{
-  uint16_t result;
-
-  if (!in.read(reinterpret_cast<char*>(&result), sizeof(result)))
-  {
-    std::ostringstream msg;
-    msg << "Problem reading uint16 value: " << strerror(errno);
-    throw std::runtime_error(msg.str());
-  }
-  {
-    return result;
-  }
-}
-
-static inline std::string read_string(std::istream& in, size_t size)
-{
-  boost::scoped_array<char> buffer(new char[size+1]);
-
-  if (!in.read(reinterpret_cast<char*>(buffer.get()), size))
-  {
-    std::ostringstream msg;
-    msg << "Problem reading string value: " << strerror(errno);
-    throw std::runtime_error(msg.str());
-  }
-  else
-  {
-    buffer[size] = '\0';
-    return std::string(buffer.get());
-  }
-}
-
-Data::Data(const Pathname& filename)
-  : meshs(),
-    attachment_points(),
-    actions()
-{
   std::ifstream in(filename.get_sys_path().c_str(), std::ios::binary);
 
   if (!in) 

Modified: trunk/windstille/src/util/util.cpp
===================================================================
--- trunk/windstille/src/util/util.cpp	2010-07-20 01:39:13 UTC (rev 3318)
+++ trunk/windstille/src/util/util.cpp	2010-07-20 11:43:37 UTC (rev 3319)
@@ -16,7 +16,14 @@
 **  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
+#include "util/util.hpp"
+
 #include <fstream>
+#include <sstream>
+#include <errno.h>
+#include <string.h>
+#include <stdexcept>
+#include <boost/scoped_array.hpp>
 
 std::string dirname(const std::string& filename)
 {
@@ -40,12 +47,12 @@
 {
   std::ifstream in(filename.c_str());
   while (true)
-    {
-      char c = static_cast<char>(in.get());
-      if (!in.good())
-        break;
-      str += c;
-    }
+  {
+    char c = static_cast<char>(in.get());
+    if (!in.good())
+      break;
+    str += c;
+  }
 }
 
 bool has_suffix(const std::string& str, const std::string& suffix)
@@ -64,4 +71,69 @@
   return out;
 }
 
+float read_float(std::istream& in)
+{
+  float result;
+  
+  if (!in.read(reinterpret_cast<char*>(&result), sizeof(result)))
+  {
+    std::ostringstream msg;
+    msg << "Problem reading float value: " << strerror(errno);
+    throw std::runtime_error(msg.str());
+  }
+  else
+  {
+    return result;
+  }
+}
+
+uint16_t read_uint16_t(std::istream& in)
+{
+  uint16_t result;
+
+  if (!in.read(reinterpret_cast<char*>(&result), sizeof(result)))
+  {
+    std::ostringstream msg;
+    msg << "Problem reading uint16 value: " << strerror(errno);
+    throw std::runtime_error(msg.str());
+  }
+  else
+  {
+    return result;
+  }
+}
+
+uint32_t read_uint32_t(std::istream& in)
+{
+  uint32_t result;
+
+  if (!in.read(reinterpret_cast<char*>(&result), sizeof(result)))
+  {
+    std::ostringstream msg;
+    msg << "Problem reading uint32 value: " << strerror(errno);
+    throw std::runtime_error(msg.str());
+  }
+  else
+  {
+    return result;
+  }
+}
+
+std::string read_string(std::istream& in, size_t size)
+{
+  boost::scoped_array<char> buffer(new char[size+1]);
+
+  if (!in.read(reinterpret_cast<char*>(buffer.get()), size))
+  {
+    std::ostringstream msg;
+    msg << "Problem reading string value: " << strerror(errno);
+    throw std::runtime_error(msg.str());
+  }
+  else
+  {
+    buffer[size] = '\0';
+    return std::string(buffer.get());
+  }
+}
+
 /* EOF */

Modified: trunk/windstille/src/util/util.hpp
===================================================================
--- trunk/windstille/src/util/util.hpp	2010-07-20 01:39:13 UTC (rev 3318)
+++ trunk/windstille/src/util/util.hpp	2010-07-20 11:43:37 UTC (rev 3319)
@@ -20,6 +20,7 @@
 #define HEADER_WINDSTILLE_UTIL_UTIL_HPP
 
 #include <sstream>
+#include <stdint.h>
 
 std::string dirname(const std::string& filename);
 std::string basename(const std::string& filename);
@@ -39,6 +40,11 @@
   return os.str();
 }
 
+float       read_float(std::istream& in);
+uint16_t    read_uint16_t(std::istream& in);
+uint32_t    read_uint32_t(std::istream& in);
+std::string read_string(std::istream& in, size_t size);
+
 #endif
 
 /* EOF */



From grumbel at mail.berlios.de  Tue Jul 20 13:48:25 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Tue, 20 Jul 2010 13:48:25 +0200
Subject: [Windstille-commit] r3320 - trunk/windstille/src/sound
Message-ID: <20100720114825.CC613480CBA@sheep.berlios.de>

Author: grumbel
Date: 2010-07-20 13:48:25 +0200 (Tue, 20 Jul 2010)
New Revision: 3320

Modified:
   trunk/windstille/src/sound/sound_manager.cpp
   trunk/windstille/src/sound/sound_manager.hpp
   trunk/windstille/src/sound/sound_source.cpp
   trunk/windstille/src/sound/sound_source.hpp
   trunk/windstille/src/sound/stream_sound_source.cpp
Log:
Return handle to the source when a sound is played


Modified: trunk/windstille/src/sound/sound_manager.cpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.cpp	2010-07-20 11:43:37 UTC (rev 3319)
+++ trunk/windstille/src/sound/sound_manager.cpp	2010-07-20 11:48:25 UTC (rev 3320)
@@ -161,7 +161,7 @@
   }
 }
 
-void
+SoundSourcePtr
 SoundManager::play(const Pathname& filename, const Vector2f& pos)
 {
   try
@@ -173,7 +173,9 @@
       source->set_position(pos);
 
       source->play();
-      m_sources.push_back(boost::shared_ptr<SoundSource>(source.release()));
+      SoundSourcePtr source_ptr(source.release());
+      m_sources.push_back(source_ptr);
+      return source_ptr;
     }
   }
   catch(std::exception& e) 
@@ -314,7 +316,7 @@
     // check for finished sound sources
     for(SoundSources::iterator i = m_sources.begin(); i != m_sources.end(); ) 
     {
-      if (!(*i)->playing())
+      if (!(*i)->is_playing())
       {
         i = m_sources.erase(i);
       } 
@@ -330,7 +332,7 @@
       m_music_source->update(delta);
     }
   
-    if (m_next_music_source.get() && (!m_music_source.get() || !m_music_source->playing())) 
+    if (m_next_music_source.get() && (!m_music_source.get() || !m_music_source->is_playing())) 
     {
       m_music_source = m_next_music_source;
       //music_source->setFading(StreamSoundSource::FadingOn, 1.0f);

Modified: trunk/windstille/src/sound/sound_manager.hpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.hpp	2010-07-20 11:43:37 UTC (rev 3319)
+++ trunk/windstille/src/sound/sound_manager.hpp	2010-07-20 11:48:25 UTC (rev 3320)
@@ -60,7 +60,7 @@
   /**
    * Convenience function to simply play a sound at a given position.
    */
-  void play(const Pathname& name, const Vector2f& pos = Vector2f(-1, -1));
+  SoundSourcePtr play(const Pathname& name, const Vector2f& pos = Vector2f(-1, -1));
 
   void play_music(const Pathname& filename, bool fade = true);
   void stop_music(bool fade = true);

Modified: trunk/windstille/src/sound/sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/sound_source.cpp	2010-07-20 11:43:37 UTC (rev 3319)
+++ trunk/windstille/src/sound/sound_source.cpp	2010-07-20 11:48:25 UTC (rev 3320)
@@ -50,7 +50,7 @@
 }
 
 bool
-SoundSource::playing()
+SoundSource::is_playing() const
 {
   ALint state = AL_PLAYING;
   alGetSourcei(m_source, AL_SOURCE_STATE, &state);

Modified: trunk/windstille/src/sound/sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/sound_source.hpp	2010-07-20 11:43:37 UTC (rev 3319)
+++ trunk/windstille/src/sound/sound_source.hpp	2010-07-20 11:48:25 UTC (rev 3320)
@@ -33,7 +33,7 @@
 
   void play();
   void stop();
-  bool playing();
+  bool is_playing() const;
 
   void set_looping(bool looping);
 

Modified: trunk/windstille/src/sound/stream_sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-20 11:43:37 UTC (rev 3319)
+++ trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-20 11:48:25 UTC (rev 3320)
@@ -65,7 +65,7 @@
 {
   m_total_time += delta;
 
-  if (playing())
+  if (is_playing())
   {
     ALint processed = 0;
     alGetSourcei(m_source, AL_BUFFERS_PROCESSED, &processed);
@@ -82,7 +82,7 @@
     }
   
     // we might have to restart the source if we had a buffer underrun
-    if (!playing()) 
+    if (!is_playing()) 
     {
       std::cerr << "Restarting audio source because of buffer underrun.\n";
       alSourcePlay(m_source);



From grumbel at mail.berlios.de  Tue Jul 20 14:32:16 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Tue, 20 Jul 2010 14:32:16 +0200
Subject: [Windstille-commit] r3321 - trunk/windstille/src/sound
Message-ID: <20100720123216.9535B480CBA@sheep.berlios.de>

Author: grumbel
Date: 2010-07-20 14:32:16 +0200 (Tue, 20 Jul 2010)
New Revision: 3321

Modified:
   trunk/windstille/src/sound/wav_sound_file.cpp
Log:
Fixed indention and a uint16/uint32 mixup


Modified: trunk/windstille/src/sound/wav_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/wav_sound_file.cpp	2010-07-20 11:48:25 UTC (rev 3320)
+++ trunk/windstille/src/sound/wav_sound_file.cpp	2010-07-20 12:32:16 UTC (rev 3321)
@@ -26,99 +26,112 @@
 #include "util/util.hpp"
 
 WavSoundFile::WavSoundFile(const Pathname& filename) :
-  file(filename.get_sys_path().c_str(), std::ios::binary),
+  file(),
   datastart()
+{
+  file.open(filename.get_sys_path().c_str(), std::ios::binary);
+  if (!file)
   {
-    char magic[4];
-    if (!file.read(magic, sizeof(magic)))
-    {
-      throw std::runtime_error("Couldn't read file magic (not a wave file)");
-    }
+    std::ostringstream str;
+    str << "WavSoundFile(): Couldn't open " << filename;
+    throw std::runtime_error(str.str());
+  }
 
-    if(strncmp(magic, "RIFF", 4) != 0) 
-    {
-      printf("MAGIC: %4s.\n", magic);
-      throw std::runtime_error("file is not a RIFF wav file");
-    }
+  char magic[4];
+  if (!file.read(magic, sizeof(magic)))
+  {
+    throw std::runtime_error("Couldn't read file magic (not a wave file)");
+  }
 
-    uint32_t wavelen = read_uint32_t(file);
+  if(strncmp(magic, "RIFF", 4) != 0) 
+  {
+    printf("MAGIC: %4s.\n", magic);
+    throw std::runtime_error("file is not a RIFF wav file");
+  }
+
+  uint32_t wavelen = read_uint32_t(file);
   
-    if (!file.read( magic, sizeof(magic)))
+  if (!file.read( magic, sizeof(magic)))
+  {
+    throw std::runtime_error("Couldn't read chunk header (not a wav file?)");
+  }
+
+  if(strncmp(magic, "WAVE", 4) != 0)
+  {
+    throw std::runtime_error("file is not a valid RIFF/WAVE file");
+  }
+
+  char chunkmagic[4];
+  uint32_t chunklen;
+
+  // search audio data format chunk
+  do {
+    if (!file.read(chunkmagic, sizeof(chunkmagic)))
     {
-      throw std::runtime_error("Couldn't read chunk header (not a wav file?)");
+      throw std::runtime_error("EOF while searching format chunk");    
     }
-
-    if(strncmp(magic, "WAVE", 4) != 0)
+    chunklen = read_uint32_t(file);
+    
+    if (strncmp(chunkmagic, "fmt ", 4) == 0)
     {
-      throw std::runtime_error("file is not a valid RIFF/WAVE file");
+      break;
     }
+    else if (strncmp(chunkmagic, "fact", 4) == 0 ||
+             strncmp(chunkmagic, "LIST", 4) == 0)
+    {
+      // skip chunk
 
-    char chunkmagic[4];
-    uint32_t chunklen;
-
-    // search audio data format chunk
-    do {
-      if (!file.read(chunkmagic, sizeof(chunkmagic)))
+      if (!file.seekg(chunklen, std::ios::cur))
       {
-        throw std::runtime_error("EOF while searching format chunk");    
+        throw std::runtime_error("EOF while searching fmt chunk");
       }
-      chunklen = read_uint16_t(file);
-    
-      if (strncmp(chunkmagic, "fmt ", 4) == 0)
-        break;
+    }
+    else 
+    {
+      throw std::runtime_error("complex WAVE files not supported");
+    }
+  } while(true); 
 
-      if (strncmp(chunkmagic, "fact", 4) == 0 ||
-          strncmp(chunkmagic, "LIST", 4) == 0) 
-      {
-        // skip chunk
-
-        if (!file.seekg(chunklen, std::ios::cur))
-        {
-          throw std::runtime_error("EOF while searching fmt chunk");
-        }
-      } 
-      else 
-      {
-        throw std::runtime_error("complex WAVE files not supported");
-      }
-    } while(true); 
-
-    if(chunklen < 16)
-      throw std::runtime_error("Format chunk too short");
+  if (chunklen < 16)
+    throw std::runtime_error("Format chunk too short");
  
-    // parse format
-    uint16_t encoding = read_uint16_t(file);
-    if(encoding != 1)
-      throw std::runtime_error("only PCM encoding supported");
-    channels = read_uint16_t(file);
-    rate = read_uint32_t(file);
-    uint32_t byterate = read_uint32_t(file);
-    uint16_t blockalign = read_uint16_t(file);
-    bits_per_sample = read_uint16_t(file);
+  // parse format
+  uint16_t encoding = read_uint16_t(file);
+  if (encoding != 1)
+  {
+    std::ostringstream str;
+    str << "WavSoundFile(): only PCM encoding supported, got " << encoding;
+    throw std::runtime_error(str.str());
+  }
+  channels = read_uint16_t(file);
+  rate = read_uint32_t(file);
+  uint32_t byterate = read_uint32_t(file);
+  uint16_t blockalign = read_uint16_t(file);
+  bits_per_sample = read_uint16_t(file);
 
-    if(chunklen > 16) 
-    {
-      if(file.seekg(chunklen-16, std::ios::cur) == 0)
-        throw std::runtime_error("EOF while reading reast of format chunk");
-    }
+  if(chunklen > 16) 
+  {
+    if(file.seekg(chunklen-16, std::ios::cur) == 0)
+      throw std::runtime_error("EOF while reading reast of format chunk");
+  }
 
-    // set file offset to DATA chunk data
-    do {
-      if (!file.read(chunkmagic, sizeof(chunkmagic)))
-        throw std::runtime_error("EOF while searching data chunk");    
-      chunklen = read_uint32_t(file);
+  // set file offset to DATA chunk data
+  do {
+    if (!file.read(chunkmagic, sizeof(chunkmagic)))
+      throw std::runtime_error("EOF while searching data chunk");    
+    chunklen = read_uint32_t(file);
 
-      if(strncmp(chunkmagic, "data", 4) == 0)
-        break;
+    if(strncmp(chunkmagic, "data", 4) == 0)
+      break;
 
-      // skip chunk
-      if(file.seekg(chunklen, std::ios::cur) == 0)
-        throw std::runtime_error("EOF while searching fmt chunk");
-    } while(true);
+    // skip chunk
+    if(file.seekg(chunklen, std::ios::cur) == 0)
+      throw std::runtime_error("EOF while searching fmt chunk");
+  } while(true);
 
-    datastart = file.tellg();
-    size = static_cast<size_t> (chunklen);
-  }
+  datastart = file.tellg();
+  size = static_cast<size_t> (chunklen);
+}
 
 WavSoundFile::~WavSoundFile()
 {



From grumbel at mail.berlios.de  Tue Jul 20 23:36:00 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Tue, 20 Jul 2010 23:36:00 +0200
Subject: [Windstille-commit] r3322 - in trunk/windstille/src: app editor
	sound
Message-ID: <20100720213600.A44B748026F@sheep.berlios.de>

Author: grumbel
Date: 2010-07-20 23:36:00 +0200 (Tue, 20 Jul 2010)
New Revision: 3322

Modified:
   trunk/windstille/src/app/config.hpp
   trunk/windstille/src/editor/timeline_commands.hpp
   trunk/windstille/src/editor/timeline_widget.cpp
   trunk/windstille/src/sound/ogg_sound_file.cpp
   trunk/windstille/src/sound/ogg_sound_file.hpp
   trunk/windstille/src/sound/sound_channel.cpp
   trunk/windstille/src/sound/sound_channel.hpp
   trunk/windstille/src/sound/sound_manager.cpp
   trunk/windstille/src/sound/sound_manager.hpp
   trunk/windstille/src/sound/sound_source.cpp
   trunk/windstille/src/sound/sound_source.hpp
   trunk/windstille/src/sound/stream_sound_source.hpp
   trunk/windstille/src/sound/wav_sound_file.cpp
   trunk/windstille/src/sound/wav_sound_file.hpp
Log:
Fixed a bunch of warnings


Modified: trunk/windstille/src/app/config.hpp
===================================================================
--- trunk/windstille/src/app/config.hpp	2010-07-20 12:32:16 UTC (rev 3321)
+++ trunk/windstille/src/app/config.hpp	2010-07-20 21:36:00 UTC (rev 3322)
@@ -95,8 +95,9 @@
     return data;
   }
   
-  T& operator=(const T& data_) {
-    return set(data_);
+  ConfigValue<T>& operator=(const T& data_) {
+    set(data_);
+    return *this;
   }
 
   void write(lisp::Writer& writer);

Modified: trunk/windstille/src/editor/timeline_commands.hpp
===================================================================
--- trunk/windstille/src/editor/timeline_commands.hpp	2010-07-20 12:32:16 UTC (rev 3321)
+++ trunk/windstille/src/editor/timeline_commands.hpp	2010-07-20 21:36:00 UTC (rev 3322)
@@ -84,8 +84,9 @@
   TimelineLayerHandle m_layer;
 
 public:
-  TimelineAddLayerCommand(SectorModel& sector, const std::string& name)
-    : m_sector(sector)
+  TimelineAddLayerCommand(SectorModel& sector, const std::string& name) :
+    m_sector(sector),
+    m_layer()
   {
     m_layer = m_sector.get_timeline()->create_layer(name);
   }

Modified: trunk/windstille/src/editor/timeline_widget.cpp
===================================================================
--- trunk/windstille/src/editor/timeline_widget.cpp	2010-07-20 12:32:16 UTC (rev 3321)
+++ trunk/windstille/src/editor/timeline_widget.cpp	2010-07-20 21:36:00 UTC (rev 3322)
@@ -131,7 +131,7 @@
       for (std::set<TimelineObjectHandle>::iterator i = m_selection.begin(); 
            i != m_selection.end(); ++i)
       {
-        (*i)->set_pos((*i)->get_pos() + (move_pos.x - down_pos.x)/m_column_width);
+        (*i)->set_pos((*i)->get_pos() + (move_pos.x - down_pos.x) / static_cast<float>(m_column_width));
       }
     }
     queue_draw();
@@ -173,13 +173,16 @@
 TimelineWidget::add_to_selection(const Rectf& selection)
 {
   Timeline::iterator start = m_timeline->begin() + 
-    std::max(0, std::min(m_timeline->size(), static_cast<int>((selection.top + m_column_height/2)    / m_column_height)));
+    std::max(0, std::min(m_timeline->size(),
+                         static_cast<int>((selection.top + static_cast<float>(m_column_height)/2) / static_cast<float>(m_column_height))));
   Timeline::iterator end   = m_timeline->begin() + 
-    std::max(0, std::min(m_timeline->size(), static_cast<int>((selection.bottom + m_column_height/2) / m_column_height)));
+    std::max(0, std::min(m_timeline->size(), 
+                         static_cast<int>((selection.bottom + static_cast<float>(m_column_height)/2) / static_cast<float>(m_column_height))));
 
   for(Timeline::iterator i = start; i != end; ++i)
   {
-    const TimelineLayer::Objects& objects = (*i)->get_objects(selection.left / m_column_width, selection.right / m_column_width);
+    const TimelineLayer::Objects& objects 
+      = (*i)->get_objects(selection.left / static_cast<float>(m_column_width), selection.right / static_cast<float>(m_column_width));
     m_selection.insert(objects.begin(), objects.end());
   }
 }
@@ -253,7 +256,7 @@
   {
     if (x % (m_column_width * 10) == 0)
     {
-      cr->rectangle(x, 0, m_column_width, height);
+      cr->rectangle(x, 0, static_cast<float>(m_column_width), height);
     }
   }
   cr->fill();
@@ -289,7 +292,7 @@
   cr->save();
 
   cr->set_source_rgb(1,1,1);
-  cr->rectangle(0, 0, allocation.get_width(), m_column_height * m_timeline->size());
+  cr->rectangle(0, 0, allocation.get_width(), static_cast<float>(m_column_height) * static_cast<float>(m_timeline->size()));
   cr->fill();
   
   draw_grid(cr);
@@ -298,12 +301,12 @@
   for(Timeline::iterator i = m_timeline->begin(); i != m_timeline->end(); ++i)
   {
     draw_timeline_layer(cr, *i);
-    cr->translate(0, m_column_height);
+    cr->translate(0, static_cast<float>(m_column_height));
   }
   cr->restore();
 
-  cr->rectangle(m_cursor_pos * m_column_width, 0,
-                m_column_width, m_timeline->size() * m_column_height);
+  cr->rectangle(m_cursor_pos * static_cast<float>(m_column_width), 0,
+                static_cast<float>(m_column_width), static_cast<float>(m_timeline->size()) * static_cast<float>(m_column_height));
   cr->set_source_rgba(1,1,0,0.5);
   cr->fill_preserve();
   cr->set_line_width(1.0f);
@@ -341,7 +344,8 @@
         cr->set_source_rgb(0.5, 0.75, 0.0);
       }
       
-      cr->rectangle(keyframe->get_pos() * m_column_width, 4, m_column_width, m_column_height - 8);
+      cr->rectangle(keyframe->get_pos() * static_cast<float>(m_column_width), 
+                    4.0f, static_cast<float>(m_column_width), static_cast<float>(m_column_height) - 8.0f);
       cr->fill();
 
       if (in_selection)
@@ -349,7 +353,8 @@
       else
         cr->set_source_rgb(0, 0, 0);
 
-      cr->rectangle(keyframe->get_pos() * m_column_width, 4, m_column_width, m_column_height - 8);
+      cr->rectangle(keyframe->get_pos() * static_cast<float>(m_column_width), 4.0f, 
+                    static_cast<float>(m_column_width), static_cast<float>(m_column_height) - 8.0f);
       cr->stroke();  
       
       cr->restore();
@@ -386,8 +391,8 @@
         cr->set_source_rgb(0.0, 0.5, 0.75);
       }
 
-      cr->rectangle(anim->get_pos()   * m_column_width,  4,
-                    anim->get_width() * m_column_width, m_column_height - 8);
+      cr->rectangle(anim->get_pos()   * static_cast<float>(m_column_width),  4,
+                    anim->get_width() * static_cast<float>(m_column_width), static_cast<float>(m_column_height) - 8);
       cr->fill();
 
       if (in_selection)
@@ -399,13 +404,13 @@
         cr->set_source_rgb(0, 0, 0);
       }
 
-      cr->rectangle(anim->get_pos()   * m_column_width, 4,
-                    anim->get_width() * m_column_width, m_column_height - 8);
+      cr->rectangle(anim->get_pos()   * static_cast<float>(m_column_width), 4,
+                    anim->get_width() * static_cast<float>(m_column_width), static_cast<float>(m_column_height) - 8);
       cr->stroke();
 
       cr->set_source_rgb(1,1,1);
-      cr->move_to((anim->get_pos() + anim->get_width()/2) * m_column_width - extents.width/2, 
-                  m_column_height / 2 + 4);
+      cr->move_to((anim->get_pos() + anim->get_width()/2) * static_cast<float>(m_column_width) - extents.width/2, 
+                  static_cast<float>(m_column_height) / 2 + 4);
       cr->show_text(anim->get_name());
 
       cr->restore();
@@ -443,18 +448,18 @@
         cr->set_source_rgb(0.75, 0.0, 0.5);
       }
 
-      cr->rectangle(sound->get_pos()   * m_column_width,  4,
-                    sound->get_width() * m_column_width, m_column_height - 8);
+      cr->rectangle(sound->get_pos()   * static_cast<float>(m_column_width),  4,
+                    sound->get_width() * static_cast<float>(m_column_width), static_cast<float>(m_column_height) - 8);
       cr->fill();
 
       cr->set_source_rgb(0, 0, 0);
-      cr->rectangle(sound->get_pos()   * m_column_width, 4,
-                    sound->get_width() * m_column_width, m_column_height - 8);
+      cr->rectangle(sound->get_pos()   * static_cast<float>(m_column_width), 4,
+                    sound->get_width() * static_cast<float>(m_column_width), static_cast<float>(m_column_height) - 8);
       cr->stroke();
 
       cr->set_source_rgb(1,1,0);
-      cr->move_to((sound->get_pos() + sound->get_width()/2) * m_column_width - extents.width/2, 
-                  m_column_height / 2 + 4);
+      cr->move_to((sound->get_pos() + sound->get_width()/2) * static_cast<float>(m_column_width) - extents.width / 2.0f, 
+                  static_cast<float>(m_column_height) / 2 + 4);
       cr->show_text(sound->get_name());
 
       cr->restore();

Modified: trunk/windstille/src/sound/ogg_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-20 12:32:16 UTC (rev 3321)
+++ trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-20 21:36:00 UTC (rev 3322)
@@ -24,9 +24,15 @@
 #include "util/pathname.hpp"
 
 OggSoundFile::OggSoundFile(const Pathname& filename) :
-  m_in(filename.get_sys_path().c_str(), std::ios::binary),
-  vorbis_file()
+  m_in(),
+  m_file_size(),
+  m_vorbis_file(),
+  m_channels(),
+  m_rate(),
+  m_bits_per_sample(),
+  m_size()
 {
+  m_in.open(filename.get_sys_path().c_str(), std::ios::binary);
   if (!m_in)
   {
     std::ostringstream str;
@@ -36,12 +42,12 @@
 
   // get the file size
   m_in.seekg(0, std::ios::end);
-  m_file_size = m_in.tellg();
+  m_file_size = static_cast<size_t>(m_in.tellg());
   m_in.seekg(0, std::ios::beg);
 
   ov_callbacks callbacks = { cb_read, cb_seek, cb_close, cb_tell };
 
-  int ret = ov_open_callbacks(this, &vorbis_file, 0, 0, callbacks);
+  int ret = ov_open_callbacks(this, &m_vorbis_file, 0, 0, callbacks);
 
   if (ret != 0)
   {
@@ -77,16 +83,16 @@
     throw std::runtime_error(str.str());
   }
 
-  vorbis_info* vi = ov_info(&vorbis_file, -1);
-  channels = vi->channels;
-  rate = vi->rate;
-  bits_per_sample = 16;
-  size = static_cast<size_t> (ov_pcm_total(&vorbis_file, -1) * 2);
+  vorbis_info* vi = ov_info(&m_vorbis_file, -1);
+  m_channels = vi->channels;
+  m_rate = vi->rate;
+  m_bits_per_sample = 16;
+  m_size = static_cast<size_t> (ov_pcm_total(&m_vorbis_file, -1) * 2);
 }
 
 OggSoundFile::~OggSoundFile()
 {
-  ov_clear(&vorbis_file);
+  ov_clear(&m_vorbis_file);
 }
 
 size_t
@@ -98,7 +104,7 @@
 
   while(buffer_size>0){
     long bytesRead 
-      = ov_read(&vorbis_file, buffer, static_cast<int> (buffer_size), 0, 2, 1,
+      = ov_read(&m_vorbis_file, buffer, static_cast<int> (buffer_size), 0, 2, 1,
                 &section);
     if(bytesRead==0){
       break;
@@ -114,7 +120,7 @@
 void
 OggSoundFile::reset()
 {
-  ov_raw_seek(&vorbis_file, 0);
+  ov_raw_seek(&m_vorbis_file, 0);
 }
 
 size_t
@@ -179,7 +185,7 @@
 {
   //std::cout << "OggSoundFile::cb_tell" << std::endl;
   OggSoundFile& ogg = *reinterpret_cast<OggSoundFile*>(userdata);
-  return ogg.m_in.tellg();
+  return static_cast<long>(ogg.m_in.tellg());
 }
 
 /* EOF */

Modified: trunk/windstille/src/sound/ogg_sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/ogg_sound_file.hpp	2010-07-20 12:32:16 UTC (rev 3321)
+++ trunk/windstille/src/sound/ogg_sound_file.hpp	2010-07-20 21:36:00 UTC (rev 3322)
@@ -34,10 +34,10 @@
   size_t read(void* buffer, size_t buffer_size);
   void reset();
 
-  int    get_bits_per_sample() const { return bits_per_sample; }
-  size_t get_size() const { return size; }
-  int    get_rate() const { return rate; }
-  int    get_channels() const { return channels; }
+  int    get_bits_per_sample() const { return m_bits_per_sample; }
+  size_t get_size() const { return m_size; }
+  int    get_rate() const { return m_rate; }
+  int    get_channels() const { return m_channels; }
   
 private:
   // I/O functions for ogg
@@ -48,12 +48,12 @@
   
   std::ifstream  m_in;
   size_t m_file_size;
-  OggVorbis_File vorbis_file;
+  OggVorbis_File m_vorbis_file;
 
-  int channels;
-  int rate;
-  int bits_per_sample;
-  size_t size; /// size in bytes
+  int m_channels;
+  int m_rate;
+  int m_bits_per_sample;
+  size_t m_size; /// size in bytes
 
 private:
   OggSoundFile(const OggSoundFile&);

Modified: trunk/windstille/src/sound/sound_channel.cpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.cpp	2010-07-20 12:32:16 UTC (rev 3321)
+++ trunk/windstille/src/sound/sound_channel.cpp	2010-07-20 21:36:00 UTC (rev 3322)
@@ -34,27 +34,27 @@
 }
 
 SoundSourcePtr
-SoundChannel::play(const SoundFile& sound_file)
-{ 
-  
+SoundChannel::play(const Pathname& filename)
+{  
+  SoundSourcePtr source = prepare(filename);
+  source->play();
+  return source;
 }
 
 SoundSourcePtr
-SoundChannel::play(const Pathname& filename)
-{  
+SoundChannel::prepare(const Pathname& filename)
+{
   try
   {
-    std::auto_ptr<SoundSource> source = m_sound_manager.create_sound_source(filename);
-
-    if (source.get())
-    {
-      source->play();
-      m_sound_sources.push_back(SoundSourcePtr(source.release()));
-    }
+    SoundSourcePtr source = m_sound_manager.create_sound_source(filename);
+    source->play();
+    m_sound_sources.push_back(SoundSourcePtr(source));
+    return source;
   }
-  catch(std::exception& e) 
+  catch(const std::exception& e) 
   {
-    std::cout << "SoundChannel::play(): Couldn't play sound " << filename << ": " << e.what() << "\n";
+    std::cout << "SoundChannel::prepare(): Couldn't play sound " << filename << ": " << e.what() << "\n";
+    return SoundSourcePtr(); // FIXME: not good, should return dummy SoundSource
   }
 }
 

Modified: trunk/windstille/src/sound/sound_channel.hpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.hpp	2010-07-20 12:32:16 UTC (rev 3321)
+++ trunk/windstille/src/sound/sound_channel.hpp	2010-07-20 21:36:00 UTC (rev 3322)
@@ -32,8 +32,10 @@
 public:
   SoundChannel(SoundManager& sound_manager);
 
-  SoundSourcePtr play(const SoundFile& sound_file);
+  // shortcut for prepare()->play()
   SoundSourcePtr play(const Pathname& filename);
+  
+  SoundSourcePtr prepare(const Pathname& filename);
 
   void update(float delta);
 

Modified: trunk/windstille/src/sound/sound_manager.cpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.cpp	2010-07-20 12:32:16 UTC (rev 3321)
+++ trunk/windstille/src/sound/sound_manager.cpp	2010-07-20 21:36:00 UTC (rev 3322)
@@ -130,12 +130,12 @@
   return buffer;
 }
 
-std::auto_ptr<SoundSource>
+SoundSourcePtr
 SoundManager::create_sound_source(const Pathname& filename)
 {
   if (!m_sound_enabled)
   {
-    return std::auto_ptr<SoundSource>();
+    return SoundSourcePtr();
   }
   else
   {
@@ -153,7 +153,7 @@
       m_buffers.insert(std::make_pair(filename, buffer));
     }
   
-    std::auto_ptr<SoundSource> source(new SoundSource(m_sound_channel));
+    SoundSourcePtr source(new SoundSource(m_sound_channel));
 
     alSourcei(source->get_id(), AL_BUFFER, buffer);
 
@@ -166,21 +166,21 @@
 {
   try
   {
-    std::auto_ptr<SoundSource> source = create_sound_source(filename);
+    SoundSourcePtr source = create_sound_source(filename);
 
     if (source.get())
     {
       source->set_position(pos);
-
       source->play();
-      SoundSourcePtr source_ptr(source.release());
-      m_sources.push_back(source_ptr);
-      return source_ptr;
+      m_sources.push_back(source);
     }
+
+    return source;
   }
   catch(std::exception& e) 
   {
     std::cout << "Couldn't play sound " << filename << ": " << e.what() << "\n";
+    return SoundSourcePtr(); // FIXME: not the best idea, should return dummy object
   }
 }
 

Modified: trunk/windstille/src/sound/sound_manager.hpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.hpp	2010-07-20 12:32:16 UTC (rev 3321)
+++ trunk/windstille/src/sound/sound_manager.hpp	2010-07-20 21:36:00 UTC (rev 3322)
@@ -57,6 +57,10 @@
   void set_sound_volume(float volume);
   void set_music_volume(float volume);
 
+  SoundChannel& voice() { return m_voice_channel; }
+  SoundChannel& sound() { return m_sound_channel; }
+  SoundChannel& music() { return m_music_channel; }
+
   /**
    * Convenience function to simply play a sound at a given position.
    */
@@ -78,7 +82,7 @@
    * This function might throw exceptions. It returns 0 if no audio device is
    * available.
    */
-  std::auto_ptr<SoundSource> create_sound_source(const Pathname& filename);
+  SoundSourcePtr create_sound_source(const Pathname& filename);
 
 private:
   static ALuint load_file_into_buffer(const Pathname& filename);
@@ -96,7 +100,7 @@
 
   typedef std::map<Pathname, ALuint> SoundBuffers;
   SoundBuffers m_buffers;
-  typedef std::vector<boost::shared_ptr<SoundSource> > SoundSources;
+  typedef std::vector<SoundSourcePtr> SoundSources;
   SoundSources m_sources;
 
   std::auto_ptr<StreamSoundSource> m_music_source;

Modified: trunk/windstille/src/sound/sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/sound_source.cpp	2010-07-20 12:32:16 UTC (rev 3321)
+++ trunk/windstille/src/sound/sound_source.cpp	2010-07-20 21:36:00 UTC (rev 3322)
@@ -17,6 +17,9 @@
 */
 
 #include "sound/sound_source.hpp"
+
+#include <assert.h>
+
 #include "sound/sound_manager.hpp"
 
 SoundSource::SoundSource(SoundChannel& channel) :
@@ -49,6 +52,20 @@
   SoundManager::check_al_error("Couldn't start audio source: ");
 }
 
+float
+SoundSource::get_length() const
+{
+  assert(!"implement me");
+  return 0.0f;
+}
+
+void
+SoundSource::seek_to(float sec)
+{
+  // FIXME: Need to be adopted for streaming sound
+  alSourcef(m_source, AL_SEC_OFFSET, sec);
+}
+
 bool
 SoundSource::is_playing() const
 {

Modified: trunk/windstille/src/sound/sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/sound_source.hpp	2010-07-20 12:32:16 UTC (rev 3321)
+++ trunk/windstille/src/sound/sound_source.hpp	2010-07-20 21:36:00 UTC (rev 3322)
@@ -35,12 +35,16 @@
   void stop();
   bool is_playing() const;
 
+  float get_length() const;
+
   void set_looping(bool looping);
 
   /// Set volume (0.0 is silent, 1.0 is normal)
   void  set_gain(float gain);
   float get_gain() const;
 
+  void seek_to(float sec);
+
   void set_position(const Vector2f& position);
   void set_velocity(const Vector2f& position);
   void set_reference_distance(float distance);

Modified: trunk/windstille/src/sound/stream_sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.hpp	2010-07-20 12:32:16 UTC (rev 3321)
+++ trunk/windstille/src/sound/stream_sound_source.hpp	2010-07-20 21:36:00 UTC (rev 3322)
@@ -53,7 +53,7 @@
   ALenum format;
 
   FadeState fade_state;
-  unsigned int fade_start_ticks;
+  float fade_start_ticks;
   float fade_time;
 
   // FIXME: simple time counter that summarizes all deltas, could be done better

Modified: trunk/windstille/src/sound/wav_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/wav_sound_file.cpp	2010-07-20 12:32:16 UTC (rev 3321)
+++ trunk/windstille/src/sound/wav_sound_file.cpp	2010-07-20 21:36:00 UTC (rev 3322)
@@ -27,7 +27,11 @@
 
 WavSoundFile::WavSoundFile(const Pathname& filename) :
   file(),
-  datastart()
+  datastart(),
+  m_channels(),
+  m_rate(),
+  m_bits_per_sample(),
+  m_size()
 {
   file.open(filename.get_sys_path().c_str(), std::ios::binary);
   if (!file)
@@ -49,7 +53,7 @@
     throw std::runtime_error("file is not a RIFF wav file");
   }
 
-  uint32_t wavelen = read_uint32_t(file);
+  /*uint32_t wavelen =*/ read_uint32_t(file);
   
   if (!file.read( magic, sizeof(magic)))
   {
@@ -103,11 +107,11 @@
     str << "WavSoundFile(): only PCM encoding supported, got " << encoding;
     throw std::runtime_error(str.str());
   }
-  channels = read_uint16_t(file);
-  rate = read_uint32_t(file);
-  uint32_t byterate = read_uint32_t(file);
-  uint16_t blockalign = read_uint16_t(file);
-  bits_per_sample = read_uint16_t(file);
+  m_channels = read_uint16_t(file);
+  m_rate = read_uint32_t(file);
+  /*uint32_t byterate =*/ read_uint32_t(file);
+  /*uint16_t blockalign =*/ read_uint16_t(file);
+  m_bits_per_sample = read_uint16_t(file);
 
   if(chunklen > 16) 
   {
@@ -129,8 +133,8 @@
       throw std::runtime_error("EOF while searching fmt chunk");
   } while(true);
 
-  datastart = file.tellg();
-  size = static_cast<size_t> (chunklen);
+  datastart = static_cast<size_t>(file.tellg());
+  m_size = static_cast<size_t>(chunklen);
 }
 
 WavSoundFile::~WavSoundFile()
@@ -147,8 +151,8 @@
 size_t
 WavSoundFile::read(void* buffer, size_t buffer_size)
 {
-  size_t end = datastart + size;
-  size_t cur = file.tellg();
+  size_t end = datastart + m_size;
+  size_t cur = static_cast<size_t>(file.tellg());
 
   if (cur >= end)
     return 0;

Modified: trunk/windstille/src/sound/wav_sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/wav_sound_file.hpp	2010-07-20 12:32:16 UTC (rev 3321)
+++ trunk/windstille/src/sound/wav_sound_file.hpp	2010-07-20 21:36:00 UTC (rev 3322)
@@ -35,19 +35,17 @@
 private:
   std::ifstream file; 
   size_t datastart;
+  int m_channels;
+  int m_rate;
+  int m_bits_per_sample;
+  size_t m_size; /// size in bytes
 
 public:
-  int    get_bits_per_sample() const { return bits_per_sample; }
-  size_t get_size() const { return size; }
-  int    get_rate() const { return rate; }
-  int    get_channels() const { return channels; }
+  int    get_bits_per_sample() const { return m_bits_per_sample; }
+  size_t get_size() const { return m_size; }
+  int    get_rate() const { return m_rate; }
+  int    get_channels() const { return m_channels; }
   
-protected:
-  int channels;
-  int rate;
-  int bits_per_sample;
-  size_t size; /// size in bytes
-
 private:
   WavSoundFile(const WavSoundFile&);
   WavSoundFile& operator=(const WavSoundFile&);



From grumbel at mail.berlios.de  Wed Jul 21 00:09:29 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed, 21 Jul 2010 00:09:29 +0200
Subject: [Windstille-commit] r3323 - in trunk/windstille: extra src/sound
Message-ID: <20100720220929.7141548026F@sheep.berlios.de>

Author: grumbel
Date: 2010-07-21 00:09:29 +0200 (Wed, 21 Jul 2010)
New Revision: 3323

Added:
   trunk/windstille/extra/soundapp.cpp
Modified:
   trunk/windstille/src/sound/sound_channel.cpp
   trunk/windstille/src/sound/sound_channel.hpp
   trunk/windstille/src/sound/sound_manager.cpp
   trunk/windstille/src/sound/sound_manager.hpp
   trunk/windstille/src/sound/sound_source.cpp
   trunk/windstille/src/sound/sound_source.hpp
Log:
Some fixes to channel volume control
A test app for sound


Added: trunk/windstille/extra/soundapp.cpp
===================================================================
--- trunk/windstille/extra/soundapp.cpp	                        (rev 0)
+++ trunk/windstille/extra/soundapp.cpp	2010-07-20 22:09:29 UTC (rev 3323)
@@ -0,0 +1,70 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <iostream>
+
+#include "sound/sound_manager.hpp"
+#include "sound/sound_source.hpp"
+
+int main(int argc, char** argv)
+{
+  if (argc != 3)
+  {
+    std::cout << "Usage: " << argv[0] << " SOUND VOICE" << std::endl;
+    return 1;
+  }
+  else
+  {
+    SoundManager sound_manager;
+  
+    Vector2f pos(0.0f, 0.0f);
+    SoundSourcePtr source = sound_manager.sound().prepare(Pathname(argv[1], Pathname::kSysPath));
+    SoundSourcePtr voice  = sound_manager.voice().prepare(Pathname(argv[2], Pathname::kSysPath));
+
+    sound_manager.set_master_volume(10.0f);
+    sound_manager.sound().set_volume(0.1f);
+    sound_manager.voice().set_volume(1.0f);
+    
+    if (true)
+    {
+      source->set_looping(true);
+      source->set_position(pos);
+      //source->set_velocity(Vector2f(5.0f, 0.0f));
+      source->play();
+    }
+
+    if (true)
+    {
+      voice->set_looping(true);
+      voice->set_position(pos);
+      voice->play();
+    }
+
+    while(source->is_playing())
+    {
+      pos.x += 25.0f;
+      //source->set_position(pos);
+      usleep(100000);
+      std::cout << "." << std::flush;
+    }
+  
+    return 0;
+  }
+}
+
+/* EOF */


Property changes on: trunk/windstille/extra/soundapp.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: trunk/windstille/src/sound/sound_channel.cpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.cpp	2010-07-20 21:36:00 UTC (rev 3322)
+++ trunk/windstille/src/sound/sound_channel.cpp	2010-07-20 22:09:29 UTC (rev 3323)
@@ -46,8 +46,8 @@
 {
   try
   {
-    SoundSourcePtr source = m_sound_manager.create_sound_source(filename);
-    source->play();
+    SoundSourcePtr source = m_sound_manager.create_sound_source(filename, *this);
+    source->update_volume();
     m_sound_sources.push_back(SoundSourcePtr(source));
     return source;
   }

Modified: trunk/windstille/src/sound/sound_channel.hpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.hpp	2010-07-20 21:36:00 UTC (rev 3322)
+++ trunk/windstille/src/sound/sound_channel.hpp	2010-07-20 22:09:29 UTC (rev 3323)
@@ -39,6 +39,7 @@
 
   void update(float delta);
 
+  // volume is clamped to [0,1]
   void  set_volume(float volume);
   float get_volume() const;
 

Modified: trunk/windstille/src/sound/sound_manager.cpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.cpp	2010-07-20 21:36:00 UTC (rev 3322)
+++ trunk/windstille/src/sound/sound_manager.cpp	2010-07-20 22:09:29 UTC (rev 3323)
@@ -131,7 +131,7 @@
 }
 
 SoundSourcePtr
-SoundManager::create_sound_source(const Pathname& filename)
+SoundManager::create_sound_source(const Pathname& filename, SoundChannel& channel)
 {
   if (!m_sound_enabled)
   {
@@ -153,7 +153,7 @@
       m_buffers.insert(std::make_pair(filename, buffer));
     }
   
-    SoundSourcePtr source(new SoundSource(m_sound_channel));
+    SoundSourcePtr source(new SoundSource(channel));
 
     alSourcei(source->get_id(), AL_BUFFER, buffer);
 
@@ -166,7 +166,7 @@
 {
   try
   {
-    SoundSourcePtr source = create_sound_source(filename);
+    SoundSourcePtr source = create_sound_source(filename, m_sound_channel);
 
     if (source.get())
     {

Modified: trunk/windstille/src/sound/sound_manager.hpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.hpp	2010-07-20 21:36:00 UTC (rev 3322)
+++ trunk/windstille/src/sound/sound_manager.hpp	2010-07-20 22:09:29 UTC (rev 3323)
@@ -52,7 +52,10 @@
   void set_listener_position(const Vector2f& position);
   void set_listener_velocity(const Vector2f& velocity);
 
+  // master volume is not clamped
   void set_master_volume(float volume);
+
+  // volume is clamped to [0,1]
   void set_voice_volume(float volume);
   void set_sound_volume(float volume);
   void set_music_volume(float volume);
@@ -82,7 +85,7 @@
    * This function might throw exceptions. It returns 0 if no audio device is
    * available.
    */
-  SoundSourcePtr create_sound_source(const Pathname& filename);
+  SoundSourcePtr create_sound_source(const Pathname& filename, SoundChannel& channel);
 
 private:
   static ALuint load_file_into_buffer(const Pathname& filename);

Modified: trunk/windstille/src/sound/sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/sound_source.cpp	2010-07-20 21:36:00 UTC (rev 3322)
+++ trunk/windstille/src/sound/sound_source.cpp	2010-07-20 22:09:29 UTC (rev 3323)
@@ -19,12 +19,14 @@
 #include "sound/sound_source.hpp"
 
 #include <assert.h>
+#include <iostream>
 
 #include "sound/sound_manager.hpp"
 
 SoundSource::SoundSource(SoundChannel& channel) :
   m_channel(channel),
-  m_source()
+  m_source(),
+  m_gain(1.0f)
 {
   alGenSources(1, &m_source);
   SoundManager::check_al_error("Couldn't create audio source: ");
@@ -95,15 +97,14 @@
 void
 SoundSource::set_gain(float gain)
 {
-  alSourcef(m_source, AL_GAIN, m_channel.get_volume() * gain);
+  m_gain = gain;
+  alSourcef(m_source, AL_GAIN, m_channel.get_volume() * m_gain);
 }
 
 float
 SoundSource::get_gain() const
 {
-  float gain = 0.0f;
-  alGetSourcef(m_source, AL_GAIN, &gain);
-  return gain;
+  return m_gain;
 }
 
 void

Modified: trunk/windstille/src/sound/sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/sound_source.hpp	2010-07-20 21:36:00 UTC (rev 3322)
+++ trunk/windstille/src/sound/sound_source.hpp	2010-07-20 22:09:29 UTC (rev 3323)
@@ -58,6 +58,7 @@
 protected:
   SoundChannel& m_channel;
   ALuint m_source;
+  float m_gain;
   
 private:
   SoundSource(const SoundSource&);



From grumbel at mail.berlios.de  Wed Jul 21 03:46:15 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed, 21 Jul 2010 03:46:15 +0200
Subject: [Windstille-commit] r3324 - trunk/windstille/src/sound
Message-ID: <20100721014616.04FF84805B1@sheep.berlios.de>

Author: grumbel
Date: 2010-07-21 03:46:15 +0200 (Wed, 21 Jul 2010)
New Revision: 3324

Modified:
   trunk/windstille/src/sound/sound_manager.cpp
   trunk/windstille/src/sound/sound_source.cpp
   trunk/windstille/src/sound/sound_source.hpp
   trunk/windstille/src/sound/stream_sound_source.cpp
Log:
Some more error checking and cleanup


Modified: trunk/windstille/src/sound/sound_manager.cpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.cpp	2010-07-20 22:09:29 UTC (rev 3323)
+++ trunk/windstille/src/sound/sound_manager.cpp	2010-07-21 01:46:15 UTC (rev 3324)
@@ -154,9 +154,7 @@
     }
   
     SoundSourcePtr source(new SoundSource(channel));
-
-    alSourcei(source->get_id(), AL_BUFFER, buffer);
-
+    source->set_buffer(buffer);
     return source;
   }
 }
@@ -244,8 +242,6 @@
       {
         std::auto_ptr<StreamSoundSource> newmusic(new StreamSoundSource(m_music_channel, SoundFile::load(filename)));
 
-        alSourcef(newmusic->get_id(), AL_ROLLOFF_FACTOR, 0);
- 
         if (fade) 
         {
           if (m_music_source.get() &&

Modified: trunk/windstille/src/sound/sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/sound_source.cpp	2010-07-20 22:09:29 UTC (rev 3323)
+++ trunk/windstille/src/sound/sound_source.cpp	2010-07-21 01:46:15 UTC (rev 3324)
@@ -37,6 +37,7 @@
 {
   stop();
   alDeleteSources(1, &m_source);
+  SoundManager::check_al_error("Couldn't delete source: ");
 }
 
 void
@@ -66,8 +67,18 @@
 {
   // FIXME: Need to be adopted for streaming sound
   alSourcef(m_source, AL_SEC_OFFSET, sec);
+  SoundManager::check_al_error("SoundSource::seek_to: ");
 }
 
+float
+SoundSource::get_pos() const
+{
+  float sec = 0.0f;
+  alGetSourcef(m_source, AL_SEC_OFFSET, &sec);
+  SoundManager::check_al_error("SoundSource::get_pos: ");
+  return sec;
+}
+
 bool
 SoundSource::is_playing() const
 {
@@ -80,18 +91,21 @@
 SoundSource::set_looping(bool looping)
 {
   alSourcei(m_source, AL_LOOPING, looping ? AL_TRUE : AL_FALSE);
+  SoundManager::check_al_error("SoundSource::set_looping: ");
 }
 
 void
 SoundSource::set_position(const Vector2f& position)
 {
   alSource3f(m_source, AL_POSITION, position.x, position.y, 0);
+  SoundManager::check_al_error("SoundSource::set_position: ");
 }
 
 void
 SoundSource::set_velocity(const Vector2f& velocity)
 {
   alSource3f(m_source, AL_VELOCITY, velocity.x, velocity.y, 0);
+  SoundManager::check_al_error("SoundSource::set_velocity: ");
 }
 
 void
@@ -99,6 +113,7 @@
 {
   m_gain = gain;
   alSourcef(m_source, AL_GAIN, m_channel.get_volume() * m_gain);
+  SoundManager::check_al_error("SoundSource::set_gain: ");
 }
 
 float
@@ -111,18 +126,28 @@
 SoundSource::set_reference_distance(float distance)
 {
   alSourcef(m_source, AL_REFERENCE_DISTANCE, distance);
+  SoundManager::check_al_error("SoundSource::set_reference_distance: ");
 }
 
 void
 SoundSource::set_rolloff_factor(float factor)
 {
   alSourcef(m_source, AL_ROLLOFF_FACTOR, factor);
+  SoundManager::check_al_error("SoundSource::set_rolloff_factor: ");
 }
 
 void
 SoundSource::update_volume() const
 {
   alSourcef(m_source, AL_GAIN, m_channel.get_volume() * get_gain());
+  SoundManager::check_al_error("SoundSource::update_volume: ");
 }
 
+void
+SoundSource::set_buffer(ALuint buffer)
+{
+  alSourcei(m_source, AL_BUFFER, buffer);
+  SoundManager::check_al_error("SoundSource::set_buffer: ");
+}
+
 /* EOF */

Modified: trunk/windstille/src/sound/sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/sound_source.hpp	2010-07-20 22:09:29 UTC (rev 3323)
+++ trunk/windstille/src/sound/sound_source.hpp	2010-07-21 01:46:15 UTC (rev 3324)
@@ -43,18 +43,27 @@
   void  set_gain(float gain);
   float get_gain() const;
 
-  void seek_to(float sec);
+  void  seek_to(float sec);
 
+  /** Return the current position in seconds */
+  float get_pos() const;
+
   void set_position(const Vector2f& position);
   void set_velocity(const Vector2f& position);
+
+  /** Distances closer then reference distance will increase the gain
+      (or keep it at 1.0f), while distances further away will lower it */
   void set_reference_distance(float distance);
+
+  /** Higher factor will mean the sound gain lowers quicker with
+      distance, while lower factor will reduce the lowering of gain */
   void set_rolloff_factor(float factor);
 
+  void set_buffer(ALuint buffer);
+
   /** Needs to be called whenever the SoundChannels volume changes */
   void update_volume() const;
 
-  ALuint get_id() const { return m_source; }
-  
 protected:
   SoundChannel& m_channel;
   ALuint m_source;

Modified: trunk/windstille/src/sound/stream_sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-20 22:09:29 UTC (rev 3323)
+++ trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-21 01:46:15 UTC (rev 3324)
@@ -76,7 +76,7 @@
 
       ALuint buffer;
       alSourceUnqueueBuffers(m_source, 1, &buffer);
-      SoundManager::check_al_error("Couldn't unqueu audio buffer: ");
+      SoundManager::check_al_error("Couldn't unqueue audio buffer: ");
 
       fillBufferAndQueue(buffer);
     }
@@ -143,7 +143,7 @@
     {
       file->reset();
     }
-  } 
+  }
   while(bytesread < STREAMFRAGMENTSIZE);
   
   alBufferData(buffer, format, bufferdata.get(), STREAMFRAGMENTSIZE, file->get_rate());



From grumbel at mail.berlios.de  Wed Jul 21 14:47:52 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed, 21 Jul 2010 14:47:52 +0200
Subject: [Windstille-commit] r3325 - in trunk/windstille/src: app sound
Message-ID: <20100721124752.A873948002A@sheep.berlios.de>

Author: grumbel
Date: 2010-07-21 14:47:52 +0200 (Wed, 21 Jul 2010)
New Revision: 3325

Modified:
   trunk/windstille/src/app/menu_manager.cpp
   trunk/windstille/src/app/windstille_main.cpp
   trunk/windstille/src/sound/ogg_sound_file.cpp
   trunk/windstille/src/sound/ogg_sound_file.hpp
   trunk/windstille/src/sound/sound_channel.cpp
   trunk/windstille/src/sound/sound_channel.hpp
   trunk/windstille/src/sound/sound_file.cpp
   trunk/windstille/src/sound/sound_file.hpp
   trunk/windstille/src/sound/sound_manager.cpp
   trunk/windstille/src/sound/sound_manager.hpp
   trunk/windstille/src/sound/sound_source.cpp
   trunk/windstille/src/sound/sound_source.hpp
   trunk/windstille/src/sound/stream_sound_source.cpp
   trunk/windstille/src/sound/stream_sound_source.hpp
   trunk/windstille/src/sound/wav_sound_file.cpp
   trunk/windstille/src/sound/wav_sound_file.hpp
Log:
Renamed volume to gain
Added seeking


Modified: trunk/windstille/src/app/menu_manager.cpp
===================================================================
--- trunk/windstille/src/app/menu_manager.cpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/app/menu_manager.cpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -532,28 +532,28 @@
 MenuManager::menu_master_volume(int i)
 {
   config.set_int("master-volume", i);
-  SoundManager::current()->set_master_volume(static_cast<float>(i)/100.0f);
+  SoundManager::current()->set_gain(static_cast<float>(i)/100.0f);
 }
 
 void
 MenuManager::menu_music_volume(int i)
 {
   config.set_int("music-volume", i);
-  SoundManager::current()->set_music_volume(static_cast<float>(i)/100.0f);
+  SoundManager::current()->music().set_gain(static_cast<float>(i)/100.0f);
 }
 
 void
 MenuManager::menu_voice_volume(int i)
 {
   config.set_int("voice-volume", i);
-  SoundManager::current()->set_voice_volume(static_cast<float>(i)/100.0f);
+  SoundManager::current()->voice().set_gain(static_cast<float>(i)/100.0f);
 }
 
 void
 MenuManager::menu_sound_volume(int i)
 {
   config.set_int("sound-volume", i);
-  SoundManager::current()->set_sound_volume(static_cast<float>(i)/100.0f);
+  SoundManager::current()->sound().set_gain(static_cast<float>(i)/100.0f);
 }
 
 /* EOF */

Modified: trunk/windstille/src/app/windstille_main.cpp
===================================================================
--- trunk/windstille/src/app/windstille_main.cpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/app/windstille_main.cpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -151,7 +151,7 @@
 void
 WindstilleMain::init_modules()
 {
-  SoundManager::current()->set_master_volume(static_cast<float>(config.get_int("master-volume"))/100.0f);
+  SoundManager::current()->set_gain(static_cast<float>(config.get_int("master-volume"))/100.0f);
   SoundManager::current()->enable_sound(config.get_bool("sound"));
   SoundManager::current()->enable_music(config.get_bool("music"));
 

Modified: trunk/windstille/src/sound/ogg_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -123,6 +123,12 @@
   ov_raw_seek(&m_vorbis_file, 0);
 }
 
+void
+OggSoundFile::seek_to(float sec)
+{
+  ov_time_seek(&m_vorbis_file, sec);
+}
+
 size_t
 OggSoundFile::cb_read(void* ptr, size_t size, size_t nmemb, void* userdata)
 {

Modified: trunk/windstille/src/sound/ogg_sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/ogg_sound_file.hpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/sound/ogg_sound_file.hpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -38,6 +38,8 @@
   size_t get_size() const { return m_size; }
   int    get_rate() const { return m_rate; }
   int    get_channels() const { return m_channels; }
+
+  void seek_to(float sec);
   
 private:
   // I/O functions for ogg

Modified: trunk/windstille/src/sound/sound_channel.cpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.cpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/sound/sound_channel.cpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -29,7 +29,7 @@
 SoundChannel::SoundChannel(SoundManager& sound_manager) :
   m_sound_manager(sound_manager),
   m_sound_sources(),
-  m_volume(1.0f)
+  m_gain(1.0f)
 {
 }
 
@@ -42,12 +42,20 @@
 }
 
 SoundSourcePtr
+SoundChannel::prepare(std::auto_ptr<SoundFile> sound_file)
+{
+  // FIXME: implement me
+  assert(!"implement me");
+  return SoundSourcePtr();
+}
+
+SoundSourcePtr
 SoundChannel::prepare(const Pathname& filename)
 {
   try
   {
     SoundSourcePtr source = m_sound_manager.create_sound_source(filename, *this);
-    source->update_volume();
+    source->update_gain();
     m_sound_sources.push_back(SoundSourcePtr(source));
     return source;
   }
@@ -59,20 +67,20 @@
 }
 
 void
-SoundChannel::set_volume(float volume)
+SoundChannel::set_gain(float gain)
 {
-  m_volume = volume;
+  m_gain = gain;
 
   for(std::vector<SoundSourcePtr>::iterator i = m_sound_sources.begin(); i != m_sound_sources.end(); ++i)
   {
-    (*i)->update_volume();
+    (*i)->update_gain();
   }
 }
 
 float
-SoundChannel::get_volume() const
+SoundChannel::get_gain() const
 {
-  return m_volume;
+  return m_gain;
 }
 
 void
@@ -80,8 +88,7 @@
 {
   for(std::vector<SoundSourcePtr>::iterator i = m_sound_sources.begin(); i != m_sound_sources.end(); ++i)
   {
-    // only needed for streamed sound sources
-    //FIXME: (*i)->update(delta);
+    (*i)->update(delta);
   }
 }
 

Modified: trunk/windstille/src/sound/sound_channel.hpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.hpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/sound/sound_channel.hpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -34,19 +34,20 @@
 
   // shortcut for prepare()->play()
   SoundSourcePtr play(const Pathname& filename);
-  
+
+  SoundSourcePtr prepare(std::auto_ptr<SoundFile> sound_file);
   SoundSourcePtr prepare(const Pathname& filename);
 
   void update(float delta);
 
   // volume is clamped to [0,1]
-  void  set_volume(float volume);
-  float get_volume() const;
+  void  set_gain(float gain);
+  float get_gain() const;
 
 private:
   SoundManager& m_sound_manager;
   std::vector<SoundSourcePtr> m_sound_sources;
-  float m_volume;
+  float m_gain;
 
 private:
   SoundChannel(const SoundChannel&);

Modified: trunk/windstille/src/sound/sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/sound_file.cpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/sound/sound_file.cpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -73,4 +73,13 @@
   }
 }
 
+float
+SoundFile::get_length() const
+{
+  return static_cast<float>(get_size()) 
+    / static_cast<float>(get_rate())
+    / static_cast<float>(get_channels())
+    / (static_cast<float>(get_bits_per_sample())/8.0f);
+}
+
 /* EOF */

Modified: trunk/windstille/src/sound/sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/sound_file.hpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/sound/sound_file.hpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -37,7 +37,12 @@
   virtual size_t get_size() const = 0;
   virtual int    get_rate() const = 0;
   virtual int    get_channels() const = 0;
+
+  virtual void   seek_to(float sec) = 0;
   
+  /** Returns the length of the file in seconds */
+  virtual float  get_length() const;
+
 public:
   static std::auto_ptr<SoundFile> load(const Pathname& filename);
 };

Modified: trunk/windstille/src/sound/sound_manager.cpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.cpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/sound/sound_manager.cpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -218,9 +218,9 @@
   if (fade) 
   {
     if (m_music_source.get() &&
-        m_music_source->getFadeState() != StreamSoundSource::FadingOff)
+        m_music_source->get_fade_state() != StreamSoundSource::kFadingOff)
     {
-      m_music_source->setFading(StreamSoundSource::FadingOff, .7f);
+      m_music_source->set_fading(StreamSoundSource::kFadingOff, .7f);
     }
   } 
   else 
@@ -245,14 +245,14 @@
         if (fade) 
         {
           if (m_music_source.get() &&
-              m_music_source->getFadeState() != StreamSoundSource::FadingOff)
+              m_music_source->get_fade_state() != StreamSoundSource::kFadingOff)
           {
-            m_music_source->setFading(StreamSoundSource::FadingOff, .7f);
+            m_music_source->set_fading(StreamSoundSource::kFadingOff, .7f);
           }
 
           m_next_music_source = newmusic;
-        } 
-        else 
+        }
+        else
         {
           m_music_source = newmusic;
           m_music_source->play();
@@ -281,30 +281,12 @@
 }
 
 void
-SoundManager::set_master_volume(float volume)
+SoundManager::set_gain(float gain)
 {
-  alListenerf(AL_GAIN, volume);
+  alListenerf(AL_GAIN, gain);
 }
 
 void
-SoundManager::set_voice_volume(float volume)
-{
-  m_voice_channel.set_volume(volume);
-}
-
-void
-SoundManager::set_sound_volume(float volume)
-{
-  m_sound_channel.set_volume(volume);
-}
-
-void
-SoundManager::set_music_volume(float volume)
-{
-  m_music_channel.set_volume(volume);
-}
-
-void
 SoundManager::update(float delta)
 {
   if (m_sound_enabled)

Modified: trunk/windstille/src/sound/sound_manager.hpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.hpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/sound/sound_manager.hpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -53,13 +53,8 @@
   void set_listener_velocity(const Vector2f& velocity);
 
   // master volume is not clamped
-  void set_master_volume(float volume);
+  void set_gain(float gain);
 
-  // volume is clamped to [0,1]
-  void set_voice_volume(float volume);
-  void set_sound_volume(float volume);
-  void set_music_volume(float volume);
-
   SoundChannel& voice() { return m_voice_channel; }
   SoundChannel& sound() { return m_sound_channel; }
   SoundChannel& music() { return m_music_channel; }
@@ -74,10 +69,6 @@
 
   void update(float delta);
 
-public:
-  static void check_al_error(const char* message);
-  static ALenum get_sample_format(SoundFile* file);
-
   /**
    * Creates a new sound source object which plays the specified soundfile.
    * You are responsible for deleting the sound source later (this will stop the
@@ -87,6 +78,10 @@
    */
   SoundSourcePtr create_sound_source(const Pathname& filename, SoundChannel& channel);
 
+public:
+  static void check_al_error(const char* message);
+  static ALenum get_sample_format(SoundFile* file);
+
 private:
   static ALuint load_file_into_buffer(const Pathname& filename);
 

Modified: trunk/windstille/src/sound/sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/sound_source.cpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/sound/sound_source.cpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -112,7 +112,7 @@
 SoundSource::set_gain(float gain)
 {
   m_gain = gain;
-  alSourcef(m_source, AL_GAIN, m_channel.get_volume() * m_gain);
+  alSourcef(m_source, AL_GAIN, m_channel.get_gain() * m_gain);
   SoundManager::check_al_error("SoundSource::set_gain: ");
 }
 
@@ -137,10 +137,10 @@
 }
 
 void
-SoundSource::update_volume() const
+SoundSource::update_gain() const
 {
-  alSourcef(m_source, AL_GAIN, m_channel.get_volume() * get_gain());
-  SoundManager::check_al_error("SoundSource::update_volume: ");
+  alSourcef(m_source, AL_GAIN, m_channel.get_gain() * get_gain());
+  SoundManager::check_al_error("SoundSource::update_gain: ");
 }
 
 void

Modified: trunk/windstille/src/sound/sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/sound_source.hpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/sound/sound_source.hpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -56,14 +56,18 @@
   void set_reference_distance(float distance);
 
   /** Higher factor will mean the sound gain lowers quicker with
-      distance, while lower factor will reduce the lowering of gain */
+      distance, while lower factor will reduce the lowering of gain,
+      0.0f disables distance based reduction completly */
   void set_rolloff_factor(float factor);
-
+  
+  /** Attaches the gives buffer to this sample */
   void set_buffer(ALuint buffer);
 
-  /** Needs to be called whenever the SoundChannels volume changes */
-  void update_volume() const;
+  /** Needs to be called whenever the SoundChannels gain changes */
+  void update_gain() const;
 
+  virtual void update(float delta) {}
+
 protected:
   SoundChannel& m_channel;
   ALuint m_source;

Modified: trunk/windstille/src/sound/stream_sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -19,35 +19,32 @@
 #include "sound/stream_sound_source.hpp"
 
 #include <iostream>
-#include <boost/scoped_array.hpp>
 
 #include "sound/sound_manager.hpp"
 #include "sound/sound_file.hpp"
 
-StreamSoundSource::StreamSoundSource(SoundChannel& channel, std::auto_ptr<SoundFile> file_) :
+StreamSoundSource::StreamSoundSource(SoundChannel& channel, std::auto_ptr<SoundFile> sound_file) :
   SoundSource(channel),
-  file(file_),
-  format(),
-  fade_state(),
-  fade_start_ticks(),
-  fade_time(),
+  m_sound_file(sound_file),
+  m_format(SoundManager::get_sample_format(m_sound_file.get())),
+  m_fade_state(),
+  m_fade_start_ticks(),
+  m_fade_time(),
   m_total_time(0.0f)
 {
-  alGenBuffers(STREAMFRAGMENTS, buffers);
+  alGenBuffers(STREAMFRAGMENTS, m_buffers);
   SoundManager::check_al_error("Couldn't allocate audio buffers: ");
 
-  format = SoundManager::get_sample_format(file.get());
-
   try 
   {
     for(size_t i = 0; i < STREAMFRAGMENTS; ++i) 
     {
-      fillBufferAndQueue(buffers[i]);
+      fill_buffer_and_queue(m_buffers[i]);
     }
   }
   catch(...) 
   {
-    alDeleteBuffers(STREAMFRAGMENTS, buffers);
+    alDeleteBuffers(STREAMFRAGMENTS, m_buffers);
     throw;
   }
 }
@@ -56,11 +53,17 @@
 {
   stop();
 
-  alDeleteBuffers(STREAMFRAGMENTS, buffers);
+  alDeleteBuffers(STREAMFRAGMENTS, m_buffers);
   SoundManager::check_al_error("Couldn't delete audio buffers: ");
 }
 
 void
+StreamSoundSource::seek_to(float sec)
+{
+  m_sound_file->seek_to(sec);
+}
+
+void
 StreamSoundSource::update(float delta)
 {
   m_total_time += delta;
@@ -78,7 +81,7 @@
       alSourceUnqueueBuffers(m_source, 1, &buffer);
       SoundManager::check_al_error("Couldn't unqueue audio buffer: ");
 
-      fillBufferAndQueue(buffer);
+      fill_buffer_and_queue(buffer);
     }
   
     // we might have to restart the source if we had a buffer underrun
@@ -89,67 +92,69 @@
       SoundManager::check_al_error("Couldn't restart audio source: ");
     }
 
-    if (fade_state == FadingOn) 
+    if (m_fade_state == kFadingOn) 
     {
-      float time = fade_start_ticks - m_total_time;
-      if (time >= fade_time)
+      float time = m_fade_start_ticks - m_total_time;
+      if (time >= m_fade_time)
       {
         set_gain(1.0);
-        fade_state = NoFading;
+        m_fade_state = kNoFading;
       } 
       else 
       {
-        set_gain(time / fade_time);
+        set_gain(time / m_fade_time);
       }
     } 
-    else if (fade_state == FadingOff) 
+    else if (m_fade_state == kFadingOff) 
     {
-      float time = fade_start_ticks - m_total_time;
+      float time = m_fade_start_ticks - m_total_time;
 
-      if (time >= fade_time) 
+      if (time >= m_fade_time) 
       {
         stop();
-        fade_state = NoFading;
+        m_fade_state = kNoFading;
       } 
       else 
       {
-        set_gain( (fade_time-time) / fade_time);
+        set_gain( (m_fade_time - time) / m_fade_time);
       }
     }
   }
 }
 
 void
-StreamSoundSource::setFading(FadeState state_, float fade_time_)
+StreamSoundSource::set_fading(FadeState fade_state, float fade_time)
 {
-  fade_state       = state_;
-  fade_time        = fade_time_;
-  fade_start_ticks = m_total_time;
+  m_fade_state       = fade_state;
+  m_fade_time        = fade_time;
+  m_fade_start_ticks = m_total_time;
 }
 
 void
-StreamSoundSource::fillBufferAndQueue(ALuint buffer)
+StreamSoundSource::fill_buffer_and_queue(ALuint buffer)
 {
-  // fill buffer
-  boost::scoped_array<char> bufferdata(new char[STREAMFRAGMENTSIZE]);
+  char bufferdata[STREAMFRAGMENTSIZE];
   size_t bytesread = 0;
 
+  // fill buffer with data from m_sound_file
   do 
   {
-    bytesread += file->read(bufferdata.get() + bytesread,
-                            STREAMFRAGMENTSIZE - bytesread);
-      
+    bytesread += m_sound_file->read(bufferdata + bytesread,
+                                    STREAMFRAGMENTSIZE - bytesread);
+
+    // if the end is reached, start from the beginning, thus loop
     if (bytesread < STREAMFRAGMENTSIZE) 
     {
-      file->reset();
+      m_sound_file->reset();
     }
   }
   while(bytesread < STREAMFRAGMENTSIZE);
   
-  alBufferData(buffer, format, bufferdata.get(), STREAMFRAGMENTSIZE, file->get_rate());
-
+  // upload data to the OpenAL buffer
+  alBufferData(buffer, m_format, bufferdata, STREAMFRAGMENTSIZE, m_sound_file->get_rate());
   SoundManager::check_al_error("Couldn't refill audio buffer: ");
 
+  // add buffer to the queue of this source
   alSourceQueueBuffers(m_source, 1, &buffer);
   SoundManager::check_al_error("Couldn't queue audio buffer: ");
 }

Modified: trunk/windstille/src/sound/stream_sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.hpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/sound/stream_sound_source.hpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -30,31 +30,33 @@
 class StreamSoundSource : public SoundSource
 {
 public:
-  enum FadeState { NoFading, FadingOn, FadingOff };
+  enum FadeState { kNoFading, kFadingOn, kFadingOff };
 
 public:
-  StreamSoundSource(SoundChannel& channel, std::auto_ptr<SoundFile> file);
+  StreamSoundSource(SoundChannel& channel, std::auto_ptr<SoundFile> sound_file);
   virtual ~StreamSoundSource();
 
-  void setFading(FadeState state, float fadetime);
-  FadeState getFadeState() const { return fade_state; }
+  void set_fading(FadeState state, float fadetime);
+  FadeState get_fade_state() const { return m_fade_state; }
+
   void update(float delta);
   
+  void seek_to(float sec);
+
 private:
-  void fillBufferAndQueue(ALuint buffer);
+  void fill_buffer_and_queue(ALuint buffer);
 
 private:
-  static const size_t STREAMBUFFERSIZE   = 1024 * 500;
-  static const size_t STREAMFRAGMENTS    = 5;
-  static const size_t STREAMFRAGMENTSIZE = STREAMBUFFERSIZE / STREAMFRAGMENTS;
+  static const size_t STREAMFRAGMENTS    = 4;
+  static const size_t STREAMFRAGMENTSIZE = 65536;
 
-  std::auto_ptr<SoundFile> file;
-  ALuint buffers[STREAMFRAGMENTS];
-  ALenum format;
+  std::auto_ptr<SoundFile> m_sound_file;
+  ALuint m_buffers[STREAMFRAGMENTS];
+  ALenum m_format;
 
-  FadeState fade_state;
-  float fade_start_ticks;
-  float fade_time;
+  FadeState m_fade_state;
+  float m_fade_start_ticks;
+  float m_fade_time;
 
   // FIXME: simple time counter that summarizes all deltas, could be done better
   float m_total_time;

Modified: trunk/windstille/src/sound/wav_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/wav_sound_file.cpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/sound/wav_sound_file.cpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -148,6 +148,15 @@
     throw std::runtime_error("Couldn't seek to data start");
 }
 
+void
+WavSoundFile::seek_to(float sec)
+{
+  size_t byte_pos = static_cast<size_t>(sec * static_cast<float>(m_rate * m_bits_per_sample/8 * m_channels));
+
+  if (!file.seekg(datastart + byte_pos))
+    throw std::runtime_error("Couldn't seek to data start");
+}
+
 size_t
 WavSoundFile::read(void* buffer, size_t buffer_size)
 {

Modified: trunk/windstille/src/sound/wav_sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/wav_sound_file.hpp	2010-07-21 01:46:15 UTC (rev 3324)
+++ trunk/windstille/src/sound/wav_sound_file.hpp	2010-07-21 12:47:52 UTC (rev 3325)
@@ -31,6 +31,7 @@
 
   size_t read(void* buffer, size_t buffer_size);
   void reset();
+  void seek_to(float sec);
 
 private:
   std::ifstream file; 



From grumbel at mail.berlios.de  Wed Jul 21 14:48:14 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed, 21 Jul 2010 14:48:14 +0200
Subject: [Windstille-commit] r3326 - trunk/windstille/extra
Message-ID: <20100721124814.E9C4F48002A@sheep.berlios.de>

Author: grumbel
Date: 2010-07-21 14:48:14 +0200 (Wed, 21 Jul 2010)
New Revision: 3326

Added:
   trunk/windstille/extra/sound_info.cpp
Log:
Added test app that lists sound file properties

Added: trunk/windstille/extra/sound_info.cpp
===================================================================
--- trunk/windstille/extra/sound_info.cpp	                        (rev 0)
+++ trunk/windstille/extra/sound_info.cpp	2010-07-21 12:48:14 UTC (rev 3326)
@@ -0,0 +1,49 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <iostream>
+
+#include "sound/sound_file.hpp"
+#include "util/pathname.hpp"
+
+int main(int argc, char** argv)
+{
+  if (argc < 2)
+  {
+    std::cout << "Usage: " << argv[0] << " FILE..." << std::endl;
+    return 0;
+  }
+  else
+  {
+    for(int i = 1; i < argc; ++i)
+    {
+      std::auto_ptr<SoundFile> sound_file = SoundFile::load(Pathname(argv[i], Pathname::kSysPath));
+      std::cout << "Filename: " << argv[i] << std::endl;
+      std::cout << "Length:   " << sound_file->get_length() << "sec" << std::endl;
+      std::cout << "Size:     " << sound_file->get_size() << "B" << std::endl;
+      std::cout << "Rate:     " << sound_file->get_rate() << "Hz" << std::endl;
+      std::cout << "Bits:     " << sound_file->get_bits_per_sample() << std::endl;
+      std::cout << "Channels: " << sound_file->get_channels() << std::endl;
+      std::cout << std::endl;
+    }
+
+    return 0;
+  }
+}
+
+/* EOF */


Property changes on: trunk/windstille/extra/sound_info.cpp
___________________________________________________________________
Added: svn:eol-style
   + native



From grumbel at mail.berlios.de  Wed Jul 21 15:50:47 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed, 21 Jul 2010 15:50:47 +0200
Subject: [Windstille-commit] r3327 - trunk/windstille/src/sound
Message-ID: <20100721135047.6ECFF48002A@sheep.berlios.de>

Author: grumbel
Date: 2010-07-21 15:50:47 +0200 (Wed, 21 Jul 2010)
New Revision: 3327

Added:
   trunk/windstille/src/sound/dummy_sound_source.hpp
   trunk/windstille/src/sound/openal_sound_source.cpp
   trunk/windstille/src/sound/openal_sound_source.hpp
   trunk/windstille/src/sound/static_sound_source.cpp
   trunk/windstille/src/sound/static_sound_source.hpp
Removed:
   trunk/windstille/src/sound/sound_source.cpp
   trunk/windstille/src/sound/sound_source.hpp
Modified:
   trunk/windstille/src/sound/sound_channel.cpp
   trunk/windstille/src/sound/sound_manager.cpp
   trunk/windstille/src/sound/stream_sound_source.cpp
   trunk/windstille/src/sound/stream_sound_source.hpp
Log:
Added DummySoundSource
Turned SoundSource into a plain interface
Renamed old SoundSource to OpenALSoundSource and split of functionality into StaticSoundSource


Added: trunk/windstille/src/sound/dummy_sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/dummy_sound_source.hpp	                        (rev 0)
+++ trunk/windstille/src/sound/dummy_sound_source.hpp	2010-07-21 13:50:47 UTC (rev 3327)
@@ -0,0 +1,72 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_WINDSTILLE_SOUND_DUMMY_SOUND_SOURCE_HPP
+#define HEADER_WINDSTILLE_SOUND_DUMMY_SOUND_SOURCE_HPP
+
+#include "sound/sound_source.hpp"
+
+class DummySoundSource : public SoundSource
+{
+private:
+public:
+  DummySoundSource() {}
+  virtual ~DummySoundSource() {}
+
+  void play() {}
+  void stop() {}
+  bool is_playing() const { return false; }
+
+  float get_length() const { return 0.0f; }
+
+  void set_looping(bool looping) {}
+
+  /// Set volume (0.0 is silent, 1.0 is normal)
+  void  set_gain(float gain) {}
+  float get_gain() const { return 1.0f; }
+
+  void  seek_to(float sec) {}
+
+  /** Return the current position in seconds */
+  float get_pos() const { return 0.0f; }
+
+  void set_position(const Vector2f& position) {}
+  void set_velocity(const Vector2f& position) {}
+
+  /** Distances closer then reference distance will increase the gain
+      (or keep it at 1.0f), while distances further away will lower it */
+  void set_reference_distance(float distance) {}
+
+  /** Higher factor will mean the sound gain lowers quicker with
+      distance, while lower factor will reduce the lowering of gain,
+      0.0f disables distance based reduction completly */
+  void set_rolloff_factor(float factor) {}
+
+  /** Needs to be called whenever the SoundChannels gain changes */
+  void update_gain() const {}
+  
+  void update(float delta) {}
+
+private:
+  DummySoundSource(const DummySoundSource&);
+  DummySoundSource& operator=(const DummySoundSource&);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/src/sound/dummy_sound_source.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Copied: trunk/windstille/src/sound/openal_sound_source.cpp (from rev 3325, trunk/windstille/src/sound/sound_source.cpp)
===================================================================
--- trunk/windstille/src/sound/openal_sound_source.cpp	                        (rev 0)
+++ trunk/windstille/src/sound/openal_sound_source.cpp	2010-07-21 13:50:47 UTC (rev 3327)
@@ -0,0 +1,146 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2005 Matthias Braun <matze at braunis.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**  
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**  
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "sound/openal_sound_source.hpp"
+
+#include <assert.h>
+#include <iostream>
+
+#include "sound/sound_manager.hpp"
+
+OpenALSoundSource::OpenALSoundSource(SoundChannel& channel) :
+  m_channel(channel),
+  m_source(),
+  m_gain(1.0f)
+{
+  alGenSources(1, &m_source);
+  SoundManager::check_al_error("Couldn't create audio source: ");
+  set_reference_distance(128);
+}
+
+OpenALSoundSource::~OpenALSoundSource()
+{
+  stop();
+  alDeleteSources(1, &m_source);
+  SoundManager::check_al_error("Couldn't delete source: ");
+}
+
+void
+OpenALSoundSource::stop()
+{
+  alSourceStop(m_source);
+  alSourcei(m_source, AL_BUFFER, AL_NONE);
+  SoundManager::check_al_error("Problem stopping audio source: ");
+}
+
+void
+OpenALSoundSource::play()
+{
+  alSourcePlay(m_source);
+  SoundManager::check_al_error("Couldn't start audio source: ");
+}
+
+float
+OpenALSoundSource::get_length() const
+{
+  assert(!"implement me");
+  return 0.0f;
+}
+
+void
+OpenALSoundSource::seek_to(float sec)
+{
+  // FIXME: Need to be adopted for streaming sound
+  alSourcef(m_source, AL_SEC_OFFSET, sec);
+  SoundManager::check_al_error("OpenALSoundSource::seek_to: ");
+}
+
+float
+OpenALSoundSource::get_pos() const
+{
+  float sec = 0.0f;
+  alGetSourcef(m_source, AL_SEC_OFFSET, &sec);
+  SoundManager::check_al_error("OpenALSoundSource::get_pos: ");
+  return sec;
+}
+
+bool
+OpenALSoundSource::is_playing() const
+{
+  ALint state = AL_PLAYING;
+  alGetSourcei(m_source, AL_SOURCE_STATE, &state);
+  return state != AL_STOPPED;
+}
+
+void
+OpenALSoundSource::set_looping(bool looping)
+{
+  alSourcei(m_source, AL_LOOPING, looping ? AL_TRUE : AL_FALSE);
+  SoundManager::check_al_error("OpenALSoundSource::set_looping: ");
+}
+
+void
+OpenALSoundSource::set_position(const Vector2f& position)
+{
+  alSource3f(m_source, AL_POSITION, position.x, position.y, 0);
+  SoundManager::check_al_error("OpenALSoundSource::set_position: ");
+}
+
+void
+OpenALSoundSource::set_velocity(const Vector2f& velocity)
+{
+  alSource3f(m_source, AL_VELOCITY, velocity.x, velocity.y, 0);
+  SoundManager::check_al_error("OpenALSoundSource::set_velocity: ");
+}
+
+void
+OpenALSoundSource::set_gain(float gain)
+{
+  m_gain = gain;
+  alSourcef(m_source, AL_GAIN, m_channel.get_gain() * m_gain);
+  SoundManager::check_al_error("OpenALSoundSource::set_gain: ");
+}
+
+float
+OpenALSoundSource::get_gain() const
+{
+  return m_gain;
+}
+
+void
+OpenALSoundSource::set_reference_distance(float distance)
+{
+  alSourcef(m_source, AL_REFERENCE_DISTANCE, distance);
+  SoundManager::check_al_error("OpenALSoundSource::set_reference_distance: ");
+}
+
+void
+OpenALSoundSource::set_rolloff_factor(float factor)
+{
+  alSourcef(m_source, AL_ROLLOFF_FACTOR, factor);
+  SoundManager::check_al_error("OpenALSoundSource::set_rolloff_factor: ");
+}
+
+void
+OpenALSoundSource::update_gain() const
+{
+  alSourcef(m_source, AL_GAIN, m_channel.get_gain() * get_gain());
+  SoundManager::check_al_error("OpenALSoundSource::update_gain: ");
+}
+
+/* EOF */

Copied: trunk/windstille/src/sound/openal_sound_source.hpp (from rev 3325, trunk/windstille/src/sound/sound_source.hpp)
===================================================================
--- trunk/windstille/src/sound/openal_sound_source.hpp	                        (rev 0)
+++ trunk/windstille/src/sound/openal_sound_source.hpp	2010-07-21 13:50:47 UTC (rev 3327)
@@ -0,0 +1,84 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2005 Matthias Braun <matze at braunis.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**  
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**  
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_WINDSTILLE_SOUND_OPENAL_SOUND_SOURCE_HPP
+#define HEADER_WINDSTILLE_SOUND_OPENAL_SOUND_SOURCE_HPP
+
+#include <AL/al.h>
+
+#include "math/vector2f.hpp"
+#include "sound/sound_source.hpp"
+
+class SoundChannel;
+
+class OpenALSoundSource : public SoundSource
+{
+public:
+  OpenALSoundSource(SoundChannel& channel);
+  virtual ~OpenALSoundSource();
+
+  void play();
+  void stop();
+  bool is_playing() const;
+
+  float get_length() const;
+
+  void set_looping(bool looping);
+
+  /// Set volume (0.0 is silent, 1.0 is normal)
+  void  set_gain(float gain);
+  float get_gain() const;
+
+  void  seek_to(float sec);
+
+  /** Return the current position in seconds */
+  float get_pos() const;
+
+  void set_position(const Vector2f& position);
+  void set_velocity(const Vector2f& position);
+
+  /** Distances closer then reference distance will increase the gain
+      (or keep it at 1.0f), while distances further away will lower it */
+  void set_reference_distance(float distance);
+
+  /** Higher factor will mean the sound gain lowers quicker with
+      distance, while lower factor will reduce the lowering of gain,
+      0.0f disables distance based reduction completly */
+  void set_rolloff_factor(float factor);
+  
+  /** Attaches the gives buffer to this sample */
+  void set_buffer(ALuint buffer);
+
+  /** Needs to be called whenever the SoundChannels gain changes */
+  void update_gain() const;
+
+  virtual void update(float delta) {}
+
+protected:
+  SoundChannel& m_channel;
+  ALuint m_source;
+  float m_gain;
+  
+private:
+  OpenALSoundSource(const OpenALSoundSource&);
+  OpenALSoundSource& operator=(const OpenALSoundSource&);
+};
+
+#endif
+
+/* EOF */

Modified: trunk/windstille/src/sound/sound_channel.cpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.cpp	2010-07-21 12:48:14 UTC (rev 3326)
+++ trunk/windstille/src/sound/sound_channel.cpp	2010-07-21 13:50:47 UTC (rev 3327)
@@ -25,6 +25,7 @@
 #include "util/pathname.hpp"
 #include "sound/sound_manager.hpp"
 #include "sound/sound_source.hpp"
+#include "sound/dummy_sound_source.hpp"
 
 SoundChannel::SoundChannel(SoundManager& sound_manager) :
   m_sound_manager(sound_manager),
@@ -46,24 +47,23 @@
 {
   // FIXME: implement me
   assert(!"implement me");
-  return SoundSourcePtr();
+  return SoundSourcePtr(new DummySoundSource());
 }
 
 SoundSourcePtr
 SoundChannel::prepare(const Pathname& filename)
 {
-  try
+  SoundSourcePtr source = m_sound_manager.create_sound_source(filename, *this);
+  if (!source)
   {
-    SoundSourcePtr source = m_sound_manager.create_sound_source(filename, *this);
+    return SoundSourcePtr(new DummySoundSource());
+  }
+  else
+  {
     source->update_gain();
     m_sound_sources.push_back(SoundSourcePtr(source));
     return source;
   }
-  catch(const std::exception& e) 
-  {
-    std::cout << "SoundChannel::prepare(): Couldn't play sound " << filename << ": " << e.what() << "\n";
-    return SoundSourcePtr(); // FIXME: not good, should return dummy SoundSource
-  }
 }
 
 void

Modified: trunk/windstille/src/sound/sound_manager.cpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.cpp	2010-07-21 12:48:14 UTC (rev 3326)
+++ trunk/windstille/src/sound/sound_manager.cpp	2010-07-21 13:50:47 UTC (rev 3327)
@@ -23,6 +23,7 @@
 
 #include "sound/sound_file.hpp"
 #include "sound/stream_sound_source.hpp"
+#include "sound/static_sound_source.hpp"
 #include "sound/sound_manager.hpp"
 #include "util/pathname.hpp"
 
@@ -153,9 +154,7 @@
       m_buffers.insert(std::make_pair(filename, buffer));
     }
   
-    SoundSourcePtr source(new SoundSource(channel));
-    source->set_buffer(buffer);
-    return source;
+    return SoundSourcePtr(new StaticSoundSource(channel, buffer));
   }
 }
 

Deleted: trunk/windstille/src/sound/sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/sound_source.cpp	2010-07-21 12:48:14 UTC (rev 3326)
+++ trunk/windstille/src/sound/sound_source.cpp	2010-07-21 13:50:47 UTC (rev 3327)
@@ -1,153 +0,0 @@
-/*
-**  Windstille - A Sci-Fi Action-Adventure Game
-**  Copyright (C) 2005 Matthias Braun <matze at braunis.de>
-**
-**  This program is free software: you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation, either version 3 of the License, or
-**  (at your option) any later version.
-**  
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**  
-**  You should have received a copy of the GNU General Public License
-**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "sound/sound_source.hpp"
-
-#include <assert.h>
-#include <iostream>
-
-#include "sound/sound_manager.hpp"
-
-SoundSource::SoundSource(SoundChannel& channel) :
-  m_channel(channel),
-  m_source(),
-  m_gain(1.0f)
-{
-  alGenSources(1, &m_source);
-  SoundManager::check_al_error("Couldn't create audio source: ");
-  set_reference_distance(128);
-}
-
-SoundSource::~SoundSource()
-{
-  stop();
-  alDeleteSources(1, &m_source);
-  SoundManager::check_al_error("Couldn't delete source: ");
-}
-
-void
-SoundSource::stop()
-{
-  alSourceStop(m_source);
-  alSourcei(m_source, AL_BUFFER, AL_NONE);
-  SoundManager::check_al_error("Problem stopping audio source: ");
-}
-
-void
-SoundSource::play()
-{
-  alSourcePlay(m_source);
-  SoundManager::check_al_error("Couldn't start audio source: ");
-}
-
-float
-SoundSource::get_length() const
-{
-  assert(!"implement me");
-  return 0.0f;
-}
-
-void
-SoundSource::seek_to(float sec)
-{
-  // FIXME: Need to be adopted for streaming sound
-  alSourcef(m_source, AL_SEC_OFFSET, sec);
-  SoundManager::check_al_error("SoundSource::seek_to: ");
-}
-
-float
-SoundSource::get_pos() const
-{
-  float sec = 0.0f;
-  alGetSourcef(m_source, AL_SEC_OFFSET, &sec);
-  SoundManager::check_al_error("SoundSource::get_pos: ");
-  return sec;
-}
-
-bool
-SoundSource::is_playing() const
-{
-  ALint state = AL_PLAYING;
-  alGetSourcei(m_source, AL_SOURCE_STATE, &state);
-  return state != AL_STOPPED;
-}
-
-void
-SoundSource::set_looping(bool looping)
-{
-  alSourcei(m_source, AL_LOOPING, looping ? AL_TRUE : AL_FALSE);
-  SoundManager::check_al_error("SoundSource::set_looping: ");
-}
-
-void
-SoundSource::set_position(const Vector2f& position)
-{
-  alSource3f(m_source, AL_POSITION, position.x, position.y, 0);
-  SoundManager::check_al_error("SoundSource::set_position: ");
-}
-
-void
-SoundSource::set_velocity(const Vector2f& velocity)
-{
-  alSource3f(m_source, AL_VELOCITY, velocity.x, velocity.y, 0);
-  SoundManager::check_al_error("SoundSource::set_velocity: ");
-}
-
-void
-SoundSource::set_gain(float gain)
-{
-  m_gain = gain;
-  alSourcef(m_source, AL_GAIN, m_channel.get_gain() * m_gain);
-  SoundManager::check_al_error("SoundSource::set_gain: ");
-}
-
-float
-SoundSource::get_gain() const
-{
-  return m_gain;
-}
-
-void
-SoundSource::set_reference_distance(float distance)
-{
-  alSourcef(m_source, AL_REFERENCE_DISTANCE, distance);
-  SoundManager::check_al_error("SoundSource::set_reference_distance: ");
-}
-
-void
-SoundSource::set_rolloff_factor(float factor)
-{
-  alSourcef(m_source, AL_ROLLOFF_FACTOR, factor);
-  SoundManager::check_al_error("SoundSource::set_rolloff_factor: ");
-}
-
-void
-SoundSource::update_gain() const
-{
-  alSourcef(m_source, AL_GAIN, m_channel.get_gain() * get_gain());
-  SoundManager::check_al_error("SoundSource::update_gain: ");
-}
-
-void
-SoundSource::set_buffer(ALuint buffer)
-{
-  alSourcei(m_source, AL_BUFFER, buffer);
-  SoundManager::check_al_error("SoundSource::set_buffer: ");
-}
-
-/* EOF */

Deleted: trunk/windstille/src/sound/sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/sound_source.hpp	2010-07-21 12:48:14 UTC (rev 3326)
+++ trunk/windstille/src/sound/sound_source.hpp	2010-07-21 13:50:47 UTC (rev 3327)
@@ -1,83 +0,0 @@
-/*
-**  Windstille - A Sci-Fi Action-Adventure Game
-**  Copyright (C) 2005 Matthias Braun <matze at braunis.de>
-**
-**  This program is free software: you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation, either version 3 of the License, or
-**  (at your option) any later version.
-**  
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**  
-**  You should have received a copy of the GNU General Public License
-**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef HEADER_WINDSTILLE_SOUND_SOUND_SOURCE_HPP
-#define HEADER_WINDSTILLE_SOUND_SOUND_SOURCE_HPP
-
-#include <AL/al.h>
-
-#include "math/vector2f.hpp"
-
-class SoundChannel;
-
-class SoundSource
-{
-public:
-  SoundSource(SoundChannel& channel);
-  virtual ~SoundSource();
-
-  void play();
-  void stop();
-  bool is_playing() const;
-
-  float get_length() const;
-
-  void set_looping(bool looping);
-
-  /// Set volume (0.0 is silent, 1.0 is normal)
-  void  set_gain(float gain);
-  float get_gain() const;
-
-  void  seek_to(float sec);
-
-  /** Return the current position in seconds */
-  float get_pos() const;
-
-  void set_position(const Vector2f& position);
-  void set_velocity(const Vector2f& position);
-
-  /** Distances closer then reference distance will increase the gain
-      (or keep it at 1.0f), while distances further away will lower it */
-  void set_reference_distance(float distance);
-
-  /** Higher factor will mean the sound gain lowers quicker with
-      distance, while lower factor will reduce the lowering of gain,
-      0.0f disables distance based reduction completly */
-  void set_rolloff_factor(float factor);
-  
-  /** Attaches the gives buffer to this sample */
-  void set_buffer(ALuint buffer);
-
-  /** Needs to be called whenever the SoundChannels gain changes */
-  void update_gain() const;
-
-  virtual void update(float delta) {}
-
-protected:
-  SoundChannel& m_channel;
-  ALuint m_source;
-  float m_gain;
-  
-private:
-  SoundSource(const SoundSource&);
-  SoundSource& operator=(const SoundSource&);
-};
-
-#endif
-
-/* EOF */

Added: trunk/windstille/src/sound/static_sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/static_sound_source.cpp	                        (rev 0)
+++ trunk/windstille/src/sound/static_sound_source.cpp	2010-07-21 13:50:47 UTC (rev 3327)
@@ -0,0 +1,30 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "sound/static_sound_source.hpp"
+
+#include "sound/sound_manager.hpp"
+
+StaticSoundSource::StaticSoundSource(SoundChannel& channel, ALuint buffer) :
+  OpenALSoundSource(channel)
+{
+  alSourcei(m_source, AL_BUFFER, buffer);
+  SoundManager::check_al_error("StaticSoundSource: ");
+}
+
+/* EOF */


Property changes on: trunk/windstille/src/sound/static_sound_source.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/src/sound/static_sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/static_sound_source.hpp	                        (rev 0)
+++ trunk/windstille/src/sound/static_sound_source.hpp	2010-07-21 13:50:47 UTC (rev 3327)
@@ -0,0 +1,38 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_WINDSTILLE_SOUND_STATIC_SOUND_SOURCE_HPP
+#define HEADER_WINDSTILLE_SOUND_STATIC_SOUND_SOURCE_HPP
+
+#include "sound/openal_sound_source.hpp"
+
+class StaticSoundSource : public OpenALSoundSource
+{
+private:
+public:
+  StaticSoundSource(SoundChannel& channel, ALuint buffer);
+  virtual ~StaticSoundSource() {}
+
+private:
+  StaticSoundSource(const StaticSoundSource&);
+  StaticSoundSource& operator=(const StaticSoundSource&);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/src/sound/static_sound_source.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: trunk/windstille/src/sound/stream_sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-21 12:48:14 UTC (rev 3326)
+++ trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-21 13:50:47 UTC (rev 3327)
@@ -24,7 +24,7 @@
 #include "sound/sound_file.hpp"
 
 StreamSoundSource::StreamSoundSource(SoundChannel& channel, std::auto_ptr<SoundFile> sound_file) :
-  SoundSource(channel),
+  OpenALSoundSource(channel),
   m_sound_file(sound_file),
   m_format(SoundManager::get_sample_format(m_sound_file.get())),
   m_fade_state(),

Modified: trunk/windstille/src/sound/stream_sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.hpp	2010-07-21 12:48:14 UTC (rev 3326)
+++ trunk/windstille/src/sound/stream_sound_source.hpp	2010-07-21 13:50:47 UTC (rev 3327)
@@ -22,12 +22,12 @@
 #include <memory>
 #include <stdio.h>
 
-#include "sound/sound_source.hpp"
+#include "sound/openal_sound_source.hpp"
 
 class SoundFile;
 class SoundChannel;
 
-class StreamSoundSource : public SoundSource
+class StreamSoundSource : public OpenALSoundSource
 {
 public:
   enum FadeState { kNoFading, kFadingOn, kFadingOff };
@@ -41,7 +41,7 @@
 
   void update(float delta);
   
-  void seek_to(float sec);
+  virtual void seek_to(float sec);
 
 private:
   void fill_buffer_and_queue(ALuint buffer);



From grumbel at mail.berlios.de  Wed Jul 21 17:00:57 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed, 21 Jul 2010 17:00:57 +0200
Subject: [Windstille-commit] r3328 - trunk/windstille/src/sound
Message-ID: <20100721150057.7143348002A@sheep.berlios.de>

Author: grumbel
Date: 2010-07-21 17:00:57 +0200 (Wed, 21 Jul 2010)
New Revision: 3328

Added:
   trunk/windstille/src/sound/openal_sound_source_type.hpp
   trunk/windstille/src/sound/sound_source.hpp
Modified:
   trunk/windstille/src/sound/sound_channel.cpp
   trunk/windstille/src/sound/sound_channel.hpp
   trunk/windstille/src/sound/sound_manager.cpp
   trunk/windstille/src/sound/sound_manager.hpp
   trunk/windstille/src/sound/stream_sound_source.cpp
Log:
Addded missing files
Addded flag to decide streamed and static sources


Added: trunk/windstille/src/sound/openal_sound_source_type.hpp
===================================================================
--- trunk/windstille/src/sound/openal_sound_source_type.hpp	                        (rev 0)
+++ trunk/windstille/src/sound/openal_sound_source_type.hpp	2010-07-21 15:00:57 UTC (rev 3328)
@@ -0,0 +1,26 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_WINDSTILLE_SOUND_OPENAL_SOUND_SOURCE_TYPE_HPP
+#define HEADER_WINDSTILLE_SOUND_OPENAL_SOUND_SOURCE_TYPE_HPP
+
+enum OpenALSoundSourceType { kStaticSoundSource, kStreamSoundSource };
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/src/sound/openal_sound_source_type.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: trunk/windstille/src/sound/sound_channel.cpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.cpp	2010-07-21 13:50:47 UTC (rev 3327)
+++ trunk/windstille/src/sound/sound_channel.cpp	2010-07-21 15:00:57 UTC (rev 3328)
@@ -43,7 +43,8 @@
 }
 
 SoundSourcePtr
-SoundChannel::prepare(std::auto_ptr<SoundFile> sound_file)
+SoundChannel::prepare(std::auto_ptr<SoundFile> sound_file, 
+                      OpenALSoundSourceType type)
 {
   // FIXME: implement me
   assert(!"implement me");
@@ -51,11 +52,14 @@
 }
 
 SoundSourcePtr
-SoundChannel::prepare(const Pathname& filename)
+SoundChannel::prepare(const Pathname& filename, 
+                      OpenALSoundSourceType type)
 {
-  SoundSourcePtr source = m_sound_manager.create_sound_source(filename, *this);
+  SoundSourcePtr source = m_sound_manager.create_sound_source(filename, *this, 
+                                                              kStaticSoundSource);
   if (!source)
   {
+    std::cout << "SourceChannel::prepare: Couldn't load " << filename << std::endl;
     return SoundSourcePtr(new DummySoundSource());
   }
   else

Modified: trunk/windstille/src/sound/sound_channel.hpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.hpp	2010-07-21 13:50:47 UTC (rev 3327)
+++ trunk/windstille/src/sound/sound_channel.hpp	2010-07-21 15:00:57 UTC (rev 3328)
@@ -21,6 +21,7 @@
 
 #include <vector>
 
+#include "sound/openal_sound_source_type.hpp"
 #include "sound/sound_source_ptr.hpp"
 
 class Pathname;
@@ -35,8 +36,10 @@
   // shortcut for prepare()->play()
   SoundSourcePtr play(const Pathname& filename);
 
-  SoundSourcePtr prepare(std::auto_ptr<SoundFile> sound_file);
-  SoundSourcePtr prepare(const Pathname& filename);
+  SoundSourcePtr prepare(std::auto_ptr<SoundFile> sound_file, 
+                         OpenALSoundSourceType type = kStaticSoundSource);
+  SoundSourcePtr prepare(const Pathname& filename,
+                         OpenALSoundSourceType type = kStaticSoundSource);
 
   void update(float delta);
 

Modified: trunk/windstille/src/sound/sound_manager.cpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.cpp	2010-07-21 13:50:47 UTC (rev 3327)
+++ trunk/windstille/src/sound/sound_manager.cpp	2010-07-21 15:00:57 UTC (rev 3328)
@@ -132,29 +132,47 @@
 }
 
 SoundSourcePtr
-SoundManager::create_sound_source(const Pathname& filename, SoundChannel& channel)
+SoundManager::create_sound_source(const Pathname& filename, SoundChannel& channel, OpenALSoundSourceType type)
 {
   if (!m_sound_enabled)
   {
     return SoundSourcePtr();
   }
   else
-  {
-    ALuint buffer;
+  { 
+    switch(type)
+    {
+      case kStaticSoundSource:
+        {
+          ALuint buffer;
   
-    // reuse an existing static sound buffer            
-    SoundBuffers::iterator i = m_buffers.find(filename);
-    if (i != m_buffers.end()) 
-    {
-      buffer = i->second;
-    } 
-    else 
-    {
-      buffer = load_file_into_buffer(filename);
-      m_buffers.insert(std::make_pair(filename, buffer));
+          // reuse an existing static sound buffer            
+          SoundBuffers::iterator i = m_buffers.find(filename);
+          if (i != m_buffers.end()) 
+          {
+            buffer = i->second;
+          } 
+          else 
+          {
+            buffer = load_file_into_buffer(filename);
+            m_buffers.insert(std::make_pair(filename, buffer));
+          }
+
+          return SoundSourcePtr(new StaticSoundSource(channel, buffer));
+        }
+        break;
+
+      case kStreamSoundSource:
+        {
+          std::auto_ptr<SoundFile> sound_file = SoundFile::load(filename);
+          return SoundSourcePtr(new StreamSoundSource(channel, sound_file));
+        }
+        break;
+
+      default:
+        assert(!"never reached");
+        return SoundSourcePtr();
     }
-  
-    return SoundSourcePtr(new StaticSoundSource(channel, buffer));
   }
 }
 
@@ -163,7 +181,7 @@
 {
   try
   {
-    SoundSourcePtr source = create_sound_source(filename, m_sound_channel);
+    SoundSourcePtr source = create_sound_source(filename, m_sound_channel, kStaticSoundSource);
 
     if (source.get())
     {

Modified: trunk/windstille/src/sound/sound_manager.hpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.hpp	2010-07-21 13:50:47 UTC (rev 3327)
+++ trunk/windstille/src/sound/sound_manager.hpp	2010-07-21 15:00:57 UTC (rev 3328)
@@ -76,7 +76,9 @@
    * This function might throw exceptions. It returns 0 if no audio device is
    * available.
    */
-  SoundSourcePtr create_sound_source(const Pathname& filename, SoundChannel& channel);
+  SoundSourcePtr create_sound_source(const Pathname& filename, 
+                                     SoundChannel& channel, 
+                                     OpenALSoundSourceType type);
 
 public:
   static void check_al_error(const char* message);

Added: trunk/windstille/src/sound/sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/sound_source.hpp	                        (rev 0)
+++ trunk/windstille/src/sound/sound_source.hpp	2010-07-21 15:00:57 UTC (rev 3328)
@@ -0,0 +1,72 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_WINDSTILLE_SOUND_SOUND_SOURCE_HPP
+#define HEADER_WINDSTILLE_SOUND_SOUND_SOURCE_HPP
+
+class Vector2f;
+
+class SoundSource
+{
+private:
+public:
+  SoundSource() {}
+  virtual ~SoundSource() {}
+
+  virtual void play() = 0;
+  virtual void stop() = 0;
+  virtual bool is_playing() const = 0;
+
+  virtual float get_length() const = 0;
+
+  virtual void set_looping(bool looping) = 0;
+
+  /// Set volume (0.0 is silent, 1.0 is normal)
+  virtual void  set_gain(float gain) = 0;
+  virtual float get_gain() const = 0;
+
+  virtual void  seek_to(float sec) = 0;
+
+  /** Return the current position in seconds */
+  virtual float get_pos() const = 0;
+
+  virtual void set_position(const Vector2f& position) = 0;
+  virtual void set_velocity(const Vector2f& position) = 0;
+
+  /** Distances closer then reference distance will increase the gain
+      (or keep it at 1.0f), while distances further away will lower it */
+  virtual void set_reference_distance(float distance) = 0;
+
+  /** Higher factor will mean the sound gain lowers quicker with
+      distance, while lower factor will reduce the lowering of gain,
+      0.0f disables distance based reduction completly */
+  virtual void set_rolloff_factor(float factor) = 0;
+
+  /** Needs to be called whenever the SoundChannels gain changes */
+  virtual void update_gain() const = 0;
+  
+  virtual void update(float delta) =0;
+
+private:
+  SoundSource(const SoundSource&);
+  SoundSource& operator=(const SoundSource&);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/src/sound/sound_source.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: trunk/windstille/src/sound/stream_sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-21 13:50:47 UTC (rev 3327)
+++ trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-21 15:00:57 UTC (rev 3328)
@@ -108,12 +108,11 @@
     else if (m_fade_state == kFadingOff) 
     {
       float time = m_fade_start_ticks - m_total_time;
-
       if (time >= m_fade_time) 
       {
         stop();
         m_fade_state = kNoFading;
-      } 
+      }
       else 
       {
         set_gain( (m_fade_time - time) / m_fade_time);



From grumbel at mail.berlios.de  Wed Jul 21 18:06:46 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed, 21 Jul 2010 18:06:46 +0200
Subject: [Windstille-commit] r3329 - trunk/windstille/src/sound
Message-ID: <20100721160646.32DD848002A@sheep.berlios.de>

Author: grumbel
Date: 2010-07-21 18:06:46 +0200 (Wed, 21 Jul 2010)
New Revision: 3329

Modified:
   trunk/windstille/src/sound/sound_channel.cpp
Log:
Use given type, instead of kStaticSoundSource


Modified: trunk/windstille/src/sound/sound_channel.cpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.cpp	2010-07-21 15:00:57 UTC (rev 3328)
+++ trunk/windstille/src/sound/sound_channel.cpp	2010-07-21 16:06:46 UTC (rev 3329)
@@ -55,8 +55,7 @@
 SoundChannel::prepare(const Pathname& filename, 
                       OpenALSoundSourceType type)
 {
-  SoundSourcePtr source = m_sound_manager.create_sound_source(filename, *this, 
-                                                              kStaticSoundSource);
+  SoundSourcePtr source = m_sound_manager.create_sound_source(filename, *this, type);
   if (!source)
   {
     std::cout << "SourceChannel::prepare: Couldn't load " << filename << std::endl;



From grumbel at mail.berlios.de  Wed Jul 21 23:45:36 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed, 21 Jul 2010 23:45:36 +0200
Subject: [Windstille-commit] r3330 - trunk/windstille/src/sound
Message-ID: <20100721214537.0A6FF480B05@sheep.berlios.de>

Author: grumbel
Date: 2010-07-21 23:45:36 +0200 (Wed, 21 Jul 2010)
New Revision: 3330

Modified:
   trunk/windstille/src/sound/ogg_sound_file.cpp
   trunk/windstille/src/sound/ogg_sound_file.hpp
   trunk/windstille/src/sound/sound_file.hpp
   trunk/windstille/src/sound/wav_sound_file.cpp
   trunk/windstille/src/sound/wav_sound_file.hpp
Log:
Added eof() handling


Modified: trunk/windstille/src/sound/ogg_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-21 16:06:46 UTC (rev 3329)
+++ trunk/windstille/src/sound/ogg_sound_file.cpp	2010-07-21 21:45:36 UTC (rev 3330)
@@ -25,6 +25,7 @@
 
 OggSoundFile::OggSoundFile(const Pathname& filename) :
   m_in(),
+  m_eof(false),
   m_file_size(),
   m_vorbis_file(),
   m_channels(),
@@ -33,6 +34,7 @@
   m_size()
 {
   m_in.open(filename.get_sys_path().c_str(), std::ios::binary);
+
   if (!m_in)
   {
     std::ostringstream str;
@@ -102,13 +104,18 @@
   int section = 0;
   size_t totalBytesRead= 0;
 
-  while(buffer_size>0){
+  while(buffer_size>0)
+  {
     long bytesRead 
-      = ov_read(&m_vorbis_file, buffer, static_cast<int> (buffer_size), 0, 2, 1,
+      = ov_read(&m_vorbis_file, buffer, static_cast<int>(buffer_size), 0, 2, 1,
                 &section);
-    if(bytesRead==0){
+
+    if (bytesRead == 0)
+    {
+      m_eof = true;
       break;
     }
+
     buffer_size -= bytesRead;
     buffer += bytesRead;
     totalBytesRead += bytesRead;
@@ -120,15 +127,25 @@
 void
 OggSoundFile::reset()
 {
+  m_eof = false;
   ov_raw_seek(&m_vorbis_file, 0);
 }
 
+bool
+OggSoundFile::eof() const
+{
+  return m_eof;
+}
+
 void
 OggSoundFile::seek_to(float sec)
 {
-  ov_time_seek(&m_vorbis_file, sec);
+  m_eof = false;
+
+  // the version 'lap' will do crosslapsing to remove clicking when seeking
+  ov_time_seek_lap(&m_vorbis_file, sec);
 }
-
+
 size_t
 OggSoundFile::cb_read(void* ptr, size_t size, size_t nmemb, void* userdata)
 {

Modified: trunk/windstille/src/sound/ogg_sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/ogg_sound_file.hpp	2010-07-21 16:06:46 UTC (rev 3329)
+++ trunk/windstille/src/sound/ogg_sound_file.hpp	2010-07-21 21:45:36 UTC (rev 3330)
@@ -33,6 +33,7 @@
 
   size_t read(void* buffer, size_t buffer_size);
   void reset();
+  bool eof() const;
 
   int    get_bits_per_sample() const { return m_bits_per_sample; }
   size_t get_size() const { return m_size; }
@@ -49,6 +50,7 @@
   static long   cb_tell(void* source);
   
   std::ifstream  m_in;
+  bool m_eof;
   size_t m_file_size;
   OggVorbis_File m_vorbis_file;
 

Modified: trunk/windstille/src/sound/sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/sound_file.hpp	2010-07-21 16:06:46 UTC (rev 3329)
+++ trunk/windstille/src/sound/sound_file.hpp	2010-07-21 21:45:36 UTC (rev 3330)
@@ -32,6 +32,7 @@
 
   virtual size_t read(void* buffer, size_t buffer_size) = 0;
   virtual void reset() = 0;
+  virtual bool eof() const = 0;
 
   virtual int    get_bits_per_sample() const = 0;
   virtual size_t get_size() const = 0;

Modified: trunk/windstille/src/sound/wav_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/wav_sound_file.cpp	2010-07-21 16:06:46 UTC (rev 3329)
+++ trunk/windstille/src/sound/wav_sound_file.cpp	2010-07-21 21:45:36 UTC (rev 3330)
@@ -27,6 +27,7 @@
 
 WavSoundFile::WavSoundFile(const Pathname& filename) :
   file(),
+  m_eof(false),
   datastart(),
   m_channels(),
   m_rate(),
@@ -141,9 +142,17 @@
 {
 }
 
+bool
+WavSoundFile::eof() const
+{
+  return m_eof;
+}
+
 void
 WavSoundFile::reset()
 {
+  m_eof = false;
+
   if (!file.seekg(datastart))
     throw std::runtime_error("Couldn't seek to data start");
 }
@@ -151,6 +160,8 @@
 void
 WavSoundFile::seek_to(float sec)
 {
+  m_eof = false;
+
   size_t byte_pos = static_cast<size_t>(sec * static_cast<float>(m_rate * m_bits_per_sample/8 * m_channels));
 
   if (!file.seekg(datastart + byte_pos))
@@ -164,7 +175,10 @@
   size_t cur = static_cast<size_t>(file.tellg());
 
   if (cur >= end)
+  {
+    m_eof = true;
     return 0;
+  }
   
   size_t readsize = std::min(static_cast<size_t> (end - cur), buffer_size);
 

Modified: trunk/windstille/src/sound/wav_sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/wav_sound_file.hpp	2010-07-21 16:06:46 UTC (rev 3329)
+++ trunk/windstille/src/sound/wav_sound_file.hpp	2010-07-21 21:45:36 UTC (rev 3330)
@@ -29,12 +29,14 @@
   WavSoundFile(const Pathname& filename);
   ~WavSoundFile();
 
+  bool eof() const;
   size_t read(void* buffer, size_t buffer_size);
   void reset();
   void seek_to(float sec);
 
 private:
   std::ifstream file; 
+  bool m_eof;
   size_t datastart;
   int m_channels;
   int m_rate;



From grumbel at mail.berlios.de  Wed Jul 21 23:46:05 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed, 21 Jul 2010 23:46:05 +0200
Subject: [Windstille-commit] r3331 - trunk/windstille/src/sound
Message-ID: <20100721214605.DEB1A480B05@sheep.berlios.de>

Author: grumbel
Date: 2010-07-21 23:46:05 +0200 (Wed, 21 Jul 2010)
New Revision: 3331

Modified:
   trunk/windstille/src/sound/sound_manager.cpp
Log:
Update the channels when the SoundManager is updated


Modified: trunk/windstille/src/sound/sound_manager.cpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.cpp	2010-07-21 21:45:36 UTC (rev 3330)
+++ trunk/windstille/src/sound/sound_manager.cpp	2010-07-21 21:46:05 UTC (rev 3331)
@@ -306,6 +306,10 @@
 void
 SoundManager::update(float delta)
 {
+  m_voice_channel.update(delta);
+  m_sound_channel.update(delta);
+  m_music_channel.update(delta);
+
   if (m_sound_enabled)
   {
     // check for finished sound sources



From grumbel at mail.berlios.de  Wed Jul 21 23:46:42 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed, 21 Jul 2010 23:46:42 +0200
Subject: [Windstille-commit] r3332 - trunk/windstille/src/sound
Message-ID: <20100721214642.533BE480B05@sheep.berlios.de>

Author: grumbel
Date: 2010-07-21 23:46:42 +0200 (Wed, 21 Jul 2010)
New Revision: 3332

Modified:
   trunk/windstille/src/sound/openal_sound_source.hpp
   trunk/windstille/src/sound/stream_sound_source.cpp
   trunk/windstille/src/sound/stream_sound_source.hpp
Log:
Added proper looping handling for StreamSoundSource


Modified: trunk/windstille/src/sound/openal_sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/openal_sound_source.hpp	2010-07-21 21:46:05 UTC (rev 3331)
+++ trunk/windstille/src/sound/openal_sound_source.hpp	2010-07-21 21:46:42 UTC (rev 3332)
@@ -32,40 +32,37 @@
   OpenALSoundSource(SoundChannel& channel);
   virtual ~OpenALSoundSource();
 
-  void play();
-  void stop();
-  bool is_playing() const;
+  virtual void play();
+  virtual void stop();
+  virtual bool is_playing() const;
 
-  float get_length() const;
+  virtual float get_length() const;
 
-  void set_looping(bool looping);
+  virtual void set_looping(bool looping);
 
   /// Set volume (0.0 is silent, 1.0 is normal)
-  void  set_gain(float gain);
-  float get_gain() const;
+  virtual void  set_gain(float gain);
+  virtual float get_gain() const;
 
-  void  seek_to(float sec);
+  virtual void  seek_to(float sec);
 
   /** Return the current position in seconds */
-  float get_pos() const;
+  virtual float get_pos() const;
 
-  void set_position(const Vector2f& position);
-  void set_velocity(const Vector2f& position);
+  virtual void set_position(const Vector2f& position);
+  virtual void set_velocity(const Vector2f& position);
 
   /** Distances closer then reference distance will increase the gain
       (or keep it at 1.0f), while distances further away will lower it */
-  void set_reference_distance(float distance);
+  virtual void set_reference_distance(float distance);
 
   /** Higher factor will mean the sound gain lowers quicker with
       distance, while lower factor will reduce the lowering of gain,
       0.0f disables distance based reduction completly */
-  void set_rolloff_factor(float factor);
+  virtual void set_rolloff_factor(float factor);
   
-  /** Attaches the gives buffer to this sample */
-  void set_buffer(ALuint buffer);
-
   /** Needs to be called whenever the SoundChannels gain changes */
-  void update_gain() const;
+  virtual void update_gain() const;
 
   virtual void update(float delta) {}
 

Modified: trunk/windstille/src/sound/stream_sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-21 21:46:05 UTC (rev 3331)
+++ trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-21 21:46:42 UTC (rev 3332)
@@ -27,6 +27,7 @@
   OpenALSoundSource(channel),
   m_sound_file(sound_file),
   m_format(SoundManager::get_sample_format(m_sound_file.get())),
+  m_looping(false),
   m_fade_state(),
   m_fade_start_ticks(),
   m_fade_time(),
@@ -58,6 +59,14 @@
 }
 
 void
+StreamSoundSource::set_looping(bool looping)
+{
+  // native OpenAL looping will result in the queue being looped, not
+  // the whole song as provided by the SoundFile, so we do it manually
+  m_looping = looping;
+}
+
+void
 StreamSoundSource::seek_to(float sec)
 {
   m_sound_file->seek_to(sec);
@@ -70,18 +79,22 @@
 
   if (is_playing())
   {
-    ALint processed = 0;
-    alGetSourcei(m_source, AL_BUFFERS_PROCESSED, &processed);
-
-    while (processed > 0) 
+    // fill the buffer queue with new data
+    if (m_looping || !m_sound_file->eof())
     {
-      processed--;
+      ALint processed = 0;
+      alGetSourcei(m_source, AL_BUFFERS_PROCESSED, &processed);
 
-      ALuint buffer;
-      alSourceUnqueueBuffers(m_source, 1, &buffer);
-      SoundManager::check_al_error("Couldn't unqueue audio buffer: ");
+      while (processed > 0) 
+      {
+        processed--;
 
-      fill_buffer_and_queue(buffer);
+        ALuint buffer;
+        alSourceUnqueueBuffers(m_source, 1, &buffer);
+        SoundManager::check_al_error("Couldn't unqueue audio buffer: ");
+
+        fill_buffer_and_queue(buffer);
+      }
     }
   
     // we might have to restart the source if we had a buffer underrun
@@ -92,6 +105,7 @@
       SoundManager::check_al_error("Couldn't restart audio source: ");
     }
 
+    // handle fade-in/out
     if (m_fade_state == kFadingOn) 
     {
       float time = m_fade_start_ticks - m_total_time;
@@ -141,21 +155,31 @@
     bytesread += m_sound_file->read(bufferdata + bytesread,
                                     STREAMFRAGMENTSIZE - bytesread);
 
-    // if the end is reached, start from the beginning, thus loop
+    // the end of the SoundFile is reached
     if (bytesread < STREAMFRAGMENTSIZE) 
     {
-      m_sound_file->reset();
+      if (m_looping)
+      { // loop
+        m_sound_file->reset();
+      }
+      else
+      { // or end
+        break;
+      }
     }
   }
   while(bytesread < STREAMFRAGMENTSIZE);
   
-  // upload data to the OpenAL buffer
-  alBufferData(buffer, m_format, bufferdata, STREAMFRAGMENTSIZE, m_sound_file->get_rate());
-  SoundManager::check_al_error("Couldn't refill audio buffer: ");
+  if (bytesread > 0)
+  {
+    // upload data to the OpenAL buffer
+    alBufferData(buffer, m_format, bufferdata, bytesread, m_sound_file->get_rate());
+    SoundManager::check_al_error("Couldn't refill audio buffer: ");
 
-  // add buffer to the queue of this source
-  alSourceQueueBuffers(m_source, 1, &buffer);
-  SoundManager::check_al_error("Couldn't queue audio buffer: ");
+    // add buffer to the queue of this source
+    alSourceQueueBuffers(m_source, 1, &buffer);
+    SoundManager::check_al_error("Couldn't queue audio buffer: ");
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/sound/stream_sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.hpp	2010-07-21 21:46:05 UTC (rev 3331)
+++ trunk/windstille/src/sound/stream_sound_source.hpp	2010-07-21 21:46:42 UTC (rev 3332)
@@ -36,13 +36,13 @@
   StreamSoundSource(SoundChannel& channel, std::auto_ptr<SoundFile> sound_file);
   virtual ~StreamSoundSource();
 
+  void update(float delta);
+  void seek_to(float sec);
+  void set_looping(bool looping);
+
   void set_fading(FadeState state, float fadetime);
   FadeState get_fade_state() const { return m_fade_state; }
 
-  void update(float delta);
-  
-  virtual void seek_to(float sec);
-
 private:
   void fill_buffer_and_queue(ALuint buffer);
 
@@ -54,6 +54,8 @@
   ALuint m_buffers[STREAMFRAGMENTS];
   ALenum m_format;
 
+  bool m_looping;
+
   FadeState m_fade_state;
   float m_fade_start_ticks;
   float m_fade_time;



From grumbel at mail.berlios.de  Thu Jul 22 02:56:03 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Thu, 22 Jul 2010 02:56:03 +0200
Subject: [Windstille-commit] r3333 - trunk/windstille/src/sound
Message-ID: <20100722005604.0A221480B05@sheep.berlios.de>

Author: grumbel
Date: 2010-07-22 02:56:03 +0200 (Thu, 22 Jul 2010)
New Revision: 3333

Added:
   trunk/windstille/src/sound/filtered_sound_file.cpp
   trunk/windstille/src/sound/filtered_sound_file.hpp
Modified:
   trunk/windstille/src/sound/sound_channel.cpp
   trunk/windstille/src/sound/sound_file.hpp
Log:
Added support for custom filters ontop of SoundFiles


Added: trunk/windstille/src/sound/filtered_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/filtered_sound_file.cpp	                        (rev 0)
+++ trunk/windstille/src/sound/filtered_sound_file.cpp	2010-07-22 00:56:03 UTC (rev 3333)
@@ -0,0 +1,105 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "sound/filtered_sound_file.hpp"
+
+#include <iostream>
+#include <stdint.h>
+#include <string.h>
+
+FilteredSoundFile::FilteredSoundFile(std::auto_ptr<SoundFile> sound_file) :
+  m_sound_file(sound_file)
+{
+}
+
+FilteredSoundFile::~FilteredSoundFile()
+{
+}
+
+size_t
+FilteredSoundFile::read(void* buffer, size_t buffer_size)
+{
+  size_t len = m_sound_file->read(buffer, buffer_size);
+
+  // apply filter here
+  // FIXME: random junk for proof of concept
+  int16_t* p = static_cast<int16_t*>(buffer);
+  for(size_t i = 0; i < len/2; i += 32)
+  {
+    // reduce bits per sample
+    p[i] = static_cast<int16_t>(p[i] / 5000 * 5000);
+
+    // reduce sample rate
+    for(size_t j = i+1; j < i + 32; ++j)
+    {
+      p[j] = p[i];
+    }
+  }
+
+  return len;
+}
+
+void
+FilteredSoundFile::reset()
+{
+  return m_sound_file->reset();
+}
+
+bool
+FilteredSoundFile::eof() const
+{
+  return m_sound_file->eof();
+}
+
+int
+FilteredSoundFile::get_bits_per_sample() const
+{
+  return m_sound_file->get_bits_per_sample();
+}
+
+size_t
+FilteredSoundFile::get_size() const
+{
+  return m_sound_file->get_size();
+}
+
+int
+FilteredSoundFile::get_rate() const
+{
+  return m_sound_file->get_rate();
+}
+
+int
+FilteredSoundFile::get_channels() const
+{
+  return m_sound_file->get_channels();
+}
+
+void
+FilteredSoundFile::seek_to(float sec)
+{
+  m_sound_file->seek_to(sec);
+}
+
+float
+FilteredSoundFile::get_length() const
+{
+  return m_sound_file->get_length();
+}
+
+/* EOF */


Property changes on: trunk/windstille/src/sound/filtered_sound_file.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/src/sound/filtered_sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/filtered_sound_file.hpp	                        (rev 0)
+++ trunk/windstille/src/sound/filtered_sound_file.hpp	2010-07-22 00:56:03 UTC (rev 3333)
@@ -0,0 +1,57 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_WINDSTILLE_SOUND_FILTERED_SOUND_FILE_HPP
+#define HEADER_WINDSTILLE_SOUND_FILTERED_SOUND_FILE_HPP
+
+#include <memory>
+#include <string>
+
+#include "sound/sound_file.hpp"
+
+class FilteredSoundFile : public SoundFile
+{
+public:
+  FilteredSoundFile(std::auto_ptr<SoundFile> sound_file);
+  virtual ~FilteredSoundFile();
+
+  virtual size_t read(void* buffer, size_t buffer_size);
+  virtual void reset();
+  virtual bool eof() const;
+
+  virtual int    get_bits_per_sample() const;
+  virtual size_t get_size() const;
+  virtual int    get_rate() const;
+  virtual int    get_channels() const;
+
+  virtual void   seek_to(float sec);
+  
+  /** Returns the length of the file in seconds */
+  virtual float  get_length() const;
+
+private:
+  std::auto_ptr<SoundFile> m_sound_file;
+
+private:
+  FilteredSoundFile(const FilteredSoundFile&);
+  FilteredSoundFile& operator=(const FilteredSoundFile&);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/src/sound/filtered_sound_file.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: trunk/windstille/src/sound/sound_channel.cpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.cpp	2010-07-21 21:46:42 UTC (rev 3332)
+++ trunk/windstille/src/sound/sound_channel.cpp	2010-07-22 00:56:03 UTC (rev 3333)
@@ -25,6 +25,7 @@
 #include "util/pathname.hpp"
 #include "sound/sound_manager.hpp"
 #include "sound/sound_source.hpp"
+#include "sound/stream_sound_source.hpp"
 #include "sound/dummy_sound_source.hpp"
 
 SoundChannel::SoundChannel(SoundManager& sound_manager) :
@@ -46,9 +47,25 @@
 SoundChannel::prepare(std::auto_ptr<SoundFile> sound_file, 
                       OpenALSoundSourceType type)
 {
-  // FIXME: implement me
-  assert(!"implement me");
-  return SoundSourcePtr(new DummySoundSource());
+  switch(type)
+  {
+    case kStreamSoundSource:
+      {
+        SoundSourcePtr source(new StreamSoundSource(*this, sound_file));
+        source->update_gain();
+        m_sound_sources.push_back(SoundSourcePtr(source));
+        return source;
+      }
+      break;
+
+    case kStaticSoundSource:
+      // FIXME: not implemented
+      assert(!"not implemented");
+      break;
+
+    default:
+      assert(!"never reached");
+  }
 }
 
 SoundSourcePtr

Modified: trunk/windstille/src/sound/sound_file.hpp
===================================================================
--- trunk/windstille/src/sound/sound_file.hpp	2010-07-21 21:46:42 UTC (rev 3332)
+++ trunk/windstille/src/sound/sound_file.hpp	2010-07-22 00:56:03 UTC (rev 3333)
@@ -51,4 +51,3 @@
 #endif
 
 /* EOF */
-



From grumbel at mail.berlios.de  Fri Jul 23 00:06:06 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Fri, 23 Jul 2010 00:06:06 +0200
Subject: [Windstille-commit] r3334 - trunk/windstille/src/sound
Message-ID: <20100722220606.9AB15480D3A@sheep.berlios.de>

Author: grumbel
Date: 2010-07-23 00:06:06 +0200 (Fri, 23 Jul 2010)
New Revision: 3334

Modified:
   trunk/windstille/src/sound/dummy_sound_source.hpp
   trunk/windstille/src/sound/openal_sound_source.cpp
   trunk/windstille/src/sound/openal_sound_source.hpp
   trunk/windstille/src/sound/sound_source.hpp
   trunk/windstille/src/sound/stream_sound_source.cpp
   trunk/windstille/src/sound/stream_sound_source.hpp
Log:
Implemented get_pos() and get_sample_pos() for normal and streamed sources


Modified: trunk/windstille/src/sound/dummy_sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/dummy_sound_source.hpp	2010-07-22 00:56:03 UTC (rev 3333)
+++ trunk/windstille/src/sound/dummy_sound_source.hpp	2010-07-22 22:06:06 UTC (rev 3334)
@@ -45,6 +45,8 @@
   /** Return the current position in seconds */
   float get_pos() const { return 0.0f; }
 
+  int get_sample_pos() const { return 0; }
+
   void set_position(const Vector2f& position) {}
   void set_velocity(const Vector2f& position) {}
 

Modified: trunk/windstille/src/sound/openal_sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/openal_sound_source.cpp	2010-07-22 00:56:03 UTC (rev 3333)
+++ trunk/windstille/src/sound/openal_sound_source.cpp	2010-07-22 22:06:06 UTC (rev 3334)
@@ -79,6 +79,15 @@
   return sec;
 }
 
+int
+OpenALSoundSource::get_sample_pos() const
+{
+  ALint sample_pos;
+  alGetSourcei(m_source, AL_SAMPLE_OFFSET, &sample_pos); 
+  SoundManager::check_al_error("OpenALSoundSource::get_sample_pos: ");
+  return sample_pos;
+}
+
 bool
 OpenALSoundSource::is_playing() const
 {

Modified: trunk/windstille/src/sound/openal_sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/openal_sound_source.hpp	2010-07-22 00:56:03 UTC (rev 3333)
+++ trunk/windstille/src/sound/openal_sound_source.hpp	2010-07-22 22:06:06 UTC (rev 3334)
@@ -49,6 +49,8 @@
   /** Return the current position in seconds */
   virtual float get_pos() const;
 
+  virtual int get_sample_pos() const;
+
   virtual void set_position(const Vector2f& position);
   virtual void set_velocity(const Vector2f& position);
 

Modified: trunk/windstille/src/sound/sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/sound_source.hpp	2010-07-22 00:56:03 UTC (rev 3333)
+++ trunk/windstille/src/sound/sound_source.hpp	2010-07-22 22:06:06 UTC (rev 3334)
@@ -45,6 +45,9 @@
   /** Return the current position in seconds */
   virtual float get_pos() const = 0;
 
+  /** Return the current position in pcm samples */
+  virtual int get_sample_pos() const = 0;
+
   virtual void set_position(const Vector2f& position) = 0;
   virtual void set_velocity(const Vector2f& position) = 0;
 

Modified: trunk/windstille/src/sound/stream_sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-22 00:56:03 UTC (rev 3333)
+++ trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-22 22:06:06 UTC (rev 3334)
@@ -28,6 +28,7 @@
   m_sound_file(sound_file),
   m_format(SoundManager::get_sample_format(m_sound_file.get())),
   m_looping(false),
+  m_total_buffers_processed(0),
   m_fade_state(),
   m_fade_start_ticks(),
   m_fade_time(),
@@ -69,9 +70,31 @@
 void
 StreamSoundSource::seek_to(float sec)
 {
+  // FIXME: should empty the queue and refill it
   m_sound_file->seek_to(sec);
 }
 
+float
+StreamSoundSource::get_pos() const
+{
+  return static_cast<float>(get_sample_pos()) / static_cast<float>(m_sound_file->get_rate());
+}
+
+int
+StreamSoundSource::get_sample_pos() const
+{
+  int samples_total = m_total_buffers_processed * (STREAMFRAGMENTSIZE
+                                                   / m_sound_file->get_channels() 
+                                                   / (m_sound_file->get_bits_per_sample()/8));
+
+  ALint sample_pos;
+  alGetSourcei(m_source, AL_SAMPLE_OFFSET, &sample_pos); 
+
+  return (samples_total + sample_pos) % (m_sound_file->get_size()
+                                         / m_sound_file->get_channels() 
+                                         / (m_sound_file->get_bits_per_sample()/8));
+}
+
 void
 StreamSoundSource::update(float delta)
 {
@@ -89,6 +112,8 @@
       {
         processed--;
 
+        m_total_buffers_processed += 1;
+    
         ALuint buffer;
         alSourceUnqueueBuffers(m_source, 1, &buffer);
         SoundManager::check_al_error("Couldn't unqueue audio buffer: ");
@@ -171,7 +196,7 @@
   while(bytesread < STREAMFRAGMENTSIZE);
   
   if (bytesread > 0)
-  {
+  {  
     // upload data to the OpenAL buffer
     alBufferData(buffer, m_format, bufferdata, bytesread, m_sound_file->get_rate());
     SoundManager::check_al_error("Couldn't refill audio buffer: ");

Modified: trunk/windstille/src/sound/stream_sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.hpp	2010-07-22 00:56:03 UTC (rev 3333)
+++ trunk/windstille/src/sound/stream_sound_source.hpp	2010-07-22 22:06:06 UTC (rev 3334)
@@ -40,6 +40,9 @@
   void seek_to(float sec);
   void set_looping(bool looping);
 
+  float get_pos() const;
+  int   get_sample_pos() const;
+
   void set_fading(FadeState state, float fadetime);
   FadeState get_fade_state() const { return m_fade_state; }
 
@@ -55,6 +58,7 @@
   ALenum m_format;
 
   bool m_looping;
+  int  m_total_buffers_processed;
 
   FadeState m_fade_state;
   float m_fade_start_ticks;



From grumbel at mail.berlios.de  Fri Jul 23 00:17:19 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Fri, 23 Jul 2010 00:17:19 +0200
Subject: [Windstille-commit] r3335 - trunk/windstille/src/sound
Message-ID: <20100722221719.6E09C480D3A@sheep.berlios.de>

Author: grumbel
Date: 2010-07-23 00:17:19 +0200 (Fri, 23 Jul 2010)
New Revision: 3335

Modified:
   trunk/windstille/src/sound/filtered_sound_file.cpp
Log:
Small fix to make it not crash


Modified: trunk/windstille/src/sound/filtered_sound_file.cpp
===================================================================
--- trunk/windstille/src/sound/filtered_sound_file.cpp	2010-07-22 22:06:06 UTC (rev 3334)
+++ trunk/windstille/src/sound/filtered_sound_file.cpp	2010-07-22 22:17:19 UTC (rev 3335)
@@ -21,6 +21,7 @@
 #include <iostream>
 #include <stdint.h>
 #include <string.h>
+#include <stdlib.h>
 
 FilteredSoundFile::FilteredSoundFile(std::auto_ptr<SoundFile> sound_file) :
   m_sound_file(sound_file)
@@ -37,18 +38,11 @@
   size_t len = m_sound_file->read(buffer, buffer_size);
 
   // apply filter here
-  // FIXME: random junk for proof of concept
+  // FIXME: add a bit of noise as proof of concept
   int16_t* p = static_cast<int16_t*>(buffer);
-  for(size_t i = 0; i < len/2; i += 32)
+  for(size_t i = 0; i < len/2; i += 1)
   {
-    // reduce bits per sample
-    p[i] = static_cast<int16_t>(p[i] / 5000 * 5000);
-
-    // reduce sample rate
-    for(size_t j = i+1; j < i + 32; ++j)
-    {
-      p[j] = p[i];
-    }
+    p[i] = static_cast<int16_t>(p[i] + rand() % 8192 - 4096);
   }
 
   return len;



From grumbel at mail.berlios.de  Sun Jul 25 05:01:28 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Sun, 25 Jul 2010 05:01:28 +0200
Subject: [Windstille-commit] r3336 - trunk/windstille/src/sound
Message-ID: <20100725030128.A3009480E6E@sheep.berlios.de>

Author: grumbel
Date: 2010-07-25 05:01:28 +0200 (Sun, 25 Jul 2010)
New Revision: 3336

Modified:
   trunk/windstille/src/sound/openal_sound_source.hpp
   trunk/windstille/src/sound/stream_sound_source.cpp
Log:
Minor docu addition

Modified: trunk/windstille/src/sound/openal_sound_source.hpp
===================================================================
--- trunk/windstille/src/sound/openal_sound_source.hpp	2010-07-22 22:17:19 UTC (rev 3335)
+++ trunk/windstille/src/sound/openal_sound_source.hpp	2010-07-25 03:01:28 UTC (rev 3336)
@@ -49,6 +49,7 @@
   /** Return the current position in seconds */
   virtual float get_pos() const;
 
+  /** Seems to be limited to an accuracy of 1024 samples */
   virtual int get_sample_pos() const;
 
   virtual void set_position(const Vector2f& position);

Modified: trunk/windstille/src/sound/stream_sound_source.cpp
===================================================================
--- trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-22 22:17:19 UTC (rev 3335)
+++ trunk/windstille/src/sound/stream_sound_source.cpp	2010-07-25 03:01:28 UTC (rev 3336)
@@ -70,8 +70,19 @@
 void
 StreamSoundSource::seek_to(float sec)
 {
-  // FIXME: should empty the queue and refill it
   m_sound_file->seek_to(sec);
+
+  if (false)
+  { // FIXME: clear the buffer or not on seek? see ov_time_seek_lap()
+    // in OggSoundFile for possible reason why jumping might not be a good idea
+    alSourceUnqueueBuffers(m_source, STREAMFRAGMENTS, m_buffers);
+    SoundManager::check_al_error("Couldn't unqueue audio buffers: ");
+
+    for(size_t i = 0; i < STREAMFRAGMENTS; ++i) 
+    {
+      fill_buffer_and_queue(m_buffers[i]);
+    }
+  }
 }
 
 float



From grumbel at mail.berlios.de  Sun Jul 25 05:20:18 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Sun, 25 Jul 2010 05:20:18 +0200
Subject: [Windstille-commit] r3337 - in trunk/windstille/src: app armature
	collision display editor engine font gui hud input lisp math
	navigation objects particles properties scenegraph screen
	scripting sound sprite2d sprite3d tile util
Message-ID: <20100725032019.5A456480E6C@sheep.berlios.de>

Author: grumbel
Date: 2010-07-25 05:20:18 +0200 (Sun, 25 Jul 2010)
New Revision: 3337

Modified:
   trunk/windstille/src/app/config.cpp
   trunk/windstille/src/app/config.hpp
   trunk/windstille/src/app/console.cpp
   trunk/windstille/src/app/controller_def.hpp
   trunk/windstille/src/app/menu_manager.cpp
   trunk/windstille/src/armature/armature.cpp
   trunk/windstille/src/armature/bone.cpp
   trunk/windstille/src/armature/ipo_curve.cpp
   trunk/windstille/src/armature/mesh.cpp
   trunk/windstille/src/armature/model.cpp
   trunk/windstille/src/armature/pose.cpp
   trunk/windstille/src/collision/collision_data.cpp
   trunk/windstille/src/collision/collision_engine.cpp
   trunk/windstille/src/collision/collision_object.cpp
   trunk/windstille/src/collision/collision_test.cpp
   trunk/windstille/src/collision/collision_test.hpp
   trunk/windstille/src/collision/stair_contact.cpp
   trunk/windstille/src/display/basic_compositor_impl.cpp
   trunk/windstille/src/display/blitter.cpp
   trunk/windstille/src/display/compositor.cpp
   trunk/windstille/src/display/display.cpp
   trunk/windstille/src/display/drawing_context.cpp
   trunk/windstille/src/display/framebuffer.cpp
   trunk/windstille/src/display/framebuffer_compositor_impl.cpp
   trunk/windstille/src/display/graphic_context_state.cpp
   trunk/windstille/src/display/opengl_state.cpp
   trunk/windstille/src/display/opengl_window.cpp
   trunk/windstille/src/display/render_buffer.cpp
   trunk/windstille/src/display/scene_context.cpp
   trunk/windstille/src/display/shader_object.cpp
   trunk/windstille/src/display/shader_program.cpp
   trunk/windstille/src/display/software_surface.cpp
   trunk/windstille/src/display/surface.cpp
   trunk/windstille/src/display/surface_manager.cpp
   trunk/windstille/src/display/text_area.cpp
   trunk/windstille/src/display/texture.cpp
   trunk/windstille/src/display/texture_manager.cpp
   trunk/windstille/src/display/texture_packer.cpp
   trunk/windstille/src/editor/control_point.cpp
   trunk/windstille/src/editor/decal_object_model.cpp
   trunk/windstille/src/editor/decal_rotate_control_point.cpp
   trunk/windstille/src/editor/decal_scale_control_point.cpp
   trunk/windstille/src/editor/document.cpp
   trunk/windstille/src/editor/editor_window.cpp
   trunk/windstille/src/editor/layer.cpp
   trunk/windstille/src/editor/layer_manager.cpp
   trunk/windstille/src/editor/layer_widget.cpp
   trunk/windstille/src/editor/navgraph_edge_object_model.cpp
   trunk/windstille/src/editor/navgraph_insert_tool.cpp
   trunk/windstille/src/editor/navgraph_node_object_model.cpp
   trunk/windstille/src/editor/navigation_graph_model.cpp
   trunk/windstille/src/editor/node_selection.cpp
   trunk/windstille/src/editor/object_model.cpp
   trunk/windstille/src/editor/object_selector.cpp
   trunk/windstille/src/editor/particle_system_object_model.cpp
   trunk/windstille/src/editor/scroll_tool.cpp
   trunk/windstille/src/editor/sector_model.cpp
   trunk/windstille/src/editor/sector_model_builder.cpp
   trunk/windstille/src/editor/select_tool.cpp
   trunk/windstille/src/editor/selection.cpp
   trunk/windstille/src/editor/sprite_object_model.cpp
   trunk/windstille/src/editor/timeline.cpp
   trunk/windstille/src/editor/timeline_layer.cpp
   trunk/windstille/src/editor/timeline_object_layer.cpp
   trunk/windstille/src/editor/undo_manager.cpp
   trunk/windstille/src/editor/windstille_widget.cpp
   trunk/windstille/src/editor/zoom_tool.cpp
   trunk/windstille/src/engine/camera.cpp
   trunk/windstille/src/engine/entity.cpp
   trunk/windstille/src/engine/game_object.hpp
   trunk/windstille/src/engine/physics.cpp
   trunk/windstille/src/engine/script_manager.cpp
   trunk/windstille/src/engine/script_manager.hpp
   trunk/windstille/src/engine/sector.cpp
   trunk/windstille/src/engine/sector_builder.cpp
   trunk/windstille/src/engine/squirrel_thread.cpp
   trunk/windstille/src/font/border_font_effect.cpp
   trunk/windstille/src/font/border_font_effect.hpp
   trunk/windstille/src/font/font_effect.hpp
   trunk/windstille/src/font/fonts.cpp
   trunk/windstille/src/font/no_font_effect.cpp
   trunk/windstille/src/font/no_font_effect.hpp
   trunk/windstille/src/font/ttf_font.cpp
   trunk/windstille/src/gui/automap.cpp
   trunk/windstille/src/gui/button.cpp
   trunk/windstille/src/gui/group_component.cpp
   trunk/windstille/src/gui/gui_manager.cpp
   trunk/windstille/src/gui/list_view.cpp
   trunk/windstille/src/gui/menu.cpp
   trunk/windstille/src/gui/menu_component.cpp
   trunk/windstille/src/gui/root_component.cpp
   trunk/windstille/src/gui/slider.cpp
   trunk/windstille/src/gui/tab_component.cpp
   trunk/windstille/src/gui/text_view.cpp
   trunk/windstille/src/hud/controller_help_window.cpp
   trunk/windstille/src/hud/conversation.cpp
   trunk/windstille/src/hud/dialog_manager.cpp
   trunk/windstille/src/hud/inventory.cpp
   trunk/windstille/src/hud/pda.cpp
   trunk/windstille/src/hud/speech_manager.cpp
   trunk/windstille/src/input/controller.cpp
   trunk/windstille/src/input/input_configurator.cpp
   trunk/windstille/src/input/input_manager_sdl.cpp
   trunk/windstille/src/input/wiimote.cpp
   trunk/windstille/src/lisp/lexer.cpp
   trunk/windstille/src/lisp/lisp.cpp
   trunk/windstille/src/lisp/parser.cpp
   trunk/windstille/src/lisp/properties.cpp
   trunk/windstille/src/lisp/writer.cpp
   trunk/windstille/src/math/line.cpp
   trunk/windstille/src/math/matrix.cpp
   trunk/windstille/src/math/origin.cpp
   trunk/windstille/src/math/origin.hpp
   trunk/windstille/src/math/point.hpp
   trunk/windstille/src/math/random.cpp
   trunk/windstille/src/math/rect.cpp
   trunk/windstille/src/math/rect.hpp
   trunk/windstille/src/math/size.hpp
   trunk/windstille/src/navigation/edge.cpp
   trunk/windstille/src/navigation/edge_position.cpp
   trunk/windstille/src/navigation/navigation_graph.cpp
   trunk/windstille/src/navigation/node.cpp
   trunk/windstille/src/objects/background_gradient.cpp
   trunk/windstille/src/objects/bomb.cpp
   trunk/windstille/src/objects/box.cpp
   trunk/windstille/src/objects/character.cpp
   trunk/windstille/src/objects/decal.cpp
   trunk/windstille/src/objects/doll.cpp
   trunk/windstille/src/objects/elevator.cpp
   trunk/windstille/src/objects/grenade.cpp
   trunk/windstille/src/objects/hedgehog.cpp
   trunk/windstille/src/objects/laser_pointer.cpp
   trunk/windstille/src/objects/layer.cpp
   trunk/windstille/src/objects/liquid.cpp
   trunk/windstille/src/objects/nightvision.cpp
   trunk/windstille/src/objects/particle_systems.cpp
   trunk/windstille/src/objects/pistol.cpp
   trunk/windstille/src/objects/player.cpp
   trunk/windstille/src/objects/scriptable_object.cpp
   trunk/windstille/src/objects/scriptable_object.hpp
   trunk/windstille/src/objects/shockwave.cpp
   trunk/windstille/src/objects/spider_mine.cpp
   trunk/windstille/src/objects/swarm.cpp
   trunk/windstille/src/objects/test_object.cpp
   trunk/windstille/src/objects/test_object.hpp
   trunk/windstille/src/objects/trigger.cpp
   trunk/windstille/src/objects/vrdummy.cpp
   trunk/windstille/src/particles/deform_drawer.cpp
   trunk/windstille/src/particles/particle_system.cpp
   trunk/windstille/src/particles/spark_drawer.cpp
   trunk/windstille/src/particles/surface_drawer.cpp
   trunk/windstille/src/properties/properties.cpp
   trunk/windstille/src/properties/property_set.cpp
   trunk/windstille/src/scenegraph/control_drawable.hpp
   trunk/windstille/src/scenegraph/shockwave_drawable.hpp
   trunk/windstille/src/screen/armature_test.cpp
   trunk/windstille/src/screen/game_session.cpp
   trunk/windstille/src/screen/geometry_test.cpp
   trunk/windstille/src/screen/navigation_test.cpp
   trunk/windstille/src/screen/particle_viewer.cpp
   trunk/windstille/src/screen/screen_manager.cpp
   trunk/windstille/src/screen/sprite2dview.cpp
   trunk/windstille/src/screen/sprite3dview.cpp
   trunk/windstille/src/screen/view.cpp
   trunk/windstille/src/scripting/game_objects.cpp
   trunk/windstille/src/scripting/game_objects.hpp
   trunk/windstille/src/scripting/squirrel_error.cpp
   trunk/windstille/src/scripting/util.cpp
   trunk/windstille/src/sound/sound_channel.cpp
   trunk/windstille/src/sound/sound_manager.cpp
   trunk/windstille/src/sprite2d/data.cpp
   trunk/windstille/src/sprite2d/manager.cpp
   trunk/windstille/src/sprite2d/sprite.cpp
   trunk/windstille/src/sprite3d/manager.cpp
   trunk/windstille/src/sprite3d/sprite3d.cpp
   trunk/windstille/src/tile/tile.cpp
   trunk/windstille/src/tile/tile_description.cpp
   trunk/windstille/src/tile/tile_factory.cpp
   trunk/windstille/src/tile/tile_map.cpp
   trunk/windstille/src/tile/tile_packer.cpp
   trunk/windstille/src/util/baby_xml.cpp
   trunk/windstille/src/util/command_line.cpp
   trunk/windstille/src/util/command_line.hpp
   trunk/windstille/src/util/command_line_generic.cpp
   trunk/windstille/src/util/command_line_generic.hpp
   trunk/windstille/src/util/file_reader.cpp
   trunk/windstille/src/util/file_reader.hpp
   trunk/windstille/src/util/file_writer.cpp
   trunk/windstille/src/util/getter.cpp
   trunk/windstille/src/util/handle.hpp
   trunk/windstille/src/util/pathname.cpp
   trunk/windstille/src/util/response_curve.cpp
   trunk/windstille/src/util/sexpr_file_reader.cpp
   trunk/windstille/src/util/system.cpp
Log:
Unified the indention

Modified: trunk/windstille/src/app/config.cpp
===================================================================
--- trunk/windstille/src/app/config.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/app/config.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -71,9 +71,9 @@
 Config::~Config()
 {
   for(ConfigValues::iterator i = config_values.begin(); i != config_values.end(); ++i)
-    {
-      delete i->second;
-    }
+  {
+    delete i->second;
+  }
   config_values.clear();
 }
 
@@ -175,119 +175,119 @@
   argp.parse_args(argc, argv);
 
   while (argp.next())
+  {
+    switch (argp.get_key())
     {
-      switch (argp.get_key())
+      case 'A':
+        int anti_aliasing;
+        if (sscanf(argp.get_argument().c_str(), "%d", &anti_aliasing) != 1)
         {
-        case 'A':
-          int anti_aliasing;
-          if (sscanf(argp.get_argument().c_str(), "%d", &anti_aliasing) != 1)
-            {
-              throw std::runtime_error("Anti-Aliasing option '-a' requires argument of type {NUM}");
-            }
-          else
-            {
-              get<int>("anti-aliasing") = anti_aliasing;
-            }
-          break;
+          throw std::runtime_error("Anti-Aliasing option '-a' requires argument of type {NUM}");
+        }
+        else
+        {
+          get<int>("anti-aliasing") = anti_aliasing;
+        }
+        break;
 
-        case 'r':
-          get<std::string>("recorder-file") = argp.get_argument();
-          break;
+      case 'r':
+        get<std::string>("recorder-file") = argp.get_argument();
+        break;
 
-        case 'x':
-          get<std::string>("screenshot-dir") = argp.get_argument();
-          break;
+      case 'x':
+        get<std::string>("screenshot-dir") = argp.get_argument();
+        break;
 
-        case 'p':
-          get<std::string>("playback-file") = argp.get_argument();
-          break;
+      case 'p':
+        get<std::string>("playback-file") = argp.get_argument();
+        break;
 
-        case 'w':
-          get<bool>("wiimote") = true;
-          break;
+      case 'w':
+        get<bool>("wiimote") = true;
+        break;
 
-        case 'd':
-          Pathname::set_datadir(argp.get_argument());
-          break;
+      case 'd':
+        Pathname::set_datadir(argp.get_argument());
+        break;
 
-        case 'f':
-          set_bool("fullscreen", true);
-          break;
+      case 'f':
+        set_bool("fullscreen", true);
+        break;
 
-        case 'g':
-          {
-            int screen_width  = 800;
-            int screen_height = 600;
-            if (sscanf(argp.get_argument().c_str(), "%dx%d",
-                       &screen_width, &screen_height) == 2)
-              {
-                get<int>("screen-width")  = screen_width;
-                get<int>("screen-height") = screen_height;
+      case 'g':
+      {
+        int screen_width  = 800;
+        int screen_height = 600;
+        if (sscanf(argp.get_argument().c_str(), "%dx%d",
+                   &screen_width, &screen_height) == 2)
+        {
+          get<int>("screen-width")  = screen_width;
+          get<int>("screen-height") = screen_height;
               
-                // FIXME: Why does this get printed twice?!
-                // Is the argument parser buggy?
-                std::cout << "Geometry: " << screen_width << "x" << screen_height << std::endl;
-              }
-            else
-              {
-                throw std::runtime_error("Geometry option '-g' requires argument of type {WIDTH}x{HEIGHT}");
-              }
-          }
-          break;
+          // FIXME: Why does this get printed twice?!
+          // Is the argument parser buggy?
+          std::cout << "Geometry: " << screen_width << "x" << screen_height << std::endl;
+        }
+        else
+        {
+          throw std::runtime_error("Geometry option '-g' requires argument of type {WIDTH}x{HEIGHT}");
+        }
+      }
+      break;
 
-        case 'a':
-          {
-            int aspect_width  = 800;
-            int aspect_height = 600;
-            if (sscanf(argp.get_argument().c_str(), "%dx%d",
-                       &aspect_width, &aspect_height) == 2)
-              {
-                get<int>("aspect-width")  = aspect_width;
-                get<int>("aspect-height") = aspect_height;
+      case 'a':
+      {
+        int aspect_width  = 800;
+        int aspect_height = 600;
+        if (sscanf(argp.get_argument().c_str(), "%dx%d",
+                   &aspect_width, &aspect_height) == 2)
+        {
+          get<int>("aspect-width")  = aspect_width;
+          get<int>("aspect-height") = aspect_height;
               
-                // FIXME: Why does this get printed twice?!
-                // Is the argument parser buggy?
-                std::cout << "Geometry: " << aspect_width << "x" << aspect_height << std::endl;
-              }
-            else
-              {
-                throw std::runtime_error("Geometry option '-a' requires argument of type {WIDTH}x{HEIGHT}");
-              }
-          }
-          break;
+          // FIXME: Why does this get printed twice?!
+          // Is the argument parser buggy?
+          std::cout << "Geometry: " << aspect_width << "x" << aspect_height << std::endl;
+        }
+        else
+        {
+          throw std::runtime_error("Geometry option '-a' requires argument of type {WIDTH}x{HEIGHT}");
+        }
+      }
+      break;
         
-        case 's':
-          set_bool("sound", false);
-          break;
+      case 's':
+        set_bool("sound", false);
+        break;
 
-        case 'S':
-          set_bool("sound", true);
-          break;  
+      case 'S':
+        set_bool("sound", true);
+        break;  
 
-        case 'c':
-          get<std::string>("primary-controller-file") = argp.get_argument();
-          break;
+      case 'c':
+        get<std::string>("primary-controller-file") = argp.get_argument();
+        break;
 
-        case secondary_controller_file:
-          get<std::string>("secondary-controller-file") = argp.get_argument();
-          break;
+      case secondary_controller_file:
+        get<std::string>("secondary-controller-file") = argp.get_argument();
+        break;
 
-        case 'v':
-          std::cout << "Windstille " << WINDSTILLE_VERSION << std::endl;
-          exit(EXIT_SUCCESS);
-          break;
+      case 'v':
+        std::cout << "Windstille " << WINDSTILLE_VERSION << std::endl;
+        exit(EXIT_SUCCESS);
+        break;
 
-        case 'h':
-          argp.print_help();
-          exit(EXIT_SUCCESS);
-          break;
+      case 'h':
+        argp.print_help();
+        exit(EXIT_SUCCESS);
+        break;
 
-        case CommandLine::REST_ARG:
-          set_string("levelfile", argp.get_argument());
-          arg_files.push_back(argp.get_argument());
-          break;
-        }
+      case CommandLine::REST_ARG:
+        set_string("levelfile", argp.get_argument());
+        arg_files.push_back(argp.get_argument());
+        break;
     }
+  }
 }
 
 bool
@@ -302,67 +302,67 @@
 {
   ConfigValues::iterator i = config_values.find(name);
   if (i == config_values.end())
-    {
-      throw std::runtime_error("Error: unknown Config value: '" + name + "'");        
-    }    
+  {
+    throw std::runtime_error("Error: unknown Config value: '" + name + "'");        
+  }    
   else
-    {
-      return i->second->is_set();
-    }
+  {
+    return i->second->is_set();
+  }
 }
 
 void
 Config::load()
 {
   try 
+  {
+    FileReader reader = FileReader::parse(Pathname("config", Pathname::kUserPath));
+    if(reader.get_name() != "windstille-config") 
     {
-      FileReader reader = FileReader::parse(Pathname("config", Pathname::kUserPath));
-      if(reader.get_name() != "windstille-config") 
-        {
-          std::cerr << "Warning: Config file is not a windstille-config file.\n";
-          return;
-        }
+      std::cerr << "Warning: Config file is not a windstille-config file.\n";
+      return;
+    }
     
-      for(ConfigValues::iterator i = config_values.begin(); i != config_values.end(); ++i)
-        { // FIXME: all this dynamic_casting is overcomplicated crap
-          if (dynamic_cast<ConfigValue<int>*>(i->second))
-            {
-              int v;
-              if (reader.get(i->first.c_str(), v))
-                set_int(i->first, v);
-            }
-          else if (dynamic_cast<ConfigValue<bool>*>(i->second))
-            {
-              bool v;
-              if (reader.get(i->first.c_str(), v))
-                set_bool(i->first, v);
-            }
-          else if (dynamic_cast<ConfigValue<float>*>(i->second))
-            {
-              float v;
-              if (reader.get(i->first.c_str(), v))
-                set_float(i->first, v);
-            }
-          else if (dynamic_cast<ConfigValue<std::string>*>(i->second))
-            {
-              std::string v;
-              if (reader.get(i->first.c_str(), v))
-                set_string(i->first, v);
-            }
-          else 
-            {
-              std::cout << "Config: Unknown type for: " << i->first << std::endl;
-            }
-        }
+    for(ConfigValues::iterator i = config_values.begin(); i != config_values.end(); ++i)
+    { // FIXME: all this dynamic_casting is overcomplicated crap
+      if (dynamic_cast<ConfigValue<int>*>(i->second))
+      {
+        int v;
+        if (reader.get(i->first.c_str(), v))
+          set_int(i->first, v);
+      }
+      else if (dynamic_cast<ConfigValue<bool>*>(i->second))
+      {
+        bool v;
+        if (reader.get(i->first.c_str(), v))
+          set_bool(i->first, v);
+      }
+      else if (dynamic_cast<ConfigValue<float>*>(i->second))
+      {
+        float v;
+        if (reader.get(i->first.c_str(), v))
+          set_float(i->first, v);
+      }
+      else if (dynamic_cast<ConfigValue<std::string>*>(i->second))
+      {
+        std::string v;
+        if (reader.get(i->first.c_str(), v))
+          set_string(i->first, v);
+      }
+      else 
+      {
+        std::cout << "Config: Unknown type for: " << i->first << std::endl;
+      }
+    }
     
-      // TODO read controller config
-    } 
+    // TODO read controller config
+  } 
   catch(std::exception& e) 
-    {
-      std::cerr << "Couldn't open config file: " << e.what() << "\n"
-                << "This is normal on first startup!\n";
-      return;
-    }
+  {
+    std::cerr << "Couldn't open config file: " << e.what() << "\n"
+              << "This is normal on first startup!\n";
+    return;
+  }
 }
 
 void
@@ -376,14 +376,14 @@
     writer.start_list("windstille-config");
 
     for(ConfigValues::iterator i = config_values.begin(); i != config_values.end(); ++i)
+    {
+      if (i->second->should_be_saved() && i->second->is_set())
       {
-        if (i->second->should_be_saved() && i->second->is_set())
-          {
-            writer.write_comment("  ;; " + i->second->get_docstring()); 
-            i->second->write(writer);
-            writer.write_comment("");
-          }
+        writer.write_comment("  ;; " + i->second->get_docstring()); 
+        i->second->write(writer);
+        writer.write_comment("");
       }
+    }
     // TODO write controller config
     
     writer.end_list("windstille-config");
@@ -398,14 +398,14 @@
 {
   out << "Config " << this << ":" << std::endl;
   for(ConfigValues::iterator i = config_values.begin(); i != config_values.end(); ++i)
-    {
-      out << boost::format("  %|1$20| = %|2$-20| (%|3$|)")
-        % i->second->get_name()
-        % (boost::format("'%|1s|'") % (*i->second))
-        % (i->second->is_set() ? "set" : "default")
-          << std::endl;
+  {
+    out << boost::format("  %|1$20| = %|2$-20| (%|3$|)")
+      % i->second->get_name()
+      % (boost::format("'%|1s|'") % (*i->second))
+      % (i->second->is_set() ? "set" : "default")
+        << std::endl;
       
-    }
+  }
 }
 
 template<>

Modified: trunk/windstille/src/app/config.hpp
===================================================================
--- trunk/windstille/src/app/config.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/app/config.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -139,17 +139,17 @@
   ConfigValue<T>& get(const std::string& name) const {
     ConfigValues::const_iterator i = config_values.find(name);
     if (i == config_values.end())
-      {
-        throw std::runtime_error("Error: unknown Config value: '" + name + "'");
-      }
+    {
+      throw std::runtime_error("Error: unknown Config value: '" + name + "'");
+    }
     else
-      {
-        ConfigValue<T>* ptr = dynamic_cast<ConfigValue<T>*>(i->second);
-        if (ptr)
-          return *ptr;
-        else
-          throw std::runtime_error("Error: Config value: '" + name + "' as wrong type");
-      }
+    {
+      ConfigValue<T>* ptr = dynamic_cast<ConfigValue<T>*>(i->second);
+      if (ptr)
+        return *ptr;
+      else
+        throw std::runtime_error("Error: Config value: '" + name + "' as wrong type");
+    }
   }
 
   std::string get_string(const std::string& name) const;

Modified: trunk/windstille/src/app/console.cpp
===================================================================
--- trunk/windstille/src/app/console.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/app/console.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -167,152 +167,152 @@
                        Color(0, 0, 0, 0.5f));
 
   for(int i = buffer.size()-1 - scroll_offset; i >= 0 && i > int(buffer.size()) - num_lines - scroll_offset; --i)
+  {
+    if (buffer[i].display_time < 5.0f || console.is_active())
     {
-      if (buffer[i].display_time < 5.0f || console.is_active())
-        {
-          float alpha = 1.0f;
-          if (buffer[i].display_time > 4.0f && !console.is_active())
-            alpha = 1.0f - (buffer[i].display_time - 4.0f);
+      float alpha = 1.0f;
+      if (buffer[i].display_time > 4.0f && !console.is_active())
+        alpha = 1.0f - (buffer[i].display_time - 4.0f);
 
-          Fonts::current()->ttffont->draw(Vector2f(x_pos, static_cast<float>(y)), buffer[i].message, 
-                                          Color(0.88f, 0.88f, 1.0f, alpha));
-        }
-      y -= Fonts::current()->ttffont->get_height() + 2;
+      Fonts::current()->ttffont->draw(Vector2f(x_pos, static_cast<float>(y)), buffer[i].message, 
+                                      Color(0.88f, 0.88f, 1.0f, alpha));
     }
+    y -= Fonts::current()->ttffont->get_height() + 2;
+  }
 
   if (active)
+  {
+    std::string str = command_line;
+    if (SDL_GetTicks() % 300 > 150)
     {
-      std::string str = command_line;
-      if (SDL_GetTicks() % 300 > 150)
-        {
-          if (cursor_pos < int(str.size()))
-            str[cursor_pos] = '_';
-          else
-            str += "_";
-        }
+      if (cursor_pos < int(str.size()))
+        str[cursor_pos] = '_';
+      else
+        str += "_";
+    }
 
-      Fonts::current()->ttffont->draw(Vector2f(x_pos, y_pos), "> " + str, Color(1.0f, 1.0f, 1.0f));
-    }
+    Fonts::current()->ttffont->draw(Vector2f(x_pos, y_pos), "> " + str, Color(1.0f, 1.0f, 1.0f));
+  }
 }
 
 void
 ConsoleImpl::update(float delta)
 {
   for(Buffer::iterator i = buffer.begin(); i != buffer.end(); ++i)
-    {
-      i->display_time += delta;
-    }  
+  {
+    i->display_time += delta;
+  }  
 
   if (active)
+  {
+    InputEventLst events = InputManagerSDL::current()->get_controller().get_events();
+  
+    for (InputEventLst::iterator i = events.begin(); i != events.end(); ++i)
     {
-      InputEventLst events = InputManagerSDL::current()->get_controller().get_events();
-  
-      for (InputEventLst::iterator i = events.begin(); i != events.end(); ++i)
+      if ((*i).type == KEYBOARD_EVENT)
+      {
+        if ((*i).keyboard.key_type == KeyboardEvent::LETTER)
         {
-          if ((*i).type == KEYBOARD_EVENT)
-            {
-              if ((*i).keyboard.key_type == KeyboardEvent::LETTER)
-                {
-                  if (cursor_pos == int(command_line.size()))
-                    {
-                      command_line += static_cast<char>((*i).keyboard.code);
-                      cursor_pos += 1;
-                    }
-                  else
-                    {
-                      command_line.insert(cursor_pos, std::string(1, static_cast<char>((*i).keyboard.code)));
-                      cursor_pos += 1;
-                    }
-                }
-              else if ((*i).keyboard.key_type == KeyboardEvent::SPECIAL)
-                {
-                  //console << "special: " << i->keyboard.code << std::endl;
+          if (cursor_pos == int(command_line.size()))
+          {
+            command_line += static_cast<char>((*i).keyboard.code);
+            cursor_pos += 1;
+          }
+          else
+          {
+            command_line.insert(cursor_pos, std::string(1, static_cast<char>((*i).keyboard.code)));
+            cursor_pos += 1;
+          }
+        }
+        else if ((*i).keyboard.key_type == KeyboardEvent::SPECIAL)
+        {
+          //console << "special: " << i->keyboard.code << std::endl;
 
-                  switch (i->keyboard.code)
-                    {
-                    case SDLK_BACKSPACE:
-                      if (!command_line.empty() && cursor_pos > 0)
-                        {
-                          command_line.erase(cursor_pos - 1, 1);
-                          cursor_pos -= 1;
-                        }
-                      break;
+          switch (i->keyboard.code)
+          {
+            case SDLK_BACKSPACE:
+              if (!command_line.empty() && cursor_pos > 0)
+              {
+                command_line.erase(cursor_pos - 1, 1);
+                cursor_pos -= 1;
+              }
+              break;
 
-                    case SDLK_DELETE:
-                      if (!command_line.empty())
-                        {
-                          command_line.erase(cursor_pos, 1);
-                        }
-                      break;
+            case SDLK_DELETE:
+              if (!command_line.empty())
+              {
+                command_line.erase(cursor_pos, 1);
+              }
+              break;
 
-                    case SDLK_DOWN:
-                      if (!history.empty())
-                        {
-                          history_position += 1;
-                          if (history_position > int(history.size())-1)
-                            history_position = int(history.size())-1;
-                          command_line = history[history_position];
-                          cursor_pos = command_line.size();
-                        }
-                      break;
+            case SDLK_DOWN:
+              if (!history.empty())
+              {
+                history_position += 1;
+                if (history_position > int(history.size())-1)
+                  history_position = int(history.size())-1;
+                command_line = history[history_position];
+                cursor_pos = command_line.size();
+              }
+              break;
 
-                    case SDLK_HOME:
-                      cursor_pos = 0;
-                      break;
+            case SDLK_HOME:
+              cursor_pos = 0;
+              break;
                       
-                    case SDLK_END:
-                      cursor_pos = command_line.size();
-                      break;
+            case SDLK_END:
+              cursor_pos = command_line.size();
+              break;
                         
-                    case SDLK_PAGEUP:
-                      console.scroll(10);
-                      break;
+            case SDLK_PAGEUP:
+              console.scroll(10);
+              break;
 
-                    case SDLK_PAGEDOWN:
-                      console.scroll(-10);
-                      break;
+            case SDLK_PAGEDOWN:
+              console.scroll(-10);
+              break;
 
-                    case SDLK_TAB:
-                      tab_complete();
-                      break;
+            case SDLK_TAB:
+              tab_complete();
+              break;
 
-                    case SDLK_UP:
-                      if (!history.empty())
-                        {
-                          history_position -= 1;
-                          if (history_position < 0)
-                            history_position = 0;
+            case SDLK_UP:
+              if (!history.empty())
+              {
+                history_position -= 1;
+                if (history_position < 0)
+                  history_position = 0;
 
-                          command_line = history[history_position];
-                          cursor_pos = command_line.size();
-                        }
-                      break;
+                command_line = history[history_position];
+                cursor_pos = command_line.size();
+              }
+              break;
 
-                    case SDLK_LEFT:
-                      cursor_pos -= 1;
-                      if (cursor_pos < 0)
-                        cursor_pos = 0;
-                      break;
+            case SDLK_LEFT:
+              cursor_pos -= 1;
+              if (cursor_pos < 0)
+                cursor_pos = 0;
+              break;
 
-                    case SDLK_RIGHT:
-                      cursor_pos += 1;
-                      if (cursor_pos > int(command_line.size()))
-                        cursor_pos = command_line.size();
-                      break;
+            case SDLK_RIGHT:
+              cursor_pos += 1;
+              if (cursor_pos > int(command_line.size()))
+                cursor_pos = command_line.size();
+              break;
 
-                    case SDLK_RETURN:
-                      eval_command_line();
-                      break;
+            case SDLK_RETURN:
+              eval_command_line();
+              break;
 
-                    case SDLK_ESCAPE:
-                    case SDLK_F1:
-                      console.deactive();
-                      break;
-                    }
-                }
-            }
+            case SDLK_ESCAPE:
+            case SDLK_F1:
+              console.deactive();
+              break;
+          }
         }
+      }
     }
+  }
 }
 
 void
@@ -320,9 +320,9 @@
 {
   ConsoleLog << std::flush;
   if (!current_entry.message.empty())
-    {
-      ConsoleLog << std::endl;
-    }
+  {
+    ConsoleLog << std::endl;
+  }
 }
 
 std::vector<std::string>
@@ -336,20 +336,20 @@
   //push your table/array here
   sq_pushnull(v);  //null iterator
   while(SQ_SUCCEEDED(sq_next(v,-2)))
+  {
+    // here -1 is the value and -2 is the key
+    const SQChar *s;
+    if (SQ_SUCCEEDED(sq_getstring(v,-2, &s)))
     {
-      // here -1 is the value and -2 is the key
-      const SQChar *s;
-      if (SQ_SUCCEEDED(sq_getstring(v,-2, &s)))
-        {
-          roottable.push_back(static_cast<const char*>(s)); // FIXME: likely not going to work on 64bit
-        }
-      else
-        {
-          ConsoleLog << "Unknown key type for element" << std::endl;
-        }
+      roottable.push_back(static_cast<const char*>(s)); // FIXME: likely not going to work on 64bit
+    }
+    else
+    {
+      ConsoleLog << "Unknown key type for element" << std::endl;
+    }
                               
-      sq_pop(v,2); //pops key and val before the nex iteration
-    }
+    sq_pop(v,2); //pops key and val before the nex iteration
+  }
                           
   sq_pop(v, 1);
   
@@ -374,21 +374,21 @@
 static std::string find_longest_prefix(const std::vector<std::string>& lst)
 {
   if (lst.empty())
+  {
+    return "";
+  }
+  else
+  {
+    std::string prefix = lst.front();
+
+    for(std::vector<std::string>::const_iterator i = lst.begin() + 1; 
+        i != lst.end(); ++i)
     {
-      return "";
+      prefix = longest_prefix(prefix, *i);
     }
-  else
-    {
-      std::string prefix = lst.front();
 
-      for(std::vector<std::string>::const_iterator i = lst.begin() + 1; 
-          i != lst.end(); ++i)
-        {
-          prefix = longest_prefix(prefix, *i);
-        }
-
-      return prefix;
-    }
+    return prefix;
+  }
 }
 
 void
@@ -400,94 +400,94 @@
   for(std::vector<std::string>::const_iterator i = roottable.begin();
       i != roottable.end();
       ++i)
+  {
+    if (has_prefix(*i, command_line))
     {
-      if (has_prefix(*i, command_line))
-        {
-          completions.push_back(*i);
-        }
+      completions.push_back(*i);
     }
+  }
 
   if (completions.empty())
-    {
-      // console << "No completions" << std::endl;
-    }
+  {
+    // console << "No completions" << std::endl;
+  }
   else if (completions.size() == 1)
+  {
+    command_line = completions.front();
+    cursor_pos = command_line.size();
+  }
+  else 
+  {
+    ConsoleLog << "> " << command_line << std::endl;
+    for(std::vector<std::string>::iterator i = completions.begin(); i != completions.end(); ++i)
     {
-      command_line = completions.front();
-      cursor_pos = command_line.size();
+      ConsoleLog << *i << " ";
     }
-  else 
-    {
-      ConsoleLog << "> " << command_line << std::endl;
-      for(std::vector<std::string>::iterator i = completions.begin(); i != completions.end(); ++i)
-        {
-          ConsoleLog << *i << " ";
-        }
-      ConsoleLog << std::endl;
+    ConsoleLog << std::endl;
 
-      command_line = find_longest_prefix(completions);
-      cursor_pos = command_line.size();
-    }
+    command_line = find_longest_prefix(completions);
+    cursor_pos = command_line.size();
+  }
 }
 
 void
 ConsoleImpl::eval_command_line()
 {
   if (!command_line.empty() && (history.empty() || history.back() != command_line))
-    {
-      history.push_back(command_line);
-      history_position = history.size();
-    }
+  {
+    history.push_back(command_line);
+    history_position = history.size();
+  }
                       
   ConsoleLog << "> " << command_line << std::endl;
 
   if (command_line == "quit" || command_line == "exit")
-    {
-      console.deactive();
-    }
+  {
+    console.deactive();
+  }
   else if (command_line == "help")
-    {
-      ConsoleLog << "This is a script console, can enter stuff in here that will then be evaluated.\n"
-              << "Type 'quit' to exit the console." << std::endl;
-    }
+  {
+    ConsoleLog << "This is a script console, can enter stuff in here that will then be evaluated.\n"
+               << "Type 'quit' to exit the console." << std::endl;
+  }
   else if (command_line == "reset")
-    {
-      GameSession::current()->set_sector(Pathname("levels/newformat2.wst"));
-    }
+  {
+    GameSession::current()->set_sector(Pathname("levels/newformat2.wst"));
+  }
   else if (command_line == "show")
-    {
-      HSQUIRRELVM v = ScriptManager::current()->get_vm();
+  {
+    HSQUIRRELVM v = ScriptManager::current()->get_vm();
 
-      int size = sq_getsize(v, -1);
-      ConsoleLog << size << " elements on the root table" << std::endl;
+    int size = sq_getsize(v, -1);
+    ConsoleLog << size << " elements on the root table" << std::endl;
 
-      sq_pushroottable(v);
+    sq_pushroottable(v);
 
-      //push your table/array here
-      sq_pushnull(v);  //null iterator
-      while(SQ_SUCCEEDED(sq_next(v,-2)))
-        {
-          //here -1 is the value and -2 is the key
-          const SQChar *s;
-          if (SQ_SUCCEEDED(sq_getstring(v,-2, &s)))
-            {
-              ConsoleLog << s << " -> " << Scripting::squirrel2string(v, -1) << std::endl;
-            }
-          else
-            {
-              ConsoleLog << "Unknown key type for element" << std::endl;
-            }
+    //push your table/array here
+    sq_pushnull(v);  //null iterator
+    while(SQ_SUCCEEDED(sq_next(v,-2)))
+    {
+      //here -1 is the value and -2 is the key
+      const SQChar *s;
+      if (SQ_SUCCEEDED(sq_getstring(v,-2, &s)))
+      {
+        ConsoleLog << s << " -> " << Scripting::squirrel2string(v, -1) << std::endl;
+      }
+      else
+      {
+        ConsoleLog << "Unknown key type for element" << std::endl;
+      }
                               
-          sq_pop(v,2); //pops key and val before the nex iteration
-        }
+      sq_pop(v,2); //pops key and val before the nex iteration
+    }
                           
-      sq_pop(v, 1);
-    }
+    sq_pop(v, 1);
+  }
   else
-    {
-      execute(command_line);
-      maybe_newline();
-    }
+  {
+    execute(command_line);
+    maybe_newline();
+  }
   command_line = "";
   cursor_pos = 0;
 }
@@ -505,25 +505,25 @@
   int oldtop = sq_gettop(vm); 
 
   try 
+  {
+    if(SQ_SUCCEEDED(sq_compilebuffer(vm, str.c_str(), i, _SC("interactive console"), SQTrue)))
     {
-      if(SQ_SUCCEEDED(sq_compilebuffer(vm, str.c_str(), i, _SC("interactive console"), SQTrue)))
-        {
-          sq_pushroottable(vm);
-          if(SQ_SUCCEEDED(sq_call(vm, 1, 1/*retval*/, true))) 
-            {
-              // FIXME: This does only work when somebody is doing a 'return', i.e. almost never
-              if (sq_gettype(vm, -1) != OT_NULL)
-                ConsoleLog << Scripting::squirrel2string(vm, -1) << std::endl;
-              // else
-              //   console << "(null)" << std::endl;
-            }
-        }
-    } 
+      sq_pushroottable(vm);
+      if(SQ_SUCCEEDED(sq_call(vm, 1, 1/*retval*/, true))) 
+      {
+        // FIXME: This does only work when somebody is doing a 'return', i.e. almost never
+        if (sq_gettype(vm, -1) != OT_NULL)
+          ConsoleLog << Scripting::squirrel2string(vm, -1) << std::endl;
+        // else
+        //   console << "(null)" << std::endl;
+      }
+    }
+  } 
   catch(std::exception& e) 
-    {
-      std::cerr << "Couldn't execute command '" << str_ << "': "
-                << e.what() << "\n";
-    }
+  {
+    std::cerr << "Couldn't execute command '" << str_ << "': "
+              << e.what() << "\n";
+  }
 
   // Reset to old stack position
   sq_settop(vm, oldtop);
@@ -531,8 +531,8 @@
 
 //-------------------------------------------------------------------------------
 
-Console::Console()
-  : impl(new ConsoleImpl(*this))
+Console::Console() :
+  impl(new ConsoleImpl(*this))
 {
 }
 

Modified: trunk/windstille/src/app/controller_def.hpp
===================================================================
--- trunk/windstille/src/app/controller_def.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/app/controller_def.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,46 +22,46 @@
 #include "input/controller_description.hpp"
 
 enum InputEventName
-  { 
-    MOUSE_MOTION_X, 
-    MOUSE_MOTION_Y, 
+{ 
+  MOUSE_MOTION_X, 
+  MOUSE_MOTION_Y, 
 
-    X_AXIS,
-    Y_AXIS,
+  X_AXIS,
+  Y_AXIS,
 
-    X2_AXIS,
-    Y2_AXIS, 
+  X2_AXIS,
+  Y2_AXIS, 
 
-    LEFT_STICK_BUTTON,    
-    RIGHT_STICK_BUTTON,
+  LEFT_STICK_BUTTON,    
+  RIGHT_STICK_BUTTON,
 
-    PRIMARY_BUTTON,
-    SECONDARY_BUTTON,
-    TERTIARY_BUTTON,
-    QUATERNARY_BUTTON,
+  PRIMARY_BUTTON,
+  SECONDARY_BUTTON,
+  TERTIARY_BUTTON,
+  QUATERNARY_BUTTON,
 
-    LEFT_SHOULDER_BUTTON,
-    RIGHT_SHOULDER_BUTTON,
+  LEFT_SHOULDER_BUTTON,
+  RIGHT_SHOULDER_BUTTON,
 
-    LEFT_TRIGGER_AXIS,
-    RIGHT_TRIGGER_AXIS,
+  LEFT_TRIGGER_AXIS,
+  RIGHT_TRIGGER_AXIS,
 
-    SELECT_BUTTON,
-    START_BUTTON,
-    DEBUG_BUTTON,
+  SELECT_BUTTON,
+  START_BUTTON,
+  DEBUG_BUTTON,
     
-    // Keys for menu navigation, they come with hardcoded defaults for
-    // the keyboard, a joystick might emmit them as well
-    ESCAPE_BUTTON,
-    ENTER_BUTTON,
+  // Keys for menu navigation, they come with hardcoded defaults for
+  // the keyboard, a joystick might emmit them as well
+  ESCAPE_BUTTON,
+  ENTER_BUTTON,
 
-    MENU_UP_BUTTON,  
-    MENU_DOWN_BUTTON,
-    MENU_LEFT_BUTTON,
-    MENU_RIGHT_BUTTON,
+  MENU_UP_BUTTON,  
+  MENU_DOWN_BUTTON,
+  MENU_LEFT_BUTTON,
+  MENU_RIGHT_BUTTON,
 
-    LAST_EVENT
-  };
+  LAST_EVENT
+};
 
 // Map the physical buttons to logical names
 #define JUMP_BUTTON   PRIMARY_BUTTON

Modified: trunk/windstille/src/app/menu_manager.cpp
===================================================================
--- trunk/windstille/src/app/menu_manager.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/app/menu_manager.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -145,10 +145,10 @@
 
   menu.add_button("Resume",  boost::bind(&MenuManager::menu_continue));
   if (Sector::current())
-    {
-      menu.add_button("Debug", boost::bind(&MenuManager::display_debug_menu));
-      //menu.add_button("Select Scenario", boost::bind(&MenuManager::display_scenario_menu));
-    }
+  {
+    menu.add_button("Debug", boost::bind(&MenuManager::display_debug_menu));
+    //menu.add_button("Select Scenario", boost::bind(&MenuManager::display_scenario_menu));
+  }
   menu.add_button("Options", boost::bind(&MenuManager::display_option_menu));
   menu.add_button("Credits", boost::bind(&MenuManager::display_credits));
   menu.add_button("Help", boost::bind(&MenuManager::display_help));
@@ -177,9 +177,9 @@
   models.push_back(Pathname("models/vehicles/train/train.wsprite")); 
 
   for(std::vector<Pathname>::const_iterator i = models.begin(); i != models.end(); ++i)
-    {
-      menu.add_button(i->get_raw_path(), boost::bind(&MenuManager::menu_show_model, *i));
-    }
+  {
+    menu.add_button(i->get_raw_path(), boost::bind(&MenuManager::menu_show_model, *i));
+  }
   
   menu.show();
 }
@@ -216,9 +216,9 @@
   scenarios.push_back(Pathname("sectors/virtualreality/virtualreality.wst"));
   
   for(std::vector<Pathname>::const_iterator i = scenarios.begin(); i != scenarios.end(); ++i)
-    {
-      menu.add_button(i->get_raw_path(), boost::bind(&MenuManager::menu_start_scenario, *i));
-    }
+  {
+    menu.add_button(i->get_raw_path(), boost::bind(&MenuManager::menu_start_scenario, *i));
+  }
 
   menu.show();
 }
@@ -301,7 +301,7 @@
                  "distribute binaries, see the file COPYING for details.\n"
                  "\n"
                  "# EOF #\n"
-                 );
+    );
   text->set_active(true);
   
   group->pack(text.release());
@@ -463,18 +463,18 @@
 MenuManager::menu_ambient_light(int i, int component)
 {
   if (Sector::current())
-    {
-      Color amb = Sector::current()->get_ambient_light();
+  {
+    Color amb = Sector::current()->get_ambient_light();
 
-      if (component == 0)
-        amb.r = static_cast<float>(i) / 100.0f;
-      else if (component == 1)
-        amb.g = static_cast<float>(i) / 100.0f;
-      else if (component == 2)
-        amb.b = static_cast<float>(i) / 100.0f;
+    if (component == 0)
+      amb.r = static_cast<float>(i) / 100.0f;
+    else if (component == 1)
+      amb.g = static_cast<float>(i) / 100.0f;
+    else if (component == 2)
+      amb.b = static_cast<float>(i) / 100.0f;
 
-      Sector::current()->set_ambient_light(amb);
-    }
+    Sector::current()->set_ambient_light(amb);
+  }
 }
 
 void
@@ -510,21 +510,21 @@
 {
 #ifdef HAVE_CWIID
   if (wiimote && !wiimote->is_connected())
-    {
-      // FIXME: This never appears on screen due to timeout
-      ConsoleLog << "Trying to connect Wiimote: Press buttons 1 and 2 to connect" << std::endl;
+  {
+    // FIXME: This never appears on screen due to timeout
+    ConsoleLog << "Trying to connect Wiimote: Press buttons 1 and 2 to connect" << std::endl;
 
-      wiimote->connect();
+    wiimote->connect();
 
-      if (wiimote->is_connected())
-        ConsoleLog << "Wiimote connected" << std::endl;
-      else
-        ConsoleLog << "Wiimote connection failed" << std::endl;
-    }
+    if (wiimote->is_connected())
+      ConsoleLog << "Wiimote connected" << std::endl;
+    else
+      ConsoleLog << "Wiimote connection failed" << std::endl;
+  }
   else
-    {
-      ConsoleLog << "Wiimote already is connected" << std::endl;
-    }
+  {
+    ConsoleLog << "Wiimote already is connected" << std::endl;
+  }
 #endif
 }
 

Modified: trunk/windstille/src/armature/armature.cpp
===================================================================
--- trunk/windstille/src/armature/armature.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/armature/armature.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -26,10 +26,10 @@
 #include "display/color.hpp"
 #include "armature/pose.hpp"
 
-Armature::Armature(FileReader& reader)
-  : name(),
-    bones(),
-    root_bone(0)
+Armature::Armature(FileReader& reader) :
+  name(),
+  bones(),
+  root_bone(0)
 {
   parse(reader);
 }
@@ -45,66 +45,66 @@
 Armature::parse(FileReader& reader)
 {
   if (reader.get_name() != "armature")
-    {
-      throw std::runtime_error("Not an armature file: " + reader.get_name());
-    }
+  {
+    throw std::runtime_error("Not an armature file: " + reader.get_name());
+  }
   else
-    {
-      reader.get("name", name);
+  {
+    reader.get("name", name);
       
-      FileReader bones_section;
-      reader.get("bones", bones_section);
+    FileReader bones_section;
+    reader.get("bones", bones_section);
 
-      std::vector<FileReader> bone_sections = bones_section.get_sections();
-      for(std::vector<FileReader>::iterator i = bone_sections.begin(); i != bone_sections.end(); ++i)
+    std::vector<FileReader> bone_sections = bones_section.get_sections();
+    for(std::vector<FileReader>::iterator i = bone_sections.begin(); i != bone_sections.end(); ++i)
+    {
+      if (i->get_name() == "bone")
+      {
+        std::auto_ptr<Bone> bone(new Bone());
+        if (!(i->get("name",     bone->name) &&
+              i->get("children", bone->children_names) &&
+              i->get("parent",   bone->parent_name) &&
+              i->get("length",   bone->length) &&
+              i->get("quat",     bone->quat) &&
+              i->get("head",     bone->offset)))
         {
-          if (i->get_name() == "bone")
-            {
-              std::auto_ptr<Bone> bone(new Bone());
-              if (!(i->get("name",     bone->name) &&
-                    i->get("children", bone->children_names) &&
-                    i->get("parent",   bone->parent_name) &&
-                    i->get("length",   bone->length) &&
-                    i->get("quat",     bone->quat) &&
-                    i->get("head",     bone->offset)))
-                {
-                  std::cout << "Error: some Bone attribute missing" << std::endl;
-                }
-              else
-                {
-                  bone->render_matrix = bone->quat.to_matrix();
-                  bones.push_back(bone.release());
-                }
-            }
-          else
-            {
-              std::cout << "Armature: unknown tag: " << i->get_name() << std::endl;
-            }
+          std::cout << "Error: some Bone attribute missing" << std::endl;
         }
+        else
+        {
+          bone->render_matrix = bone->quat.to_matrix();
+          bones.push_back(bone.release());
+        }
+      }
+      else
+      {
+        std::cout << "Armature: unknown tag: " << i->get_name() << std::endl;
+      }
     }
+  }
   
   // insert code here to connet parent bones
   for(Bones::iterator i = bones.begin(); i != bones.end(); ++i)
+  {
+    Bone& bone = **i;
+    for(std::vector<std::string>::iterator j = bone.children_names.begin(); j != bone.children_names.end(); ++j)
     {
-      Bone& bone = **i;
-      for(std::vector<std::string>::iterator j = bone.children_names.begin(); j != bone.children_names.end(); ++j)
-        {
-          Bone* child = get_bone(*j);
-          if (child)
-            bone.children.push_back(child);
-        }
+      Bone* child = get_bone(*j);
+      if (child)
+        bone.children.push_back(child);
+    }
 
-      if (bone.parent_name.empty())
-        {
-          root_bone = &bone;
-        }
-      else
-        {
-          Bone* parent = get_bone(bone.parent_name);
-          if (parent)
-            bone.parent = parent;
-        }
+    if (bone.parent_name.empty())
+    {
+      root_bone = &bone;
     }
+    else
+    {
+      Bone* parent = get_bone(bone.parent_name);
+      if (parent)
+        bone.parent = parent;
+    }
+  }
 
   if (!root_bone)
     std::cout << "Root Bone Missing!" << std::endl;
@@ -114,10 +114,10 @@
 Armature::get_bone(const std::string& name_)
 {
   for(Bones::iterator i = bones.begin(); i != bones.end(); ++i)
-    {
-      if ((*i)->name == name_)
-        return *i;
-    }
+  {
+    if ((*i)->name == name_)
+      return *i;
+  }
   std::cout << "Error: Bone: '" << name_ << "' not found" << std::endl;
   return 0;
 }
@@ -171,34 +171,34 @@
 Armature::apply(const Pose& pose)
 {
   if (pose.get_name() != name)
+  {
+    std::cout << "Can't apply pose '" << pose.get_name() << "' to armature '" << name << "'" << std::endl;
+  }
+  else
+  {                                           
+    for(std::vector<PoseBone>::const_iterator pbone = pose.bones.begin(); pbone != pose.bones.end(); ++pbone)
     {
-      std::cout << "Can't apply pose '" << pose.get_name() << "' to armature '" << name << "'" << std::endl;
+      Bone* bone = get_bone(pbone->name);
+      if (!bone)
+      {
+        std::cout << "Error: Couldn't find bone: " << pbone->name << std::endl;
+      }
+      else
+      {
+        bone->render_matrix = bone->quat.to_matrix().multiply(pbone->quat.to_matrix());
+      }
     }
-  else
-    {                                           
-      for(std::vector<PoseBone>::const_iterator pbone = pose.bones.begin(); pbone != pose.bones.end(); ++pbone)
-        {
-          Bone* bone = get_bone(pbone->name);
-          if (!bone)
-            {
-              std::cout << "Error: Couldn't find bone: " << pbone->name << std::endl;
-            }
-          else
-            {
-              bone->render_matrix = bone->quat.to_matrix().multiply(pbone->quat.to_matrix());
-            }
-        }
-    }
+  }
 }
 
 void
 Armature::reset()
 {
   for(Bones::iterator i = bones.begin(); i != bones.end(); ++i)
-    {
-      Bone* bone = *i;
-      bone->render_matrix = bone->quat.to_matrix();
-    }
+  {
+    Bone* bone = *i;
+    bone->render_matrix = bone->quat.to_matrix();
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/armature/bone.cpp
===================================================================
--- trunk/windstille/src/armature/bone.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/armature/bone.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -18,18 +18,18 @@
 
 #include "armature/bone.hpp"
 
-Bone::Bone()
-  : name(),
-    children_names(),
-    parent_name(),
-    children(),
-    parent(0),
-    length(),
-    quat(),
-    offset(),
-    render_matrix(),
-    render_head(),
-    render_tail()
+Bone::Bone() :
+  name(),
+  children_names(),
+  parent_name(),
+  children(),
+  parent(0),
+  length(),
+  quat(),
+  offset(),
+  render_matrix(),
+  render_head(),
+  render_tail()
 {
 }
 

Modified: trunk/windstille/src/armature/ipo_curve.cpp
===================================================================
--- trunk/windstille/src/armature/ipo_curve.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/armature/ipo_curve.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -18,8 +18,8 @@
 
 #include "armature/ipo_curve.hpp"
 
-IpoCurve::IpoCurve()
-  : points()
+IpoCurve::IpoCurve() :
+  points()
 {
 }
 
@@ -48,11 +48,11 @@
 IpoCurve::add_point(const BezierPoint& /*p*/)
 {
   /*
-  assert(points.empty() ||
-         points.back().point.x < p.x &&
-         p.handle_left.x < p.x &&
-         p.x < p.handle_right.x);
-  points.push_back(p);
+    assert(points.empty() ||
+    points.back().point.x < p.x &&
+    p.handle_left.x < p.x &&
+    p.x < p.handle_right.x);
+    points.push_back(p);
   */
 }
 

Modified: trunk/windstille/src/armature/mesh.cpp
===================================================================
--- trunk/windstille/src/armature/mesh.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/armature/mesh.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -26,17 +26,17 @@
 #include "display/texture_manager.hpp"
 #include "util/util.hpp"
 
-Mesh::Mesh(FileReader& reader, const std::string& path)
-  : name(),
-    vertices(),
-    normals(),
-    texcoords(),
-    triangles(),
-    groups(),
-    vertices_(),
-    texture(),
-    blend_sfactor(GL_ONE),
-    blend_dfactor(GL_ZERO)
+Mesh::Mesh(FileReader& reader, const std::string& path) :
+  name(),
+  vertices(),
+  normals(),
+  texcoords(),
+  triangles(),
+  groups(),
+  vertices_(),
+  texture(),
+  blend_sfactor(GL_ONE),
+  blend_dfactor(GL_ZERO)
 {
   if (reader.get_name() != "mesh")
     throw std::runtime_error("Not a 'mesh' type, its '" + reader.get_name() + "'");
@@ -52,31 +52,31 @@
 
   FileReader groups_reader;
   if (reader.get("groups", groups_reader))
+  {
+    std::vector<FileReader> sections = groups_reader.get_sections();
+    for(std::vector<FileReader>::iterator i = sections.begin(); i != sections.end(); ++i)
     {
-      std::vector<FileReader> sections = groups_reader.get_sections();
-      for(std::vector<FileReader>::iterator i = sections.begin(); i != sections.end(); ++i)
+      if ((*i).get_name() == "group")
+      {
+        VertexGroup group;
+        if ((*i).get("bone",     group.bone_name) &&
+            (*i).get("weight",   group.weight) && 
+            (*i).get("vertices", group.vertices))
         {
-          if ((*i).get_name() == "group")
-            {
-              VertexGroup group;
-              if ((*i).get("bone",     group.bone_name) &&
-                  (*i).get("weight",   group.weight) && 
-                  (*i).get("vertices", group.vertices))
-                {
-                  if (group.weight != 0.0f) // ignore useless bones
-                    groups.push_back(group);
-                }
-              else
-                {
-                std::cout << "Mesh::VertexGroup: Element missing" << std::endl;
-                }
-            }
-          else
-            {
-              std::cout << "Unknown tag: " << (*i).get_name() << std::endl;
-            }
+          if (group.weight != 0.0f) // ignore useless bones
+            groups.push_back(group);
         }
+        else
+        {
+          std::cout << "Mesh::VertexGroup: Element missing" << std::endl;
+        }
+      }
+      else
+      {
+        std::cout << "Unknown tag: " << (*i).get_name() << std::endl;
+      }
     }
+  }
 
   // Check that all vectors have the same right modulo
   assert(vertices.size()  % 3 == 0);
@@ -86,83 +86,83 @@
   // Convert the data to something we can use together with Armatures
   // and Bones
   for(std::vector<float>::size_type i = 0; i < vertices.size()/3; ++i)
-    {
-      Vertex vertex;
+  {
+    Vertex vertex;
 
-      vertex.pos.x = vertices[3*i+0];
-      vertex.pos.y = vertices[3*i+1];
-      vertex.pos.z = vertices[3*i+2];
+    vertex.pos.x = vertices[3*i+0];
+    vertex.pos.y = vertices[3*i+1];
+    vertex.pos.z = vertices[3*i+2];
 
-      vertex.normal.x = normals[3*i+0];
-      vertex.normal.y = normals[3*i+1];
-      vertex.normal.z = normals[3*i+2];
+    vertex.normal.x = normals[3*i+0];
+    vertex.normal.y = normals[3*i+1];
+    vertex.normal.z = normals[3*i+2];
 
-      vertex.texcoord.x = texcoords[2*i+0];
-      vertex.texcoord.y = texcoords[2*i+1];
+    vertex.texcoord.x = texcoords[2*i+0];
+    vertex.texcoord.y = texcoords[2*i+1];
 
-      vertices_.push_back(vertex);
-    }
+    vertices_.push_back(vertex);
+  }
   
   // Add bone and weight to the individual vertices
   for(Groups::iterator i = groups.begin(); i != groups.end(); ++i)
+  {
+    VertexGroup& group = *i;
+    for(std::vector<int>::iterator j = group.vertices.begin(); j != group.vertices.end(); ++j)
     {
-      VertexGroup& group = *i;
-      for(std::vector<int>::iterator j = group.vertices.begin(); j != group.vertices.end(); ++j)
-        {
-          vertices_[*j].bone_names.push_back(group.bone_name);
-          vertices_[*j].weights.push_back(group.weight);
-        }
+      vertices_[*j].bone_names.push_back(group.bone_name);
+      vertices_[*j].weights.push_back(group.weight);
     }
+  }
   
   // Normalize Weight to 1.0f
   for(Vertices::iterator i = vertices_.begin(); i != vertices_.end(); ++i)
-    {
-      if (i->weights.empty())
-        std::cout << "Vertex doesn't have weight: " << i - vertices_.begin() << std::endl;
+  {
+    if (i->weights.empty())
+      std::cout << "Vertex doesn't have weight: " << i - vertices_.begin() << std::endl;
 
-      float total_weight = 0.0f;
-      for(std::vector<float>::iterator w = i->weights.begin(); w != i->weights.end(); ++w)
-        total_weight += *w;
+    float total_weight = 0.0f;
+    for(std::vector<float>::iterator w = i->weights.begin(); w != i->weights.end(); ++w)
+      total_weight += *w;
      
-      for(std::vector<float>::iterator w = i->weights.begin(); w != i->weights.end(); ++w)
-        *w /= total_weight;
-    }
+    for(std::vector<float>::iterator w = i->weights.begin(); w != i->weights.end(); ++w)
+      *w /= total_weight;
+  }
 
 #if 0 
   // FIXME: Broken by design
   FileReader influences_reader;
   if (reader.get("influences", influences_reader))
+  {
+    std::vector<FileReader> sections = influences_reader.get_sections();
+    for(std::vector<FileReader>::iterator i = sections.begin(); i != sections.end(); ++i)
     {
-      std::vector<FileReader> sections = influences_reader.get_sections();
-      for(std::vector<FileReader>::iterator i = sections.begin(); i != sections.end(); ++i)
+      if ((*i).get_name() == "vertex")
+      {
+        FileReader influences_sub_reader;
+
+        (*i).get("index", index);
+        if ((*i).get("influences", influences_sub_reader))
         {
-          if ((*i).get_name() == "vertex")
+          std::vector<FileReader> sub_sections = influences_sub_reader.get_sections();
+          for(std::vector<FileReader>::iterator j = sub_sections.begin(); j != sub_sections.end(); ++j)
+          {
+            if ((*j).get_name() == "influences")
             {
-              FileReader influences_sub_reader;
-
-              (*i).get("index", index);
-              if ((*i).get("influences", influences_sub_reader))
-                {
-                  std::vector<FileReader> sub_sections = influences_sub_reader.get_sections();
-                  for(std::vector<FileReader>::iterator j = sub_sections.begin(); j != sub_sections.end(); ++j)
-                    {
-                      if ((*j).get_name() == "influences")
-                        {
-                          float weight;
-                          std::string bone_name;
+              float weight;
+              std::string bone_name;
                       
-                          (*j).get("weight", weight);
-                          (*j).get("bone",   bone_name);                         
-                        }
-                    }
-                }
+              (*j).get("weight", weight);
+              (*j).get("bone",   bone_name);                         
             }
-          else
-            {
-              std::cout << "Unknown tag: " << (*i).get_name() << std::endl;
-            }
+          }
         }
+      }
+      else
+      {
+        std::cout << "Unknown tag: " << (*i).get_name() << std::endl;
+      }
     }
+  }
 #endif
 
   texture_filename = path + basename(texture_filename);
@@ -191,14 +191,14 @@
   OpenGLState state;
 
   if (blend_sfactor != GL_ONE || blend_dfactor != GL_ZERO)
-    {
-      state.enable(GL_BLEND);
-      state.set_blend_func(blend_sfactor, blend_dfactor);
-    }
+  {
+    state.enable(GL_BLEND);
+    state.set_blend_func(blend_sfactor, blend_dfactor);
+  }
   else
-    {
-      state.enable(GL_DEPTH_TEST);
-    }
+  {
+    state.enable(GL_DEPTH_TEST);
+  }
 
   state.bind_texture(texture);
 
@@ -212,11 +212,11 @@
   assert_gl("gl init before sprite");
 
   for(Vertices::size_type i = 0; i < vertices_.size(); ++i)
-    { // evil messing around with vertices, need more order
-      vertices[3*i + 0] = vertices_[i].render_pos.x;
-      vertices[3*i + 1] = vertices_[i].render_pos.y;
-      vertices[3*i + 2] = vertices_[i].render_pos.z;
-    }
+  { // evil messing around with vertices, need more order
+    vertices[3*i + 0] = vertices_[i].render_pos.x;
+    vertices[3*i + 1] = vertices_[i].render_pos.y;
+    vertices[3*i + 2] = vertices_[i].render_pos.z;
+  }
 
   glVertexPointer(3, GL_FLOAT, 0, &*vertices.begin());
 
@@ -229,48 +229,48 @@
 Mesh::apply(Armature* armature)
 {
   for(Vertices::iterator i = vertices_.begin(); i != vertices_.end(); ++i)
+  {
+    if (i->bone_names.empty())
     {
-      if (i->bone_names.empty())
-        {
-          // This shouldn't be reached for full mehes
-          i->render_pos = i->pos;
-        }
-      else
-        {
-          if (i->bones.empty())
-            {
-              for(unsigned int j = 0; j < i->bone_names.size(); ++j)
-                i->bones.push_back(armature->get_bone(i->bone_names[j]));
-            }
+      // This shouldn't be reached for full mehes
+      i->render_pos = i->pos;
+    }
+    else
+    {
+      if (i->bones.empty())
+      {
+        for(unsigned int j = 0; j < i->bone_names.size(); ++j)
+          i->bones.push_back(armature->get_bone(i->bone_names[j]));
+      }
 
-          i->render_pos = Vector3(0.0f, 0.0f, 0.0f);
-          for(unsigned int j = 0; j < i->bone_names.size(); ++j)
-            {
-              Bone* bone   = i->bones[j];
-              float weight = i->weights[j];
+      i->render_pos = Vector3(0.0f, 0.0f, 0.0f);
+      for(unsigned int j = 0; j < i->bone_names.size(); ++j)
+      {
+        Bone* bone   = i->bones[j];
+        float weight = i->weights[j];
 
-              //std::cout << "apply: " << i->bone_names[j] << " " << bone << " " << weight << std::endl;
+        //std::cout << "apply: " << i->bone_names[j] << " " << bone << " " << weight << std::endl;
 
-              if (bone)
-                { // FIXME: Need to calculate the offset from the bone and rotate that, not the pos
-                  i->render_pos += (bone->render_matrix.multiply(i->pos)) * weight;
-                }
-              else
-                {
-                  std::cout << "Couldn't find bone: " << i->bone_names[j] << std::endl;
-                }
-            }
+        if (bone)
+        { // FIXME: Need to calculate the offset from the bone and rotate that, not the pos
+          i->render_pos += (bone->render_matrix.multiply(i->pos)) * weight;
         }
+        else
+        {
+          std::cout << "Couldn't find bone: " << i->bone_names[j] << std::endl;
+        }
+      }
     }
+  }
 }
 
 void
 Mesh::reset()
 {
   for(Vertices::iterator i = vertices_.begin(); i != vertices_.end(); ++i)
-    {
-      i->render_pos = i->pos;
-    }
+  {
+    i->render_pos = i->pos;
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/armature/model.cpp
===================================================================
--- trunk/windstille/src/armature/model.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/armature/model.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,9 +22,9 @@
 #include "armature/mesh.hpp"
 #include "armature/model.hpp"
 
-Model::Model(FileReader& reader, const std::string& path)
-  : name(),
-    meshes()
+Model::Model(FileReader& reader, const std::string& path) :
+  name(),
+  meshes()
 {
   if (reader.get_name() != "windstille-model")
     throw std::runtime_error("Not a 'windstille-model' file, its '" + reader.get_name() + "'");
@@ -33,17 +33,17 @@
 
   std::vector<FileReader> sections = reader.get_sections();
   for(std::vector<FileReader>::iterator i = sections.begin(); i != sections.end(); ++i)
+  {
+    if (i->get_name() == "mesh")
     {
-      if (i->get_name() == "mesh")
-        {
-          Mesh* mesh = new Mesh(*i, path);
-          meshes.push_back(mesh);
-        }
-      else
-        {
-          std::cout << "Ignoring unhandled tag: " << i->get_name() << std::endl;
-        }
+      Mesh* mesh = new Mesh(*i, path);
+      meshes.push_back(mesh);
     }
+    else
+    {
+      std::cout << "Ignoring unhandled tag: " << i->get_name() << std::endl;
+    }
+  }
 
   reset();
 }
@@ -58,27 +58,27 @@
 Model::draw()
 {
   for(Meshes::iterator i = meshes.begin(); i != meshes.end(); ++i)
-    {
-      (*i)->draw();
-    }
+  {
+    (*i)->draw();
+  }
 }
 
 void
 Model::reset()
 {
   for(Meshes::iterator i = meshes.begin(); i != meshes.end(); ++i)
-    {
-      (*i)->reset();
-    }  
+  {
+    (*i)->reset();
+  }  
 }
 
 void
 Model::apply(Armature* armature)
 {
   for(Meshes::iterator i = meshes.begin(); i != meshes.end(); ++i)
-    {
-      (*i)->apply(armature);
-    }    
+  {
+    (*i)->apply(armature);
+  }    
 }
 
 /* EOF */

Modified: trunk/windstille/src/armature/pose.cpp
===================================================================
--- trunk/windstille/src/armature/pose.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/armature/pose.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,42 +22,42 @@
 
 #include "util/file_reader.hpp"
 
-Pose::Pose(FileReader& reader)
-  : name(),
-    bones()
+Pose::Pose(FileReader& reader) :
+  name(),
+  bones()
 {
   if (reader.get_name() != "pose")
+  {
+    throw std::runtime_error("not a pose file");
+  }
+  else
+  {
+    reader.get("name",  name);
+
+    FileReader bones_reader;
+    if (!reader.get("bones", bones_reader))
     {
-      throw std::runtime_error("not a pose file");
+      std::cout << "Bones section missing" << std::endl;
     }
-  else
+    else
     {
-      reader.get("name",  name);
-
-      FileReader bones_reader;
-      if (!reader.get("bones", bones_reader))
+      std::vector<FileReader> sections = bones_reader.get_sections();
+      for(std::vector<FileReader>::iterator i = sections.begin(); i != sections.end(); ++i)
+      {
+        if (i->get_name() == "bone")
         {
-          std::cout << "Bones section missing" << std::endl;
+          PoseBone bone;
+          i->get("name", bone.name);
+          i->get("quat", bone.quat);
+          bones.push_back(bone);
         }
-      else
+        else
         {
-          std::vector<FileReader> sections = bones_reader.get_sections();
-          for(std::vector<FileReader>::iterator i = sections.begin(); i != sections.end(); ++i)
-            {
-              if (i->get_name() == "bone")
-                {
-                  PoseBone bone;
-                  i->get("name", bone.name);
-                  i->get("quat", bone.quat);
-                  bones.push_back(bone);
-                }
-              else
-                {
-                  std::cout << "Unhandled tag: " << i->get_name() << std::endl;
-                }
-            }
+          std::cout << "Unhandled tag: " << i->get_name() << std::endl;
         }
+      }
     }
+  }
 
   //std::cout << "Pose: " << name << " " << bones.size() << std::endl;
 }

Modified: trunk/windstille/src/collision/collision_data.cpp
===================================================================
--- trunk/windstille/src/collision/collision_data.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/collision/collision_data.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,14 +22,14 @@
 CollisionData::merge(const CollisionData &r)
 {
   if (state==COLLISION)
-    {
-      if (( r.state==COLLISION && r.col_time<col_time ) || r.state==STUCK )
-	*this=r;
-    }
+  {
+    if (( r.state==COLLISION && r.col_time<col_time ) || r.state==STUCK )
+      *this=r;
+  }
   else if (state == NONE)
-    {
-      *this=r;
-    }
+  {
+    *this=r;
+  }
 
   return *this;
 }

Modified: trunk/windstille/src/collision/collision_engine.cpp
===================================================================
--- trunk/windstille/src/collision/collision_engine.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/collision/collision_engine.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -37,7 +37,7 @@
 CollisionEngine::~CollisionEngine()
 {
   for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-      delete *i;
+    delete *i;
   objects.clear();
 }
 
@@ -45,51 +45,51 @@
 CollisionEngine::draw(DrawingContext& dc)
 {
   for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-    {
-      (*i)->draw(dc);
-    }
+  {
+    (*i)->draw(dc);
+  }
 }
 
 void
 CollisionEngine::collision(const CollisionData &result)
 {
   if (result.object2->get_is_domains() & result.object1->get_check_domains())
-    {
-      result.object1->sig_collision()(result);
-    }
+  {
+    result.object1->sig_collision()(result);
+  }
   else
-    {
-      std::cout << (result.object2->get_is_domains() & result.object1->get_check_domains()) << std::endl;
-    }
+  {
+    std::cout << (result.object2->get_is_domains() & result.object1->get_check_domains()) << std::endl;
+  }
   
   unsigned int res1 = result.object1->get_is_domains() & result.object2->get_check_domains();
 
   if (res1)
-    {
-      result.object2->sig_collision()(result.invert());
-    }
+  {
+    result.object2->sig_collision()(result.invert());
+  }
   else
-    {
-      std::cout << "obj1: " << result.object1->get_is_domains() << std::endl;
-      std::cout << "obj2: " << result.object2->get_check_domains() << std::endl;
-    }
+  {
+    std::cout << "obj1: " << result.object1->get_is_domains() << std::endl;
+    std::cout << "obj2: " << result.object2->get_check_domains() << std::endl;
+  }
 }
 
 void
 CollisionEngine::unstuck(CollisionObject& a, CollisionObject& b, float delta)
 {
   if (a.get_type() == CollisionObject::RECTANGLE && b.get_type() == CollisionObject::RECTANGLE)
-    {
-      unstuck_rect_rect (a, b, delta);
-    }
+  {
+    unstuck_rect_rect (a, b, delta);
+  }
   else
-    {
-      if (a.get_type() == CollisionObject::RECTANGLE)
-	unstuck_tilemap (b, a, delta);
-      else
-	unstuck_tilemap (a, b, delta);
+  {
+    if (a.get_type() == CollisionObject::RECTANGLE)
+      unstuck_tilemap (b, a, delta);
+    else
+      unstuck_tilemap (a, b, delta);
 
-    }
+  }
 }
 
 Vector2f unstuck_direction(const Rectf &a, const Rectf &b, float delta, float unstuck_velocity)
@@ -111,21 +111,21 @@
   Vector2f dir;
 
   if (left < right && left < top && left < bottom)
-    {
-      dir = Vector2f(std::min(left/2 + grace, add), 0);
-    }
+  {
+    dir = Vector2f(std::min(left/2 + grace, add), 0);
+  }
   else if (right < left && right < top && right < bottom)
-    {
-      dir = Vector2f(-std::min(right/2 + grace, add), 0);
-    }
+  {
+    dir = Vector2f(-std::min(right/2 + grace, add), 0);
+  }
   else if (top < left && top < right && top < bottom)
-    {
-      dir = Vector2f( 0, std::min(top/2 + grace, add));
-    }
+  {
+    dir = Vector2f( 0, std::min(top/2 + grace, add));
+  }
   else // (bottom < left && bottom < right && bottom < top)
-    {
-      dir = Vector2f( 0, -std::min(bottom/2 + grace, add));
-    }
+  {
+    dir = Vector2f( 0, -std::min(bottom/2 + grace, add));
+  }
   return dir;
 }
 
@@ -141,12 +141,12 @@
 {
   int i = static_cast<int>(f);
   if(fabsf(f-static_cast<float>(i)) > 0.5f)
-    {
-      if(i>0)
-	i++;
-      else
-	i--;
-    }
+  {
+    if(i>0)
+      i++;
+    else
+      i--;
+  }
   return i;
 }
 
@@ -155,10 +155,10 @@
   int x,y;
   for (x=l; x<=l+w; x++)
     for (y=t; y<=t+h; y++)
-      {
-	if (tilemap->is_ground(static_cast<float>(x * TILE_SIZE), static_cast<float>(y * TILE_SIZE)))
-	  return false;
-      }
+    {
+      if (tilemap->is_ground(static_cast<float>(x * TILE_SIZE), static_cast<float>(y * TILE_SIZE)))
+        return false;
+    }
   return true;
 }
 
@@ -178,22 +178,22 @@
   // find first set of free rectangle
   // simply iterate the rectangles around current position
   for(int d=1; d<20; d++) // not more than 20 steps
+  {
+    for(int i=-d; i<=d; i++)
     {
-      for(int i=-d; i<=d; i++)
-	{
-	  if (is_rect_free(tilemap, i + rx, -d + ry, rw, rh))
-	    rects.push_back( Rect(i + rx, -d + ry, rw, rh));
-	  if (is_rect_free(tilemap, i + rx, d + ry, rw, rh))
-	    rects.push_back( Rect(i + rx, d + ry, rw, rh));
+      if (is_rect_free(tilemap, i + rx, -d + ry, rw, rh))
+        rects.push_back( Rect(i + rx, -d + ry, rw, rh));
+      if (is_rect_free(tilemap, i + rx, d + ry, rw, rh))
+        rects.push_back( Rect(i + rx, d + ry, rw, rh));
 
-	  if (is_rect_free(tilemap, -d + rx, i + ry, rw, rh))
-	    rects.push_back( Rect(-d + rx, i + ry, rw, rh));
-	  if (is_rect_free(tilemap,  d + rx, i + ry, rw, rh))
-	    rects.push_back( Rect(d  + rx, i + ry, rw, rh));
-	}
-      if (rects.size())
-	break;
+      if (is_rect_free(tilemap, -d + rx, i + ry, rw, rh))
+        rects.push_back( Rect(-d + rx, i + ry, rw, rh));
+      if (is_rect_free(tilemap,  d + rx, i + ry, rw, rh))
+        rects.push_back( Rect(d  + rx, i + ry, rw, rh));
     }
+    if (rects.size())
+      break;
+  }
   assert(rects.size());
 
   // find nearest rectangle in this set
@@ -201,16 +201,16 @@
   float dx,dy,d;
   Rectf nr;
   for (std::vector<Rectf>::iterator i = rects.begin(); i != rects.end(); ++i)
+  {
+    dx = i->left - r.left / static_cast<float>(TILE_SIZE);
+    dy = i->top  - r.top  / static_cast<float>(TILE_SIZE);
+    d = sqrtf( dx * dx + dy * dy );
+    if (d < distance)
     {
-      dx = i->left - r.left / static_cast<float>(TILE_SIZE);
-      dy = i->top  - r.top  / static_cast<float>(TILE_SIZE);
-      d = sqrtf( dx * dx + dy * dy );
-      if (d < distance)
-	{
-	  distance=d;
-	  nr=*i;
-	}
+      distance=d;
+      nr=*i;
     }
+  }
 
   nr.right += nr.left; 
   nr.bottom += nr.top; 
@@ -239,18 +239,18 @@
   // align to grid, if coming from right or bottom
 
   if(target.top < rb.top)
-    {
-      float v = static_cast<float>(c_roundup(target.bottom / static_cast<float>(TILE_SIZE)))
-        * static_cast<float>(TILE_SIZE) - target.bottom;
-      target.top    += v;
-      target.bottom += v;
-    }
+  {
+    float v = static_cast<float>(c_roundup(target.bottom / static_cast<float>(TILE_SIZE)))
+      * static_cast<float>(TILE_SIZE) - target.bottom;
+    target.top    += v;
+    target.bottom += v;
+  }
   if(target.left < rb.left)
-    {
-      float v = static_cast<float>(c_roundup(target.right / static_cast<float>(TILE_SIZE))) * static_cast<float>(TILE_SIZE) - target.right;
-      target.left  += v;
-      target.right += v;
-    }
+  {
+    float v = static_cast<float>(c_roundup(target.right / static_cast<float>(TILE_SIZE))) * static_cast<float>(TILE_SIZE) - target.right;
+    target.left  += v;
+    target.right += v;
+  }
 
   b.pos = Vector2f(target.left-b.primitive.left, target.top-b.primitive.top);
 }
@@ -293,91 +293,91 @@
   int max_tries=200;
 
   do
+  {
+    min_time=frame;
+      
+    for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
     {
-      min_time=frame;
-      
+      for(Objects::iterator j = i + 1; j != objects.end(); ++j)
+      {
+        if (i != j && (((*i)->get_is_domains() & (*j)->get_check_domains()) ||
+                       ((*j)->get_is_domains() & (*i)->get_check_domains())))
+        {
+          CollisionData r = collide(**i, **j, frame);
+          if(r.state!=CollisionData::NONE)
+          {
+            if (min_time > r.col_time && r.col_time>=0)
+            {
+              r.object1 = *i;
+              r.object2 = *j;
+              col_data = r;
+              min_time = r.col_time;
+              if (min_time > 0.0005f)
+                min_time -= 0.0005f;
+            }
+          }
+        }
+      }
+    }
+
+    // move till first collision (or till end, when no collision occured)
+    if(min_time>0)
+    {
       for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-	{
-	  for(Objects::iterator j = i + 1; j != objects.end(); ++j)
-	    {
-	      if (i != j && (((*i)->get_is_domains() & (*j)->get_check_domains()) ||
-                             ((*j)->get_is_domains() & (*i)->get_check_domains())))
-		{
-		  CollisionData r = collide(**i, **j, frame);
-		  if(r.state!=CollisionData::NONE)
-		    {
-		      if (min_time > r.col_time && r.col_time>=0)
-			{
-			  r.object1 = *i;
-			  r.object2 = *j;
-			  col_data = r;
-			  min_time = r.col_time;
-			  if (min_time > 0.0005f)
-			    min_time -= 0.0005f;
-			}
-		    }
-		}
-	    }
-	}
+      {
+        update(**i,min_time);
+      }
+    }
+    // report collision
+    if (min_time < frame)
+    {
+      collision (col_data);
+    }
 
-      // move till first collision (or till end, when no collision occured)
-      if(min_time>0)
-	{
-	  for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-	    {
-	      update(**i,min_time);
-	    }
-	}
-      // report collision
-      if (min_time < frame)
-	{
-	  collision (col_data);
-	}
+    frame-=min_time;
+    min_time=0;
 
-      frame-=min_time;
-      min_time=0;
+    // check tries
+    --max_tries;
+    if (max_tries == 0)
+      std::cerr<<"Too much tries in collision detection"<<std::endl;
 
-      // check tries
-      --max_tries;
-      if (max_tries == 0)
-	std::cerr<<"Too much tries in collision detection"<<std::endl;
+  }while (min_time < frame  && max_tries>0);
 
-    }while (min_time < frame  && max_tries>0);
-
   //return; // uncomment, if you want no unstucking
 
   // check penetration and resolve
   bool penetration = true;
   int maxtries=15;
   while(penetration)
+  {
+    penetration=false;
+    // FIXME: support this by some spatial container
+    for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
     {
-      penetration=false;
-      // FIXME: support this by some spatial container
-      for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-	{
-	  if(!(*i)->unstuck())
-	    continue;
-	  
-          for(Objects::iterator j = i+1; j != objects.end(); ++j)
-	    {
-	      if(!(*j)->unstuck())
-		continue;
-	      
-	      if (i != j && ((*i)->unstuck_movable() || ((*j)->unstuck_movable())))
-		{
-		  CollisionData r = collide(**i, **j, 0);
-		  if(r.state!=CollisionData::NONE)
-		    {
-		      penetration=true;
-		      unstuck(**i, **j, delta/3.0f);
-		    }
-		}
-	    }
-	}
-      maxtries--;
-      if(maxtries==0)
-	break;
+      if(!(*i)->unstuck())
+        continue;
+          
+      for(Objects::iterator j = i+1; j != objects.end(); ++j)
+      {
+        if(!(*j)->unstuck())
+          continue;
+              
+        if (i != j && ((*i)->unstuck_movable() || ((*j)->unstuck_movable())))
+        {
+          CollisionData r = collide(**i, **j, 0);
+          if(r.state!=CollisionData::NONE)
+          {
+            penetration=true;
+            unstuck(**i, **j, delta/3.0f);
+          }
+        }
+      }
     }
+    maxtries--;
+    if(maxtries==0)
+      break;
+  }
 }
 
 void
@@ -411,51 +411,51 @@
                          float delta)
 {
   SweepResult result0 = simple_sweep_1d(b1.left, b1.get_width(),  b1_v.x,
-					b2.left, b2.get_width(),  b2_v.x);
+                                        b2.left, b2.get_width(),  b2_v.x);
   SweepResult result1 = simple_sweep_1d(b1.top,  b1.get_height(), b1_v.y,
-					b2.top,  b2.get_height(), b2_v.y);
+                                        b2.top,  b2.get_height(), b2_v.y);
 
   CollisionData result;
   result.delta = delta;
 
   if(result0.collision(delta) && result1.collision(delta))
+  {
+    if(result0.always() && result1.always())
+      result.state = CollisionData::STUCK;
+    else
     {
-      if(result0.always() && result1.always())
-	result.state = CollisionData::STUCK;
+      if(result0.begin(delta)<result1.begin(delta))
+      {
+        // x direction prior
+        if(b1.left < b2.left)
+        {
+          result.state=CollisionData::COLLISION;
+          result.direction=Vector2f(-1, 0);
+        }
+        else
+        {
+          result.state=CollisionData::COLLISION;
+          result.direction=Vector2f(1, 0);
+        }
+        result.col_time=result0.t0;
+      }
       else
-	{
-	  if(result0.begin(delta)<result1.begin(delta))
-	    {
-	      // x direction prior
-	      if(b1.left < b2.left)
-		{
-		  result.state=CollisionData::COLLISION;
-		  result.direction=Vector2f(-1, 0);
-		}
-	      else
-		{
-		  result.state=CollisionData::COLLISION;
-		  result.direction=Vector2f(1, 0);
-		}
-	      result.col_time=result0.t0;
-	    }
-	  else
-	    {
-	      // x direction prior
-	      if(b1.top < b2.top)
-		{
-		  result.state=CollisionData::COLLISION;
-		  result.direction=Vector2f(0, -1);
-		}
-	      else
-		{
-		  result.state=CollisionData::COLLISION;
-		  result.direction=Vector2f(0, 1);
-		}
-	      result.col_time=result1.t0;
-	    }
-	}
+      {
+        // x direction prior
+        if(b1.top < b2.top)
+        {
+          result.state=CollisionData::COLLISION;
+          result.direction=Vector2f(0, -1);
+        }
+        else
+        {
+          result.state=CollisionData::COLLISION;
+          result.direction=Vector2f(0, 1);
+        }
+        result.col_time=result1.t0;
+      }
     }
+  }
   return result;
 }
 
@@ -463,31 +463,31 @@
 CollisionEngine::collide(CollisionObject& a, CollisionObject& b, float delta)
 {
   if (a.get_type() == CollisionObject::RECTANGLE && b.get_type() == CollisionObject::RECTANGLE)
-    {
-      Rectf ra = a.primitive;
-      Rectf rb = b.primitive;
+  {
+    Rectf ra = a.primitive;
+    Rectf rb = b.primitive;
       
-      ra.left   += a.get_pos().x;
-      ra.right  += a.get_pos().x;
-      ra.top    += a.get_pos().y;
-      ra.bottom += a.get_pos().y;
+    ra.left   += a.get_pos().x;
+    ra.right  += a.get_pos().x;
+    ra.top    += a.get_pos().y;
+    ra.bottom += a.get_pos().y;
       
-      rb.left   += b.get_pos().x;
-      rb.right  += b.get_pos().x;
-      rb.top    += b.get_pos().y;
-      rb.bottom += b.get_pos().y;
+    rb.left   += b.get_pos().x;
+    rb.right  += b.get_pos().x;
+    rb.top    += b.get_pos().y;
+    rb.bottom += b.get_pos().y;
       
-      return collide(ra, rb,
-		     a.get_velocity(), b.get_velocity(),
-		     delta);
-    }
+    return collide(ra, rb,
+                   a.get_velocity(), b.get_velocity(),
+                   delta);
+  }
   else
-    {
-      if (a.get_type() == CollisionObject::RECTANGLE)
-	return collide_tilemap (b, a, delta).invert();
-      else
-	return collide_tilemap (a, b, delta);
-    }
+  {
+    if (a.get_type() == CollisionObject::RECTANGLE)
+      return collide_tilemap (b, a, delta).invert();
+    else
+      return collide_tilemap (a, b, delta);
+  }
 }
 
 int get_next_integer(float f, float direction)
@@ -495,17 +495,17 @@
   int result;
 
   if(direction < 0)
-    {
-      result = int (f);
-      if (result >= f)
-	--result;
-    }
+  {
+    result = int (f);
+    if (result >= f)
+      --result;
+  }
   else
-    {
-      result = int (f);
-      if (result <= f)
-	++result;
-    }
+  {
+    result = int (f);
+    if (result <= f)
+      ++result;
+  }
   return result;
 }
 
@@ -514,11 +514,11 @@
   int result=static_cast<int>(f);
 
   if(direction < 0)
-    {
-      result = static_cast<int>(f);
-      if (result > f)
-	--result;
-    }
+  {
+    result = static_cast<int>(f);
+    if (result > f)
+      --result;
+  }
   return result;
 }
 
@@ -538,12 +538,12 @@
 
   for (y = std::max (0, miny); y <= std::min (maxy, tilemap->get_height() - 1); ++y)
     for (x = std::max (0, minx); x <= std::min (maxx, tilemap->get_width() - 1); ++x)
+    {
+      if(tilemap->is_ground (static_cast<float>(x * TILE_SIZE), static_cast<float>(y * TILE_SIZE) ))
       {
-	if(tilemap->is_ground (static_cast<float>(x * TILE_SIZE), static_cast<float>(y * TILE_SIZE) ))
-	  {
-	    return true;
-	  }
+        return true;
       }
+    }
   return false;
 }
 
@@ -561,15 +561,15 @@
 
   for (y = std::max (0, miny); y <= std::min (maxy, tilemap->get_height() - 1); ++y)
     for (x = std::max (0, minx); x <= std::min (maxx, tilemap->get_width() - 1); ++x)
+    {
+      if(tilemap->is_ground (static_cast<float>(x * TILE_SIZE), static_cast<float>(y * TILE_SIZE) ) == is_ground)
       {
-	if(tilemap->is_ground (static_cast<float>(x * TILE_SIZE), static_cast<float>(y * TILE_SIZE) ) == is_ground)
-	  {
-	    rect_list.push_back (Rectf (static_cast<float>(x * TILE_SIZE), 
-                                        static_cast<float>(y * TILE_SIZE), 
-                                        static_cast<float>(TILE_SIZE), 
-                                        static_cast<float>(TILE_SIZE)));
-	  }
+        rect_list.push_back (Rectf (static_cast<float>(x * TILE_SIZE), 
+                                    static_cast<float>(y * TILE_SIZE), 
+                                    static_cast<float>(TILE_SIZE), 
+                                    static_cast<float>(TILE_SIZE)));
       }
+    }
   return rect_list;
 }
 
@@ -602,12 +602,12 @@
 
   // check, if stuck
   if (tilemap_collision (a.tilemap, r))
-    {
-      result.state=CollisionData::STUCK;
-      result.col_time = 0;
+  {
+    result.state=CollisionData::STUCK;
+    result.col_time = 0;
       
-      return result;
-    }
+    return result;
+  }
 
   float time=0.0f;
   
@@ -634,100 +634,100 @@
   int maxtries=20; // prevent loops
 
   while (time < delta && ct >= 0.0f && maxtries>0)
+  {
+    ct = -1.0f;
+
+    if(first_time)
     {
-      ct = -1.0f;
+      next_x = get_integer(static_cast<float>(*x) / static_cast<float>(TILE_SIZE), vel.x) * TILE_SIZE;
+      next_y = get_integer(static_cast<float>(*y) / static_cast<float>(TILE_SIZE), vel.y) * TILE_SIZE;
+      first_time = false;
+    }
+    else
+    {
+      next_x = get_next_integer ((static_cast<float>(*x) / static_cast<float>(TILE_SIZE)), vel.x) * TILE_SIZE;
+      next_y = get_next_integer ((static_cast<float>(*y) / static_cast<float>(TILE_SIZE)), vel.y) * TILE_SIZE;
 
-      if(first_time)
-	{
-	  next_x = get_integer(static_cast<float>(*x) / static_cast<float>(TILE_SIZE), vel.x) * TILE_SIZE;
-	  next_y = get_integer(static_cast<float>(*y) / static_cast<float>(TILE_SIZE), vel.y) * TILE_SIZE;
-	  first_time = false;
-	}
-      else
-	{
-	  next_x = get_next_integer ((static_cast<float>(*x) / static_cast<float>(TILE_SIZE)), vel.x) * TILE_SIZE;
-          next_y = get_next_integer ((static_cast<float>(*y) / static_cast<float>(TILE_SIZE)), vel.y) * TILE_SIZE;
+         
+      assert ( static_cast<float>(next_x) * static_cast<float>(c_sign(vel.x)) > *x * static_cast<float>(c_sign(vel.x)) || vel.x == 0.0f);
+      assert ( static_cast<float>(next_y) * static_cast<float>(c_sign(vel.y)) > *y * static_cast<float>(c_sign(vel.y)) || vel.y == 0.0f);
+    }
 
-	 
-	  assert ( static_cast<float>(next_x) * static_cast<float>(c_sign(vel.x)) > *x * static_cast<float>(c_sign(vel.x)) || vel.x == 0.0f);
-          assert ( static_cast<float>(next_y) * static_cast<float>(c_sign(vel.y)) > *y * static_cast<float>(c_sign(vel.y)) || vel.y == 0.0f);
-	}
+    if (vel.x != 0.0f)
+      tx = (static_cast<float>(next_x) - *x) / vel.x;
+    else
+      tx = 10000.0f;
 
-      if (vel.x != 0.0f)
-	tx = (static_cast<float>(next_x) - *x) / vel.x;
-      else
-	tx = 10000.0f;
+    if (vel.y != 0.0f)
+      ty = (static_cast<float>(next_y) - *y) / vel.y;
+    else
+      ty = 10000.0f;
 
-      if (vel.y != 0.0f)
-	ty = (static_cast<float>(next_y) - *y) / vel.y;
-      else
-	ty = 10000.0f;
+    if(tx<0)
+      tx=0;
+    if(ty<0)
+      ty=0;
 
-      if(tx<0)
-	tx=0;
-      if(ty<0)
-	ty=0;
-
-      if (tx < ty)
-	{
-	  if (time + tx < delta)
-	    ct = tx;
-	}
-      else
-	{
-	  if (time + ty < delta)
-	    ct = ty;
-	}
+    if (tx < ty)
+    {
+      if (time + tx < delta)
+        ct = tx;
+    }
+    else
+    {
+      if (time + ty < delta)
+        ct = ty;
+    }
       
-      if (ct >= 0.0f)
-	{
-	  // move to next position
-	  float dx, dy;
+    if (ct >= 0.0f)
+    {
+      // move to next position
+      float dx, dy;
 
-	  dx = ct * vel.x;
-	  dy = ct * vel.y;
+      dx = ct * vel.x;
+      dy = ct * vel.y;
 
-	  r.left   += dx;
-	  r.right  += dx;
-	  r.top    += dy;
-	  r.bottom += dy;
+      r.left   += dx;
+      r.right  += dx;
+      r.top    += dy;
+      r.bottom += dy;
 
-	  if(last_zero && ct==0.0f)
-	    time += 0.0005f;
-	  else
-	    time += ct;
-	  last_zero=(ct==0.0f);
+      if(last_zero && ct==0.0f)
+        time += 0.0005f;
+      else
+        time += ct;
+      last_zero=(ct==0.0f);
 
-	  // now shift one more pixel and check for collision with tilemap
-	  Rectf tmp(r);
-	  
-	  if (tx < ty)
-	    {
-	      tmp.left  += static_cast<float>(c_sign(vel.x));
-              tmp.right += static_cast<float>(c_sign(vel.x));
-	    }
-	  else
-	    {
-	      tmp.top    += static_cast<float>(c_sign(vel.y));
-	      tmp.bottom += static_cast<float>(c_sign(vel.y));
-	    }
+      // now shift one more pixel and check for collision with tilemap
+      Rectf tmp(r);
+          
+      if (tx < ty)
+      {
+        tmp.left  += static_cast<float>(c_sign(vel.x));
+        tmp.right += static_cast<float>(c_sign(vel.x));
+      }
+      else
+      {
+        tmp.top    += static_cast<float>(c_sign(vel.y));
+        tmp.bottom += static_cast<float>(c_sign(vel.y));
+      }
 
-	  // check collision with tilemap
+      // check collision with tilemap
 
-	  if (tilemap_collision (a.tilemap, tmp))
-	    {
-	      result.state=CollisionData::COLLISION;
-	      result.col_time = time;
-	      
-	      if (tx < ty)
-		result.direction = Vector2f(static_cast<float>(c_sign(vel.x)), 0.0f);
-	      else
-		result.direction = Vector2f(0, static_cast<float>(c_sign(vel.y)));
-	      return result;
-	    }
-	}
-      maxtries--;
+      if (tilemap_collision (a.tilemap, tmp))
+      {
+        result.state=CollisionData::COLLISION;
+        result.col_time = time;
+              
+        if (tx < ty)
+          result.direction = Vector2f(static_cast<float>(c_sign(vel.x)), 0.0f);
+        else
+          result.direction = Vector2f(0, static_cast<float>(c_sign(vel.y)));
+        return result;
+      }
     }
+    maxtries--;
+  }
   if(maxtries==0)
     std::cerr<<"MAXTRIES reached"<<std::endl;
 
@@ -738,12 +738,12 @@
 CollisionEngine::raycast(const Vector2f& pos, float angle)
 {
   for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
+  {
+    if ((*i)->get_type() == CollisionObject::TILEMAP)
     {
-      if ((*i)->get_type() == CollisionObject::TILEMAP)
-        {
-          return (*i)->tilemap->raycast(pos, angle);
-        }
+      return (*i)->tilemap->raycast(pos, angle);
     }
+  }
 
   return Vector2f(0, 0);
 }

Modified: trunk/windstille/src/collision/collision_object.cpp
===================================================================
--- trunk/windstille/src/collision/collision_object.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/collision/collision_object.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -27,32 +27,32 @@
  ***********************************************************************/
 
 CollisionObject::CollisionObject(GameObject* game_object_, const Rectf& rect_)
- : object_type(RECTANGLE),
-   pos(0,0),
-   velocity(0,0),
-   game_object(game_object_),
-   collision(),
-   primitive(rect_),
-   tilemap(),
-   is_unstuckable(true),
-   is_unstuck_movable(true),
-   is_domains(DOMAIN_PLAYER  | DOMAIN_ENEMY),
-   check_domains(DOMAIN_TILEMAP | DOMAIN_PLAYER | DOMAIN_ENEMY)
+  : object_type(RECTANGLE),
+    pos(0,0),
+    velocity(0,0),
+    game_object(game_object_),
+    collision(),
+    primitive(rect_),
+    tilemap(),
+    is_unstuckable(true),
+    is_unstuck_movable(true),
+    is_domains(DOMAIN_PLAYER  | DOMAIN_ENEMY),
+    check_domains(DOMAIN_TILEMAP | DOMAIN_PLAYER | DOMAIN_ENEMY)
 {
 }
 
 CollisionObject::CollisionObject(TileMap* tilemap_)
- : object_type(),
-   pos(),
-   velocity(),
-   game_object(),
-   collision(),
-   primitive(),
-   tilemap(tilemap_),
-   is_unstuckable(),
-   is_unstuck_movable(),
-   is_domains(),
-   check_domains() 
+  : object_type(),
+    pos(),
+    velocity(),
+    game_object(),
+    collision(),
+    primitive(),
+    tilemap(tilemap_),
+    is_unstuckable(),
+    is_unstuck_movable(),
+    is_domains(),
+    check_domains() 
 {
   object_type        = TILEMAP;
   is_unstuckable     = true;
@@ -82,9 +82,9 @@
   dc.draw_rect(r, Color(0.6f, 0.6f, 0.6f), 100.0f);
   
   dc.draw_line(Vector2f(r.left + r.get_width ()/2,
-                      r.top  + r.get_height ()/2),
+                        r.top  + r.get_height ()/2),
                Vector2f(r.left + r.get_width ()/2  + get_velocity ().x,
-                      r.top  + r.get_height ()/2 + get_velocity ().y),
+                        r.top  + r.get_height ()/2 + get_velocity ().y),
                Color(1.0f, 0, 1.0f), 100.0f);
 }
 

Modified: trunk/windstille/src/collision/collision_test.cpp
===================================================================
--- trunk/windstille/src/collision/collision_test.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/collision/collision_test.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -21,35 +21,35 @@
 #include <assert.h>
 
 SweepResult simple_sweep_1d(float a, float aw, float av,
-			    float b, float bw, float bv)
+                            float b, float bw, float bv)
 {
   SweepResult res;
   // Normalize the calculation so that only A moves and B stands still
   float v = av - bv;
 
   if (v > 0)
-    {
-      res.t0 = (b - (a + aw)) / v;
-      res.t1 = (b + bw - a) / v;
-      res.state = SweepResult::COL_AT;
+  {
+    res.t0 = (b - (a + aw)) / v;
+    res.t1 = (b + bw - a) / v;
+    res.state = SweepResult::COL_AT;
 
-      assert(res.t0 <= res.t1);
-    }
+    assert(res.t0 <= res.t1);
+  }
   else if (v < 0)
-    {
-      res.t0 = (b + bw - a) / v;
-      res.t1 = (b - (a + aw)) / v;
-      res.state = SweepResult::COL_AT;
+  {
+    res.t0 = (b + bw - a) / v;
+    res.t1 = (b - (a + aw)) / v;
+    res.state = SweepResult::COL_AT;
 
-      assert(res.t0 <= res.t1);
-    }
+    assert(res.t0 <= res.t1);
+  }
   else // (v == 0)
-    {
-      if ((a + aw) < b || (a > b + bw))
-        res.state = SweepResult::COL_NEVER;
-      else
-        res.state = SweepResult::COL_ALWAYS;
-    }
+  {
+    if ((a + aw) < b || (a > b + bw))
+      res.state = SweepResult::COL_NEVER;
+    else
+      res.state = SweepResult::COL_ALWAYS;
+  }
   return res;
 }
 

Modified: trunk/windstille/src/collision/collision_test.hpp
===================================================================
--- trunk/windstille/src/collision/collision_test.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/collision/collision_test.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -68,7 +68,7 @@
 }
 
 SweepResult simple_sweep_1d(float a, float aw, float av,
-			    float b, float bw, float bv);
+                            float b, float bw, float bv);
 
 #endif
 

Modified: trunk/windstille/src/collision/stair_contact.cpp
===================================================================
--- trunk/windstille/src/collision/stair_contact.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/collision/stair_contact.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -53,14 +53,14 @@
 
   // advancement must happen tile by tile  
   while ((fabs(s) > fabs(step)) && is_active())
-    {
-      advancement += step;
-      s -= step;
+  {
+    advancement += step;
+    s -= step;
 
-      // increment tile position, based on tile direction
-      // can be up/down, left/rigth
-      advance_or_not();
-    }
+    // increment tile position, based on tile direction
+    // can be up/down, left/rigth
+    advance_or_not();
+  }
 
   advancement += s;
   advance_or_not();
@@ -70,35 +70,35 @@
 StairContact::advance_or_not()
 {
   if (tile_type & TILE_LEFT)
+  {
+    if (advancement < -0.5f)
     {
-      if (advancement < -0.5f)
-        {
-          pos.x -= 1;
-          pos.y += 1;
-          advancement += 1.0f;
-        }
-      else if (advancement > 0.5f)
-        {
-          pos.x += 1;
-          pos.y -= 1;
-          advancement -= 1.0f;
-        }
+      pos.x -= 1;
+      pos.y += 1;
+      advancement += 1.0f;
     }
+    else if (advancement > 0.5f)
+    {
+      pos.x += 1;
+      pos.y -= 1;
+      advancement -= 1.0f;
+    }
+  }
   else if (tile_type & TILE_RIGHT)
+  {
+    if (advancement < -0.5f)
     {
-      if (advancement < -0.5f)
-        {
-          pos.x += 1;
-          pos.y -= 1;
-          advancement += 1.0f;
-        }
-      else if (advancement > 0.5f)
-        {
-          pos.x -= 1;
-          pos.y += 1;
-          advancement -= 1.0f;
-        }
+      pos.x += 1;
+      pos.y -= 1;
+      advancement += 1.0f;
     }
+    else if (advancement > 0.5f)
+    {
+      pos.x -= 1;
+      pos.y += 1;
+      advancement -= 1.0f;
+    }
+  }
 }
 
 Vector2f

Modified: trunk/windstille/src/display/basic_compositor_impl.cpp
===================================================================
--- trunk/windstille/src/display/basic_compositor_impl.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/basic_compositor_impl.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -28,10 +28,10 @@
 
 static const int LIGHTMAP_DIV = 4;
 
-BasicCompositorImpl::BasicCompositorImpl(const Size& window, const Size& viewport)
-  : CompositorImpl(window, viewport),
-    m_lightmap(m_window.width  / LIGHTMAP_DIV,
-               m_window.height / LIGHTMAP_DIV)
+BasicCompositorImpl::BasicCompositorImpl(const Size& window, const Size& viewport) :
+  CompositorImpl(window, viewport),
+  m_lightmap(m_window.width  / LIGHTMAP_DIV,
+             m_window.height / LIGHTMAP_DIV)
 {
 }
 

Modified: trunk/windstille/src/display/blitter.cpp
===================================================================
--- trunk/windstille/src/display/blitter.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/blitter.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -44,12 +44,12 @@
 
   // duplicate left and right borders
   for(int y = y_pos-1; y < y_pos + height+1; ++y)
-    {
-      uint32_t* p = reinterpret_cast<uint32_t*> (data + (y*pitch + 4*(x_pos-1)));
-      *p = *(p+1);
-      p = reinterpret_cast<uint32_t*> (data + (y*pitch + 4*(x_pos + width)));
-      *p = *(p-1);
-    }
+  {
+    uint32_t* p = reinterpret_cast<uint32_t*> (data + (y*pitch + 4*(x_pos-1)));
+    *p = *(p+1);
+    p = reinterpret_cast<uint32_t*> (data + (y*pitch + 4*(x_pos + width)));
+    *p = *(p-1);
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/display/compositor.cpp
===================================================================
--- trunk/windstille/src/display/compositor.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/compositor.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -23,8 +23,8 @@
 #include "display/framebuffer_compositor_impl.hpp"
 #include "display/basic_compositor_impl.hpp"
 
-Compositor::Compositor(const Size& window, const Size& viewport)
-  : impl()
+Compositor::Compositor(const Size& window, const Size& viewport) :
+  impl()
 {
   if (glewIsSupported("GL_EXT_framebuffer_object")) //(GLEW_EXT_framebuffer_object)
   {

Modified: trunk/windstille/src/display/display.cpp
===================================================================
--- trunk/windstille/src/display/display.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/display.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -165,21 +165,21 @@
   int n = 8;
   glBegin(GL_QUAD_STRIP);
   for(int i = 0; i <= n; ++i)
-    {
-      float x = sinf(static_cast<float>(i) * (math::pi/2.0f) / static_cast<float>(n)) * radius;
-      float y = cosf(static_cast<float>(i) * (math::pi/2.0f) / static_cast<float>(n)) * radius;
+  {
+    float x = sinf(static_cast<float>(i) * (math::pi/2.0f) / static_cast<float>(n)) * radius;
+    float y = cosf(static_cast<float>(i) * (math::pi/2.0f) / static_cast<float>(n)) * radius;
 
-      glVertex2f(irect.left  - x, irect.top - y);
-      glVertex2f(irect.right + x, irect.top - y);
-    }
+    glVertex2f(irect.left  - x, irect.top - y);
+    glVertex2f(irect.right + x, irect.top - y);
+  }
   for(int i = 0; i <= n; ++i)
-    {
-      float x = cosf(static_cast<float>(i) * (math::pi/2.0f) / static_cast<float>(n)) * radius;
-      float y = sinf(static_cast<float>(i) * (math::pi/2.0f) / static_cast<float>(n)) * radius;
+  {
+    float x = cosf(static_cast<float>(i) * (math::pi/2.0f) / static_cast<float>(n)) * radius;
+    float y = sinf(static_cast<float>(i) * (math::pi/2.0f) / static_cast<float>(n)) * radius;
 
-      glVertex2f(irect.left  - x, irect.bottom + y);
-      glVertex2f(irect.right + x, irect.bottom + y);
-    }
+    glVertex2f(irect.left  - x, irect.bottom + y);
+    glVertex2f(irect.right + x, irect.bottom + y);
+  }
   glEnd();
 }
 
@@ -207,35 +207,35 @@
   int n = 4;
   glBegin(GL_LINE_STRIP);
   for(int i = 0; i <= n; ++i)
-    {
-      float x = sinf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
-      float y = cosf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
+  {
+    float x = sinf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
+    float y = cosf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
 
-      glVertex2f(irect.left  - x, irect.top - y);
-    }
+    glVertex2f(irect.left  - x, irect.top - y);
+  }
   for(int i = 0; i <= n; ++i)
-    {
-      float x = cosf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
-      float y = sinf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
+  {
+    float x = cosf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
+    float y = sinf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
 
-      glVertex2f(irect.left  - x, irect.bottom + y);
-    }
+    glVertex2f(irect.left  - x, irect.bottom + y);
+  }
 
   for(int i = 0; i <= n; ++i)
-    {
-      float x = sinf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
-      float y = cosf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
+  {
+    float x = sinf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
+    float y = cosf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
 
-      glVertex2f(irect.right + x, irect.bottom + y);
-    }
+    glVertex2f(irect.right + x, irect.bottom + y);
+  }
 
   for(int i = 0; i <= n; ++i)
-    {
-      float x = cosf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
-      float y = sinf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
+  {
+    float x = cosf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
+    float y = sinf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
         
-      glVertex2f(irect.right + x, irect.top - y);
-    }
+    glVertex2f(irect.right + x, irect.top - y);
+  }
   // go back to start
   glVertex2f(irect.left, irect.top - radius);
 
@@ -271,12 +271,12 @@
   glBegin(GL_LINE_STRIP);
   glVertex2f(radius + pos.x, pos.y);
   for(int i = 1; i < segments; ++i)
-    {
-      float x = cosf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
-      float y = sinf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
+  {
+    float x = cosf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
+    float y = sinf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
       
-      glVertex2f(x + pos.x, y + pos.y);
-    }
+    glVertex2f(x + pos.x, y + pos.y);
+  }
   glVertex2f(radius + pos.x, pos.y);
   glEnd();
 }
@@ -298,12 +298,12 @@
   glVertex2f(pos.x, pos.y);
   glVertex2f(radius + pos.x, pos.y);
   for(int i = 1; i < segments; ++i)
-    {
-      float x = cosf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
-      float y = sinf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
+  {
+    float x = cosf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
+    float y = sinf(static_cast<float>(i) * (math::pi/2) / static_cast<float>(n)) * radius;
       
-      glVertex2f(x + pos.x, y + pos.y);
-    }
+    glVertex2f(x + pos.x, y + pos.y);
+  }
   glVertex2f(radius + pos.x, pos.y);
   glEnd();
 }
@@ -314,38 +314,38 @@
   assert(segments >= 0);
 
   if (fabs(end - start) >= 360.0f)
-    {
-      draw_circle(pos, radius, color, segments);
-    }
+  {
+    draw_circle(pos, radius, color, segments);
+  }
   else
-    {
-      float step  = (2.0f * math::pi) / static_cast<float>(segments);
+  {
+    float step  = (2.0f * math::pi) / static_cast<float>(segments);
 
-      if (start > end) 
-        std::swap(start, end);
+    if (start > end) 
+      std::swap(start, end);
 
-      OpenGLState state;
+    OpenGLState state;
 
-      state.enable(GL_BLEND);
-      state.set_blend_func(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-      state.color(color);
-      state.activate();
+    state.enable(GL_BLEND);
+    state.set_blend_func(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    state.color(color);
+    state.activate();
 
-      start = math::deg2rad(start);
-      end   = math::deg2rad(end);
+    start = math::deg2rad(start);
+    end   = math::deg2rad(end);
 
-      glBegin(GL_LINE_STRIP);
-      glVertex2f(pos.x, pos.y);
+    glBegin(GL_LINE_STRIP);
+    glVertex2f(pos.x, pos.y);
 
-      for(float angle = start; angle < end; angle += step)
-        glVertex2f((cosf(angle) * radius) + pos.x,
-                   (sinf(angle) * radius) + pos.y);
+    for(float angle = start; angle < end; angle += step)
+      glVertex2f((cosf(angle) * radius) + pos.x,
+                 (sinf(angle) * radius) + pos.y);
 
-      glVertex2f((cosf(end) * radius) + pos.x,
-                 (sinf(end) * radius) + pos.y);
-      glVertex2f(pos.x, pos.y);
-      glEnd();
-    }
+    glVertex2f((cosf(end) * radius) + pos.x,
+               (sinf(end) * radius) + pos.y);
+    glVertex2f(pos.x, pos.y);
+    glEnd();
+  }
 }
 
 void
@@ -354,38 +354,38 @@
   assert(segments >= 0);
 
   if (fabs(end - start) >= 360.0f)
-    {
-      fill_circle(pos, radius, color, segments);
-    }
+  {
+    fill_circle(pos, radius, color, segments);
+  }
   else
-    {
-      float step  = (2.0f * math::pi) / static_cast<float>(segments);
+  {
+    float step  = (2.0f * math::pi) / static_cast<float>(segments);
 
-      if (start > end) 
-        std::swap(start, end);
+    if (start > end) 
+      std::swap(start, end);
 
-      OpenGLState state;
+    OpenGLState state;
 
-      state.enable(GL_BLEND);
-      state.set_blend_func(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-      state.color(color);
-      state.activate();
+    state.enable(GL_BLEND);
+    state.set_blend_func(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    state.color(color);
+    state.activate();
 
-      start = math::deg2rad(start);
-      end   = math::deg2rad(end);
+    start = math::deg2rad(start);
+    end   = math::deg2rad(end);
 
-      glBegin(GL_TRIANGLE_FAN);
-      glVertex2f(pos.x, pos.y);
+    glBegin(GL_TRIANGLE_FAN);
+    glVertex2f(pos.x, pos.y);
 
-      for(float angle = start; angle < end; angle += step)
-        glVertex2f((cosf(angle) * radius) + pos.x,
-                   (sinf(angle) * radius) + pos.y);
+    for(float angle = start; angle < end; angle += step)
+      glVertex2f((cosf(angle) * radius) + pos.x,
+                 (sinf(angle) * radius) + pos.y);
 
-      glVertex2f(cosf(end) * radius + pos.x,
-                 sinf(end) * radius + pos.y);
+    glVertex2f(cosf(end) * radius + pos.x,
+               sinf(end) * radius + pos.y);
 
-      glEnd();
-    }
+    glEnd();
+  }
 }
 
 void
@@ -405,16 +405,16 @@
   float start_y = fmodf(offset.y, size.height);
 
   for(float x = start_x; x < Display::get_width(); x += size.width)
-    {
-      glVertex2f(x, 0);
-      glVertex2f(x, static_cast<float>(Display::get_height()));
-    }
+  {
+    glVertex2f(x, 0);
+    glVertex2f(x, static_cast<float>(Display::get_height()));
+  }
 
   for(float y = start_y; y < Display::get_height(); y += size.height)
-    {
-      glVertex2f(0, y);
-      glVertex2f(static_cast<float>(Display::get_width()), y);
-    }
+  {
+    glVertex2f(0, y);
+    glVertex2f(static_cast<float>(Display::get_width()), y);
+  }
 
   glEnd();  
 }
@@ -425,13 +425,13 @@
   Rect rect = rect_;
 
   if (!cliprects.empty())
-    {
-      rect.left   = std::max(rect.left, cliprects.back().left);
-      rect.top    = std::max(rect.top,  cliprects.back().top);
+  {
+    rect.left   = std::max(rect.left, cliprects.back().left);
+    rect.top    = std::max(rect.top,  cliprects.back().top);
 
-      rect.right  = std::min(rect.right,  cliprects.back().right);
-      rect.bottom = std::min(rect.bottom, cliprects.back().bottom);
-    }
+    rect.right  = std::min(rect.right,  cliprects.back().right);
+    rect.bottom = std::min(rect.bottom, cliprects.back().bottom);
+  }
 
   cliprects.push_back(rect);
 
@@ -448,16 +448,16 @@
   cliprects.pop_back();
 
   if (!cliprects.empty())
-    {
-      const Rect& rect = cliprects.back();
+  {
+    const Rect& rect = cliprects.back();
 
-      glScissor(rect.left, get_height() - rect.top - rect.get_height(),
-                rect.get_width(), rect.get_height());
-    }
+    glScissor(rect.left, get_height() - rect.top - rect.get_height(),
+              rect.get_width(), rect.get_height());
+  }
   else
-    {
-      glDisable(GL_SCISSOR_TEST);
-    }
+  {
+    glDisable(GL_SCISSOR_TEST);
+  }
 }
 
 void
@@ -479,64 +479,64 @@
   glReadPixels(0, 0, size.width, size.height, GL_RGB, GL_UNSIGNED_BYTE, pixels.get());
 
   if (0)
-    { // PPM saving
-      int pitch = size.width * 3;
+  { // PPM saving
+    int pitch = size.width * 3;
 
-      // save to ppm
-      std::ofstream out(filename.get_sys_path().c_str());
-      out << "P6\n"
-          << "# Windstille Screenshot\n"
-          << size.width << " " << size.height << "\n"
-          << "255\n";
+    // save to ppm
+    std::ofstream out(filename.get_sys_path().c_str());
+    out << "P6\n"
+        << "# Windstille Screenshot\n"
+        << size.width << " " << size.height << "\n"
+        << "255\n";
       
-      for(int y = size.height-1; y >= 0; --y)
-        out.write(reinterpret_cast<const char*>(pixels.get() + y*pitch), pitch);
+    for(int y = size.height-1; y >= 0; --y)
+      out.write(reinterpret_cast<const char*>(pixels.get() + y*pitch), pitch);
 
-      out.close();
-    }
+    out.close();
+  }
   else 
-    { // PNG saving
-      FILE* fp = fopen(filename.get_sys_path().c_str(), "w");
+  { // PNG saving
+    FILE* fp = fopen(filename.get_sys_path().c_str(), "w");
 
-      if (!fp)
-        {
-          std::cout << "Error: Couldn't save screenshot: " << strerror(errno) << std::endl;
-          return;
-        }
-      else
-        {
-          int pitch = size.width * 3;
-          png_structp png_ptr;
-          png_infop   info_ptr;
+    if (!fp)
+    {
+      std::cout << "Error: Couldn't save screenshot: " << strerror(errno) << std::endl;
+      return;
+    }
+    else
+    {
+      int pitch = size.width * 3;
+      png_structp png_ptr;
+      png_infop   info_ptr;
 
-          png_ptr  = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-          info_ptr = png_create_info_struct(png_ptr);
+      png_ptr  = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+      info_ptr = png_create_info_struct(png_ptr);
 
-          png_init_io(png_ptr, fp);
+      png_init_io(png_ptr, fp);
 
-          png_set_IHDR(png_ptr, info_ptr, 
-                       size.width, size.height, 8 /* bitdepth */,
-                       PNG_COLOR_TYPE_RGB,
-                       PNG_INTERLACE_NONE, 
-                       PNG_COMPRESSION_TYPE_BASE, 
-                       PNG_FILTER_TYPE_BASE);
+      png_set_IHDR(png_ptr, info_ptr, 
+                   size.width, size.height, 8 /* bitdepth */,
+                   PNG_COLOR_TYPE_RGB,
+                   PNG_INTERLACE_NONE, 
+                   PNG_COMPRESSION_TYPE_BASE, 
+                   PNG_FILTER_TYPE_BASE);
       
-          png_set_compression_level(png_ptr, 3);
-          png_write_info(png_ptr, info_ptr);
+      png_set_compression_level(png_ptr, 3);
+      png_write_info(png_ptr, info_ptr);
 
-          boost::scoped_array<png_bytep> row_pointers(new png_bytep[size.height]);
+      boost::scoped_array<png_bytep> row_pointers(new png_bytep[size.height]);
    
-          // generate row pointers
-          for (int k = 0; k < size.height; k++)
-            row_pointers[k] = reinterpret_cast<png_byte*>(pixels.get() + ((size.height - k - 1) * pitch));
+      // generate row pointers
+      for (int k = 0; k < size.height; k++)
+        row_pointers[k] = reinterpret_cast<png_byte*>(pixels.get() + ((size.height - k - 1) * pitch));
 
-          png_write_image(png_ptr, row_pointers.get());
+      png_write_image(png_ptr, row_pointers.get());
 
-          png_write_end(png_ptr, info_ptr);
+      png_write_end(png_ptr, info_ptr);
 
-          fclose(fp);
-        }
+      fclose(fp);
     }
+  }
 }
 
 void
@@ -554,13 +554,13 @@
   framebuffers.pop_back();
   
   if (!framebuffers.empty())
-    {
-      glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, framebuffers.back().get_handle());
-    }
+  {
+    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, framebuffers.back().get_handle());
+  }
   else
-    {
-      glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
-    }
+  {
+    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+  }
 }
 
 Framebuffer

Modified: trunk/windstille/src/display/drawing_context.cpp
===================================================================
--- trunk/windstille/src/display/drawing_context.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/drawing_context.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -47,9 +47,9 @@
   }
 };
 
-DrawingContext::DrawingContext()
-  : drawingrequests(),
-    modelview_stack()
+DrawingContext::DrawingContext() :
+  drawingrequests(),
+  modelview_stack()
 {
   modelview_stack.push_back(Matrix::identity());
 }
@@ -65,18 +65,18 @@
   std::stable_sort(drawingrequests.begin(), drawingrequests.end(), DrawablesSorter());
   
   for(Drawables::iterator i = drawingrequests.begin(); i != drawingrequests.end(); ++i)
-    {
-      (*i)->render(~0u);
-    }
+  {
+    (*i)->render(~0u);
+  }
 }
 
 void
 DrawingContext::clear()
 {
   for(Drawables::iterator i = drawingrequests.begin(); i != drawingrequests.end(); ++i)
-    {
-      delete *i;
-    }
+  {
+    delete *i;
+  }
   drawingrequests.clear();
 }
 
@@ -123,8 +123,8 @@
 DrawingContext::draw(Surface surface, float x, float y, float z, float )
 {
   draw(new SurfaceDrawable(surface,
-                                 SurfaceDrawingParameters().set_pos(Vector2f(x, y)),
-                                 z, modelview_stack.back()));
+                           SurfaceDrawingParameters().set_pos(Vector2f(x, y)),
+                           z, modelview_stack.back()));
 }
 
 void
@@ -156,12 +156,12 @@
 {
   float len2 = x*x+y*y+z*z;
   if (len2 != 1.0)
-    {
-      float len = sqrtf(len2);
-      x /= len;
-      y /= len;
-      z /= len;
-    }
+  {
+    float len = sqrtf(len2);
+    x /= len;
+    y /= len;
+    z /= len;
+  }
 
   float c = cosf(angle*3.14159265f/180.0f);
   float s = sinf(angle*3.14159265f/180.0f);

Modified: trunk/windstille/src/display/framebuffer.cpp
===================================================================
--- trunk/windstille/src/display/framebuffer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/framebuffer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -59,13 +59,13 @@
   }
 };
 
-Framebuffer::Framebuffer()
-  : impl()
+Framebuffer::Framebuffer() :
+  impl()
 {
 }
 
-Framebuffer::Framebuffer(GLenum target, int width, int height)
-  : impl(new FramebufferImpl(target, width, height))
+Framebuffer::Framebuffer(GLenum target, int width, int height) :
+  impl(new FramebufferImpl(target, width, height))
 {  
 }
 

Modified: trunk/windstille/src/display/framebuffer_compositor_impl.cpp
===================================================================
--- trunk/windstille/src/display/framebuffer_compositor_impl.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/framebuffer_compositor_impl.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -26,10 +26,10 @@
 
 static const int LIGHTMAP_DIV = 4;
 
-FramebufferCompositorImpl::FramebufferCompositorImpl(const Size& window, const Size& viewport)
-  : CompositorImpl(window, viewport),
-    m_screen  (GL_TEXTURE_2D, window.width, window.height),
-    m_lightmap(GL_TEXTURE_2D, window.width / LIGHTMAP_DIV, window.height / LIGHTMAP_DIV)
+FramebufferCompositorImpl::FramebufferCompositorImpl(const Size& window, const Size& viewport) :
+  CompositorImpl(window, viewport),
+  m_screen  (GL_TEXTURE_2D, window.width, window.height),
+  m_lightmap(GL_TEXTURE_2D, window.width / LIGHTMAP_DIV, window.height / LIGHTMAP_DIV)
 {
 }
 

Modified: trunk/windstille/src/display/graphic_context_state.cpp
===================================================================
--- trunk/windstille/src/display/graphic_context_state.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/graphic_context_state.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -40,13 +40,13 @@
   {}
 };
 
-GraphicContextState::GraphicContextState()
-  : impl(new GraphicContextStateImpl())
+GraphicContextState::GraphicContextState() :
+  impl(new GraphicContextStateImpl())
 {
 }
 
-GraphicContextState::GraphicContextState(int w, int h)
-  : impl(new GraphicContextStateImpl())
+GraphicContextState::GraphicContextState(int w, int h) :
+  impl(new GraphicContextStateImpl())
 {  
   impl->width  = w;
   impl->height = h;
@@ -68,12 +68,12 @@
   Matrix matrix = Matrix::identity();
 
   matrix = matrix.translate(static_cast<float>(impl->width)  / 2.0f, 
-                   static_cast<float>(impl->height) / 2.0f,
-                   0.0f);
+                            static_cast<float>(impl->height) / 2.0f,
+                            0.0f);
   matrix = matrix.rotate(impl->rotation, 0.0f, 0.0f, 1.0f);
   matrix = matrix.translate(static_cast<float>(-impl->width)  / 2.0f,
-               static_cast<float>(-impl->height) / 2.0f, 
-               0.0f);
+                            static_cast<float>(-impl->height) / 2.0f, 
+                            0.0f);
 
   matrix = matrix.scale(get_zoom(), get_zoom(), 1.0f);
   
@@ -107,7 +107,7 @@
 GraphicContextState::get_clip_rect()
 {
   return Rectf(Vector2f(-impl->offset.x,
-                         -impl->offset.y),
+                        -impl->offset.y),
                Sizef(static_cast<float>(get_width())  / impl->zoom,
                      static_cast<float>(get_height()) / impl->zoom));
 }
@@ -166,13 +166,13 @@
   
   //std::cout << "Screen: " << screen_relation << " Zoom: " << rect_relation << std::endl;
   if (rect_relation < screen_relation) // take width, ignore height
-    {
-      impl->zoom = static_cast<float>(get_width()) / width; 
-    }
+  {
+    impl->zoom = static_cast<float>(get_width()) / width; 
+  }
   else // take height, ignore width
-    {
-      impl->zoom = static_cast<float>(get_height()) / height;
-    }
+  {
+    impl->zoom = static_cast<float>(get_height()) / height;
+  }
 
   impl->offset.x = (static_cast<float>(get_width())  / (2.0f * impl->zoom)) - center_x;
   impl->offset.y = (static_cast<float>(get_height()) / (2.0f * impl->zoom)) - center_y;

Modified: trunk/windstille/src/display/opengl_state.cpp
===================================================================
--- trunk/windstille/src/display/opengl_state.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/opengl_state.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -91,8 +91,8 @@
 
 // The code here is just as placeholder for the moment, should be
 // replaced with something more optimized later
-OpenGLState::OpenGLState()
-  : impl(new OpenGLStateImpl())
+OpenGLState::OpenGLState() :
+  impl(new OpenGLStateImpl())
 {
   impl->state[GL_DEPTH_TEST]  = false;
   impl->state[GL_BLEND]       = false;
@@ -133,14 +133,14 @@
 {
   std::map<GLenum, bool>::const_iterator i = impl->state.find(cap);
   if (i == impl->state.end())
-    {
-      std::cout << "OpenGLState: Unknown state requested: " << cap << std::endl;
-      return false;
-    }
+  {
+    std::cout << "OpenGLState: Unknown state requested: " << cap << std::endl;
+    return false;
+  }
   else
-    {
-      return i->second;
-    }
+  {
+    return i->second;
+  }
 }
 
 void 
@@ -148,13 +148,13 @@
 {
   std::map<GLenum, bool>::iterator i = impl->state.find(cap);
   if (i == impl->state.end())
-    {
-      std::cout << "OpenGLState: Unknown state set: " << cap << std::endl;
-    }
+  {
+    std::cout << "OpenGLState: Unknown state set: " << cap << std::endl;
+  }
   else
-    {
-      i->second = value;
-    } 
+  {
+    i->second = value;
+  } 
 }
 
 void
@@ -180,14 +180,14 @@
 {
   std::map<GLenum, bool>::const_iterator i = impl->client_state.find(array);
   if (i == impl->client_state.end())
-    {
-      std::cout << "OpenGLState: Unknown client state requested: " << array << std::endl;
-      return false;
-    }
+  {
+    std::cout << "OpenGLState: Unknown client state requested: " << array << std::endl;
+    return false;
+  }
   else
-    {
-      return i->second;
-    }
+  {
+    return i->second;
+  }
 }
 
 void
@@ -195,13 +195,13 @@
 {
   std::map<GLenum, bool>::iterator i = impl->client_state.find(array);
   if (i == impl->client_state.end())
-    {
-      std::cout << "OpenGLState: Unknown client state set: " << array << std::endl;
-    }
+  {
+    std::cout << "OpenGLState: Unknown client state set: " << array << std::endl;
+  }
   else
-    {
-      i->second = value;
-    }
+  {
+    i->second = value;
+  }
 }
   
 void
@@ -236,74 +236,74 @@
 
   for(std::map<GLenum, bool>::iterator i = impl->state.begin();
       i != impl->state.end(); ++i)
+  {
+    if (global_state->get_state(i->first) != i->second)
     {
-      if (global_state->get_state(i->first) != i->second)
-        {
-          if (i->second)
-            glEnable(i->first);
-          else
-            glDisable(i->first);
+      if (i->second)
+        glEnable(i->first);
+      else
+        glDisable(i->first);
 
-          global_state->set_state(i->first, i->second);
-        }
+      global_state->set_state(i->first, i->second);
     }
+  }
 
   for(std::map<GLenum, bool>::iterator i = impl->client_state.begin();
       i != impl->client_state.end(); ++i)
+  {
+    if (global_state->get_client_state(i->first) != i->second)
     {
-      if (global_state->get_client_state(i->first) != i->second)
-        {
-          if (i->second)
-            glEnableClientState(i->first);
-          else
-            glDisableClientState(i->first);
+      if (i->second)
+        glEnableClientState(i->first);
+      else
+        glDisableClientState(i->first);
 
-          global_state->set_client_state(i->first, i->second);
-        }
+      global_state->set_client_state(i->first, i->second);
     }
+  }
 
   if (impl->blend_sfactor != global_state->impl->blend_sfactor ||
       impl->blend_dfactor != global_state->impl->blend_dfactor)
-    {
-      glBlendFunc(impl->blend_sfactor, impl->blend_dfactor);
+  {
+    glBlendFunc(impl->blend_sfactor, impl->blend_dfactor);
 
-      global_state->impl->blend_sfactor = impl->blend_sfactor;
-      global_state->impl->blend_dfactor = impl->blend_dfactor;
-    }
+    global_state->impl->blend_sfactor = impl->blend_sfactor;
+    global_state->impl->blend_dfactor = impl->blend_dfactor;
+  }
 
   for(int i = 0; i < MAX_TEXTURE_UNITS; ++i)
-    {
-      if (impl->texture[i] != global_state->impl->texture[i])
-        { 
-          // FIXME: glActiveTexture() makes the game crash on Matrox
-          // G450, without that line it works
-          glActiveTexture(GL_TEXTURE0 + i);
-          if (impl->texture[i])
-            {
-              global_state->impl->texture[i] = impl->texture[i];
+  {
+    if (impl->texture[i] != global_state->impl->texture[i])
+    { 
+      // FIXME: glActiveTexture() makes the game crash on Matrox
+      // G450, without that line it works
+      glActiveTexture(GL_TEXTURE0 + i);
+      if (impl->texture[i])
+      {
+        global_state->impl->texture[i] = impl->texture[i];
 
-              switch (impl->texture[i].get_target())
-                {                 
-                case GL_TEXTURE_2D:
-                  glBindTexture(GL_TEXTURE_2D, impl->texture[i].get_handle());
-                  glEnable(GL_TEXTURE_2D);
-                  break;
+        switch (impl->texture[i].get_target())
+        {                 
+          case GL_TEXTURE_2D:
+            glBindTexture(GL_TEXTURE_2D, impl->texture[i].get_handle());
+            glEnable(GL_TEXTURE_2D);
+            break;
                   
-                default:
-                  assert(!"Unknown texture target");
-                  break;
-                }
-            }
-          else
-            {
-              // FIXME: Hacky, should disable only the right target
-              glBindTexture(GL_TEXTURE_2D, 0);
-              glDisable(GL_TEXTURE_2D);
+          default:
+            assert(!"Unknown texture target");
+            break;
+        }
+      }
+      else
+      {
+        // FIXME: Hacky, should disable only the right target
+        glBindTexture(GL_TEXTURE_2D, 0);
+        glDisable(GL_TEXTURE_2D);
 
-              global_state->impl->texture[i] = impl->texture[i];
-            }
-        }
+        global_state->impl->texture[i] = impl->texture[i];
+      }
     }
+  }
 
 #if 0
   if (debug)
@@ -316,45 +316,45 @@
 {
   for(std::map<GLenum, bool>::iterator i = impl->client_state.begin();
       i != impl->client_state.end(); ++i)
+  {
+    if (glIsEnabled(i->first) != i->second)
     {
-      if (glIsEnabled(i->first) != i->second)
-        {
-          std::cout << "OpenGLState: client_state " << i->first << " is out of sync" << std::endl;
-        }
-    }  
+      std::cout << "OpenGLState: client_state " << i->first << " is out of sync" << std::endl;
+    }
+  }  
 
   for(std::map<GLenum, bool>::iterator i = impl->state.begin();
       i != impl->state.end(); ++i)
+  {
+    if (glIsEnabled(i->first) != i->second)
     {
-      if (glIsEnabled(i->first) != i->second)
-        {
-          std::cout << "OpenGLState: state " << i->first << " is out of sync" << std::endl;
-        }
+      std::cout << "OpenGLState: state " << i->first << " is out of sync" << std::endl;
     }
+  }
 
   GLint sfactor; glGetIntegerv(GL_BLEND_SRC, &sfactor);
   if (sfactor != int(impl->blend_sfactor))
-    {
-      std::cout << "OpenGLState: src blendfunc is out of sync" << std::endl;
-    }
+  {
+    std::cout << "OpenGLState: src blendfunc is out of sync" << std::endl;
+  }
 
   GLint dfactor; glGetIntegerv(GL_BLEND_DST, &dfactor);
   if (dfactor != int(impl->blend_dfactor))
-    {
-      std::cout << "OpenGLState: dst blendfunc is out of sync" << std::endl;
-    }
+  {
+    std::cout << "OpenGLState: dst blendfunc is out of sync" << std::endl;
+  }
 
   if (0)
+  {
+    // FIXME: Add multitexture support here
+    GLint texture_handle;
+    glActiveTexture(GL_TEXTURE0);
+    glGetIntegerv(GL_TEXTURE_2D_BINDING_EXT, &texture_handle);
+    if (impl->texture[0] && static_cast<GLuint>(texture_handle) != impl->texture[0].get_handle())
     {
-      // FIXME: Add multitexture support here
-      GLint texture_handle;
-      glActiveTexture(GL_TEXTURE0);
-      glGetIntegerv(GL_TEXTURE_2D_BINDING_EXT, &texture_handle);
-      if (impl->texture[0] && static_cast<GLuint>(texture_handle) != impl->texture[0].get_handle())
-        {
-          std::cout << "OpenGLState: texture handle is out of sync: " << impl->texture[0].get_handle() << std::endl;
-        }
+      std::cout << "OpenGLState: texture handle is out of sync: " << impl->texture[0].get_handle() << std::endl;
     }
+  }
   assert_gl("OpenGLState::verify");
 }
 

Modified: trunk/windstille/src/display/opengl_window.cpp
===================================================================
--- trunk/windstille/src/display/opengl_window.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/opengl_window.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -40,8 +40,8 @@
   {}
 };
 
-OpenGLWindow::OpenGLWindow(const Size& size, const Size& aspect, bool fullscreen, int anti_aliasing)
-  : m_impl(new OpenGLWindowImpl)
+OpenGLWindow::OpenGLWindow(const Size& size, const Size& aspect, bool fullscreen, int anti_aliasing) :
+  m_impl(new OpenGLWindowImpl)
 {
   m_impl->m_size = size;
 
@@ -143,18 +143,18 @@
   m_impl->m_window = SDL_SetVideoMode(m_impl->m_size.width, m_impl->m_size.height, 0, flags);
 
   if (!m_impl->m_window)
-    {
-      throw std::runtime_error("OpenGLWindow: Couldn't create window");
-    }
+  {
+    throw std::runtime_error("OpenGLWindow: Couldn't create window");
+  }
 }
 
 void
 OpenGLWindow::set_gamma(float r, float g, float b)
 {
   if (SDL_SetGamma(r, g, b) == -1)
-    {
-      // Couldn't set gamma
-    }
+  {
+    // Couldn't set gamma
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/display/render_buffer.cpp
===================================================================
--- trunk/windstille/src/display/render_buffer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/render_buffer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -42,8 +42,8 @@
   }
 };
 
-RenderBuffer::RenderBuffer(GLenum format, int width, int height)
-  : impl(new RenderBufferImpl(format, width, height))
+RenderBuffer::RenderBuffer(GLenum format, int width, int height) :
+  impl(new RenderBufferImpl(format, width, height))
 {
 }
 

Modified: trunk/windstille/src/display/scene_context.cpp
===================================================================
--- trunk/windstille/src/display/scene_context.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/scene_context.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -52,8 +52,8 @@
   }
 };
 
-SceneContext::SceneContext()
-  : impl(new SceneContextImpl())
+SceneContext::SceneContext() :
+  impl(new SceneContextImpl())
 {
 }
 
@@ -163,34 +163,34 @@
   
   glBegin(GL_QUADS);
   for (int i = 0; i < segments; ++i)
-    {
-      float angel = 2.0f * math::pi / static_cast<float>(segments);
+  {
+    float angel = 2.0f * math::pi / static_cast<float>(segments);
 
-      float x1 =  sinf(angel * static_cast<float>(i)) * radius;
-      float y1 = -cosf(angel * static_cast<float>(i)) * radius;
+    float x1 =  sinf(angel * static_cast<float>(i)) * radius;
+    float y1 = -cosf(angel * static_cast<float>(i)) * radius;
 
-      float x2 =  sinf(angel * static_cast<float>(i+1)) * radius;
-      float y2 = -cosf(angel * static_cast<float>(i+1)) * radius;
+    float x2 =  sinf(angel * static_cast<float>(i+1)) * radius;
+    float y2 = -cosf(angel * static_cast<float>(i+1)) * radius;
 
-      glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
-      glTexCoord2f(x1/512.0f+0.5f, y1/512.0f+0.5f);
-      glVertex3f(x1+256, y1+256, 0);
+    glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
+    glTexCoord2f(x1/512.0f+0.5f, y1/512.0f+0.5f);
+    glVertex3f(x1+256, y1+256, 0);
 
-      glTexCoord2f(x2/512.0f+0.5f, y2/512.0f+0.5f);
-      glVertex3f(x2+256, y2+256, 0);
+    glTexCoord2f(x2/512.0f+0.5f, y2/512.0f+0.5f);
+    glVertex3f(x2+256, y2+256, 0);
 
-      float x3 =  sinf(angel * static_cast<float>(i)) * minradius;
-      float y3 = -cosf(angel * static_cast<float>(i)) * minradius;
+    float x3 =  sinf(angel * static_cast<float>(i)) * minradius;
+    float y3 = -cosf(angel * static_cast<float>(i)) * minradius;
 
-      float x4 =  sinf(angel * static_cast<float>(i+1)) * minradius;
-      float y4 = -cosf(angel * static_cast<float>(i+1)) * minradius;
+    float x4 =  sinf(angel * static_cast<float>(i+1)) * minradius;
+    float y4 = -cosf(angel * static_cast<float>(i+1)) * minradius;
 
-      glColor4f(1.0f, 1.0f, 1.0f, 0.0f);
-      glTexCoord2f(x4/512.0f+0.5f, y4/512.0f+0.5f);
-      glVertex3f(x4+256, y4+256, 0);
-      glTexCoord2f(x3/512.0f+0.5f, y3/512.0f+0.5f);
-      glVertex3f(x3+256, y3+256, 0);
-    }
+    glColor4f(1.0f, 1.0f, 1.0f, 0.0f);
+    glTexCoord2f(x4/512.0f+0.5f, y4/512.0f+0.5f);
+    glVertex3f(x4+256, y4+256, 0);
+    glTexCoord2f(x3/512.0f+0.5f, y3/512.0f+0.5f);
+    glVertex3f(x3+256, y3+256, 0);
+  }
   glEnd();
 }
 

Modified: trunk/windstille/src/display/shader_object.cpp
===================================================================
--- trunk/windstille/src/display/shader_object.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/shader_object.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -32,20 +32,20 @@
   GLchar* str = static_cast<char*>(malloc(size));
   FILE* f = fopen(filename, "r");
   if (!f)
-    {
-      perror(filename);
-      exit(EXIT_FAILURE);
-    }
+  {
+    perror(filename);
+    exit(EXIT_FAILURE);
+  }
   else
+  {
+    while ((true_size += fread(str, sizeof(GLchar), 4096, f)) == 4096)
     {
-      while ((true_size += fread(str, sizeof(GLchar), 4096, f)) == 4096)
-        {
-          size += block_size;
-          str = static_cast<GLchar*>(realloc(str, size));
-        }
-      str = static_cast<GLchar*>(realloc(str, true_size+1));
-      str[true_size] = '\0';
+      size += block_size;
+      str = static_cast<GLchar*>(realloc(str, size));
     }
+    str = static_cast<GLchar*>(realloc(str, true_size+1));
+    str[true_size] = '\0';
+  }
 
   fclose(f);
   return str;
@@ -67,8 +67,8 @@
   }
 };
 
-ShaderObject::ShaderObject(GLenum type, const std::string& filename)
-  : impl(new ShaderObjectImpl(type))
+ShaderObject::ShaderObject(GLenum type, const std::string& filename) :
+  impl(new ShaderObjectImpl(type))
 {
   load(filename);
   compile();
@@ -114,17 +114,17 @@
   assert_gl("print_log2");
 
   if (infologLength > 0)
+  {
+    infoLog = static_cast<GLchar*>(malloc(infologLength));
+    if (infoLog == NULL)
     {
-      infoLog = static_cast<GLchar*>(malloc(infologLength));
-      if (infoLog == NULL)
-        {
-          printf("ERROR: Could not allocate InfoLog buffer\n");
-          exit(1);
-        }
-      glGetShaderInfoLog(impl->handle, infologLength, &charsWritten, infoLog);
-      printf("InfoLog:\n%s\n\n", infoLog);
-      free(infoLog);
+      printf("ERROR: Could not allocate InfoLog buffer\n");
+      exit(1);
     }
+    glGetShaderInfoLog(impl->handle, infologLength, &charsWritten, infoLog);
+    printf("InfoLog:\n%s\n\n", infoLog);
+    free(infoLog);
+  }
   assert_gl("print_log3");
 }
 

Modified: trunk/windstille/src/display/shader_program.cpp
===================================================================
--- trunk/windstille/src/display/shader_program.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/shader_program.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -36,8 +36,8 @@
   }
 };
 
-ShaderProgram::ShaderProgram()
-  : impl(new ShaderProgramImpl())
+ShaderProgram::ShaderProgram() :
+  impl(new ShaderProgramImpl())
 {
 }
 

Modified: trunk/windstille/src/display/software_surface.cpp
===================================================================
--- trunk/windstille/src/display/software_surface.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/software_surface.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -32,27 +32,27 @@
   SDL_Surface* surface;
 };
 
-SoftwareSurface::SoftwareSurface(const Pathname& filename)
-  : impl(new SoftwareSurfaceImpl())
+SoftwareSurface::SoftwareSurface(const Pathname& filename) :
+  impl(new SoftwareSurfaceImpl())
 {
   impl->surface = IMG_Load(filename.get_sys_path().c_str());
 
   if (!impl->surface)
-    {
-      std::ostringstream str;
-      str << "SoftwareSurface: Couldn't load: " << filename << std::endl;
-      throw std::runtime_error(str.str());
-    }
+  {
+    std::ostringstream str;
+    str << "SoftwareSurface: Couldn't load: " << filename << std::endl;
+    throw std::runtime_error(str.str());
+  }
   else
-    {
-      SDL_SetAlpha(impl->surface, 0, 0);
+  {
+    SDL_SetAlpha(impl->surface, 0, 0);
 
-      assert(!SDL_MUSTLOCK(impl->surface));
-    }
+    assert(!SDL_MUSTLOCK(impl->surface));
+  }
 }
 
-SoftwareSurface::SoftwareSurface(int width, int height, Format format)
-  : impl(new SoftwareSurfaceImpl())
+SoftwareSurface::SoftwareSurface(int width, int height, Format format) :
+  impl(new SoftwareSurfaceImpl())
 {
   assert(format == RGBA);
 
@@ -155,22 +155,22 @@
 {
   if (x >= 0 && x < impl->surface->w &&
       y >= 0 && y < impl->surface->h)
+  {
+    if (get_bits_per_pixel() == 32)
     {
-      if (get_bits_per_pixel() == 32)
-        {
-          uint8_t* pixels = static_cast<uint8_t*>(impl->surface->pixels);
+      uint8_t* pixels = static_cast<uint8_t*>(impl->surface->pixels);
           
-          return pixels[y * impl->surface->pitch + x*4 + 3] > 128;
-        }
-      else
-        {
-          return true;
-        }
+      return pixels[y * impl->surface->pitch + x*4 + 3] > 128;
     }
-  else
+    else
     {
-      return false;
+      return true;
     }
+  }
+  else
+  {
+    return false;
+  }
 }
 
 void
@@ -180,52 +180,52 @@
 
   if (get_bytes_per_pixel() != 4 &&
       get_bytes_per_pixel() != 3)
-    {
-      std::cout << "SoftwareSurface::save_png(): Unsupported pixel format" << std::endl;
-      return;
-    }
+  {
+    std::cout << "SoftwareSurface::save_png(): Unsupported pixel format" << std::endl;
+    return;
+  }
 
   FILE* fp = fopen(filename.c_str(), "w");
 
   if (!fp)
-    {
-      std::cout << "Error: Couldn't save screenshot: " << strerror(errno) << std::endl;
-      return;
-    }
+  {
+    std::cout << "Error: Couldn't save screenshot: " << strerror(errno) << std::endl;
+    return;
+  }
   else
-    {
-      int pitch   = get_pitch();
-      png_structp png_ptr;
-      png_infop   info_ptr;
-      png_byte* pixels = static_cast<png_byte*>(get_pixels());
+  {
+    int pitch   = get_pitch();
+    png_structp png_ptr;
+    png_infop   info_ptr;
+    png_byte* pixels = static_cast<png_byte*>(get_pixels());
 
-      png_ptr  = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-      info_ptr = png_create_info_struct(png_ptr);
+    png_ptr  = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+    info_ptr = png_create_info_struct(png_ptr);
 
-      png_init_io(png_ptr, fp);
+    png_init_io(png_ptr, fp);
 
-      png_set_IHDR(png_ptr, info_ptr, 
-                   get_width(), get_height(), 8 /* bitdepth */,
-                   (get_bytes_per_pixel() == 32) ? PNG_COLOR_TYPE_RGBA : PNG_COLOR_TYPE_RGB,
-                   PNG_INTERLACE_NONE, 
-                   PNG_COMPRESSION_TYPE_BASE, 
-                   PNG_FILTER_TYPE_BASE);
+    png_set_IHDR(png_ptr, info_ptr, 
+                 get_width(), get_height(), 8 /* bitdepth */,
+                 (get_bytes_per_pixel() == 32) ? PNG_COLOR_TYPE_RGBA : PNG_COLOR_TYPE_RGB,
+                 PNG_INTERLACE_NONE, 
+                 PNG_COMPRESSION_TYPE_BASE, 
+                 PNG_FILTER_TYPE_BASE);
       
-      png_set_compression_level(png_ptr, 6);
-      png_write_info(png_ptr, info_ptr);
+    png_set_compression_level(png_ptr, 6);
+    png_write_info(png_ptr, info_ptr);
 
-      boost::scoped_array<png_bytep> row_pointers(new png_bytep[get_height()]);
+    boost::scoped_array<png_bytep> row_pointers(new png_bytep[get_height()]);
    
-      // generate row pointers
-      for (int k = 0; k < get_height(); k++)
-        row_pointers[k] = reinterpret_cast<png_byte*>(pixels + ((get_height() - k - 1) * pitch));
+    // generate row pointers
+    for (int k = 0; k < get_height(); k++)
+      row_pointers[k] = reinterpret_cast<png_byte*>(pixels + ((get_height() - k - 1) * pitch));
 
-      png_write_image(png_ptr, row_pointers.get());
+    png_write_image(png_ptr, row_pointers.get());
 
-      png_write_end(png_ptr, info_ptr);
+    png_write_end(png_ptr, info_ptr);
 
-      fclose(fp);
-    }
+    fclose(fp);
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/display/surface.cpp
===================================================================
--- trunk/windstille/src/display/surface.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/surface.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -48,20 +48,20 @@
   {}
 };
 
-Surface::Surface()
-  : impl()
+Surface::Surface() :
+  impl()
 {
 }
 
-Surface::Surface(const Pathname& filename)
-  : impl()
+Surface::Surface(const Pathname& filename) :
+  impl()
 {
   // FIXME: a bit ugly, should move some of the surface_manager code over here
   *this = SurfaceManager::current()->get(filename);
 }
 
-Surface::Surface(int width, int height)
-  : impl(new SurfaceImpl())
+Surface::Surface(int width, int height) :
+  impl(new SurfaceImpl())
 {
   impl->size  = Size(width, height);
 
@@ -71,8 +71,8 @@
                         impl->size.height / static_cast<float>(impl->texture.get_height()));
 }
 
-Surface::Surface(Texture texture, const Rectf& uv, const Sizef& size)
-  : impl(new SurfaceImpl())
+Surface::Surface(Texture texture, const Rectf& uv, const Sizef& size) :
+  impl(new SurfaceImpl())
 {
   impl->texture = texture;
   impl->uv      = uv;

Modified: trunk/windstille/src/display/surface_manager.cpp
===================================================================
--- trunk/windstille/src/display/surface_manager.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/surface_manager.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -25,9 +25,9 @@
 #include "display/texture_packer.hpp"
 
 
-SurfaceManager::SurfaceManager()
-  : texture_packer(0), // (new TexturePacker(Size(2048, 2048))),
-    surfaces()
+SurfaceManager::SurfaceManager() :
+  texture_packer(0), // (new TexturePacker(Size(2048, 2048))),
+  surfaces()
 {
 }
 
@@ -35,13 +35,13 @@
 {
 #if 0 
   if (debug)
+  {
+    for(Surfaces::iterator i = surfaces.begin(); i != surfaces.end(); ++i)
     {
-      for(Surfaces::iterator i = surfaces.begin(); i != surfaces.end(); ++i)
-        {
-          //      if (i->second.use_count() > 1)
-          std::cerr << "Warning: Surface '" << i->first << "' not released.\n";
-        }
+      //      if (i->second.use_count() > 1)
+      std::cerr << "Warning: Surface '" << i->first << "' not released.\n";
     }
+  }
 #endif
 }
 
@@ -101,31 +101,31 @@
   Texture texture;
 
   try
-    {                                                                       
-      texture = create_texture(image, &maxu, &maxv);
-    }
+  {                                                                       
+    texture = create_texture(image, &maxu, &maxv);
+  }
   catch(std::exception& e)
-    {
-      std::ostringstream msg;
-      msg << "Couldn't create texture for '" << filename << "': " << e.what();
-      throw std::runtime_error(msg.str());                                      
-    }
+  {
+    std::ostringstream msg;
+    msg << "Couldn't create texture for '" << filename << "': " << e.what();
+    throw std::runtime_error(msg.str());                                      
+  }
 
   for(int y = 0; y <= image.get_height() - height + 1; y += height)
+  {
+    for(int x = 0; x <= image.get_width() - width + 1; x += width)
     {
-      for(int x = 0; x <= image.get_width() - width + 1; x += width)
-        {
-          float s_min_u = maxu * static_cast<float>(x) / static_cast<float>(image.get_width());
-          float s_min_v = maxv * static_cast<float>(x) / static_cast<float>(image.get_height());
-          float s_max_u = (maxu * (static_cast<float>(x + width)))  / static_cast<float>(image.get_width());
-          float s_max_v = (maxv * (static_cast<float>(x + height))) / static_cast<float>(image.get_height());
+      float s_min_u = maxu * static_cast<float>(x) / static_cast<float>(image.get_width());
+      float s_min_v = maxv * static_cast<float>(x) / static_cast<float>(image.get_height());
+      float s_max_u = (maxu * (static_cast<float>(x + width)))  / static_cast<float>(image.get_width());
+      float s_max_v = (maxv * (static_cast<float>(x + height))) / static_cast<float>(image.get_height());
 
-          out_surfaces.push_back(Surface(texture, 
-                                         Rectf(s_min_u, s_min_v, s_max_u, s_max_v), 
-                                         Sizef(static_cast<float>(width),
-                                               static_cast<float>(height))));
-        }
+      out_surfaces.push_back(Surface(texture, 
+                                     Rectf(s_min_u, s_min_v, s_max_u, s_max_v), 
+                                     Sizef(static_cast<float>(width),
+                                           static_cast<float>(height))));
     }
+  }
 }
 
 Texture
@@ -152,12 +152,12 @@
 SurfaceManager::cleanup()
 {
   for(Surfaces::iterator i = surfaces.begin(); i != surfaces.end(); ++i)
+  {
+    if (i->second.use_count() == 1)
     {
-      if (i->second.use_count() == 1)
-        {
-          surfaces.erase(i);
-        }
+      surfaces.erase(i);
     }
+  }
 }
 
 void

Modified: trunk/windstille/src/display/text_area.cpp
===================================================================
--- trunk/windstille/src/display/text_area.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/text_area.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -66,8 +66,8 @@
   TextAreaImpl& operator=(const TextAreaImpl&);
 };
 
-TextArea::TextArea(const Rectf& rect, bool letter_by_letter)
-  : impl(new TextAreaImpl)
+TextArea::TextArea(const Rectf& rect, bool letter_by_letter) :
+  impl(new TextAreaImpl)
 {
   impl->font = Fonts::current()->vera20.get();
   impl->rect    = rect;
@@ -101,45 +101,45 @@
   BabyXML xml(str);
 
   for(BabyXML::iterator i = xml.begin(); i != xml.end(); ++i)
+  {
+    if (i->type == BabyXML::Node::START_TAG)
     {
-      if (i->type == BabyXML::Node::START_TAG)
+      impl->commands.push_back(TextAreaCommand(TextAreaCommand::START, i->content));
+    }
+    else if (i->type == BabyXML::Node::END_TAG)
+    {
+      impl->commands.push_back(TextAreaCommand(TextAreaCommand::END, i->content));
+    }
+    else if (i->type == BabyXML::Node::TEXT)
+    {      
+      // Seperate the given str into words, words are seperated by either
+      // ' ' or '\n', space is threaded as a word of its own
+      // "Hello  World \n" => ("Hello", " ", " ", "World", " ", "\n")
+      std::string word;
+      for(std::string::const_iterator j = i->content.begin(); j != i->content.end(); ++j)
+      {
+        if (*j == ' ' || *j == '\n')
         {
-          impl->commands.push_back(TextAreaCommand(TextAreaCommand::START, i->content));
+          if (word.empty())
+          {
+            impl->commands.push_back(TextAreaCommand(TextAreaCommand::WORD, std::string(1, *j)));
+          }
+          else
+          {
+            impl->commands.push_back(TextAreaCommand(TextAreaCommand::WORD, word));
+            impl->commands.push_back(TextAreaCommand(TextAreaCommand::WORD, std::string(1, *j)));
+            word = "";
+          }
         }
-      else if (i->type == BabyXML::Node::END_TAG)
+        else
         {
-          impl->commands.push_back(TextAreaCommand(TextAreaCommand::END, i->content));
+          word += *j;
         }
-      else if (i->type == BabyXML::Node::TEXT)
-        {      
-          // Seperate the given str into words, words are seperated by either
-          // ' ' or '\n', space is threaded as a word of its own
-          // "Hello  World \n" => ("Hello", " ", " ", "World", " ", "\n")
-          std::string word;
-          for(std::string::const_iterator j = i->content.begin(); j != i->content.end(); ++j)
-            {
-              if (*j == ' ' || *j == '\n')
-                {
-                  if (word.empty())
-                    {
-                      impl->commands.push_back(TextAreaCommand(TextAreaCommand::WORD, std::string(1, *j)));
-                    }
-                  else
-                    {
-                      impl->commands.push_back(TextAreaCommand(TextAreaCommand::WORD, word));
-                      impl->commands.push_back(TextAreaCommand(TextAreaCommand::WORD, std::string(1, *j)));
-                      word = "";
-                    }
-                }
-              else
-                {
-                  word += *j;
-                }
-            }
-          if (!word.empty())
-            impl->commands.push_back(TextAreaCommand(TextAreaCommand::WORD, word));
-        }
+      }
+      if (!word.empty())
+        impl->commands.push_back(TextAreaCommand(TextAreaCommand::WORD, word));
     }
+  }
 }
 
 void
@@ -165,14 +165,14 @@
 {
   assert(impl->font);
   if (impl->max_scroll_offset > 0.0f)
-    {
-      float height = impl->max_scroll_offset + impl->rect.get_height();
+  {
+    float height = impl->max_scroll_offset + impl->rect.get_height();
 
-      Display::fill_rounded_rect(Rectf(Vector2f(impl->rect.right + 4,
-                                                impl->rect.top + impl->scroll_offset*impl->rect.get_height()/height), 
-                                       Sizef(8, impl->rect.get_height()*impl->rect.get_height()/height)),
-                                 4.0f, Color(1.0f, 1.0f, 1.0f, 0.25f));
-    }
+    Display::fill_rounded_rect(Rectf(Vector2f(impl->rect.right + 4,
+                                              impl->rect.top + impl->scroll_offset*impl->rect.get_height()/height), 
+                                     Sizef(8, impl->rect.get_height()*impl->rect.get_height()/height)),
+                               4.0f, Color(1.0f, 1.0f, 1.0f, 0.25f));
+  }
   OpenGLState state;
   
   state.bind_texture(impl->font->get_texture());
@@ -201,201 +201,201 @@
 
   std::vector<TextAreaCommand>::const_iterator i = impl->commands.begin();
   for(; i != impl->commands.end(); ++i)
+  {
+    if (break_writing)
+      break;
+        
+    switch (i->type)
     {
-      if (break_writing)
+      case TextAreaCommand::START:
+        if (i->content == "b")
+        {
+          top_color    = Color(1.0f, 0.0f, 0.0f);
+          bottom_color = Color(0.8f, 0.0f, 0.0f);
+        }
+        else if (i->content == "i")
+        {
+          top_color    = Color(0.65f, 0.7f, 1.0f);
+          bottom_color = Color(0.65f, 0.7f, 1.0f);
+        }
+        else if (i->content == "small")
+        {
+          is_small = true;
+        }
+        else if (i->content == "large")
+        {
+          is_large = true;
+        }
+        else if (i->content == "sleep")
+        {
+          eat_time -= 1.0f;
+        }
+        else if (i->content == "sin")
+        {
+          sinus = true;
+        }
         break;
-        
-      switch (i->type)
+
+      case TextAreaCommand::END:
+        if (i->content == "b" || i->content == "i")
         {
-          case TextAreaCommand::START:
-            if (i->content == "b")
-              {
-                top_color    = Color(1.0f, 0.0f, 0.0f);
-                bottom_color = Color(0.8f, 0.0f, 0.0f);
-              }
-            else if (i->content == "i")
-              {
-                top_color    = Color(0.65f, 0.7f, 1.0f);
-                bottom_color = Color(0.65f, 0.7f, 1.0f);
-              }
-            else if (i->content == "small")
-              {
-                is_small = true;
-              }
-            else if (i->content == "large")
-              {
-                is_large = true;
-              }
-            else if (i->content == "sleep")
-              {
-                eat_time -= 1.0f;
-              }
-            else if (i->content == "sin")
-              {
-                sinus = true;
-              }
-            break;
-
-          case TextAreaCommand::END:
-            if (i->content == "b" || i->content == "i")
-              {
-                top_color    = Color(1.0f, 1.0f, 1.0f);
-                bottom_color = Color(1.0f, 1.0f, 1.0f);
-              }
-            else if (i->content == "small")
-              {
-                is_small = false;
-              }
-            else if (i->content == "large")
-              {
-                is_large = false;
-              }
-            else if (i->content == "sin")
-              {
-                sinus = false;
-              }
-            break;
+          top_color    = Color(1.0f, 1.0f, 1.0f);
+          bottom_color = Color(1.0f, 1.0f, 1.0f);
+        }
+        else if (i->content == "small")
+        {
+          is_small = false;
+        }
+        else if (i->content == "large")
+        {
+          is_large = false;
+        }
+        else if (i->content == "sin")
+        {
+          sinus = false;
+        }
+        break;
           
-          case TextAreaCommand::WORD:
-            retry:
-            int word_width;
+      case TextAreaCommand::WORD:
+        retry:
+        int word_width;
 
-            if (is_small)
-              word_width = static_cast<int>(static_cast<float>(impl->font->get_width(i->content)) * 0.6f);
-            else if (is_large)
-              word_width = static_cast<int>(static_cast<float>(impl->font->get_width(i->content)) * 2.0f);
-            else
-              word_width = impl->font->get_width(i->content);
+        if (is_small)
+          word_width = static_cast<int>(static_cast<float>(impl->font->get_width(i->content)) * 0.6f);
+        else if (is_large)
+          word_width = static_cast<int>(static_cast<float>(impl->font->get_width(i->content)) * 2.0f);
+        else
+          word_width = impl->font->get_width(i->content);
           
-            if (i->content == "\n")
+        if (i->content == "\n")
+        {
+          x_pos = 0;
+          y_pos += impl->font->get_height() + impl->v_space;
+        }
+        else if (x_pos + word_width > impl->rect.get_width() && word_width <= impl->rect.get_width())
+        {
+          x_pos = 0;
+          y_pos += impl->font->get_height() + impl->v_space;
+          goto retry;
+        }
+        else
+        {
+          if (x_pos == 0 && i->content == " ")
+          {
+            // ignore space at the beginning of a line
+          }
+          else
+          {
+            for(std::string::const_iterator j = i->content.begin(); j != i->content.end(); ++j)
+            {
+              if (impl->letter_by_letter && eat_time <= 0)
               {
-                x_pos = 0;
-                y_pos += impl->font->get_height() + impl->v_space;
+                break_writing = true;
+                break;
               }
-            else if (x_pos + word_width > impl->rect.get_width() && word_width <= impl->rect.get_width())
-              {
-                x_pos = 0;
-                y_pos += impl->font->get_height() + impl->v_space;
-                goto retry;
-              }
-            else
-              {
-                if (x_pos == 0 && i->content == " ")
-                  {
-                    // ignore space at the beginning of a line
-                  }
-                else
-                  {
-                    for(std::string::const_iterator j = i->content.begin(); j != i->content.end(); ++j)
-                      {
-                        if (impl->letter_by_letter && eat_time <= 0)
-                          {
-                            break_writing = true;
-                            break;
-                          }
                         
-                        float x = static_cast<float>(x_pos);
-                        float y = static_cast<float>(y_pos);
+              float x = static_cast<float>(x_pos);
+              float y = static_cast<float>(y_pos);
                         
-                        if (sinus) // FIXME: this could actually work per vertex
-                          y += sinf(impl->passed_time * 10.0f + static_cast<float>(x_pos) / 15.0f) * 5.0f;
+              if (sinus) // FIXME: this could actually work per vertex
+                y += sinf(impl->passed_time * 10.0f + static_cast<float>(x_pos) / 15.0f) * 5.0f;
 
-                        if (*j == '.' || *j == '\n')
-                          eat_time -= 0.50f;
-                        else
-                          eat_time -= 0.05f;
+              if (*j == '.' || *j == '\n')
+                eat_time -= 0.50f;
+              else
+                eat_time -= 0.05f;
 
-                        const TTFCharacter& character = impl->font->get_character(*j);
+              const TTFCharacter& character = impl->font->get_character(*j);
                       
-                        bool draw_it = (y_pos >= impl->scroll_offset && 
-                                        y_pos < impl->scroll_offset + impl->rect.get_height() - static_cast<float>(impl->font->get_height()));
-                        if (is_small)
-                          {
-                            float scale = 0.6f;
-                            if (draw_it)
-                              {
-                                glColor4f(top_color.r, top_color.g, top_color.b, top_color.a);
-                                glTexCoord2f(character.uv.left, character.uv.top);
-                                glVertex2f(x + scale * static_cast<float>(character.pos.left),
-                                           y + scale * static_cast<float>(character.pos.top));
+              bool draw_it = (y_pos >= impl->scroll_offset && 
+                              y_pos < impl->scroll_offset + impl->rect.get_height() - static_cast<float>(impl->font->get_height()));
+              if (is_small)
+              {
+                float scale = 0.6f;
+                if (draw_it)
+                {
+                  glColor4f(top_color.r, top_color.g, top_color.b, top_color.a);
+                  glTexCoord2f(character.uv.left, character.uv.top);
+                  glVertex2f(x + scale * static_cast<float>(character.pos.left),
+                             y + scale * static_cast<float>(character.pos.top));
 
-                                glTexCoord2f(character.uv.right, character.uv.top);
-                                glVertex2f(x + scale * static_cast<float>(character.pos.right), 
-                                           y + scale * static_cast<float>(character.pos.top));
+                  glTexCoord2f(character.uv.right, character.uv.top);
+                  glVertex2f(x + scale * static_cast<float>(character.pos.right), 
+                             y + scale * static_cast<float>(character.pos.top));
 
-                                glColor4f(bottom_color.r, bottom_color.g, bottom_color.b, bottom_color.a);
-                                glTexCoord2f(character.uv.right, character.uv.bottom);
-                                glVertex2f(x + scale * static_cast<float>(character.pos.right), 
-                                           y + scale * static_cast<float>(character.pos.bottom));
+                  glColor4f(bottom_color.r, bottom_color.g, bottom_color.b, bottom_color.a);
+                  glTexCoord2f(character.uv.right, character.uv.bottom);
+                  glVertex2f(x + scale * static_cast<float>(character.pos.right), 
+                             y + scale * static_cast<float>(character.pos.bottom));
 
-                                glTexCoord2f(character.uv.left, character.uv.bottom);
-                                glVertex2f(x + scale * static_cast<float>(character.pos.left), 
-                                           y + scale * static_cast<float>(character.pos.bottom));
-                              }
-                            x_pos += static_cast<int>(scale * static_cast<float>(character.advance));
-                          }
-                        else if (is_large)
-                          {
-                            float scale = 2.0f;
-                            if (draw_it)
-                              {
-                                glColor4f(top_color.r, top_color.g, top_color.b, top_color.a);
-                                glTexCoord2f(character.uv.left, character.uv.top);
-                                glVertex2f(x + scale * static_cast<float>(character.pos.left),
-                                           y + static_cast<float>(character.pos.top));
+                  glTexCoord2f(character.uv.left, character.uv.bottom);
+                  glVertex2f(x + scale * static_cast<float>(character.pos.left), 
+                             y + scale * static_cast<float>(character.pos.bottom));
+                }
+                x_pos += static_cast<int>(scale * static_cast<float>(character.advance));
+              }
+              else if (is_large)
+              {
+                float scale = 2.0f;
+                if (draw_it)
+                {
+                  glColor4f(top_color.r, top_color.g, top_color.b, top_color.a);
+                  glTexCoord2f(character.uv.left, character.uv.top);
+                  glVertex2f(x + scale * static_cast<float>(character.pos.left),
+                             y + static_cast<float>(character.pos.top));
 
-                                glTexCoord2f(character.uv.right, character.uv.top);
-                                glVertex2f(x + scale * static_cast<float>(character.pos.right), 
-                                           y + static_cast<float>(character.pos.top));
+                  glTexCoord2f(character.uv.right, character.uv.top);
+                  glVertex2f(x + scale * static_cast<float>(character.pos.right), 
+                             y + static_cast<float>(character.pos.top));
 
-                                glColor4f(bottom_color.r, bottom_color.g, bottom_color.b, bottom_color.a);
-                                glTexCoord2f(character.uv.right, character.uv.bottom);
-                                glVertex2f(x + scale * static_cast<float>(character.pos.right), 
-                                           y + static_cast<float>(character.pos.bottom));
+                  glColor4f(bottom_color.r, bottom_color.g, bottom_color.b, bottom_color.a);
+                  glTexCoord2f(character.uv.right, character.uv.bottom);
+                  glVertex2f(x + scale * static_cast<float>(character.pos.right), 
+                             y + static_cast<float>(character.pos.bottom));
 
-                                glTexCoord2f(character.uv.left, character.uv.bottom);
-                                glVertex2f(x + scale * static_cast<float>(character.pos.left), 
-                                           y + static_cast<float>(character.pos.bottom));
-                              }
-                            x_pos += static_cast<int>(scale * static_cast<float>(character.advance));
-                          }
-                        else   
-                          {
-                            if (draw_it)
-                              {
-                                glColor4f(top_color.r, top_color.g, top_color.b, top_color.a);
-                                glTexCoord2f(character.uv.left, character.uv.top);
-                                glVertex2f(x + static_cast<float>(character.pos.left),
-                                           y + static_cast<float>(character.pos.top));
+                  glTexCoord2f(character.uv.left, character.uv.bottom);
+                  glVertex2f(x + scale * static_cast<float>(character.pos.left), 
+                             y + static_cast<float>(character.pos.bottom));
+                }
+                x_pos += static_cast<int>(scale * static_cast<float>(character.advance));
+              }
+              else   
+              {
+                if (draw_it)
+                {
+                  glColor4f(top_color.r, top_color.g, top_color.b, top_color.a);
+                  glTexCoord2f(character.uv.left, character.uv.top);
+                  glVertex2f(x + static_cast<float>(character.pos.left),
+                             y + static_cast<float>(character.pos.top));
 
-                                glTexCoord2f(character.uv.right, character.uv.top);
-                                glVertex2f(x + static_cast<float>(character.pos.right), 
-                                           y + static_cast<float>(character.pos.top));
+                  glTexCoord2f(character.uv.right, character.uv.top);
+                  glVertex2f(x + static_cast<float>(character.pos.right), 
+                             y + static_cast<float>(character.pos.top));
 
-                                glColor4f(bottom_color.r, bottom_color.g, bottom_color.b, bottom_color.a);
-                                glTexCoord2f(character.uv.right, character.uv.bottom);
-                                glVertex2f(x + static_cast<float>(character.pos.right), 
-                                           y + static_cast<float>(character.pos.bottom));
+                  glColor4f(bottom_color.r, bottom_color.g, bottom_color.b, bottom_color.a);
+                  glTexCoord2f(character.uv.right, character.uv.bottom);
+                  glVertex2f(x + static_cast<float>(character.pos.right), 
+                             y + static_cast<float>(character.pos.bottom));
 
-                                glTexCoord2f(character.uv.left, character.uv.bottom);
-                                glVertex2f(x + static_cast<float>(character.pos.left), 
-                                           y + static_cast<float>(character.pos.bottom));
-                              }
-                            x_pos += character.advance;
-                          }
-                      }
-                  }
+                  glTexCoord2f(character.uv.left, character.uv.bottom);
+                  glVertex2f(x + static_cast<float>(character.pos.left), 
+                             y + static_cast<float>(character.pos.bottom));
+                }
+                x_pos += character.advance;
               }
-            break;
+            }
+          }
         }
+        break;
     }
+  }
 
   if (impl->max_scroll_offset == -1.0f)
-    {
-      impl->max_scroll_offset = static_cast<float>(y_pos) - impl->rect.get_height();
-      if (impl->max_scroll_offset < 0)
-        impl->max_scroll_offset = 0;
-    }
+  {
+    impl->max_scroll_offset = static_cast<float>(y_pos) - impl->rect.get_height();
+    if (impl->max_scroll_offset < 0)
+      impl->max_scroll_offset = 0;
+  }
 
   // FIXME: This is not correct, since the last command itself might
   // not be completly excecuted

Modified: trunk/windstille/src/display/texture.cpp
===================================================================
--- trunk/windstille/src/display/texture.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/texture.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -52,19 +52,19 @@
   }
 };
 
-Texture::Texture()
-  : impl()
+Texture::Texture() :
+  impl()
 {
 }
 
-Texture::Texture(const Pathname& filename)
-  : impl()
+Texture::Texture(const Pathname& filename) :
+  impl()
 {
   *this = TextureManager::current()->get(filename);
 }
 
-Texture::Texture(GLenum target, int width, int height, GLint format)
-  : impl(new TextureImpl())
+Texture::Texture(GLenum target, int width, int height, GLint format) :
+  impl(new TextureImpl())
 {
   impl->target = target;
   impl->width  = width;
@@ -89,8 +89,8 @@
   return (v & (v-1)) == 0;
 }
 
-Texture::Texture(const SoftwareSurface& image, GLint glformat)
-  : impl(new TextureImpl())
+Texture::Texture(const SoftwareSurface& image, GLint glformat) :
+  impl(new TextureImpl())
 {
   impl->target = GL_TEXTURE_2D;
   impl->width  = image.get_width();
@@ -107,68 +107,68 @@
   // SDL_ConvertSurface(bmp, screen->format, SDL_SWSURFACE);
   
   try 
+  {
+    GLint maxt;
+    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxt);
+
+    if(image.get_width() > maxt || image.get_height() > maxt)
     {
-      GLint maxt;
-      glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxt);
+      throw std::runtime_error("Texture size not supported");
+    }
 
-      if(image.get_width() > maxt || image.get_height() > maxt)
-        {
-          throw std::runtime_error("Texture size not supported");
-        }
+    GLint sdl_format;
 
-      GLint sdl_format;
+    if (image.get_bytes_per_pixel() == 3)
+    {
+      sdl_format = GL_RGB;
+    }
+    else if (image.get_bytes_per_pixel() == 4)
+    {
+      sdl_format = GL_RGBA;
+    }
+    else
+    {
+      throw std::runtime_error("Texture: Image format not supported");
+    }
 
-      if (image.get_bytes_per_pixel() == 3)
-        {
-          sdl_format = GL_RGB;
-        }
-      else if (image.get_bytes_per_pixel() == 4)
-        {
-          sdl_format = GL_RGBA;
-        }
-      else
-        {
-          throw std::runtime_error("Texture: Image format not supported");
-        }
+    OpenGLState state;
+    state.bind_texture(*this);
+    state.activate();
 
-      OpenGLState state;
-      state.bind_texture(*this);
-      state.activate();
+    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+    glPixelStorei(GL_UNPACK_ROW_LENGTH, image.get_pitch() / image.get_bytes_per_pixel());
 
-      glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
-      glPixelStorei(GL_UNPACK_ROW_LENGTH, image.get_pitch() / image.get_bytes_per_pixel());
-
-      if (0)
-      { // no mipmapping
-        glTexImage2D(impl->target, 0, glformat,
-                     image.get_width(), image.get_height(), 0, sdl_format,
-                     GL_UNSIGNED_BYTE, image.get_pixels());
+    if (0)
+    { // no mipmapping
+      glTexImage2D(impl->target, 0, glformat,
+                   image.get_width(), image.get_height(), 0, sdl_format,
+                   GL_UNSIGNED_BYTE, image.get_pixels());
         
-        glTexParameteri(impl->target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-        glTexParameteri(impl->target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-      }
-      else
-      { // use mipmapping
-        gluBuild2DMipmaps(impl->target, glformat,
-                          image.get_width(), image.get_height(), sdl_format,
-                          GL_UNSIGNED_BYTE, image.get_pixels());
+      glTexParameteri(impl->target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexParameteri(impl->target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    }
+    else
+    { // use mipmapping
+      gluBuild2DMipmaps(impl->target, glformat,
+                        image.get_width(), image.get_height(), sdl_format,
+                        GL_UNSIGNED_BYTE, image.get_pixels());
         
-        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
-        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-      }
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    }
 
-      assert_gl("creating texture");
+    assert_gl("creating texture");
 
-      glTexParameteri(impl->target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-      glTexParameteri(impl->target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-      glTexParameteri(impl->target, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
+    glTexParameteri(impl->target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameteri(impl->target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    glTexParameteri(impl->target, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
 
-      assert_gl("setting texture parameters");
-    } 
+    assert_gl("setting texture parameters");
+  } 
   catch(...)
-    {
-      throw;
-    }
+  {
+    throw;
+  }
 }
 
 Texture::~Texture()
@@ -199,17 +199,17 @@
   GLint sdl_format;
 
   if (image.get_bytes_per_pixel() == 3)
-    {
-      sdl_format = GL_RGB;
-    }
+  {
+    sdl_format = GL_RGB;
+  }
   else if (image.get_bytes_per_pixel() == 4)
-    {
-      sdl_format = GL_RGBA;
-    }
+  {
+    sdl_format = GL_RGBA;
+  }
   else
-    {
-      throw std::runtime_error("Texture: Image format not supported");
-    }
+  {
+    throw std::runtime_error("Texture: Image format not supported");
+  }
 
   OpenGLState state;
   state.bind_texture(*this);

Modified: trunk/windstille/src/display/texture_manager.cpp
===================================================================
--- trunk/windstille/src/display/texture_manager.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/texture_manager.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -21,8 +21,8 @@
 #include "display/texture.hpp"
 #include "display/software_surface.hpp"
 
-TextureManager::TextureManager()
-  : textures()
+TextureManager::TextureManager() :
+  textures()
 {
 }
 
@@ -43,26 +43,26 @@
 {
   Textures::iterator i = textures.find(filename);
   if(i != textures.end())
-    {
-      return i->second;
-    }
+  {
+    return i->second;
+  }
   else
+  {
+    try 
     {
-      try 
-        {
-          SoftwareSurface image(filename);
-          Texture texture(image);
+      SoftwareSurface image(filename);
+      Texture texture(image);
 
-          textures.insert(std::make_pair(filename, texture));
+      textures.insert(std::make_pair(filename, texture));
 
-          return texture;
-        } 
-      catch(std::exception& e) 
-        {
-          std::cerr << e.what() << std::endl;
-          return get(Pathname("images/404.png"));
-        }
+      return texture;
+    } 
+    catch(std::exception& e) 
+    {
+      std::cerr << e.what() << std::endl;
+      return get(Pathname("images/404.png"));
     }
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/display/texture_packer.cpp
===================================================================
--- trunk/windstille/src/display/texture_packer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/display/texture_packer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -47,36 +47,36 @@
   {
     if (size.width  <= rect.get_width() &&
         size.height <= rect.get_height())
+    {
+      if (!used)
       {
-        if (!used)
-          {
-            used = true;
-            out_rect = Rect(Point(rect.left, rect.top), size);
+        used = true;
+        out_rect = Rect(Point(rect.left, rect.top), size);
 
-            // FIXME: Make this alterate between horizontal and
-            // vertical splitting or chose whichever split options
-            // leads to less 'ugly' rectangle (how much different does
-            // this make in terms of packing density?)
-            left.reset(new TextureSpace(Rect(out_rect.left,  out_rect.bottom,
-                                             out_rect.right, rect.bottom)));
+        // FIXME: Make this alterate between horizontal and
+        // vertical splitting or chose whichever split options
+        // leads to less 'ugly' rectangle (how much different does
+        // this make in terms of packing density?)
+        left.reset(new TextureSpace(Rect(out_rect.left,  out_rect.bottom,
+                                         out_rect.right, rect.bottom)));
 
-            right.reset(new TextureSpace(Rect(out_rect.right, out_rect.top, 
-                                              rect.right, rect.bottom)));
+        right.reset(new TextureSpace(Rect(out_rect.right, out_rect.top, 
+                                          rect.right, rect.bottom)));
 
-            return true;
-          }
-        else
-          {
-            return
-              left->allocate(size, out_rect) ||
-              right->allocate(size, out_rect);
-          }
+        return true;
       }
-    else
+      else
       {
-        // Size doesn't fit here
-        return false;
+        return
+          left->allocate(size, out_rect) ||
+          right->allocate(size, out_rect);
       }
+    }
+    else
+    {
+      // Size doesn't fit here
+      return false;
+    }
   }
 
 private:
@@ -105,14 +105,14 @@
   bool allocate(const Size& size, Rect& out_rect, Texture& out_texture)
   {
     if (space.allocate(size, out_rect))
-      {
-        out_texture = texture;
-        return true;
-      }
+    {
+      out_texture = texture;
+      return true;
+    }
     else
-      {
-        return false;
-      }
+    {
+      return false;
+    }
   }
 
 private:
@@ -120,9 +120,9 @@
   TexturePackerTexture& operator=(const TexturePackerTexture&);
 };
 
-TexturePacker::TexturePacker(const Size& texture_size_)
-  : texture_size(texture_size_),
-    textures()
+TexturePacker::TexturePacker(const Size& texture_size_) :
+  texture_size(texture_size_),
+  textures()
 {
 }
 
@@ -137,12 +137,12 @@
 TexturePacker::allocate(const Size& size, Rect& rect, Texture& texture)
 {
   for(Textures::iterator i = textures.begin(); i != textures.end(); ++i)
+  {
+    if ((*i)->allocate(size, rect, texture))
     {
-      if ((*i)->allocate(size, rect, texture))
-        {
-          return true;
-        }
+      return true;
     }
+  }
 
   textures.push_back(new TexturePackerTexture(texture_size));
   return textures.back()->allocate(size, rect, texture);
@@ -159,61 +159,61 @@
   Texture texture;
 
   if (!allocate(size, rect, texture))
-    {
-      throw std::runtime_error("TexturePacker::upload: texture space allocation failed");
-    }
+  {
+    throw std::runtime_error("TexturePacker::upload: texture space allocation failed");
+  }
   else
-    {
-      // duplicate border pixel
+  {
+    // duplicate border pixel
 
-      // top
-      texture.put(surface, Rect(Point(0, 0), Size(surface.get_width(), 1)), 
-                  rect.left+1, rect.top);
-      // bottom
-      texture.put(surface, Rect(Point(0, surface.get_height()-1), Size(surface.get_width(), 1)), 
-                  rect.left+1, rect.bottom-1);
-      // left
-      texture.put(surface, Rect(Point(0, 0), Size(1, surface.get_height())), 
-                  rect.left, rect.top+1);
-      // right
-      texture.put(surface, Rect(Point(surface.get_width()-1, 0), Size(1, surface.get_height())),
-                  rect.right-1, rect.top+1);
+    // top
+    texture.put(surface, Rect(Point(0, 0), Size(surface.get_width(), 1)), 
+                rect.left+1, rect.top);
+    // bottom
+    texture.put(surface, Rect(Point(0, surface.get_height()-1), Size(surface.get_width(), 1)), 
+                rect.left+1, rect.bottom-1);
+    // left
+    texture.put(surface, Rect(Point(0, 0), Size(1, surface.get_height())), 
+                rect.left, rect.top+1);
+    // right
+    texture.put(surface, Rect(Point(surface.get_width()-1, 0), Size(1, surface.get_height())),
+                rect.right-1, rect.top+1);
 
-      // duplicate corner pixels
-      texture.put(surface, Rect(Point(0, 0), Size(1, 1)), 
-                  rect.left, rect.top);     
-      texture.put(surface, Rect(Point(surface.get_width()-1, 0), Size(1, 1)), 
-                  rect.right-1, rect.top);
-      texture.put(surface, Rect(Point(surface.get_width()-1, surface.get_height()-1), Size(1, 1)), 
-                  rect.right-1, rect.bottom-1);
-      texture.put(surface, Rect(Point(0, surface.get_height()-1), Size(1, 1)),
-                  rect.left, rect.bottom-1);
+    // duplicate corner pixels
+    texture.put(surface, Rect(Point(0, 0), Size(1, 1)), 
+                rect.left, rect.top);     
+    texture.put(surface, Rect(Point(surface.get_width()-1, 0), Size(1, 1)), 
+                rect.right-1, rect.top);
+    texture.put(surface, Rect(Point(surface.get_width()-1, surface.get_height()-1), Size(1, 1)), 
+                rect.right-1, rect.bottom-1);
+    texture.put(surface, Rect(Point(0, surface.get_height()-1), Size(1, 1)),
+                rect.left, rect.bottom-1);
 
-      // draw the main surface
-      texture.put(surface, rect.left+1, rect.top+1);
+    // draw the main surface
+    texture.put(surface, rect.left+1, rect.top+1);
 
-      return Surface(texture,
-                     Rectf(static_cast<float>(rect.left+1)   / static_cast<float>(texture.get_width()),
-                           static_cast<float>(rect.top+1)    / static_cast<float>(texture.get_height()),
-                           static_cast<float>(rect.right-1)  / static_cast<float>(texture.get_width()), 
-                           static_cast<float>(rect.bottom-1) / static_cast<float>(texture.get_height())),
-                     Sizef(static_cast<float>(surface.get_width()), static_cast<float>(surface.get_height())));
-    }
+    return Surface(texture,
+                   Rectf(static_cast<float>(rect.left+1)   / static_cast<float>(texture.get_width()),
+                         static_cast<float>(rect.top+1)    / static_cast<float>(texture.get_height()),
+                         static_cast<float>(rect.right-1)  / static_cast<float>(texture.get_width()), 
+                         static_cast<float>(rect.bottom-1) / static_cast<float>(texture.get_height())),
+                   Sizef(static_cast<float>(surface.get_width()), static_cast<float>(surface.get_height())));
+  }
 }
 
 void
 TexturePacker::save_all_as_png() const
 {
   for(Textures::const_iterator i = textures.begin(); i != textures.end(); ++i)
-    {
-      Texture texture = (*i)->get_texture();
-      SoftwareSurface surface = texture.get_software_surface();
+  {
+    Texture texture = (*i)->get_texture();
+    SoftwareSurface surface = texture.get_software_surface();
 
-      char filename[1024];
-      sprintf(filename, "/tmp/texture_packer%04d.png", int(i - textures.begin()));
-      std::cout << "Saving: " << filename << std::endl;
-      surface.save_png(filename);
-    }
+    char filename[1024];
+    sprintf(filename, "/tmp/texture_packer%04d.png", int(i - textures.begin()));
+    std::cout << "Saving: " << filename << std::endl;
+    surface.save_png(filename);
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/editor/control_point.cpp
===================================================================
--- trunk/windstille/src/editor/control_point.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/control_point.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -27,10 +27,10 @@
   return ControlPointHandle(new ControlPoint(Surface(Pathname("editor/handle.png")), pos));
 }
 
-ControlPoint::ControlPoint(const Surface& surface_, const Vector2f& pos_)
-  : surface(surface_),
-    pos(pos_),
-    offset()
+ControlPoint::ControlPoint(const Surface& surface_, const Vector2f& pos_) :
+  surface(surface_),
+  pos(pos_),
+  offset()
 {
 }
 

Modified: trunk/windstille/src/editor/decal_object_model.cpp
===================================================================
--- trunk/windstille/src/editor/decal_object_model.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/decal_object_model.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -39,17 +39,17 @@
   return ObjectModelHandle(new DecalObjectModel(name, pos, path, type));
 }
 
-DecalObjectModel::DecalObjectModel(const FileReader& reader)
-  : ObjectModel(reader),
-    path(),
-    surface(),
-    software_surface(),
-    type(),
-    scale(1.0f, 1.0f),
-    angle(0.0f),
-    hflip(false),
-    vflip(false),
-    m_drawable()
+DecalObjectModel::DecalObjectModel(const FileReader& reader) :
+  ObjectModel(reader),
+  path(),
+  surface(),
+  software_surface(),
+  type(),
+  scale(1.0f, 1.0f),
+  angle(0.0f),
+  hflip(false),
+  vflip(false),
+  m_drawable()
 {
   int map_type = 0;
   reader.get("path", path);
@@ -65,31 +65,31 @@
 }
 
 DecalObjectModel::DecalObjectModel(const std::string& /*name*/, const Vector2f& rel_pos_, 
-                                   const std::string& path_, MapType type_)
-  : ObjectModel("DecalObjectModel", rel_pos_),
-    path(path_),
-    surface(Pathname(path_)),
-    software_surface(Pathname(path_)),
-    type(type_),
-    scale(1.0f, 1.0f),
-    angle(0.0f),
-    hflip(false),
-    vflip(false),
-    m_drawable()
+                                   const std::string& path_, MapType type_) :
+  ObjectModel("DecalObjectModel", rel_pos_),
+  path(path_),
+  surface(Pathname(path_)),
+  software_surface(Pathname(path_)),
+  type(type_),
+  scale(1.0f, 1.0f),
+  angle(0.0f),
+  hflip(false),
+  vflip(false),
+  m_drawable()
 {
 }
 
-DecalObjectModel::DecalObjectModel(const DecalObjectModel& rhs)
-  : ObjectModel(rhs),
-    path(rhs.path),
-    surface(rhs.surface),
-    software_surface(rhs.software_surface),
-    type(rhs.type),
-    scale(rhs.scale),
-    angle(rhs.angle),
-    hflip(rhs.hflip),
-    vflip(rhs.vflip),
-    m_drawable()
+DecalObjectModel::DecalObjectModel(const DecalObjectModel& rhs) :
+  ObjectModel(rhs),
+  path(rhs.path),
+  surface(rhs.surface),
+  software_surface(rhs.software_surface),
+  type(rhs.type),
+  scale(rhs.scale),
+  angle(rhs.angle),
+  hflip(rhs.hflip),
+  vflip(rhs.vflip),
+  m_drawable()
 {
 }
 

Modified: trunk/windstille/src/editor/decal_rotate_control_point.cpp
===================================================================
--- trunk/windstille/src/editor/decal_rotate_control_point.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/decal_rotate_control_point.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -19,12 +19,12 @@
 #include "display/scene_context.hpp"
 #include "editor/decal_rotate_control_point.hpp"
 
-DecalRotateControlPoint::DecalRotateControlPoint(DecalObjectModel* object_, float ctrl_angle_, const Vector2f& pos_)
-  : ControlPoint(Surface(Pathname("editor/rotate_handle.png")), pos_),
-    object(object_),
-    ctrl_angle(ctrl_angle_),
-    orig_angle(object->get_angle()),
-    center(object->get_world_pos())
+DecalRotateControlPoint::DecalRotateControlPoint(DecalObjectModel* object_, float ctrl_angle_, const Vector2f& pos_) :
+  ControlPoint(Surface(Pathname("editor/rotate_handle.png")), pos_),
+  object(object_),
+  ctrl_angle(ctrl_angle_),
+  orig_angle(object->get_angle()),
+  center(object->get_world_pos())
 {
 }
 

Modified: trunk/windstille/src/editor/decal_scale_control_point.cpp
===================================================================
--- trunk/windstille/src/editor/decal_scale_control_point.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/decal_scale_control_point.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -20,13 +20,13 @@
 #include "editor/decal_scale_control_point.hpp"
 
 DecalScaleControlPoint::DecalScaleControlPoint(DecalObjectModel* object_, float ctrl_angle_, const Vector2f& pos_, 
-                                               bool x_scale_, bool y_scale_)
-  : ControlPoint(Surface(Pathname("editor/scale_handle.png")), pos_),
-    object(object_),
-    ctrl_angle(ctrl_angle_),
-    orig_scale(object_->get_scale()),
-    x_scale(x_scale_),
-    y_scale(y_scale_)
+                                               bool x_scale_, bool y_scale_) :
+  ControlPoint(Surface(Pathname("editor/scale_handle.png")), pos_),
+  object(object_),
+  ctrl_angle(ctrl_angle_),
+  orig_scale(object_->get_scale()),
+  x_scale(x_scale_),
+  y_scale(y_scale_)
 {}
 
 void

Modified: trunk/windstille/src/editor/document.cpp
===================================================================
--- trunk/windstille/src/editor/document.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/document.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -36,14 +36,14 @@
 #include "editor/object_commands.hpp"
 #include "editor/timeline_commands.hpp"
 
-Document::Document()
-  : m_undo_manager(new UndoManager()),
-    m_sector_model(new SectorModel()),
-    m_group_command(),
-    m_group_command_count(0),
-    m_selection(Selection::create()),
-    m_control_points(),
-    m_sig_on_change()    
+Document::Document() :
+  m_undo_manager(new UndoManager()),
+  m_sector_model(new SectorModel()),
+  m_group_command(),
+  m_group_command_count(0),
+  m_selection(Selection::create()),
+  m_control_points(),
+  m_sig_on_change()    
 {
   m_sector_model->get_layer_tree()->signal_row_changed().connect(sigc::mem_fun(*this, &Document::on_row_changed));
   m_sector_model->get_layer_tree()->signal_row_deleted().connect(sigc::mem_fun(*this, &Document::on_row_deleted));
@@ -52,14 +52,14 @@
   m_sector_model->get_layer_tree()->signal_rows_reordered().connect(sigc::mem_fun(*this, &Document::on_rows_reordered));
 }
 
-Document::Document(const std::string& filename)
-  : m_undo_manager(new UndoManager()),
-    m_sector_model(new SectorModel(filename)),
-    m_group_command(),
-    m_group_command_count(0),
-    m_selection(Selection::create()),
-    m_control_points(),
-    m_sig_on_change()
+Document::Document(const std::string& filename) :
+  m_undo_manager(new UndoManager()),
+  m_sector_model(new SectorModel(filename)),
+  m_group_command(),
+  m_group_command_count(0),
+  m_selection(Selection::create()),
+  m_control_points(),
+  m_sig_on_change()
 {
   m_sector_model->get_layer_tree()->signal_row_changed().connect(sigc::mem_fun(*this, &Document::on_row_changed));
   m_sector_model->get_layer_tree()->signal_row_deleted().connect(sigc::mem_fun(*this, &Document::on_row_deleted));

Modified: trunk/windstille/src/editor/editor_window.cpp
===================================================================
--- trunk/windstille/src/editor/editor_window.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/editor_window.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -54,44 +54,44 @@
 #include "editor/timeline_sound_object.hpp"
 #include "editor/timeline_widget.hpp"
 
-EditorWindow::EditorWindow(const Glib::RefPtr<const Gdk::GL::Config>& glconfig_)
-  : vbox(),
-    sidebar_vbox(),
-    hbox(),
-    hpaned(),
-    vpaned(),
-    status_hbox(),
-    status_label(),
-    status(),
-    ui_manager(Gtk::UIManager::create()),
-    action_group(Gtk::ActionGroup::create()),
-    share_list(),
-    glconfig(glconfig_),
-    notebook(),
-    object_selector(*this),
-    layer_manager(*this),
-    minimap_widget(glconfig_),
-    select_tool_action(),
-    navgraph_insert_tool_action(),
-    navgraph_select_tool_action(),
-    zoom_tool_action(),
-    toggle_color_layer(),
-    toggle_light_layer(),
-    toggle_highlight_layer(),
-    toggle_control_layer(),
-    background_layer(),
-    visible_layer(),
-    grid_layer(),
-    play_action(),
-    snap_action(),
-    select_tool(new SelectTool()),
-    navgraph_insert_tool(new NavgraphInsertTool()),
-    zoom_tool(new ZoomTool()),
-    scroll_tool(new ScrollTool()),
-    current_tool(select_tool.get()),
-    layer_widget(),
-    timeout_connection(),
-    clipboard()
+EditorWindow::EditorWindow(const Glib::RefPtr<const Gdk::GL::Config>& glconfig_) :
+  vbox(),
+  sidebar_vbox(),
+  hbox(),
+  hpaned(),
+  vpaned(),
+  status_hbox(),
+  status_label(),
+  status(),
+  ui_manager(Gtk::UIManager::create()),
+  action_group(Gtk::ActionGroup::create()),
+  share_list(),
+  glconfig(glconfig_),
+  notebook(),
+  object_selector(*this),
+  layer_manager(*this),
+  minimap_widget(glconfig_),
+  select_tool_action(),
+  navgraph_insert_tool_action(),
+  navgraph_select_tool_action(),
+  zoom_tool_action(),
+  toggle_color_layer(),
+  toggle_light_layer(),
+  toggle_highlight_layer(),
+  toggle_control_layer(),
+  background_layer(),
+  visible_layer(),
+  grid_layer(),
+  play_action(),
+  snap_action(),
+  select_tool(new SelectTool()),
+  navgraph_insert_tool(new NavgraphInsertTool()),
+  zoom_tool(new ZoomTool()),
+  scroll_tool(new ScrollTool()),
+  current_tool(select_tool.get()),
+  layer_widget(),
+  timeout_connection(),
+  clipboard()
 {
   set_title("Windstille Editor");
   set_default_size(1280, 800);

Modified: trunk/windstille/src/editor/layer.cpp
===================================================================
--- trunk/windstille/src/editor/layer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/layer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -21,12 +21,12 @@
 #include "editor/layer_manager_columns.hpp"
 #include "editor/sector_model.hpp"
 
-Layer::Layer(SectorModel& sector)
-  : m_sector(sector),
-    objects(),
-    name(),
-    visible(true),
-    locked(false)
+Layer::Layer(SectorModel& sector) :
+  m_sector(sector),
+  objects(),
+  name(),
+  visible(true),
+  locked(false)
 {
 }
 

Modified: trunk/windstille/src/editor/layer_manager.cpp
===================================================================
--- trunk/windstille/src/editor/layer_manager.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/layer_manager.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -30,12 +30,12 @@
 #include "editor/sector_model.hpp"
 #include "editor/layer_manager_columns.hpp"
 
-LayerManager::LayerManager(EditorWindow& editor_)
-  : editor(editor_),
-    label("Layer Manager", Gtk::ALIGN_LEFT),
-    scrolled(),
-    treeview(),
-    auto_lock()
+LayerManager::LayerManager(EditorWindow& editor_) :
+  editor(editor_),
+  label("Layer Manager", Gtk::ALIGN_LEFT),
+  scrolled(),
+  treeview(),
+  auto_lock()
 {
   treeview.set_headers_clickable();
   treeview.set_headers_visible(true);

Modified: trunk/windstille/src/editor/layer_widget.cpp
===================================================================
--- trunk/windstille/src/editor/layer_widget.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/layer_widget.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -23,10 +23,10 @@
 #include "editor/select_mask.hpp"
 #include "editor/layer_widget.hpp"
 
-LayerWidget::LayerWidget()
-  : table(2, 9, false),
-    buttons(),
-    signal_layer_toggle()
+LayerWidget::LayerWidget() :
+  table(2, 9, false),
+  buttons(),
+  signal_layer_toggle()
 {
   int layer_number = 0;
   for(int y = 0; y < 2; ++y)

Modified: trunk/windstille/src/editor/navgraph_edge_object_model.cpp
===================================================================
--- trunk/windstille/src/editor/navgraph_edge_object_model.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/navgraph_edge_object_model.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -25,11 +25,11 @@
 #include "scenegraph/vertex_array_drawable.hpp"
 
 NavGraphEdgeObjectModel::NavGraphEdgeObjectModel(boost::shared_ptr<NavGraphNodeObjectModel> lhs,
-                                                 boost::shared_ptr<NavGraphNodeObjectModel> rhs)
-  : ObjectModel("NavGraphEdgeObjectModel", Vector2f()),
-    m_lhs(lhs),
-    m_rhs(rhs),
-    m_drawable()
+                                                 boost::shared_ptr<NavGraphNodeObjectModel> rhs) :
+  ObjectModel("NavGraphEdgeObjectModel", Vector2f()),
+  m_lhs(lhs),
+  m_rhs(rhs),
+  m_drawable()
 {
   if (m_lhs == m_rhs)
   {

Modified: trunk/windstille/src/editor/navgraph_insert_tool.cpp
===================================================================
--- trunk/windstille/src/editor/navgraph_insert_tool.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/navgraph_insert_tool.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -28,13 +28,13 @@
 #include "editor/navgraph_node_object_model.hpp"
 #include "editor/navgraph_edge_object_model.hpp"
 
-NavgraphInsertTool::NavgraphInsertTool()
-  : mouse_pos(),
-    mode(NO_MODE),
-    last_node(),
-    connection_node(),
-    mouse_over_node(),
-    mouse_over_edge()
+NavgraphInsertTool::NavgraphInsertTool() :
+  mouse_pos(),
+  mode(NO_MODE),
+  last_node(),
+  connection_node(),
+  mouse_over_node(),
+  mouse_over_edge()
 {
 }
 

Modified: trunk/windstille/src/editor/navgraph_node_object_model.cpp
===================================================================
--- trunk/windstille/src/editor/navgraph_node_object_model.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/navgraph_node_object_model.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -24,15 +24,15 @@
 #include "navigation/node.hpp"
 #include "editor/constants.hpp"
 
-NavGraphNodeObjectModel::NavGraphNodeObjectModel(const FileReader& reader)
-  : ObjectModel(reader),
-    m_drawable()
+NavGraphNodeObjectModel::NavGraphNodeObjectModel(const FileReader& reader) :
+  ObjectModel(reader),
+  m_drawable()
 {
 }
 
-NavGraphNodeObjectModel::NavGraphNodeObjectModel(const Vector2f& pos)
-  : ObjectModel("NavGraphNodeObjectModel", pos),
-    m_drawable()
+NavGraphNodeObjectModel::NavGraphNodeObjectModel(const Vector2f& pos) :
+  ObjectModel("NavGraphNodeObjectModel", pos),
+  m_drawable()
 {
 }
 
@@ -98,14 +98,14 @@
   SnapData snap;
 
   if (fabs(snap_x) < g_snap_threshold)
-    {
-      snap.set_x(snap_x);
-    }
+  {
+    snap.set_x(snap_x);
+  }
 
   if (fabs(snap_y) < g_snap_threshold)
-    {
-      snap.set_y(snap_y);
-    }
+  {
+    snap.set_y(snap_y);
+  }
 
   return snap;
 }

Modified: trunk/windstille/src/editor/navigation_graph_model.cpp
===================================================================
--- trunk/windstille/src/editor/navigation_graph_model.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/navigation_graph_model.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -24,10 +24,10 @@
 #include "navigation/navigation_graph.hpp"
 #include "util/file_reader.hpp"
 
-NavigationGraphModel::NavigationGraphModel(SectorModel& sector)
-  : m_sector(sector),
-    m_nodes(),
-    m_edges()   
+NavigationGraphModel::NavigationGraphModel(SectorModel& sector) :
+  m_sector(sector),
+  m_nodes(),
+  m_edges()   
 {
 }
 

Modified: trunk/windstille/src/editor/node_selection.cpp
===================================================================
--- trunk/windstille/src/editor/node_selection.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/node_selection.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -18,8 +18,8 @@
 
 #include "editor/node_selection.hpp"
 
-NodeSelection::NodeSelection()
-  : nodes()
+NodeSelection::NodeSelection() :
+  nodes()
 {
 }
 

Modified: trunk/windstille/src/editor/object_model.cpp
===================================================================
--- trunk/windstille/src/editor/object_model.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/object_model.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -27,19 +27,19 @@
 #include "editor/editor_window.hpp"
 #include "util/file_reader.hpp"
 
-ObjectModel::ObjectModel(const std::string& name_, const Vector2f& rel_pos_)
-  : name(name_),
-    rel_pos(rel_pos_),
-    select_mask(),
-    parent_ptr()
+ObjectModel::ObjectModel(const std::string& name_, const Vector2f& rel_pos_) :
+  name(name_),
+  rel_pos(rel_pos_),
+  select_mask(),
+  parent_ptr()
 {
 }
 
-ObjectModel::ObjectModel(const FileReader& reader)
-  : name(),
-    rel_pos(),
-    select_mask(),
-    parent_ptr()
+ObjectModel::ObjectModel(const FileReader& reader) :
+  name(),
+  rel_pos(),
+  select_mask(),
+  parent_ptr()
 {
   reader.get("name", name);
   reader.get("pos",  rel_pos);

Modified: trunk/windstille/src/editor/object_selector.cpp
===================================================================
--- trunk/windstille/src/editor/object_selector.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/object_selector.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -64,16 +64,16 @@
 
 ObjectSelector::Columns* ObjectSelector::Columns::instance_ = 0;
 
-ObjectSelector::ObjectSelector(EditorWindow& editor_)
-  : editor(editor_),
-    label("Object Selector", Gtk::ALIGN_LEFT),
-    scrolled(),
-    iconview(),
-    list_store(),
-    list_filter(),
-    filter_box(),
-    filter_entries(),
-    filter_mask(OBJECT_GROUP_ALL)
+ObjectSelector::ObjectSelector(EditorWindow& editor_) :
+  editor(editor_),
+  label("Object Selector", Gtk::ALIGN_LEFT),
+  scrolled(),
+  iconview(),
+  list_store(),
+  list_filter(),
+  filter_box(),
+  filter_entries(),
+  filter_mask(OBJECT_GROUP_ALL)
 {
 #if 0
   Glib::RefPtr<Gtk::UIManager>   ui_manager   = editor.get_ui_manager();

Modified: trunk/windstille/src/editor/particle_system_object_model.cpp
===================================================================
--- trunk/windstille/src/editor/particle_system_object_model.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/particle_system_object_model.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -19,9 +19,9 @@
 #include "particles/particle_system.hpp"
 #include "editor/particle_system_object_model.hpp"
 
-ParticleSystemObjectModel::ParticleSystemObjectModel(const Vector2f& pos)
-  : ObjectModel("ParticleSystem", pos),
-    systems()
+ParticleSystemObjectModel::ParticleSystemObjectModel(const Vector2f& pos) :
+  ObjectModel("ParticleSystem", pos),
+  systems()
 {
 }
 

Modified: trunk/windstille/src/editor/scroll_tool.cpp
===================================================================
--- trunk/windstille/src/editor/scroll_tool.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/scroll_tool.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -20,10 +20,10 @@
 #include "editor/windstille_widget.hpp"
 #include "editor/scroll_tool.hpp"
 
-ScrollTool::ScrollTool()
-  : orig_state(),
-    orig_click(),
-    mode(NO_MODE)
+ScrollTool::ScrollTool() :
+  orig_state(),
+  orig_click(),
+  mode(NO_MODE)
 {
 }
 

Modified: trunk/windstille/src/editor/sector_model.cpp
===================================================================
--- trunk/windstille/src/editor/sector_model.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/sector_model.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -52,11 +52,11 @@
   SectorModelBuilder(filename, *this);
 }
 
-SectorModel::SectorModel()
-  : nav_graph(new NavigationGraphModel(*this)),
-    layer_tree(Gtk::ListStore::create(LayerManagerColumns::instance())),
-    m_timeline(new Timeline()),
-    ambient_color()
+SectorModel::SectorModel() :
+  nav_graph(new NavigationGraphModel(*this)),
+  layer_tree(Gtk::ListStore::create(LayerManagerColumns::instance())),
+  m_timeline(new Timeline()),
+  ambient_color()
 {
   register_callbacks();
 

Modified: trunk/windstille/src/editor/sector_model_builder.cpp
===================================================================
--- trunk/windstille/src/editor/sector_model_builder.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/sector_model_builder.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -28,10 +28,10 @@
 #include "editor/sector_model.hpp"
 #include "util/file_reader.hpp"
 
-SectorModelBuilder::SectorModelBuilder(const std::string& filename, SectorModel& sector)
-  : m_sector(sector),
-    m_id_table(),
-    m_parent_table()
+SectorModelBuilder::SectorModelBuilder(const std::string& filename, SectorModel& sector) :
+  m_sector(sector),
+  m_id_table(),
+  m_parent_table()
 {
   m_sector.get_layer_tree()->clear();
 

Modified: trunk/windstille/src/editor/select_tool.cpp
===================================================================
--- trunk/windstille/src/editor/select_tool.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/select_tool.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -27,13 +27,13 @@
 static const guint32 MOVE_TIMEOUT = 100;
 static const int MOVE_THRESHOLD = 16;
 
-SelectTool::SelectTool()
-  : click_pos(),
-    rect(),
-    selection(),
-    ctrl_point(),
-    start_time(),
-    mode(NO_MODE)    
+SelectTool::SelectTool() :
+  click_pos(),
+  rect(),
+  selection(),
+  ctrl_point(),
+  start_time(),
+  mode(NO_MODE)    
 {
 }
 

Modified: trunk/windstille/src/editor/selection.cpp
===================================================================
--- trunk/windstille/src/editor/selection.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/selection.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -23,12 +23,12 @@
 #include "editor/editor_window.hpp"
 #include "editor/selection.hpp"
 
-Selection::Selection()
-  : objects(),
-    object_orig_poss(),
-    non_moveable_objects(),
-    moving(false),
-    signal_changed()
+Selection::Selection() :
+  objects(),
+  object_orig_poss(),
+  non_moveable_objects(),
+  moving(false),
+  signal_changed()
 {
 }
 

Modified: trunk/windstille/src/editor/sprite_object_model.cpp
===================================================================
--- trunk/windstille/src/editor/sprite_object_model.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/sprite_object_model.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -21,10 +21,10 @@
 #include "editor/sprite_object_model.hpp"
 
 SpriteObjectModel::SpriteObjectModel(const std::string& name_, const Vector2f& rel_pos_,
-                                     const std::string& path_)
-  : ObjectModel(name_, rel_pos_),
-    path(path_),
-    sprite(Pathname(path_))
+                                     const std::string& path_) :
+  ObjectModel(name_, rel_pos_),
+  path(path_),
+  sprite(Pathname(path_))
 {
 }
 

Modified: trunk/windstille/src/editor/timeline.cpp
===================================================================
--- trunk/windstille/src/editor/timeline.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/timeline.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -21,8 +21,8 @@
 #include "editor/timeline_object_layer.hpp"
 #include "editor/timeline_layer.hpp"
 
-Timeline::Timeline()
-  : m_layers()
+Timeline::Timeline() :
+  m_layers()
 {
 }
 

Modified: trunk/windstille/src/editor/timeline_layer.cpp
===================================================================
--- trunk/windstille/src/editor/timeline_layer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/timeline_layer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -23,9 +23,9 @@
 #include "util/file_writer.hpp"
 #include "editor/timeline_object.hpp"
 
-TimelineLayer::TimelineLayer(const std::string& name)
-  : m_name(name),
-    m_objects()
+TimelineLayer::TimelineLayer(const std::string& name) :
+  m_name(name),
+  m_objects()
 {
 }
 

Modified: trunk/windstille/src/editor/timeline_object_layer.cpp
===================================================================
--- trunk/windstille/src/editor/timeline_object_layer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/timeline_object_layer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -18,10 +18,10 @@
 
 #include "timeline_object_layer.hpp"
 
-TimelineObjectLayer::TimelineObjectLayer(ObjectModelHandle object, TimelineProperty property)
-  : TimelineLayer("TimelineObjectLayer"),
-    m_object(object),
-    m_property(property)
+TimelineObjectLayer::TimelineObjectLayer(ObjectModelHandle object, TimelineProperty property) :
+  TimelineLayer("TimelineObjectLayer"),
+  m_object(object),
+  m_property(property)
 {
 }
 

Modified: trunk/windstille/src/editor/undo_manager.cpp
===================================================================
--- trunk/windstille/src/editor/undo_manager.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/undo_manager.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -18,9 +18,9 @@
 
 #include "editor/undo_manager.hpp"
 
-UndoManager::UndoManager()
-  : undo_stack(),
-    redo_stack()
+UndoManager::UndoManager() :
+  undo_stack(),
+  redo_stack()
 {
 }
 

Modified: trunk/windstille/src/editor/windstille_widget.cpp
===================================================================
--- trunk/windstille/src/editor/windstille_widget.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/windstille_widget.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -44,21 +44,21 @@
 
 WindstilleWidget::WindstilleWidget(EditorWindow& editor_,
                                    const Glib::RefPtr<const Gdk::GL::Config>&  glconfig,
-                                   const Glib::RefPtr<const Gdk::GL::Context>& share_list)
-  : editor(editor_),
-    m_document(new Document),
-    m_scene_graph(new SceneGraph()),
-    m_rebuild_scene_graph(true),
-    filename(),
-    state(),
-    compositor(),
-    sc(),
-    map_type(DecalObjectModel::COLORMAP),
-    background_pattern(),
-    select_mask(1),
-    draw_background_pattern(true),
-    draw_only_active_layers(true),
-    grid_enabled(false)
+                                   const Glib::RefPtr<const Gdk::GL::Context>& share_list) :
+  editor(editor_),
+  m_document(new Document),
+  m_scene_graph(new SceneGraph()),
+  m_rebuild_scene_graph(true),
+  filename(),
+  state(),
+  compositor(),
+  sc(),
+  map_type(DecalObjectModel::COLORMAP),
+  background_pattern(),
+  select_mask(1),
+  draw_background_pattern(true),
+  draw_only_active_layers(true),
+  grid_enabled(false)
 {
   set_gl_capability(glconfig, share_list);
 

Modified: trunk/windstille/src/editor/zoom_tool.cpp
===================================================================
--- trunk/windstille/src/editor/zoom_tool.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/editor/zoom_tool.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,10 +22,10 @@
 #include "display/color.hpp"
 #include "editor/windstille_widget.hpp"
 
-ZoomTool::ZoomTool()
-  : click_pos(),
-    mouse_pos(),
-    mode(NO_MODE)
+ZoomTool::ZoomTool() :
+  click_pos(),
+  mouse_pos(),
+  mode(NO_MODE)
 {
 }
 

Modified: trunk/windstille/src/engine/camera.cpp
===================================================================
--- trunk/windstille/src/engine/camera.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/engine/camera.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -45,26 +45,26 @@
 {
   float length_so_far = 0.0f;
   for(std::vector<Camera::PathPoint>::size_type i = 0; i < path.size()-1; ++i)
+  {
+    float  segment_length = distance(path[i], path[i+1]);
+
+    if (length_so_far + segment_length > length)
     {
-      float  segment_length = distance(path[i], path[i+1]);
-
-      if (length_so_far + segment_length > length)
-        {
-          float factor = (length - length_so_far) / segment_length;
-          return Camera::PathPoint((path[i+1].pos * factor) + (path[i].pos * (1.0f - factor)),
-                                   (factor * path[i+1].zoom) + ((1.0f - factor) * path[i].zoom));
-        }
-      length_so_far += segment_length;
+      float factor = (length - length_so_far) / segment_length;
+      return Camera::PathPoint((path[i+1].pos * factor) + (path[i].pos * (1.0f - factor)),
+                               (factor * path[i+1].zoom) + ((1.0f - factor) * path[i].zoom));
     }
+    length_so_far += segment_length;
+  }
 
   return path.back();
 }
 
-Camera::Camera()
-  : mode(CAMERA_FOLLOW_PLAYER),
-    pos(0, 0), 
-    zoom(1.0f),
-    path_pos(0)
+Camera::Camera() :
+  mode(CAMERA_FOLLOW_PLAYER),
+  pos(0, 0), 
+  zoom(1.0f),
+  path_pos(0)
 {  
 }
 
@@ -72,54 +72,54 @@
 Camera::update(float delta)
 {
   switch (mode)
-    {
+  {
     case CAMERA_INACTIVE:
       // do nothing
       break;
 
     case CAMERA_FOLLOW_PLAYER:
-      {
-        float hscroll_threshold = 100.0f;
-        float vscroll_threshold  = 150.0f;
+    {
+      float hscroll_threshold = 100.0f;
+      float vscroll_threshold  = 150.0f;
 
-        Vector2f tpos;
-        if (Player::current())
-          tpos = Player::current()->get_pos();
-        else if (Doll::current())
-          tpos = Doll::current()->get_pos();
+      Vector2f tpos;
+      if (Player::current())
+        tpos = Player::current()->get_pos();
+      else if (Doll::current())
+        tpos = Doll::current()->get_pos();
 
-        float dist = tpos.x - pos.x;
-        if (dist > hscroll_threshold)
-          pos.x = tpos.x - hscroll_threshold;
-        else if (dist < - hscroll_threshold)
-          pos.x = tpos.x + hscroll_threshold;
+      float dist = tpos.x - pos.x;
+      if (dist > hscroll_threshold)
+        pos.x = tpos.x - hscroll_threshold;
+      else if (dist < - hscroll_threshold)
+        pos.x = tpos.x + hscroll_threshold;
 
-        dist = tpos.y - pos.y;
-        if (dist > vscroll_threshold)
-          pos.y = tpos.y - vscroll_threshold;
-        else if (dist < -vscroll_threshold)
-          pos.y = tpos.y + vscroll_threshold;
-      }
-      break;
+      dist = tpos.y - pos.y;
+      if (dist > vscroll_threshold)
+        pos.y = tpos.y - vscroll_threshold;
+      else if (dist < -vscroll_threshold)
+        pos.y = tpos.y + vscroll_threshold;
+    }
+    break;
 
     case CAMERA_FOLLOW_PATH:
-      {
-        assert(!path.empty());
-        path_pos += delta * 50.0f;
+    {
+      assert(!path.empty());
+      path_pos += delta * 50.0f;
 
-        PathPoint p = interpolate_path(path, path_pos);
+      PathPoint p = interpolate_path(path, path_pos);
 
-        set_pos(p.pos.x, p.pos.y);
-        set_zoom(p.zoom);
+      set_pos(p.pos.x, p.pos.y);
+      set_zoom(p.zoom);
 
-        if (p == path.back())
-          {
-            ScriptManager::current()->fire_wakeup_event(ScriptManager::CAMERA_DONE);
-            set_mode(CAMERA_INACTIVE);
-          }
+      if (p == path.back())
+      {
+        ScriptManager::current()->fire_wakeup_event(ScriptManager::CAMERA_DONE);
+        set_mode(CAMERA_INACTIVE);
       }
-      break;
     }
+    break;
+  }
 }
 
 void

Modified: trunk/windstille/src/engine/entity.cpp
===================================================================
--- trunk/windstille/src/engine/entity.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/engine/entity.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,13 +22,13 @@
 #include "engine/sector.hpp"
 #include "tile/tile_map.hpp"
 
-Entity::Entity()
-  : done(),
-    pos(),
-    velocity(0, 0),
-    useable(false),
-    use_verb(),
-    parent(0)
+Entity::Entity() :
+  done(),
+  pos(),
+  velocity(0, 0),
+  useable(false),
+  use_verb(),
+  parent(0)
 {
 }
 
@@ -58,9 +58,9 @@
 Entity::set_parent(Entity* parent_)
 {
   if (parent_ != this)
-    {
-      parent = parent_;
-    }
+  {
+    parent = parent_;
+  }
 }
 
 Properties
@@ -68,10 +68,10 @@
 {
   static PropertySet* type = 0;
   if (!type) 
-    {
-      type = new PropertySet("Entity");
-      type->add_bool("usable", &Entity::useable);
-    }
+  {
+    type = new PropertySet("Entity");
+    type->add_bool("usable", &Entity::useable);
+  }
 
   return Properties(type, this);
 }

Modified: trunk/windstille/src/engine/game_object.hpp
===================================================================
--- trunk/windstille/src/engine/game_object.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/engine/game_object.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -49,9 +49,9 @@
 
 public:
   GameObject() 
-  : remove_flag(false), 
-    name(),
-    active(true)
+    : remove_flag(false), 
+      name(),
+      active(true)
   {}
   virtual ~GameObject() {}
 

Modified: trunk/windstille/src/engine/physics.cpp
===================================================================
--- trunk/windstille/src/engine/physics.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/engine/physics.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,13 +22,13 @@
 
 #include "collision/collision_object.hpp"
 
-Physics::Physics(Entity* entity_)
-  : entity(entity_),
-    mass(200.0),
-    bounciness(1.0),
-    force(),
-    air_friction(0.0),
-    contact_friction(0.0)
+Physics::Physics(Entity* entity_) :
+  entity(entity_),
+  mass(200.0),
+  bounciness(1.0),
+  force(),
+  air_friction(0.0),
+  contact_friction(0.0)
 {
 }
 

Modified: trunk/windstille/src/engine/script_manager.cpp
===================================================================
--- trunk/windstille/src/engine/script_manager.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/engine/script_manager.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -64,51 +64,51 @@
 {
   vm = sq_open(1024);
   if(vm == 0)
-    {
-      throw std::runtime_error("Couldn't initialize squirrel vm");
-    }
+  {
+    throw std::runtime_error("Couldn't initialize squirrel vm");
+  }
   else
-    {
-      // register default error handlers
-      sqstd_seterrorhandlers(vm);
+  {
+    // register default error handlers
+    sqstd_seterrorhandlers(vm);
 
-      { // register squirrel libs in the root table
+    { // register squirrel libs in the root table
         
-        sq_pushroottable(vm);
+      sq_pushroottable(vm);
       
-        /* FIXME: None of these should be needed for scripts
+      /* FIXME: None of these should be needed for scripts
 
-           if(SQ_FAILED(sqstd_register_bloblib(v)))
-           throw SquirrelError(v, "Couldn't register blob lib");
+         if(SQ_FAILED(sqstd_register_bloblib(v)))
+         throw SquirrelError(v, "Couldn't register blob lib");
 
-           if(SQ_FAILED(sqstd_register_iolib(v)))
-           throw SquirrelError(v, "Couldn't register io lib");
+         if(SQ_FAILED(sqstd_register_iolib(v)))
+         throw SquirrelError(v, "Couldn't register io lib");
 
-           if(SQ_FAILED(sqstd_register_systemlib(v)))
-           throw SquirrelError(v, "Couldn't register system lib");
-        */
+         if(SQ_FAILED(sqstd_register_systemlib(v)))
+         throw SquirrelError(v, "Couldn't register system lib");
+      */
 
-        if(SQ_FAILED(sqstd_register_mathlib(vm)))
-          throw SquirrelError(vm, "Couldn't register math lib");
+      if(SQ_FAILED(sqstd_register_mathlib(vm)))
+        throw SquirrelError(vm, "Couldn't register math lib");
 
-        if(SQ_FAILED(sqstd_register_stringlib(vm)))
-          throw SquirrelError(vm, "Couldn't register string lib");
+      if(SQ_FAILED(sqstd_register_stringlib(vm)))
+        throw SquirrelError(vm, "Couldn't register string lib");
 
-        // register print function
-        sq_setprintfunc(vm, printfunc);
+      // register print function
+      sq_setprintfunc(vm, printfunc);
   
-        // register windstille API
-        Scripting::register_windstille_wrapper(vm);
-        sq_pop(vm, 1);
-      }
-
-      // Create the empty "objects" table
-      sq_pushroottable(vm);
-      sq_pushstring(vm, OBJECTS_TABLE, -1);
-      sq_newtable(vm);
-      sq_newslot(vm, -3, SQFalse);
+      // register windstille API
+      Scripting::register_windstille_wrapper(vm);
       sq_pop(vm, 1);
     }
+
+    // Create the empty "objects" table
+    sq_pushroottable(vm);
+    sq_pushstring(vm, OBJECTS_TABLE, -1);
+    sq_newtable(vm);
+    sq_newslot(vm, -3, SQFalse);
+    sq_pop(vm, 1);
+  }
 }
 
 ScriptManager::~ScriptManager()
@@ -134,94 +134,94 @@
   std::ifstream in(filename.get_sys_path().c_str());
 
   if (global)
-    {
-      // Scripts run in the global namespace must not suspend
+  {
+    // Scripts run in the global namespace must not suspend
 
-      // Compile the script and push it on the stack
-      if (sq_compile(vm, squirrel_read_char, &in, filename.get_sys_path().c_str(), true) < 0)
-        throw SquirrelError(vm, "Couldn't parse script");
+    // Compile the script and push it on the stack
+    if (sq_compile(vm, squirrel_read_char, &in, filename.get_sys_path().c_str(), true) < 0)
+      throw SquirrelError(vm, "Couldn't parse script");
 
-      // Set 'this' environment
-      sq_pushroottable(vm);
+    // Set 'this' environment
+    sq_pushroottable(vm);
 
-      // Execute the script
-      if (SQ_FAILED(sq_call(vm, 1, false, true)))
-        {
-          std::ostringstream str;
-          str << "SquirrelThread::run(): " << filename << ": Couldn't start script";
-          throw SquirrelError(vm, str.str());
-        }
-      else
-        {
-          sq_pop(vm, 1);
+    // Execute the script
+    if (SQ_FAILED(sq_call(vm, 1, false, true)))
+    {
+      std::ostringstream str;
+      str << "SquirrelThread::run(): " << filename << ": Couldn't start script";
+      throw SquirrelError(vm, str.str());
+    }
+    else
+    {
+      sq_pop(vm, 1);
 
-          if (sq_getvmstate(vm) != SQ_VMSTATE_IDLE)
-            {
-              std::ostringstream str;
-              str << "ScriptManager::run_script(): '" << filename << "': global scripts must not suspend";
-              throw std::runtime_error(str.str());
-            }
+      if (sq_getvmstate(vm) != SQ_VMSTATE_IDLE)
+      {
+        std::ostringstream str;
+        str << "ScriptManager::run_script(): '" << filename << "': global scripts must not suspend";
+        throw std::runtime_error(str.str());
+      }
 
-          return boost::shared_ptr<SquirrelThread>();
-        }
+      return boost::shared_ptr<SquirrelThread>();
     }
+  }
   else
+  {
+    SquirrelThreads::iterator it = squirrel_vms.end();
+
+    // Look if the VM is associated with the source file
+    for(SquirrelThreads::iterator i = squirrel_vms.begin(); i != squirrel_vms.end(); ++i)
     {
-      SquirrelThreads::iterator it = squirrel_vms.end();
-
-      // Look if the VM is associated with the source file
-      for(SquirrelThreads::iterator i = squirrel_vms.begin(); i != squirrel_vms.end(); ++i)
-        {
-          if ((*i)->get_filename() == filename)
-            {
-              it = i;
-              break;
-            }
-        }
+      if ((*i)->get_filename() == filename)
+      {
+        it = i;
+        break;
+      }
+    }
       
-      if (it != squirrel_vms.end())
-        {
-          // Call the run method
-          if ((*it)->is_idle())
-            {
-              (*it)->call("run");
-              return *it;
-            }
-          else
-            {
-              std::ostringstream str;
-              str << filename << ": ScriptManager::run_script(): Script must be idle to be 'run()'";
-              throw std::runtime_error(str.str());
-            }
-        }
+    if (it != squirrel_vms.end())
+    {
+      // Call the run method
+      if ((*it)->is_idle())
+      {
+        (*it)->call("run");
+        return *it;
+      }
       else
-        { // Add VM to the list of VMs
-          squirrel_vms.push_back(boost::shared_ptr<SquirrelThread>(new SquirrelThread(vm, true)));
-          squirrel_vms.back()->load(in, filename);
-          squirrel_vms.back()->call("init");
-          squirrel_vms.back()->call("run");
-          return squirrel_vms.back();
-        }
+      {
+        std::ostringstream str;
+        str << filename << ": ScriptManager::run_script(): Script must be idle to be 'run()'";
+        throw std::runtime_error(str.str());
+      }
     }
+    else
+    { // Add VM to the list of VMs
+      squirrel_vms.push_back(boost::shared_ptr<SquirrelThread>(new SquirrelThread(vm, true)));
+      squirrel_vms.back()->load(in, filename);
+      squirrel_vms.back()->call("init");
+      squirrel_vms.back()->call("run");
+      return squirrel_vms.back();
+    }
+  }
 }
 
 void
 ScriptManager::update()
 {
   for(SquirrelThreads::iterator i = squirrel_vms.begin(); i != squirrel_vms.end(); ++i)
-    {
-      (*i)->update();
-    }
+  {
+    (*i)->update();
+  }
 }
 
 boost::shared_ptr<SquirrelThread>
 ScriptManager::get_thread(HSQUIRRELVM v) const
 {
   for(SquirrelThreads::const_iterator i = squirrel_vms.begin(); i != squirrel_vms.end(); ++i) 
-    {
-      if ((*i)->get_thread() == v)
-        return *i;
-    }
+  {
+    if ((*i)->get_thread() == v)
+      return *i;
+  }
 
   return boost::shared_ptr<SquirrelThread>();
 }
@@ -232,9 +232,9 @@
   assert(event.type >= 0 && event.type < MAX_WAKEUP_EVENT_COUNT);
 
   for(SquirrelThreads::iterator i = squirrel_vms.begin(); i != squirrel_vms.end(); ++i) 
-    {
-      (*i)->fire_wakeup_event(event);
-    }
+  {
+    (*i)->fire_wakeup_event(event);
+  }
 }
 
 void
@@ -251,11 +251,11 @@
   sq_pushroottable(v);
   sq_pushstring(v, OBJECTS_TABLE, -1);
   if(SQ_FAILED(sq_get(v, -2)))
-    {
-      std::ostringstream msg;
-      msg << "Couldn't get objects table '" << OBJECTS_TABLE << "'";
-      throw SquirrelError(v, msg.str());
-    }
+  {
+    std::ostringstream msg;
+    msg << "Couldn't get objects table '" << OBJECTS_TABLE << "'";
+    throw SquirrelError(v, msg.str());
+  }
 
   // remove object from table
   sq_pushstring(v, object->get_name().c_str(), object->get_name().size());
@@ -275,23 +275,23 @@
 static inline void create_squirrel_instance(HSQUIRRELVM v, boost::shared_ptr<GameObject> object)
 {
   if (dynamic_cast<ScriptableObject*>(object.get()))
-    {
-      create_squirrel_instance(v, new Scripting::ScriptableObject(object),
-                               true);
-      return;
-    }
+  {
+    create_squirrel_instance(v, new Scripting::ScriptableObject(object),
+                             true);
+    return;
+  }
   
   if (dynamic_cast<TestObject*>(object.get()))
-    {
-      create_squirrel_instance(v, new Scripting::TestObject(object), true);
-      return;
-    }                                                                             
+  {
+    create_squirrel_instance(v, new Scripting::TestObject(object), true);
+    return;
+  }                                                                             
 
   if (dynamic_cast<Player*>(object.get()))
-    {
-      create_squirrel_instance(v, new Scripting::Player(object), true);
-      return;
-    }
+  {
+    create_squirrel_instance(v, new Scripting::Player(object), true);
+    return;
+  }
 
   create_squirrel_instance(v, new Scripting::GameObject(object), true);
 }
@@ -304,21 +304,21 @@
   sq_pushroottable(v);
   sq_pushstring(v, OBJECTS_TABLE, -1);
   if(SQ_FAILED(sq_get(v, -2)))
-    {
-      std::ostringstream msg;
-      msg << "Couldn't get objects table '" << OBJECTS_TABLE << "'";
-      throw SquirrelError(v, msg.str());
-    }
+  {
+    std::ostringstream msg;
+    msg << "Couldn't get objects table '" << OBJECTS_TABLE << "'";
+    throw SquirrelError(v, msg.str());
+  }
   
   // create squirrel instance and register in table
   sq_pushstring(v, object->get_name().c_str(), object->get_name().size());
   create_squirrel_instance(v, object);
   if(SQ_FAILED(sq_createslot(v, -3)))
-    {
-      std::ostringstream msg;
-      msg << "Couldn't register object in objects tab?e";
-      throw SquirrelError(v, msg.str());
-    }
+  {
+    std::ostringstream msg;
+    msg << "Couldn't register object in objects tab?e";
+    throw SquirrelError(v, msg.str());
+  }
 
   // pop roottable and objects table
   sq_pop(v, 2);

Modified: trunk/windstille/src/engine/script_manager.hpp
===================================================================
--- trunk/windstille/src/engine/script_manager.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/engine/script_manager.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -47,17 +47,17 @@
 {
 public:
   enum WakeupEvent 
-    {
-      NO_EVENT,
-      TIME,
-      DIALOG_CLOSED,
-      CONVERSATION_CLOSED,
-      SPEECH_DONE,
-      FADE_DONE,
-      CAMERA_DONE,
-      GAMEOBJECT_DONE,
-      MAX_WAKEUP_EVENT_COUNT
-    };
+  {
+    NO_EVENT,
+    TIME,
+    DIALOG_CLOSED,
+    CONVERSATION_CLOSED,
+    SPEECH_DONE,
+    FADE_DONE,
+    CAMERA_DONE,
+    GAMEOBJECT_DONE,
+    MAX_WAKEUP_EVENT_COUNT
+  };
 
   struct WakeupData 
   {

Modified: trunk/windstille/src/engine/sector.cpp
===================================================================
--- trunk/windstille/src/engine/sector.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/engine/sector.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -31,21 +31,21 @@
 #include "sound/sound_manager.hpp"
 #include "tile/tile_map.hpp"
 
-Sector::Sector(const Pathname& arg_filename)
-  : collision_engine(new CollisionEngine()),
-    navigation_graph(new NavigationGraph()),
-    scene_graph(new SceneGraph()),
-    filename(arg_filename),
-    name(),
-    music(),
-    init_script(),
-    vm(),
-    objects(),
-    new_objects(),
-    ambient_light(),
-    interactive_tilemap(0),
-    interactivebackground_tilemap(0),
-    player()
+Sector::Sector(const Pathname& arg_filename) :
+  collision_engine(new CollisionEngine()),
+  navigation_graph(new NavigationGraph()),
+  scene_graph(new SceneGraph()),
+  filename(arg_filename),
+  name(),
+  music(),
+  init_script(),
+  vm(),
+  objects(),
+  new_objects(),
+  ambient_light(),
+  interactive_tilemap(0),
+  interactivebackground_tilemap(0),
+  player()
 {
   SectorBuilder(arg_filename, *this);
 
@@ -94,10 +94,10 @@
   sc.light().fill_screen(ambient_light);
 
   for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-    {
-      if ((*i)->is_active())
-        (*i)->draw(sc);
-    }
+  {
+    if ((*i)->is_active())
+      (*i)->draw(sc);
+  }
 }
 
 void Sector::commit_adds()
@@ -119,10 +119,10 @@
   collision_engine->update(delta);
 
   for(Objects::iterator i = objects.begin(); i != objects.end(); ++i) 
-    {
-      if ((*i)->is_active())
-        (*i)->update(delta);
-    }
+  {
+    if ((*i)->is_active())
+      (*i)->update(delta);
+  }
 
   commit_removes();
 }
@@ -132,22 +132,22 @@
 {
   // remove objects
   for(Objects::iterator i = objects.begin(); i != objects.end(); ) 
+  {
+    boost::shared_ptr<GameObject>& object = *i;
+
+    if(object->is_removable()) 
     {
-      boost::shared_ptr<GameObject>& object = *i;
+      if(object->get_name() != "") 
+      {
+        ScriptManager::current()->remove_object_from_squirrel(object);
+      }
 
-      if(object->is_removable()) 
-        {
-          if(object->get_name() != "") 
-            {
-              ScriptManager::current()->remove_object_from_squirrel(object);
-            }
+      i = objects.erase(i);
+      continue;
+    }
 
-          i = objects.erase(i);
-          continue;
-        }
-
-      ++i;
-    }
+    ++i;
+  }
 }
 
 void
@@ -156,21 +156,21 @@
   new_objects.push_back(obj);
 
   if(obj->get_name() != "") 
-    {
-      ScriptManager::current()->expose_object_to_squirrel(new_objects.back());
-    }
+  {
+    ScriptManager::current()->expose_object_to_squirrel(new_objects.back());
+  }
 }
 
 GameObject*
 Sector::get_object(const std::string& name_) const
 {
   for(Objects::const_iterator i = objects.begin(); i != objects.end(); ++i) 
+  {
+    if ((*i)->get_name() == name_)
     {
-      if ((*i)->get_name() == name_)
-        {
-          return i->get();
-        }
+      return i->get();
     }
+  }
 
   return 0;
 }
@@ -227,20 +227,20 @@
 Sector::call_script_function(const std::string& name_)
 {
   if (!vm.get())
+  {
+    throw std::runtime_error("Sector::call_script_function(): Can't call function '" + name_ + "' without a init script");
+  }
+  else
+  {
+    if (!vm->is_idle())
     {
-      throw std::runtime_error("Sector::call_script_function(): Can't call function '" + name_ + "' without a init script");
+      throw std::runtime_error("Sector::call_script_function(): VM must be idle to call  '" + name_ + "'");
     }
-  else
+    else
     {
-      if (!vm->is_idle())
-        {
-          throw std::runtime_error("Sector::call_script_function(): VM must be idle to call  '" + name_ + "'");
-        }
-      else
-        {
-          vm->call(name_);
-        }
+      vm->call(name_);
     }
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/engine/sector_builder.cpp
===================================================================
--- trunk/windstille/src/engine/sector_builder.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/engine/sector_builder.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -32,11 +32,11 @@
 #include "tile/tile_map.hpp"
 #include "util/file_reader.hpp"
 
-SectorBuilder::SectorBuilder(const Pathname& filename, Sector& sector)
-  : m_filename(filename),
-    m_sector(sector),
-    id_table(),
-    parent_table()
+SectorBuilder::SectorBuilder(const Pathname& filename, Sector& sector) :
+  m_filename(filename),
+  m_sector(sector),
+  id_table(),
+  parent_table()
 {
   FileReader reader = FileReader::parse(m_filename);
   if(reader.get_name() != "windstille-sector") 

Modified: trunk/windstille/src/engine/squirrel_thread.cpp
===================================================================
--- trunk/windstille/src/engine/squirrel_thread.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/engine/squirrel_thread.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -45,69 +45,69 @@
   thread = sq_newthread(parent_vm, 1024);  // create thread and store it on the stack
 
   if (thread == 0)
-    {
-      throw SquirrelError(thread, filename, "Couldn't create new THREAD");
-    }
+  {
+    throw SquirrelError(thread, filename, "Couldn't create new THREAD");
+  }
   else
-    { // Create a HSQOBJECT to hold a reference to the thread
+  { // Create a HSQOBJECT to hold a reference to the thread
 
-      sq_resetobject(&thread_obj); // init the object
+    sq_resetobject(&thread_obj); // init the object
 
-      // store thread created by sq_newthread into thread_obj
-      if (sq_getstackobj(parent_vm, -1, &thread_obj) < 0)
-        {
-          throw SquirrelError(parent_vm, filename, "Couldn't get coroutine thread from stack");
-        }
-      else
-        {
-          sq_addref(parent_vm, &thread_obj); // add reference
-          sq_pop(parent_vm, 1); // remove the thread from the stack
-        }
+    // store thread created by sq_newthread into thread_obj
+    if (sq_getstackobj(parent_vm, -1, &thread_obj) < 0)
+    {
+      throw SquirrelError(parent_vm, filename, "Couldn't get coroutine thread from stack");
     }
+    else
+    {
+      sq_addref(parent_vm, &thread_obj); // add reference
+      sq_pop(parent_vm, 1); // remove the thread from the stack
+    }
+  }
 }
 
-SquirrelThread::SquirrelThread(HSQUIRRELVM parent_vm_, bool isolated_)
-  : parent_vm(parent_vm_),
-    isolated(isolated_),
-    thread(0),
-    filename("<unset>"),
-    oldtop(-1),
-    waiting_for_events(ScriptManager::NO_EVENT),
-    wakeup_time(0)
+SquirrelThread::SquirrelThread(HSQUIRRELVM parent_vm_, bool isolated_) :
+  parent_vm(parent_vm_),
+  isolated(isolated_),
+  thread(0),
+  filename("<unset>"),
+  oldtop(-1),
+  waiting_for_events(ScriptManager::NO_EVENT),
+  wakeup_time(0)
 {
   create_thread();
 
   std::cout << "SquirrelThread: isolated = " << isolated << std::endl;
   if (isolated)
-    { // create a local environment for the thread
-      HSQOBJECT env;
-      sq_resetobject(&env);
+  { // create a local environment for the thread
+    HSQOBJECT env;
+    sq_resetobject(&env);
 
-      sq_newtable(thread);
+    sq_newtable(thread);
 
-      // store the object in env
-      if(sq_getstackobj(thread, -1, &env) < 0) 
-        {
-          throw SquirrelError(parent_vm, filename, "couldn't get table from stack");
-        }
-      else
-        {
-          sq_addref(thread, &env); 
-          sq_pop(thread, 1); // remove env from stack
+    // store the object in env
+    if(sq_getstackobj(thread, -1, &env) < 0) 
+    {
+      throw SquirrelError(parent_vm, filename, "couldn't get table from stack");
+    }
+    else
+    {
+      sq_addref(thread, &env); 
+      sq_pop(thread, 1); // remove env from stack
     
-          // set old roottable as delegate on env
-          sq_pushobject(thread, env); // push env
-          sq_pushroottable(thread);   // [env, root]
-          sq_setdelegate(thread, -2); // env.set_delegate(root)
-          sq_pop(thread, 1);          // pop env
+      // set old roottable as delegate on env
+      sq_pushobject(thread, env); // push env
+      sq_pushroottable(thread);   // [env, root]
+      sq_setdelegate(thread, -2); // env.set_delegate(root)
+      sq_pop(thread, 1);          // pop env
 
-          // set env as new roottable
-          sq_pushobject(thread, env);
-          sq_setroottable(thread);
+      // set env as new roottable
+      sq_pushobject(thread, env);
+      sq_setroottable(thread);
 
-          sq_release(thread, &env);
-        }
+      sq_release(thread, &env);
     }
+  }
 }
 
 void
@@ -119,29 +119,29 @@
 
   // compile the script and push it on the stack
   if (SQ_FAILED(sq_compile(thread, squirrel_read_char, &in, filename.get_sys_path().c_str(), SQTrue)))
+  {
+    throw SquirrelError(thread, filename, "Couldn't parse script");
+  }
+  else
+  {
+    // start the script that was previously compiled
+    sq_pushroottable(thread);
+    if (SQ_FAILED(sq_call(thread, 1, SQFalse, SQTrue)))
     {
-      throw SquirrelError(thread, filename, "Couldn't parse script");
+      sq_pop(thread, 1); // pop the compiled closure
+      throw SquirrelError(thread, filename, "SquirrelThread::load(): Couldn't start script");
     }
-  else
+    else
     {
-      // start the script that was previously compiled
-      sq_pushroottable(thread);
-      if (SQ_FAILED(sq_call(thread, 1, SQFalse, SQTrue)))
-        {
-          sq_pop(thread, 1); // pop the compiled closure
-          throw SquirrelError(thread, filename, "SquirrelThread::load(): Couldn't start script");
-        }
-      else
-        {
-          if (sq_getvmstate(thread) != SQ_VMSTATE_IDLE)
-            {
-              std::ostringstream str;
-              str << "SquirrelThread::load(): Script '" << filename << "' must not suspend outside of run call";
-              throw SquirrelError(thread, filename, str.str());
-            }
-          sq_pop(thread, 1); // pop the compiled closure
-        }
+      if (sq_getvmstate(thread) != SQ_VMSTATE_IDLE)
+      {
+        std::ostringstream str;
+        str << "SquirrelThread::load(): Script '" << filename << "' must not suspend outside of run call";
+        throw SquirrelError(thread, filename, str.str());
+      }
+      sq_pop(thread, 1); // pop the compiled closure
     }
+  }
 }
 
 void
@@ -155,19 +155,19 @@
   // Execute the function
   sq_pushroottable(thread);
   if (SQ_FAILED(sq_call(thread, 1, SQFalse, SQTrue)))
-    {
-      if(sq_getvmstate(thread) == SQ_VMSTATE_IDLE)
-        { // Cleanup stack
-          sq_settop(thread, oldtop);
-        }
+  {
+    if(sq_getvmstate(thread) == SQ_VMSTATE_IDLE)
+    { // Cleanup stack
+      sq_settop(thread, oldtop);
+    }
 
-      throw SquirrelError(thread, filename, "SquirrelThread::run(): Couldn't start script");
-    }
+    throw SquirrelError(thread, filename, "SquirrelThread::run(): Couldn't start script");
+  }
   else
-    {
-      if(sq_getvmstate(thread) == SQ_VMSTATE_IDLE)
-        sq_settop(thread, oldtop);
-    }
+  {
+    if(sq_getvmstate(thread) == SQ_VMSTATE_IDLE)
+      sq_settop(thread, oldtop);
+  }
 }
 
 SquirrelThread::~SquirrelThread()
@@ -187,13 +187,13 @@
   waiting_for_events = event;
 
   if (timeout < 0) 
-    {
-      wakeup_time = -1;
-    } 
+  {
+    wakeup_time = -1;
+  } 
   else 
-    {
-      wakeup_time = game_time + timeout;
-    }
+  {
+    wakeup_time = game_time + timeout;
+  }
 }
 
 void
@@ -201,28 +201,28 @@
 { 
   if (waiting_for_events.type == event.type && 
       waiting_for_events.type != ScriptManager::NO_EVENT)
+  {
+    switch (event.type)
     {
-      switch (event.type)
+      case ScriptManager::SPEECH_DONE:
+        if (waiting_for_events.id == event.id)
         {
-          case ScriptManager::SPEECH_DONE:
-            if (waiting_for_events.id == event.id)
-              {
-                wakeup_time = game_time;
-              }
-            break;
+          wakeup_time = game_time;
+        }
+        break;
 
-          case ScriptManager::GAMEOBJECT_DONE:
-            if (waiting_for_events.game_object == event.game_object)
-              {
-                wakeup_time = game_time;
-              }
-            break;
+      case ScriptManager::GAMEOBJECT_DONE:
+        if (waiting_for_events.game_object == event.game_object)
+        {
+          wakeup_time = game_time;
+        }
+        break;
 
-          default:
-            wakeup_time = game_time;
-            break;
-        }
+      default:
+        wakeup_time = game_time;
+        break;
     }
+  }
 }
 
 void
@@ -231,43 +231,43 @@
   int thread_state = sq_getvmstate(thread);
     
   switch(thread_state)
-    {
-      case SQ_VMSTATE_SUSPENDED:
-        if (wakeup_time > 0 && game_time >= wakeup_time)
+  {
+    case SQ_VMSTATE_SUSPENDED:
+      if (wakeup_time > 0 && game_time >= wakeup_time)
+      {
+        waiting_for_events = ScriptManager::WakeupData(ScriptManager::NO_EVENT);
+
+        try 
+        {
+          // Try to return a value
+          if (sq_wakeupvm(thread, SQFalse, SQFalse, SQTrue) < 0)
           {
-            waiting_for_events = ScriptManager::WakeupData(ScriptManager::NO_EVENT);
-
-            try 
-              {
-                // Try to return a value
-                if (sq_wakeupvm(thread, SQFalse, SQFalse, SQTrue) < 0)
-                  {
-                    throw SquirrelError(thread, filename, "Couldn't resume script");
-                  }
-                else
-                  {
-                    if(sq_getvmstate(thread) == SQ_VMSTATE_IDLE) 
-                      { // Cleanup stack
-                        sq_settop(thread, oldtop);
-                      }
-                  }
-              }
-            catch(std::exception& e) 
-              {
-                std::cerr << "Problem executing script: " << e.what() << "\n";
-              }
+            throw SquirrelError(thread, filename, "Couldn't resume script");
           }
-        break;
+          else
+          {
+            if(sq_getvmstate(thread) == SQ_VMSTATE_IDLE) 
+            { // Cleanup stack
+              sq_settop(thread, oldtop);
+            }
+          }
+        }
+        catch(std::exception& e) 
+        {
+          std::cerr << "Problem executing script: " << e.what() << "\n";
+        }
+      }
+      break;
 
-      case SQ_VMSTATE_IDLE:
-        break;
+    case SQ_VMSTATE_IDLE:
+      break;
 
-      case SQ_VMSTATE_RUNNING: // FIXME: Can this happen without multithreading?
-        break;
+    case SQ_VMSTATE_RUNNING: // FIXME: Can this happen without multithreading?
+      break;
 
-      default: 
-        assert(!"never reached");
-    }
+    default: 
+      assert(!"never reached");
+  }
 }
 
 bool
@@ -288,15 +288,15 @@
 SquirrelThread::call(const std::string& function)
 {
   if (0)
-    { // Debug stuff that prints the current roottable and its delegate
-      sq_pushroottable(thread);
-      std::cout << ".------------------------------------------" << std::endl;
-      std::cout << "################\nRootTable:\n{{{" << Scripting::squirrel2string(thread, -1) << "\n}}}" << std::endl;
-      sq_getdelegate(thread, -1);
-      std::cout << "################\nDelegate:\n{{{" << Scripting::squirrel2string(thread, -1) << "\n}}}" << std::endl;
-      sq_pop(thread, 2);
-      std::cout << "'------------------------------------------" << std::endl;
-    }
+  { // Debug stuff that prints the current roottable and its delegate
+    sq_pushroottable(thread);
+    std::cout << ".------------------------------------------" << std::endl;
+    std::cout << "################\nRootTable:\n{{{" << Scripting::squirrel2string(thread, -1) << "\n}}}" << std::endl;
+    sq_getdelegate(thread, -1);
+    std::cout << "################\nDelegate:\n{{{" << Scripting::squirrel2string(thread, -1) << "\n}}}" << std::endl;
+    sq_pop(thread, 2);
+    std::cout << "'------------------------------------------" << std::endl;
+  }
 
   //std::cout << "SquirrelThread::call(\"" << function << "\")" << std::endl;
 
@@ -306,29 +306,29 @@
   sq_pushroottable(thread);
   sq_pushstring(thread, function.c_str(), -1);
   if (SQ_SUCCEEDED(sq_get(thread, -2)))
+  {
+    sq_pushroottable(thread);
+
+    if (SQ_FAILED(sq_call(thread, 1, SQFalse, SQTrue)))
     {
-      sq_pushroottable(thread);
-
-      if (SQ_FAILED(sq_call(thread, 1, SQFalse, SQTrue)))
-        {
-          sq_settop(thread, oldtop);
-          throw SquirrelError(thread, filename, "SquirrelThread: couldn't call '" + function + "'");
-        }
-      else
-        {
-          if(sq_getvmstate(thread) != SQ_VMSTATE_SUSPENDED) 
-            {
-              sq_settop(thread, oldtop);
-            }
-        }
+      sq_settop(thread, oldtop);
+      throw SquirrelError(thread, filename, "SquirrelThread: couldn't call '" + function + "'");
     }
+    else
+    {
+      if(sq_getvmstate(thread) != SQ_VMSTATE_SUSPENDED) 
+      {
+        sq_settop(thread, oldtop);
+      }
+    }
+  }
   else
-    {
-      sq_settop(thread, oldtop);
+  {
+    sq_settop(thread, oldtop);
 
-      if (0)
-        std::cout << filename << ": Function '" << function << "' not found in roottable" << std::endl;
-    }
+    if (0)
+      std::cout << filename << ": Function '" << function << "' not found in roottable" << std::endl;
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/font/border_font_effect.cpp
===================================================================
--- trunk/windstille/src/font/border_font_effect.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/font/border_font_effect.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -21,9 +21,9 @@
 #include "display/software_surface.hpp"
 #include "font/border_font_effect.hpp"
 
-BorderFontEffect::BorderFontEffect(int size_, bool outline_)
-  : size(size_),
-    outline(outline_)
+BorderFontEffect::BorderFontEffect(int size_, bool outline_) :
+  size(size_),
+  outline(outline_)
 {
 }
 
@@ -82,44 +82,44 @@
   uint8_t green = 0;
 
   if (!outline)
-    {
-      red = blue = green = 255;
-    }
+  {
+    red = blue = green = 255;
+  }
 
   // Draw the border
   for (int y = start_y; y < end_y; ++y)
     for (int x = start_x; x < end_x; ++x)
-      {
-        for(int by = -size; by <= size; ++by)
-          for(int bx = -size+abs(by); bx <= size-abs(by); ++bx)
-            {
-              int target_pos = (y + y_pos + by) * target_pitch + 4*(x + x_pos + bx);
-              int brush_pos  = y * brush.pitch + x;
+    {
+      for(int by = -size; by <= size; ++by)
+        for(int bx = -size+abs(by); bx <= size-abs(by); ++bx)
+        {
+          int target_pos = (y + y_pos + by) * target_pitch + 4*(x + x_pos + bx);
+          int brush_pos  = y * brush.pitch + x;
             
-              target_buf[target_pos + 0] = red;
-              target_buf[target_pos + 1] = blue;
-              target_buf[target_pos + 2] = green;
-              target_buf[target_pos + 3] = static_cast<uint8_t>(std::min(target_buf[target_pos + 3] + brush.buffer[brush_pos], 255));
-            }
-      }
+          target_buf[target_pos + 0] = red;
+          target_buf[target_pos + 1] = blue;
+          target_buf[target_pos + 2] = green;
+          target_buf[target_pos + 3] = static_cast<uint8_t>(std::min(target_buf[target_pos + 3] + brush.buffer[brush_pos], 255));
+        }
+    }
 
   if (outline)
-    {
-      // Draw the font itself
-      for (int y = start_y; y < end_y; ++y)
-        for (int x = start_x; x < end_x; ++x)
-          {
-            int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
-            int brush_pos  = y * brush.pitch + x;
+  {
+    // Draw the font itself
+    for (int y = start_y; y < end_y; ++y)
+      for (int x = start_x; x < end_x; ++x)
+      {
+        int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
+        int brush_pos  = y * brush.pitch + x;
         
-            int alpha = brush.buffer[brush_pos];
+        int alpha = brush.buffer[brush_pos];
 
-            target_buf[target_pos + 0] = static_cast<uint8_t>(std::min((target_buf[target_pos + 0] * (255 - alpha) + alpha * 255)/255, 255));
-            target_buf[target_pos + 1] = static_cast<uint8_t>(std::min((target_buf[target_pos + 1] * (255 - alpha) + alpha * 255)/255, 255));
-            target_buf[target_pos + 2] = static_cast<uint8_t>(std::min((target_buf[target_pos + 2] * (255 - alpha) + alpha * 255)/255, 255));
-            target_buf[target_pos + 3] = static_cast<uint8_t>(std::min(target_buf[target_pos + 3] + brush.buffer[brush_pos], 255));
-          }
-    }
+        target_buf[target_pos + 0] = static_cast<uint8_t>(std::min((target_buf[target_pos + 0] * (255 - alpha) + alpha * 255)/255, 255));
+        target_buf[target_pos + 1] = static_cast<uint8_t>(std::min((target_buf[target_pos + 1] * (255 - alpha) + alpha * 255)/255, 255));
+        target_buf[target_pos + 2] = static_cast<uint8_t>(std::min((target_buf[target_pos + 2] * (255 - alpha) + alpha * 255)/255, 255));
+        target_buf[target_pos + 3] = static_cast<uint8_t>(std::min(target_buf[target_pos + 3] + brush.buffer[brush_pos], 255));
+      }
+  }
 }  
 
 /* EOF */

Modified: trunk/windstille/src/font/border_font_effect.hpp
===================================================================
--- trunk/windstille/src/font/border_font_effect.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/font/border_font_effect.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -33,7 +33,7 @@
       
       @param size     Size of the border in pixel
       @param outline  If true add the border as an outline to the font, else add it to the font itself
-   */
+  */
   BorderFontEffect(int size, bool outline);
   ~BorderFontEffect();
   
@@ -48,9 +48,9 @@
   void blit(const SoftwareSurface& target, const FT_Bitmap& brush, int x_pos, int y_pos) const;
 
   /* disabled for g++-4.2 compatibilty
-  private:
-    BorderFontEffect (const BorderFontEffect&);
-    BorderFontEffect& operator= (const BorderFontEffect&);
+     private:
+     BorderFontEffect (const BorderFontEffect&);
+     BorderFontEffect& operator= (const BorderFontEffect&);
   */
 };
 

Modified: trunk/windstille/src/font/font_effect.hpp
===================================================================
--- trunk/windstille/src/font/font_effect.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/font/font_effect.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -49,9 +49,9 @@
   virtual void blit(const SoftwareSurface& target, const FT_Bitmap& brush, int x_pos, int y_pos) const =0;
 
   /* disabled for g++-4.2 compatibilty
-private:
-  FontEffect (const FontEffect&);
-  FontEffect& operator= (const FontEffect&);
+     private:
+     FontEffect (const FontEffect&);
+     FontEffect& operator= (const FontEffect&);
   */
 };
 

Modified: trunk/windstille/src/font/fonts.cpp
===================================================================
--- trunk/windstille/src/font/fonts.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/font/fonts.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -19,10 +19,10 @@
 #include "font/border_font_effect.hpp"
 #include "font/fonts.hpp"
 
-Fonts::Fonts()
-  : ttffont(new TTFFont(Pathname("fonts/VeraMono.ttf"), 14, BorderFontEffect(1, true))),
-    vera12(new TTFFont(Pathname("fonts/Vera.ttf"),     12, BorderFontEffect(2, true))),
-    vera20(new TTFFont(Pathname("fonts/Vera.ttf"),     20, BorderFontEffect(2, true)))
+Fonts::Fonts() :
+  ttffont(new TTFFont(Pathname("fonts/VeraMono.ttf"), 14, BorderFontEffect(1, true))),
+  vera12(new TTFFont(Pathname("fonts/Vera.ttf"),     12, BorderFontEffect(2, true))),
+  vera20(new TTFFont(Pathname("fonts/Vera.ttf"),     20, BorderFontEffect(2, true)))
 {
 }
 

Modified: trunk/windstille/src/font/no_font_effect.cpp
===================================================================
--- trunk/windstille/src/font/no_font_effect.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/font/no_font_effect.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -34,15 +34,15 @@
 
   for (int y = start_y; y < end_y; ++y)
     for (int x = start_x; x < end_x; ++x)
-      {
-        int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
-        int brush_pos  = y * brush.pitch + x;
+    {
+      int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
+      int brush_pos  = y * brush.pitch + x;
             
-        target_buf[target_pos + 0] = 255;
-        target_buf[target_pos + 1] = 255;
-        target_buf[target_pos + 2] = 255;
-        target_buf[target_pos + 3] = brush.buffer[brush_pos];
-      }
+      target_buf[target_pos + 0] = 255;
+      target_buf[target_pos + 1] = 255;
+      target_buf[target_pos + 2] = 255;
+      target_buf[target_pos + 3] = brush.buffer[brush_pos];
+    }
 }
 
 /* EOF */

Modified: trunk/windstille/src/font/no_font_effect.hpp
===================================================================
--- trunk/windstille/src/font/no_font_effect.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/font/no_font_effect.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -39,9 +39,9 @@
   void blit(const SoftwareSurface& target, const FT_Bitmap& brush, int x_pos, int y_pos) const;
   
   /* disabled for g++-4.2 compatibilty
-private:
-  NoFontEffect (const NoFontEffect&);
-  NoFontEffect& operator= (const NoFontEffect&);
+     private:
+     NoFontEffect (const NoFontEffect&);
+     NoFontEffect& operator= (const NoFontEffect&);
   */
 };
 

Modified: trunk/windstille/src/font/ttf_font.cpp
===================================================================
--- trunk/windstille/src/font/ttf_font.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/font/ttf_font.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -31,10 +31,10 @@
 
 TTFCharacter::TTFCharacter(const Rect& pos_,
                            const Rectf& uv_, 
-                           int advance_)
-  : pos(pos_),
-    uv(uv_), 
-    advance(advance_)
+                           int advance_) :
+  pos(pos_),
+  uv(uv_), 
+  advance(advance_)
 {
 }
 
@@ -63,8 +63,8 @@
 
 FT_Library TTFFontImpl::library;
 
-TTFFont::TTFFont(const Pathname& filename, int size_, const FontEffect& effect)
-  : impl(new TTFFontImpl())
+TTFFont::TTFFont(const Pathname& filename, int size_, const FontEffect& effect) :
+  impl(new TTFFontImpl())
 {
   assert(size_ > 0);
 
@@ -78,11 +78,11 @@
   if (FT_New_Memory_Face(TTFFontImpl::library, 
                          reinterpret_cast<FT_Byte*>(&*buffer.begin()), buffer.size(), 
                          0, &face))
-    {
-      std::ostringstream str;
-      str << "Couldn't load font: " << filename;
-      throw std::runtime_error(str.str());
-    }
+  {
+    std::ostringstream str;
+    str << "Couldn't load font: " << filename;
+    throw std::runtime_error(str.str());
+  }
   
   FT_Set_Pixel_Sizes(face, impl->size, impl->size);
 
@@ -108,45 +108,45 @@
 
   // We limit ourself to 256 characters for the momemnt
   for(std::vector<uint32_t>::iterator i = characters.begin(); i != characters.end(); ++i)
+  {
+    if (FT_Load_Char( face,  *i, FT_LOAD_RENDER))
     {
-      if (FT_Load_Char( face,  *i, FT_LOAD_RENDER))
-        {
-          // FIXME: What happens when character is not in font, should be handled more gentle
-          throw std::runtime_error("couldn't load char");
-        }
-      else
-        {      
-          effect.blit(pixelbuffer, face->glyph->bitmap, x_pos, y_pos);
+      // FIXME: What happens when character is not in font, should be handled more gentle
+      throw std::runtime_error("couldn't load char");
+    }
+    else
+    {      
+      effect.blit(pixelbuffer, face->glyph->bitmap, x_pos, y_pos);
 
-          int glyph_width  = effect.get_glyph_width(face->glyph->bitmap.width);
-          int glyph_height = effect.get_glyph_height(face->glyph->bitmap.rows);
+      int glyph_width  = effect.get_glyph_width(face->glyph->bitmap.width);
+      int glyph_height = effect.get_glyph_height(face->glyph->bitmap.rows);
 
-          generate_border(pixelbuffer, x_pos, y_pos, glyph_width, glyph_height);
+      generate_border(pixelbuffer, x_pos, y_pos, glyph_width, glyph_height);
 
-          Rect pos(Point(effect.get_x_offset(face->glyph->bitmap_left),
-                         effect.get_y_offset(-face->glyph->bitmap_top)),
-                   Size(glyph_width, glyph_height));
+      Rect pos(Point(effect.get_x_offset(face->glyph->bitmap_left),
+                     effect.get_y_offset(-face->glyph->bitmap_top)),
+               Size(glyph_width, glyph_height));
 
-          Rectf uv(static_cast<float>(x_pos) / static_cast<float>(pixelbuffer.get_width()),
-                   static_cast<float>(y_pos) / static_cast<float>(pixelbuffer.get_height()),
-                   static_cast<float>(x_pos + glyph_width)/static_cast<float>(pixelbuffer.get_width()),
-                   static_cast<float>(y_pos + glyph_height)/static_cast<float>(pixelbuffer.get_height()));
+      Rectf uv(static_cast<float>(x_pos) / static_cast<float>(pixelbuffer.get_width()),
+               static_cast<float>(y_pos) / static_cast<float>(pixelbuffer.get_height()),
+               static_cast<float>(x_pos + glyph_width)/static_cast<float>(pixelbuffer.get_width()),
+               static_cast<float>(y_pos + glyph_height)/static_cast<float>(pixelbuffer.get_height()));
       
-          impl->characters.push_back(TTFCharacter(pos, uv,
-                                                  face->glyph->advance.x >> 6));
+      impl->characters.push_back(TTFCharacter(pos, uv,
+                                              face->glyph->advance.x >> 6));
 
-          // we leave a one pixel border around the letters which we fill with generate_border
-          x_pos += glyph_width + 2;
-          if (x_pos + max_glyph_height + 2 > pixelbuffer.get_width()) // FIXME: should use glyph_width of the next glyph instead of max_glyph_height
-            {
-              y_pos += max_glyph_height + 2;
-              x_pos = 1;
-            }
+      // we leave a one pixel border around the letters which we fill with generate_border
+      x_pos += glyph_width + 2;
+      if (x_pos + max_glyph_height + 2 > pixelbuffer.get_width()) // FIXME: should use glyph_width of the next glyph instead of max_glyph_height
+      {
+        y_pos += max_glyph_height + 2;
+        x_pos = 1;
+      }
 
-          if (y_pos + max_glyph_height + 2 > pixelbuffer.get_height())
-            throw std::runtime_error("Font Texture to small");
-        }
+      if (y_pos + max_glyph_height + 2 > pixelbuffer.get_height())
+        throw std::runtime_error("Font Texture to small");
     }
+  }
   FT_Done_Face(face);
 
   impl->texture = Texture(pixelbuffer);
@@ -186,27 +186,27 @@
 
   glBegin(GL_QUADS);
   for(std::string::const_iterator i = str.begin(); i != str.end(); ++i)
-    {
-      const TTFCharacter& character = impl->characters[*i];
+  {
+    const TTFCharacter& character = impl->characters[*i];
       
-      glTexCoord2f(character.uv.left, character.uv.top);
-      glVertex2f(pos.x + static_cast<float>(character.pos.left),
-                 pos.y + static_cast<float>(character.pos.top));
+    glTexCoord2f(character.uv.left, character.uv.top);
+    glVertex2f(pos.x + static_cast<float>(character.pos.left),
+               pos.y + static_cast<float>(character.pos.top));
 
-      glTexCoord2f(character.uv.right, character.uv.top);
-      glVertex2f(pos.x + static_cast<float>(character.pos.right),
-                 pos.y + static_cast<float>(character.pos.top));
+    glTexCoord2f(character.uv.right, character.uv.top);
+    glVertex2f(pos.x + static_cast<float>(character.pos.right),
+               pos.y + static_cast<float>(character.pos.top));
 
-      glTexCoord2f(character.uv.right, character.uv.bottom);
-      glVertex2f(pos.x + static_cast<float>(character.pos.right),
-                 pos.y + static_cast<float>(character.pos.bottom));
+    glTexCoord2f(character.uv.right, character.uv.bottom);
+    glVertex2f(pos.x + static_cast<float>(character.pos.right),
+               pos.y + static_cast<float>(character.pos.bottom));
 
-      glTexCoord2f(character.uv.left, character.uv.bottom);
-      glVertex2f(pos.x + static_cast<float>(character.pos.left),
-                 pos.y + static_cast<float>(character.pos.bottom));
+    glTexCoord2f(character.uv.left, character.uv.bottom);
+    glVertex2f(pos.x + static_cast<float>(character.pos.left),
+               pos.y + static_cast<float>(character.pos.bottom));
 
-      pos.x += static_cast<float>(character.advance);
-    }
+    pos.x += static_cast<float>(character.advance);
+  }
   glEnd();
 }
 

Modified: trunk/windstille/src/gui/automap.cpp
===================================================================
--- trunk/windstille/src/gui/automap.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/gui/automap.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -49,22 +49,22 @@
 
   for(int y = 0; y < image.get_height(); ++y)
     for(int x = 0; x < image.get_width(); ++x)
+    {
+      if (tilemap->get_pixel(x, y))
       {
-        if (tilemap->get_pixel(x, y))
-          {
-            buffer[image.get_pitch() * y + 4*x + 0] = 255;
-            buffer[image.get_pitch() * y + 4*x + 1] = 255;
-            buffer[image.get_pitch() * y + 4*x + 2] = 255;
-            buffer[image.get_pitch() * y + 4*x + 3] = 255;
-          }
-        else
-          {
-            buffer[image.get_pitch() * y + 4*x + 0] = 0;
-            buffer[image.get_pitch() * y + 4*x + 1] = 0;
-            buffer[image.get_pitch() * y + 4*x + 2] = 0;
-            buffer[image.get_pitch() * y + 4*x + 3] = 255;
-          }
+        buffer[image.get_pitch() * y + 4*x + 0] = 255;
+        buffer[image.get_pitch() * y + 4*x + 1] = 255;
+        buffer[image.get_pitch() * y + 4*x + 2] = 255;
+        buffer[image.get_pitch() * y + 4*x + 3] = 255;
       }
+      else
+      {
+        buffer[image.get_pitch() * y + 4*x + 0] = 0;
+        buffer[image.get_pitch() * y + 4*x + 1] = 0;
+        buffer[image.get_pitch() * y + 4*x + 2] = 0;
+        buffer[image.get_pitch() * y + 4*x + 3] = 255;
+      }
+    }
 
   surface = Surface(tilemap->get_width(), tilemap->get_height());
   surface.get_texture().set_filter(GL_NEAREST);
@@ -90,31 +90,31 @@
 Automap::update(float delta, const Controller& controller)
 {
   if (controller.get_button_state(AIM_BUTTON))
-    {
-      if (controller.get_axis_state(Y_AXIS) < 0)
-        zoom /= 1.0f + (0.5f * fabsf(controller.get_axis_state(Y_AXIS))) * delta;
-      else if (controller.get_axis_state(Y_AXIS) > 0)
-        zoom *= 1.0f + (0.5f * controller.get_axis_state(Y_AXIS)) * delta;
-    }
+  {
+    if (controller.get_axis_state(Y_AXIS) < 0)
+      zoom /= 1.0f + (0.5f * fabsf(controller.get_axis_state(Y_AXIS))) * delta;
+    else if (controller.get_axis_state(Y_AXIS) > 0)
+      zoom *= 1.0f + (0.5f * controller.get_axis_state(Y_AXIS)) * delta;
+  }
   else
-    {
-      pos.x += controller.get_axis_state(X_AXIS) * delta * 100.0f;
-      pos.y += controller.get_axis_state(Y_AXIS) * delta * 100.0f;
-    }
+  {
+    pos.x += controller.get_axis_state(X_AXIS) * delta * 100.0f;
+    pos.y += controller.get_axis_state(Y_AXIS) * delta * 100.0f;
+  }
 
   for(InputEventLst::const_iterator i = controller.get_events().begin(); i != controller.get_events().end(); ++i) 
+  {
+    if (i->type == BUTTON_EVENT && i->button.down)
     {
-      if (i->type == BUTTON_EVENT && i->button.down)
-        {
-          if (i->button.name == OK_BUTTON)
-            {
-            }
-          else if (i->button.name == CANCEL_BUTTON)
-            {
-              set_active(false);
-            }
-        }
+      if (i->button.name == OK_BUTTON)
+      {
+      }
+      else if (i->button.name == CANCEL_BUTTON)
+      {
+        set_active(false);
+      }
     }
+  }
 }
 
 } // namespace gui

Modified: trunk/windstille/src/gui/button.cpp
===================================================================
--- trunk/windstille/src/gui/button.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/gui/button.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -58,18 +58,18 @@
   set_active(false);
 
   for(InputEventLst::const_iterator i = controller.get_events().begin(); i != controller.get_events().end(); ++i) 
+  {
+    if (i->type == BUTTON_EVENT && i->button.down)
     {
-      if (i->type == BUTTON_EVENT && i->button.down)
-        {
-          if (i->button.name == OK_BUTTON)
-            {
-            }
-          else if (i->button.name == CANCEL_BUTTON || i->button.name == ESCAPE_BUTTON)
-            {            
-              set_active(false);
-            }
-        }
-    }  
+      if (i->button.name == OK_BUTTON)
+      {
+      }
+      else if (i->button.name == CANCEL_BUTTON || i->button.name == ESCAPE_BUTTON)
+      {            
+        set_active(false);
+      }
+    }
+  }  
 }
 
 } // namespace gui

Modified: trunk/windstille/src/gui/group_component.cpp
===================================================================
--- trunk/windstille/src/gui/group_component.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/gui/group_component.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -41,16 +41,16 @@
   Display::draw_rounded_rect(rect, 5.0f, Color(1.0f, 1.0f, 1.0f, 0.5f));
 
   if (!title.empty())
-    {
-      TTFFont* font = Fonts::current()->vera20.get();
-      font->draw_center(Vector2f(rect.left + static_cast<float>(rect.get_width()) / 2.0f,
-                                 rect.top  + static_cast<float>(font->get_height()) + 5.0f),
-                        title, Color(1.0f, 1.0f, 1.0f));
+  {
+    TTFFont* font = Fonts::current()->vera20.get();
+    font->draw_center(Vector2f(rect.left + static_cast<float>(rect.get_width()) / 2.0f,
+                               rect.top  + static_cast<float>(font->get_height()) + 5.0f),
+                      title, Color(1.0f, 1.0f, 1.0f));
 
-      Display::fill_rect(Rectf(rect.left  + 8.0f, rect.top + static_cast<float>(font->get_height()) + 16.0f,
-                               rect.right - 8.0f, rect.top + static_cast<float>(font->get_height()) + 18.0f),
-                         Color(1.0f, 1.0f, 1.0f, 0.5f));
-    }
+    Display::fill_rect(Rectf(rect.left  + 8.0f, rect.top + static_cast<float>(font->get_height()) + 16.0f,
+                             rect.right - 8.0f, rect.top + static_cast<float>(font->get_height()) + 18.0f),
+                       Color(1.0f, 1.0f, 1.0f, 0.5f));
+  }
 
   if (child.get())
     child->draw();

Modified: trunk/windstille/src/gui/gui_manager.cpp
===================================================================
--- trunk/windstille/src/gui/gui_manager.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/gui/gui_manager.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -23,7 +23,7 @@
 namespace gui {
 
 GUIManager::GUIManager()
- : root(new RootComponent(Rectf(0,0,800,600)))
+  : root(new RootComponent(Rectf(0,0,800,600)))
 {
 }
 
@@ -43,10 +43,10 @@
   root->update(delta, controller);
 
   if (!root->is_active())
-    {
-      //FIXME: This doesn't work when GUI isn't an overlay
-      ScreenManager::current()->pop_overlay();
-    }
+  {
+    //FIXME: This doesn't work when GUI isn't an overlay
+    ScreenManager::current()->pop_overlay();
+  }
 }
 
 RootComponent*

Modified: trunk/windstille/src/gui/list_view.cpp
===================================================================
--- trunk/windstille/src/gui/list_view.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/gui/list_view.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -45,74 +45,74 @@
   float padding = 10;
 
   for(int i = 0; i < int(columns.size()); ++i)
-    {
-      // FIXME: Poor mans outline effect
-      font->draw_center(Vector2f(x + columns[i].width/2 + 1, y - 1), columns[i].title);
-      font->draw_center(Vector2f(x + columns[i].width/2 - 1, y - 1), columns[i].title);
-      font->draw_center(Vector2f(x + columns[i].width/2 + 1, y + 1), columns[i].title);
-      font->draw_center(Vector2f(x + columns[i].width/2 - 1, y + 1), columns[i].title);
-      font->draw_center(Vector2f(x + columns[i].width/2, y), columns[i].title, Color(0.0f, 0.0f, 0.0f));
-      x += columns[i].width;
-    }
+  {
+    // FIXME: Poor mans outline effect
+    font->draw_center(Vector2f(x + columns[i].width/2 + 1, y - 1), columns[i].title);
+    font->draw_center(Vector2f(x + columns[i].width/2 - 1, y - 1), columns[i].title);
+    font->draw_center(Vector2f(x + columns[i].width/2 + 1, y + 1), columns[i].title);
+    font->draw_center(Vector2f(x + columns[i].width/2 - 1, y + 1), columns[i].title);
+    font->draw_center(Vector2f(x + columns[i].width/2, y), columns[i].title, Color(0.0f, 0.0f, 0.0f));
+    x += columns[i].width;
+  }
 
   for(int j = 0; j < int(items.size()); ++j)
-    {
-      x = rect.left;
+  {
+    x = rect.left;
 
-      if (j == current_item)
-        Display::fill_rect(Rectf(x, y,
-                                 rect.right, y + static_cast<float>(font->get_height())), 
-                           is_active() ? Color(0.5f, 0.5f, 1.0f, 0.8f) : Color(0.5f, 0.5f, 1.0f, 0.3f));
+    if (j == current_item)
+      Display::fill_rect(Rectf(x, y,
+                               rect.right, y + static_cast<float>(font->get_height())), 
+                         is_active() ? Color(0.5f, 0.5f, 1.0f, 0.8f) : Color(0.5f, 0.5f, 1.0f, 0.3f));
 
-      y += static_cast<float>(font->get_height());
+    y += static_cast<float>(font->get_height());
           
-      for(int i = 0; i < int(items[j].columns.size()) && i < int(columns.size()); ++i)
-        {
-          font->draw(Vector2f(x + padding, y), items[j].columns[i]);
+    for(int i = 0; i < int(items[j].columns.size()) && i < int(columns.size()); ++i)
+    {
+      font->draw(Vector2f(x + padding, y), items[j].columns[i]);
             
-          x += columns[i].width;
-        }
+      x += columns[i].width;
     }
+  }
 }
 
 void
 ListView::update(float , const Controller& controller)
 {
-   for(InputEventLst::const_iterator i = controller.get_events().begin(); 
-       i != controller.get_events().end(); ++i) 
+  for(InputEventLst::const_iterator i = controller.get_events().begin(); 
+      i != controller.get_events().end(); ++i) 
+  {
+    if (i->type == BUTTON_EVENT && i->button.down)
     {
-      if (i->type == BUTTON_EVENT && i->button.down)
+      if (i->button.name == OK_BUTTON)
+      {
+        // do something with item (scripting callback)
+      }
+      else if (i->button.name == CANCEL_BUTTON || i->button.name == ESCAPE_BUTTON)
+      {
+        set_active(false);
+      }
+    }
+    else if (i->type == AXIS_EVENT)
+    {
+      if (i->axis.name == Y_AXIS)
+      {
+        if (i->axis.pos > 0)
         {
-          if (i->button.name == OK_BUTTON)
-            {
-              // do something with item (scripting callback)
-            }
-          else if (i->button.name == CANCEL_BUTTON || i->button.name == ESCAPE_BUTTON)
-            {
-              set_active(false);
-            }
+          if (current_item == int(items.size()) - 1)
+            current_item = 0;
+          else
+            current_item += 1;
         }
-      else if (i->type == AXIS_EVENT)
+        else if (i->axis.pos < 0)
         {
-          if (i->axis.name == Y_AXIS)
-            {
-              if (i->axis.pos > 0)
-                {
-                  if (current_item == int(items.size()) - 1)
-                    current_item = 0;
-                  else
-                    current_item += 1;
-                }
-              else if (i->axis.pos < 0)
-                {
-                  if (current_item == 0)
-                    current_item = items.size() - 1;
-                  else
-                    current_item -= 1;
-                }
-            }
+          if (current_item == 0)
+            current_item = items.size() - 1;
+          else
+            current_item -= 1;
         }
+      }
     }
+  }
 }
 
 void

Modified: trunk/windstille/src/gui/menu.cpp
===================================================================
--- trunk/windstille/src/gui/menu.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/gui/menu.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -32,10 +32,10 @@
     menu()
 {
   if (!parent)
-    {
-      manager.reset(new GUIManager());
-      parent = manager->get_root();
-    }  
+  {
+    manager.reset(new GUIManager());
+    parent = manager->get_root();
+  }  
 
   group.reset(new GroupComponent(rect, name, parent));
   menu.reset(new MenuComponent(group->get_child_rect(), allow_cancel, group.get()));

Modified: trunk/windstille/src/gui/menu_component.cpp
===================================================================
--- trunk/windstille/src/gui/menu_component.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/gui/menu_component.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -40,7 +40,7 @@
 MenuComponent::~MenuComponent()
 {
   for(Items::iterator i = items.begin(); i != items.end(); ++i)
-      delete *i;
+    delete *i;
   items.clear();
 }
 
@@ -50,11 +50,11 @@
   items.push_back(item);
   
   if (calc_height() >= rect.get_height())
-    {
-      scroll_mode   = true;
-      scroll_offset = 0;
-      num_displayable_items = static_cast<int>(rect.get_height() / item_height());
-    }
+  {
+    scroll_mode   = true;
+    scroll_offset = 0;
+    num_displayable_items = static_cast<int>(rect.get_height() / item_height());
+  }
 }
 
 void
@@ -63,117 +63,117 @@
   float step = item_height();
 
   if (scroll_mode)
-    { // we can only display a subset of items and have to scroll
-      for(int i = 0; i < num_displayable_items; ++i)
-        {
-          items[i+scroll_offset]->draw(Rectf(rect.left, rect.top + static_cast<float>(i) * step + 2.0f, 
-                                             rect.right - 32.0f, rect.top + static_cast<float>(i+1) * step - 2.0f), 
-                                       is_active() && (int(i+scroll_offset) == current_item));
-        }
+  { // we can only display a subset of items and have to scroll
+    for(int i = 0; i < num_displayable_items; ++i)
+    {
+      items[i+scroll_offset]->draw(Rectf(rect.left, rect.top + static_cast<float>(i) * step + 2.0f, 
+                                         rect.right - 32.0f, rect.top + static_cast<float>(i+1) * step - 2.0f), 
+                                   is_active() && (int(i+scroll_offset) == current_item));
+    }
       
-      // draw scrollbar
-      float scrollbar_height = (rect.get_height() - 4.0f) * static_cast<float>(num_displayable_items) / static_cast<float>(items.size());
-      float scrollbar_incr   = (rect.get_height() - 4.0f) * static_cast<float>(scroll_offset) / static_cast<float>(items.size());
+    // draw scrollbar
+    float scrollbar_height = (rect.get_height() - 4.0f) * static_cast<float>(num_displayable_items) / static_cast<float>(items.size());
+    float scrollbar_incr   = (rect.get_height() - 4.0f) * static_cast<float>(scroll_offset) / static_cast<float>(items.size());
 
-      Display::fill_rounded_rect(Rectf(rect.right - 24, rect.top + 2.0f + scrollbar_incr,
-                                       rect.right - 2,  rect.top + 2.0f + scrollbar_incr + scrollbar_height),
-                                 5.0f,
-                                 Color(0.5f, 0.5f, 0.5f, 0.75f));
+    Display::fill_rounded_rect(Rectf(rect.right - 24, rect.top + 2.0f + scrollbar_incr,
+                                     rect.right - 2,  rect.top + 2.0f + scrollbar_incr + scrollbar_height),
+                               5.0f,
+                               Color(0.5f, 0.5f, 0.5f, 0.75f));
       
-      Display::draw_rounded_rect(Rectf(rect.right - 24, rect.top + 2.0f,
-                                       rect.right - 2,  rect.bottom - 2.0f),
-                                 5.0f,
-                                 Color(1.0f, 1.0f, 1.0f, 1.0f));
-    }
+    Display::draw_rounded_rect(Rectf(rect.right - 24, rect.top + 2.0f,
+                                     rect.right - 2,  rect.bottom - 2.0f),
+                               5.0f,
+                               Color(1.0f, 1.0f, 1.0f, 1.0f));
+  }
   else
-    { // all items fit on the screen
-      for(Items::size_type i = 0; i < items.size(); ++i)
-        {
-          items[i]->draw(Rectf(rect.left, rect.top + static_cast<float>(i) * step + 2.0f, 
-                               rect.right, rect.top + static_cast<float>(i+1) * step - 2.0f), 
-                         is_active() && (int(i) == current_item));
-        }
+  { // all items fit on the screen
+    for(Items::size_type i = 0; i < items.size(); ++i)
+    {
+      items[i]->draw(Rectf(rect.left, rect.top + static_cast<float>(i) * step + 2.0f, 
+                           rect.right, rect.top + static_cast<float>(i+1) * step - 2.0f), 
+                     is_active() && (int(i) == current_item));
     }
+  }
 }
 
 void
 MenuComponent::update(float delta, const Controller& controller)
 {
   for(Items::size_type i = 0; i < items.size(); ++i)
-    {
-      items[i]->update(delta);
-    }
+  {
+    items[i]->update(delta);
+  }
 
   for(InputEventLst::const_iterator i = controller.get_events().begin(); 
       i != controller.get_events().end(); 
       ++i)
+  {
+    if (i->type == BUTTON_EVENT && i->button.down)
     {
-      if (i->type == BUTTON_EVENT && i->button.down)
+      if (i->button.name == OK_BUTTON || i->button.name == ENTER_BUTTON)
+      {
+        items[current_item]->click();
+      }
+      else if (i->button.name == CANCEL_BUTTON || 
+               i->button.name == ESCAPE_BUTTON ||
+               i->button.name == PAUSE_BUTTON)
+      {
+        if (allow_cancel) // FIXME: Could use a signal instead
         {
-          if (i->button.name == OK_BUTTON || i->button.name == ENTER_BUTTON)
-            {
-              items[current_item]->click();
-            }
-          else if (i->button.name == CANCEL_BUTTON || 
-                   i->button.name == ESCAPE_BUTTON ||
-                   i->button.name == PAUSE_BUTTON)
-            {
-              if (allow_cancel) // FIXME: Could use a signal instead
-                {
-                  SoundManager::current()->play(Pathname("sounds/menu_click.wav", Pathname::kDataPath));
-                  set_active(false);
-                }
-            }
-          else if (i->button.name == MENU_LEFT_BUTTON)
-            {
-              items[current_item]->incr();              
-            }
-          else if (i->button.name == MENU_RIGHT_BUTTON)
-            {
-              items[current_item]->decr();              
-            }          
-          else if (i->button.name == MENU_UP_BUTTON)
-            {
-              SoundManager::current()->play(Pathname("sounds/menu_change.wav", Pathname::kDataPath));
+          SoundManager::current()->play(Pathname("sounds/menu_click.wav", Pathname::kDataPath));
+          set_active(false);
+        }
+      }
+      else if (i->button.name == MENU_LEFT_BUTTON)
+      {
+        items[current_item]->incr();              
+      }
+      else if (i->button.name == MENU_RIGHT_BUTTON)
+      {
+        items[current_item]->decr();              
+      }          
+      else if (i->button.name == MENU_UP_BUTTON)
+      {
+        SoundManager::current()->play(Pathname("sounds/menu_change.wav", Pathname::kDataPath));
               
-              current_item = current_item - 1;
-              if (current_item < 0)
-                {
-                  if (dynamic_cast<TabComponent*>(parent))
-                    {
-                      current_item = 0;
-                      set_active(false);
-                    }
-                  else
-                    { 
-                      current_item = static_cast<int>(items.size())-1; 
-                    }
-                }
+        current_item = current_item - 1;
+        if (current_item < 0)
+        {
+          if (dynamic_cast<TabComponent*>(parent))
+          {
+            current_item = 0;
+            set_active(false);
+          }
+          else
+          { 
+            current_item = static_cast<int>(items.size())-1; 
+          }
+        }
                   
-              adjust_scroll_offset();
-            }
-          else if (i->button.name == MENU_DOWN_BUTTON)
-            {
-              SoundManager::current()->play(Pathname("sounds/menu_change.wav", Pathname::kDataPath));
+        adjust_scroll_offset();
+      }
+      else if (i->button.name == MENU_DOWN_BUTTON)
+      {
+        SoundManager::current()->play(Pathname("sounds/menu_change.wav", Pathname::kDataPath));
 
-              if (dynamic_cast<TabComponent*>(parent))
-                {
-                  current_item = math::mid(0, current_item + 1, static_cast<int>(items.size()-1)); 
-                }
-              else
-                {
-                  current_item += 1;
-                  if (current_item >= static_cast<int>(items.size()))
-                    {
-                      current_item = 0;
-                    }
+        if (dynamic_cast<TabComponent*>(parent))
+        {
+          current_item = math::mid(0, current_item + 1, static_cast<int>(items.size()-1)); 
+        }
+        else
+        {
+          current_item += 1;
+          if (current_item >= static_cast<int>(items.size()))
+          {
+            current_item = 0;
+          }
 
-                }
+        }
 
-              adjust_scroll_offset();
-            }
-        }
+        adjust_scroll_offset();
+      }
     }
+  }
 }
 
 void
@@ -223,16 +223,16 @@
 MenuComponent::adjust_scroll_offset()
 {
   if (scroll_mode)
-    {
-      if (current_item - scroll_offset >= num_displayable_items)
-        { // scrolling down
-          scroll_offset = current_item - (num_displayable_items-1);
-        }
-      else if (current_item < scroll_offset)
-        { // scrolling up
-          scroll_offset = current_item;
-        }
-    }  
+  {
+    if (current_item - scroll_offset >= num_displayable_items)
+    { // scrolling down
+      scroll_offset = current_item - (num_displayable_items-1);
+    }
+    else if (current_item < scroll_offset)
+    { // scrolling up
+      scroll_offset = current_item;
+    }
+  }  
 }
 
 void
@@ -241,15 +241,15 @@
   num_displayable_items = static_cast<int>(rect_.get_height() / item_height());  
 
   if (num_displayable_items < int(items.size()))
-    {
-      scroll_mode   = true;
-      scroll_offset = 0;
-    }
+  {
+    scroll_mode   = true;
+    scroll_offset = 0;
+  }
   else
-    {
-      scroll_mode   = false;
-      scroll_offset = 0;
-    }
+  {
+    scroll_mode   = false;
+    scroll_offset = 0;
+  }
 
   
   Component::set_screen_rect(rect_);

Modified: trunk/windstille/src/gui/root_component.cpp
===================================================================
--- trunk/windstille/src/gui/root_component.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/gui/root_component.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -43,21 +43,21 @@
 RootComponent::draw()
 {
   for(Children::iterator i = children.begin(); i != children.end(); ++i)
-    {
-      (*i)->draw();
-    }
+  {
+    (*i)->draw();
+  }
 }
 
 void
 RootComponent::update(float delta, const Controller& controller)
 {
   for(Children::iterator i = children.begin(); i != children.end(); ++i)
-    {
-      if (*i == focus)
-        (*i)->update(delta, controller);
-      else
-        (*i)->update(delta, Controller());
-    }
+  {
+    if (*i == focus)
+      (*i)->update(delta, controller);
+    else
+      (*i)->update(delta, Controller());
+  }
 }
 
 bool
@@ -81,14 +81,14 @@
 {
   Children::iterator i = std::find(children.begin(), children.end(), child_);
   if (i != children.end())
-    {
-      focus = child_;
-      focus->set_active(true);
-    }
+  {
+    focus = child_;
+    focus->set_active(true);
+  }
   else
-    {
-      ConsoleLog << "Error: Need to add_child() first befor calling set_focus()" << std::endl;
-    }
+  {
+    ConsoleLog << "Error: Need to add_child() first befor calling set_focus()" << std::endl;
+  }
 }
 
 } // namespace gui

Modified: trunk/windstille/src/gui/slider.cpp
===================================================================
--- trunk/windstille/src/gui/slider.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/gui/slider.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -73,51 +73,51 @@
                              rect.top + 2.0f),
                     Sizef(width, rect.get_height() - 4.0f));
   if (is_active())
-    {
-      Display::fill_rect(slider_rect, Color(1.0f, 1.0f, 1.0f, 0.5f));
-      Display::draw_rect(slider_rect, Color(1.0f, 1.0f, 1.0f, 1.0f));
-    }
+  {
+    Display::fill_rect(slider_rect, Color(1.0f, 1.0f, 1.0f, 0.5f));
+    Display::draw_rect(slider_rect, Color(1.0f, 1.0f, 1.0f, 1.0f));
+  }
   else
-    {
-      Display::draw_rect(slider_rect, Color(1.0f, 1.0f, 1.0f, 0.5f));
-    }
+  {
+    Display::draw_rect(slider_rect, Color(1.0f, 1.0f, 1.0f, 0.5f));
+  }
 }
 
 void
 Slider::update(float /*delta*/, const Controller& controller)
 {
   for(InputEventLst::const_iterator i = controller.get_events().begin(); i != controller.get_events().end(); ++i) 
+  {
+    if (i->type == BUTTON_EVENT && i->button.down)
     {
-      if (i->type == BUTTON_EVENT && i->button.down)
+      if (i->button.name == OK_BUTTON || i->button.name == ENTER_BUTTON)
+      {
+              
+      }
+      else if (i->button.name == CANCEL_BUTTON || i->button.name == ESCAPE_BUTTON)
+      {
+        set_active(false);
+      }
+    }
+    else if (i->type == AXIS_EVENT)
+    {
+      if (i->axis.name == X_AXIS)
+      {
+        if (i->axis.pos < 0)
         {
-          if (i->button.name == OK_BUTTON || i->button.name == ENTER_BUTTON)
-            {
-              
-            }
-          else if (i->button.name == CANCEL_BUTTON || i->button.name == ESCAPE_BUTTON)
-            {
-              set_active(false);
-            }
+          pos -= step;
+          if (pos < min) 
+            pos = min;
         }
-      else if (i->type == AXIS_EVENT)
+        else if (i->axis.pos > 0)
         {
-          if (i->axis.name == X_AXIS)
-            {
-              if (i->axis.pos < 0)
-                {
-                  pos -= step;
-                  if (pos < min) 
-                    pos = min;
-                }
-              else if (i->axis.pos > 0)
-                {
-                  pos += step;
-                  if (pos > max) 
-                    pos = max;
-                }
-            }
+          pos += step;
+          if (pos > max) 
+            pos = max;
         }
+      }
     }
+  }
 }
 
 int

Modified: trunk/windstille/src/gui/tab_component.cpp
===================================================================
--- trunk/windstille/src/gui/tab_component.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/gui/tab_component.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -49,25 +49,25 @@
 
   float tab_width = rect.get_width() / static_cast<float>(tabs.size());
   for(int i = 0; i != int(tabs.size()); ++i)
-    {
-      Rectf tab_rect(Vector2f(rect.left + tab_width * static_cast<float>(i) + 10.0f,
-                              rect.top),
-                     Sizef(tab_width - 20.0f, static_cast<float>(Fonts::current()->vera20->get_height()) + 6.0f));
+  {
+    Rectf tab_rect(Vector2f(rect.left + tab_width * static_cast<float>(i) + 10.0f,
+                            rect.top),
+                   Sizef(tab_width - 20.0f, static_cast<float>(Fonts::current()->vera20->get_height()) + 6.0f));
 
-      if (i == current_tab)
-        Display::fill_rounded_rect(tab_rect, 5.0f, Color(1.0f, 1.0f, 1.0f, 0.5f));
-      else
-        Display::fill_rounded_rect(tab_rect, 5.0f, Color(0.0f, 0.0f, 0.0f, 0.5f));
+    if (i == current_tab)
+      Display::fill_rounded_rect(tab_rect, 5.0f, Color(1.0f, 1.0f, 1.0f, 0.5f));
+    else
+      Display::fill_rounded_rect(tab_rect, 5.0f, Color(0.0f, 0.0f, 0.0f, 0.5f));
 
-      Display::draw_rounded_rect(tab_rect, 5.0f, Color(1.0f, 1.0f, 1.0f, 0.5f));
+    Display::draw_rounded_rect(tab_rect, 5.0f, Color(1.0f, 1.0f, 1.0f, 0.5f));
 
-      Fonts::current()->vera20->draw_center(Vector2f(rect.left + tab_width * static_cast<float>(i) + tab_width/2,
-                                                     rect.top + static_cast<float>(Fonts::current()->vera20->get_height())),
-                                            tabs[i].label,
-                                            tabs[current_tab].component->is_active()
-                                            ? Color(1.0f, 1.0f, 1.0f, 0.5f) 
-                                            : Color(1.0f, 1.0f, 1.0f, 1.0f));
-    }
+    Fonts::current()->vera20->draw_center(Vector2f(rect.left + tab_width * static_cast<float>(i) + tab_width/2,
+                                                   rect.top + static_cast<float>(Fonts::current()->vera20->get_height())),
+                                          tabs[i].label,
+                                          tabs[current_tab].component->is_active()
+                                          ? Color(1.0f, 1.0f, 1.0f, 0.5f) 
+                                          : Color(1.0f, 1.0f, 1.0f, 1.0f));
+  }
 
   tabs[current_tab].component->draw();
 }
@@ -78,59 +78,59 @@
   if (tabs.empty()) return;
 
   if (tabs[current_tab].component->is_active())
-    {
-      tabs[current_tab].component->update(delta, controller);
-    }
+  {
+    tabs[current_tab].component->update(delta, controller);
+  }
   else
+  {
+    tabs[current_tab].component->update(delta, Controller());
+
+    for(InputEventLst::const_iterator i = controller.get_events().begin(); i != controller.get_events().end(); ++i) 
     {
-      tabs[current_tab].component->update(delta, Controller());
-
-      for(InputEventLst::const_iterator i = controller.get_events().begin(); i != controller.get_events().end(); ++i) 
+      if (i->type == BUTTON_EVENT && i->button.down)
+      {
+        if (i->button.name == OK_BUTTON || i->button.name == ENTER_BUTTON)
         {
-          if (i->type == BUTTON_EVENT && i->button.down)
-            {
-              if (i->button.name == OK_BUTTON || i->button.name == ENTER_BUTTON)
-                {
-                  tabs[current_tab].component->set_active(true);
-                }
-              else if (i->button.name == CANCEL_BUTTON || i->button.name == ESCAPE_BUTTON)
-                {
-                  tabs[current_tab].component->set_active(false);
-                  set_active(false);
-                }
-            }
-          else if (i->type == AXIS_EVENT)
-            {
-              if (i->axis.name == X_AXIS)
-                {
-                  if (i->axis.pos < 0)
-                    {
-                      if (current_tab == 0)
-                        current_tab = tabs.size() - 1;
-                      else
-                        current_tab -= 1;
-                    }
-                  else if (i->axis.pos > 0)
-                    {
-                      if (current_tab == int(tabs.size()) - 1)
-                        current_tab = 0;
-                      else
-                        current_tab += 1;
-                    }
-                }
-              else if (i->axis.name == Y_AXIS)
-                {
-                  if (i->axis.pos < 0)
-                    {
-                    }
-                  else if (i->axis.pos > 0)
-                    {
-                      tabs[current_tab].component->set_active(true); 
-                    }
-                }
-            }
+          tabs[current_tab].component->set_active(true);
         }
+        else if (i->button.name == CANCEL_BUTTON || i->button.name == ESCAPE_BUTTON)
+        {
+          tabs[current_tab].component->set_active(false);
+          set_active(false);
+        }
+      }
+      else if (i->type == AXIS_EVENT)
+      {
+        if (i->axis.name == X_AXIS)
+        {
+          if (i->axis.pos < 0)
+          {
+            if (current_tab == 0)
+              current_tab = tabs.size() - 1;
+            else
+              current_tab -= 1;
+          }
+          else if (i->axis.pos > 0)
+          {
+            if (current_tab == int(tabs.size()) - 1)
+              current_tab = 0;
+            else
+              current_tab += 1;
+          }
+        }
+        else if (i->axis.name == Y_AXIS)
+        {
+          if (i->axis.pos < 0)
+          {
+          }
+          else if (i->axis.pos > 0)
+          {
+            tabs[current_tab].component->set_active(true); 
+          }
+        }
+      }
     }
+  }
 }
 
 void
@@ -143,7 +143,7 @@
                                    rect.top  + padding + static_cast<float>(Fonts::current()->vera20->get_height()) + 10.0f,
                                    rect.right  - padding,
                                    rect.bottom - padding
-                                   ));
+                               ));
 }
 
 } // namespace gui

Modified: trunk/windstille/src/gui/text_view.cpp
===================================================================
--- trunk/windstille/src/gui/text_view.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/gui/text_view.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -46,19 +46,19 @@
   text_area.set_scroll_offset(text_area.get_scroll_offset() + 500.0f * controller.get_axis_state(Y2_AXIS) * delta);
 
   for(InputEventLst::const_iterator i = controller.get_events().begin(); i != controller.get_events().end(); ++i) 
+  {
+    if (i->type == BUTTON_EVENT && i->button.down)
     {
-      if (i->type == BUTTON_EVENT && i->button.down)
-        {
-          if (i->button.name == OK_BUTTON || i->button.name == ENTER_BUTTON)
-            {
-              set_active(false);
-            }
-          else if (i->button.name == CANCEL_BUTTON || i->button.name == ESCAPE_BUTTON)
-            {            
-              set_active(false);
-            }
-        }
-    }  
+      if (i->button.name == OK_BUTTON || i->button.name == ENTER_BUTTON)
+      {
+        set_active(false);
+      }
+      else if (i->button.name == CANCEL_BUTTON || i->button.name == ESCAPE_BUTTON)
+      {            
+        set_active(false);
+      }
+    }
+  }  
 }
 
 void

Modified: trunk/windstille/src/hud/controller_help_window.cpp
===================================================================
--- trunk/windstille/src/hud/controller_help_window.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/hud/controller_help_window.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -30,15 +30,15 @@
 ControllerHelpWindow::draw_button(const Vector2f& pos, bool pressed)
 {  
   if (pressed)
-    {
-      Display::fill_circle(pos, 12.0f, Color(0.8f, 0.0f, 0.0f));
-      //Display::draw_circle(pos, 12.0f, Color(1.0f, 0.0f, 0.0f));
-    }
+  {
+    Display::fill_circle(pos, 12.0f, Color(0.8f, 0.0f, 0.0f));
+    //Display::draw_circle(pos, 12.0f, Color(1.0f, 0.0f, 0.0f));
+  }
   else
-    {
-      Display::fill_circle(pos, 12.0f, Color(1.0f, 1.0f, 1.0f, 0.2f));
-      //Display::draw_circle(pos, 12.0f, Color(1.0f, 1.0f, 1.0f, 0.5f));
-    }
+  {
+    Display::fill_circle(pos, 12.0f, Color(1.0f, 1.0f, 1.0f, 0.2f));
+    //Display::draw_circle(pos, 12.0f, Color(1.0f, 1.0f, 1.0f, 0.5f));
+  }
 }
 
 void
@@ -71,8 +71,8 @@
   
   if (value > 0.0f)
     Display::fill_rect(Rectf(Vector2f(rect.left, rect.top),
-                                     Sizef(rect.get_width() * value,
-                                           rect.get_height())),
+                             Sizef(rect.get_width() * value,
+                                   rect.get_height())),
                        Color(1.0f, 0.0f, 0.0f));
 
   //Display::draw_rect(rect, Color(1.0f, 1.0f, 1.0f, 0.5f));

Modified: trunk/windstille/src/hud/conversation.cpp
===================================================================
--- trunk/windstille/src/hud/conversation.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/hud/conversation.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -36,22 +36,22 @@
 Conversation::add(const std::string& text)
 {
   if (!active)
-    {
-      choices.push_back(Choice(text, ""));
-      if (selection >= int(choices.size()))
-        selection = 0;
-    }
+  {
+    choices.push_back(Choice(text, ""));
+    if (selection >= int(choices.size()))
+      selection = 0;
+  }
 }
 
 void
 Conversation::add(const std::string& topic, const std::string& text)
 {
   if (!active)
-    {
-      choices.push_back(Choice(topic, text));
-      if (selection >= int(choices.size()))
-        selection = 0;
-    }
+  {
+    choices.push_back(Choice(topic, text));
+    if (selection >= int(choices.size()))
+      selection = 0;
+  }
 }
 
 void
@@ -65,50 +65,50 @@
   float segment = 360.0f / static_cast<float>(choices.size());
 
   for(int i = 0; i < static_cast<int>(choices.size()); ++i)
-    { // FIXME:
-      Vector2f offset(0.0f, 1.0f);
-      offset = offset.rotate(math::deg2rad(segment * static_cast<float>(i)) - math::pi/2.0f);
+  { // FIXME:
+    Vector2f offset(0.0f, 1.0f);
+    offset = offset.rotate(math::deg2rad(segment * static_cast<float>(i)) - math::pi/2.0f);
 
-      float start = -segment / 2.0f - 90.0f + segment * static_cast<float>(i);
-      float end   = -segment / 2.0f - 90.0f + segment * static_cast<float>(i+1);
+    float start = -segment / 2.0f - 90.0f + segment * static_cast<float>(i);
+    float end   = -segment / 2.0f - 90.0f + segment * static_cast<float>(i+1);
       
-      float distance = 160.0f;
+    float distance = 160.0f;
 
-      Vector2f textpos = pos + Vector2f(0, 16.0f);
-      // FIXME: Doesn't handle multi line text
-      Sizef size(static_cast<float>(Fonts::current()->vera20->get_width(choices[i].topic)) + 40.0f,
-                 static_cast<float>(Fonts::current()->vera20->get_height()) + 25.0f);
-      Rectf  rect(textpos + distance * offset - Vector2f(size.width/2, size.height - 15), size);
+    Vector2f textpos = pos + Vector2f(0, 16.0f);
+    // FIXME: Doesn't handle multi line text
+    Sizef size(static_cast<float>(Fonts::current()->vera20->get_width(choices[i].topic)) + 40.0f,
+               static_cast<float>(Fonts::current()->vera20->get_height()) + 25.0f);
+    Rectf  rect(textpos + distance * offset - Vector2f(size.width/2, size.height - 15), size);
 
-      if (i == selection)
-        {
-          rect = rect.grow(grow);
+    if (i == selection)
+    {
+      rect = rect.grow(grow);
           
-          Display::fill_arc(pos, 42.0f, start, end, Color(1.0f, 1.0f, 1.0f, 0.5f), 24);
-          Display::fill_rounded_rect(rect, 5.0f, Color(0.5f, 0.5f, 0.5f, 0.75f));
+      Display::fill_arc(pos, 42.0f, start, end, Color(1.0f, 1.0f, 1.0f, 0.5f), 24);
+      Display::fill_rounded_rect(rect, 5.0f, Color(0.5f, 0.5f, 0.5f, 0.75f));
 
-          Fonts::current()->vera20->draw_center(Vector2f(textpos.x + distance * offset.x,
-                                                         textpos.y + distance * offset.y), 
-                                                choices[i].topic, Color(1.0f, 1.0f, 0.0f));
+      Fonts::current()->vera20->draw_center(Vector2f(textpos.x + distance * offset.x,
+                                                     textpos.y + distance * offset.y), 
+                                            choices[i].topic, Color(1.0f, 1.0f, 0.0f));
           
-          Fonts::current()->vera20->draw_center(Vector2f(400.0f, static_cast<float>(Display::get_height()) - 32.0f),
-                                                choices[i].text, Color(1.0f, 1.0f, 1.0f));
-          Display::draw_rounded_rect(rect, 5.0f, Color(1.0f, 1.0f, 0.0f));
-        }
-      else
-        {
-          Display::fill_rounded_rect(rect, 5.0f, Color(0.25f, 0.25f, 0.25f, 0.75f));
-          Fonts::current()->vera20->draw_center(Vector2f(textpos.x + distance * offset.x,
-                                            textpos.y + distance * offset.y),
-                                     choices[i].topic, Color(0.8f, 0.8f, 0.8f));
-          Display::draw_rounded_rect(rect, 5.0f, Color(1.0f, 1.0f, 1.0f));
-        }
+      Fonts::current()->vera20->draw_center(Vector2f(400.0f, static_cast<float>(Display::get_height()) - 32.0f),
+                                            choices[i].text, Color(1.0f, 1.0f, 1.0f));
+      Display::draw_rounded_rect(rect, 5.0f, Color(1.0f, 1.0f, 0.0f));
+    }
+    else
+    {
+      Display::fill_rounded_rect(rect, 5.0f, Color(0.25f, 0.25f, 0.25f, 0.75f));
+      Fonts::current()->vera20->draw_center(Vector2f(textpos.x + distance * offset.x,
+                                                     textpos.y + distance * offset.y),
+                                            choices[i].topic, Color(0.8f, 0.8f, 0.8f));
+      Display::draw_rounded_rect(rect, 5.0f, Color(1.0f, 1.0f, 1.0f));
+    }
 
-      //Display::draw_arc(pos + 5.0f * offset, 32.0f,
-      //                  start, end,
-      //                  Color(1.0f, 1.0f, 1.0f, 1.0f), 24);
+    //Display::draw_arc(pos + 5.0f * offset, 32.0f,
+    //                  start, end,
+    //                  Color(1.0f, 1.0f, 1.0f, 1.0f), 24);
 
-    }
+  }
   Display::draw_circle(pos, 42.0f, Color(1.0f, 1.0f, 1.0f, 0.5f), 24);
 
   Display::fill_circle(pos + direction * 34.0f, 8.0f, Color(1.0f, 1.0f, 1.0f));
@@ -130,35 +130,35 @@
 
   if (fabs(controller.get_axis_state(X_AXIS)) > 0.3f ||
       fabs(controller.get_axis_state(Y_AXIS)) > 0.3f)
-    {
-      float segment = 360.0f / static_cast<float>(choices.size());
-      float angle = math::rad2deg(math::normalize_angle(atan2f(direction.y, direction.x) + math::pi/2.0f + math::deg2rad(segment/2.0f)));
+  {
+    float segment = 360.0f / static_cast<float>(choices.size());
+    float angle = math::rad2deg(math::normalize_angle(atan2f(direction.y, direction.x) + math::pi/2.0f + math::deg2rad(segment/2.0f)));
 
-      int new_selection = int(angle / segment);
-      new_selection = math::mid(0, new_selection, int(choices.size()));
+    int new_selection = int(angle / segment);
+    new_selection = math::mid(0, new_selection, int(choices.size()));
 
-      if (new_selection != selection) {
-        selection = new_selection;
-        // FIXME: Might be a good idea to do the woople-size per button, not globaly
-        grow = 0.0f;
-        time = 0;
-      }
+    if (new_selection != selection) {
+      selection = new_selection;
+      // FIXME: Might be a good idea to do the woople-size per button, not globaly
+      grow = 0.0f;
+      time = 0;
     }
+  }
   else
-    {
-      selection = -1;
-    }
+  {
+    selection = -1;
+  }
   
   if (controller.button_was_pressed(OK_BUTTON) && selection != -1)
-    {
-      active = false;
-      GameSession::current()->get_pda().add_dialog("Jane",
-                                                   choices[selection].topic + " - " +
-                                                   choices[selection].text);
-      choices.clear();
-      GameSession::current()->set_control_state(GameSession::GAME);
-      ScriptManager::current()->fire_wakeup_event(ScriptManager::CONVERSATION_CLOSED);
-    }
+  {
+    active = false;
+    GameSession::current()->get_pda().add_dialog("Jane",
+                                                 choices[selection].topic + " - " +
+                                                 choices[selection].text);
+    choices.clear();
+    GameSession::current()->set_control_state(GameSession::GAME);
+    ScriptManager::current()->fire_wakeup_event(ScriptManager::CONVERSATION_CLOSED);
+  }
 }
 
 int

Modified: trunk/windstille/src/hud/dialog_manager.cpp
===================================================================
--- trunk/windstille/src/hud/dialog_manager.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/hud/dialog_manager.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -99,12 +99,12 @@
   text_area->draw();
 
   if (text_area->is_progress_complete())
-    {
-      const Vector2f& pos_ = text_area->get_cursor_pos();
-      Rectf cursor(pos_.x + 8, pos_.y + 8, pos_.x + 24, pos_.y + 24);
-      Display::fill_rect(cursor, Color(1.0, 1.0, 1.0, 
-                                       fabsf(sinf(static_cast<float>(SDL_GetTicks()) / 1000.0f * math::pi * 3.0f))));
-    }
+  {
+    const Vector2f& pos_ = text_area->get_cursor_pos();
+    Rectf cursor(pos_.x + 8, pos_.y + 8, pos_.x + 24, pos_.y + 24);
+    Display::fill_rect(cursor, Color(1.0, 1.0, 1.0, 
+                                     fabsf(sinf(static_cast<float>(SDL_GetTicks()) / 1000.0f * math::pi * 3.0f))));
+  }
 }
 
 void
@@ -115,23 +115,23 @@
   delay += delta;
 
   InputEventLst events = controller.get_events();
-	
+        
   for (InputEventLst::iterator i = events.begin(); i != events.end(); ++i)
+  {
+    if ((*i).type == BUTTON_EVENT)
     {
-      if ((*i).type == BUTTON_EVENT)
+      if ((*i).button.name == OK_BUTTON && (*i).button.down == true)
+      {
+        if (text_area->is_progress_complete())
         {
-          if ((*i).button.name == OK_BUTTON && (*i).button.down == true)
-            {
-              if (text_area->is_progress_complete())
-                {
-                  GameSession::current()->set_control_state(GameSession::GAME);
-                  ScriptManager::current()->fire_wakeup_event(ScriptManager::DIALOG_CLOSED);
-                }
-              else if (delay > 0.2)
-                text_area->set_progress_complete();
-            } 
+          GameSession::current()->set_control_state(GameSession::GAME);
+          ScriptManager::current()->fire_wakeup_event(ScriptManager::DIALOG_CLOSED);
         }
+        else if (delay > 0.2)
+          text_area->set_progress_complete();
+      } 
     }
+  }
 }
 
 void

Modified: trunk/windstille/src/hud/inventory.cpp
===================================================================
--- trunk/windstille/src/hud/inventory.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/hud/inventory.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -101,22 +101,22 @@
   float step_angle = (2.0f * math::pi) / static_cast<float>(num_items);
 
   for(int i = 0; i < int(items.size()); ++i)
+  {
+    const InventoryItem& item = items[(i+current_item) % items.size()];
+    Vector2f draw_pos = pos + Vector2f(128.0f, 0.0f).rotate(step_angle * static_cast<float>(i) - math::pi/2.0f + add_angle);
+
+    if (i == 0 && moving == 0)
     {
-      const InventoryItem& item = items[(i+current_item) % items.size()];
-      Vector2f draw_pos = pos + Vector2f(128.0f, 0.0f).rotate(step_angle * static_cast<float>(i) - math::pi/2.0f + add_angle);
+      slothighlight.draw(draw_pos);
+      Fonts::current()->vera20->draw_center(Vector2f(draw_pos.x, draw_pos.y - 64), item.name);
+    }
+    else
+    {
+      slot.draw(draw_pos);
+    }
 
-      if (i == 0 && moving == 0)
-        {
-          slothighlight.draw(draw_pos);
-          Fonts::current()->vera20->draw_center(Vector2f(draw_pos.x, draw_pos.y - 64), item.name);
-        }
-      else
-        {
-          slot.draw(draw_pos);
-        }
-
-      item.sprite.draw(draw_pos - Vector2f(32,32));
-    }
+    item.sprite.draw(draw_pos - Vector2f(32,32));
+  }
 }
 
 void
@@ -136,55 +136,55 @@
 {
   float step_angle = (2.0f * math::pi) / static_cast<float>(items.size());
   if (fabsf(add_angle) > step_angle)
-    {
-      if (moving == 1)
-        decr_current_item();
-      else if (moving == -1)
-        incr_current_item();
+  {
+    if (moving == 1)
+      decr_current_item();
+    else if (moving == -1)
+      incr_current_item();
 
-      moving = 0;
-      add_angle = 0;
-    }
+    moving = 0;
+    add_angle = 0;
+  }
 
   if (controller.get_axis_state(X_AXIS) < -0.5f)
+  {
+    if (moving == 1)
     {
-      if (moving == 1)
-        {
-          add_angle = -step_angle + add_angle;
-          decr_current_item();
-        }
+      add_angle = -step_angle + add_angle;
+      decr_current_item();
+    }
 
-      moving = -1;
-    }
+    moving = -1;
+  }
   else if (controller.get_axis_state(X_AXIS) > 0.5f)
+  {
+    if (moving == -1)
     {
-      if (moving == -1)
-        {
-          add_angle = step_angle + add_angle;
-          incr_current_item();
-        }
-
-      moving =  1;
+      add_angle = step_angle + add_angle;
+      incr_current_item();
     }
 
+    moving =  1;
+  }
+
   if (moving == -1)
-    {
-      add_angle -= 3 * delta;
-    }
+  {
+    add_angle -= 3 * delta;
+  }
   else if (moving == 1)
-    {
-      add_angle += 3 * delta;
-    }
+  {
+    add_angle += 3 * delta;
+  }
 
   if (moving == 0)
+  {
+    if (controller.button_was_pressed(OK_BUTTON) ||
+        controller.button_was_pressed(CANCEL_BUTTON) ||
+        controller.button_was_pressed(INVENTORY_BUTTON))
     {
-      if (controller.button_was_pressed(OK_BUTTON) ||
-          controller.button_was_pressed(CANCEL_BUTTON) ||
-          controller.button_was_pressed(INVENTORY_BUTTON))
-        {
-          GameSession::current()->set_control_state(GameSession::GAME);
-        }
+      GameSession::current()->set_control_state(GameSession::GAME);
     }
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/hud/pda.cpp
===================================================================
--- trunk/windstille/src/hud/pda.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/hud/pda.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -85,47 +85,47 @@
   const InputEventLst& events = controller.get_events();
 
   for(InputEventLst::const_iterator i = events.begin(); i != events.end(); ++i) 
+  {
+    if (i->type == BUTTON_EVENT)
     {
-      if (i->type == BUTTON_EVENT)
-        {
-          if (i->axis.name == MENU_LEFT_BUTTON && i->button.down) 
-            {
-              state = static_cast<PDAState>(state + 1);
-              if (state > PDA_DIALOGS)
-                state = PDA_OBJECTIVES;
-            }
-          else if (i->axis.name == MENU_RIGHT_BUTTON && i->button.down) 
-            {
-              state = static_cast<PDAState>(state - 1);
-              if (state < PDA_OBJECTIVES)
-                state = PDA_DIALOGS;
-            }
-        }
+      if (i->axis.name == MENU_LEFT_BUTTON && i->button.down) 
+      {
+        state = static_cast<PDAState>(state + 1);
+        if (state > PDA_DIALOGS)
+          state = PDA_OBJECTIVES;
+      }
+      else if (i->axis.name == MENU_RIGHT_BUTTON && i->button.down) 
+      {
+        state = static_cast<PDAState>(state - 1);
+        if (state < PDA_OBJECTIVES)
+          state = PDA_DIALOGS;
+      }
     }
+  }
   
   if (text_area.get())
-    {
-      text_area->set_scroll_offset(text_area->get_scroll_offset() + 500.0f * controller.get_axis_state(Y2_AXIS) * delta);
-    }
+  {
+    text_area->set_scroll_offset(text_area->get_scroll_offset() + 500.0f * controller.get_axis_state(Y2_AXIS) * delta);
+  }
     
   if (old_state != state) 
+  {
+    old_state = state;
+
+    switch (state) 
     {
-      old_state = state;
+      case PDA_NONE:
+        break;
 
-      switch (state) 
-        {
-          case PDA_NONE:
-            break;
+      case PDA_OBJECTIVES:
+        generate_objectives();
+        break;
 
-          case PDA_OBJECTIVES:
-            generate_objectives();
-            break;
-
-          case PDA_DIALOGS:
-            generate_dialogs();
-            break;
-        }
+      case PDA_DIALOGS:
+        generate_dialogs();
+        break;
     }
+  }
   
   text_area->update(delta);
 }
@@ -156,21 +156,21 @@
   force_regeneration();
 
   for (std::vector<ObjectiveEntry>::iterator i = objectives.begin(); i != objectives.end(); ++i) 
-    {
-      if (i->name == name)
-        i->complete = true;
-      return;
-    }
+  {
+    if (i->name == name)
+      i->complete = true;
+    return;
+  }
 }
 
 bool
 PDA::is_objective_given(const std::string& name)
 {
   for (std::vector<ObjectiveEntry>::iterator i = objectives.begin(); i != objectives.end(); ++i) 
-    {
-      if (i->name == name)
-        return true;
-    }
+  {
+    if (i->name == name)
+      return true;
+  }
   
   return false;
 }
@@ -179,10 +179,10 @@
 PDA::is_objective_complete(const std::string& name)
 {
   for (std::vector<ObjectiveEntry>::iterator i = objectives.begin(); i != objectives.end(); ++i) 
-    {
-      if (i->name == name && i->complete)
-        return true;
-    }
+  {
+    if (i->name == name && i->complete)
+      return true;
+  }
   
   return false;
 }
@@ -195,16 +195,16 @@
   
   std::ostringstream out;
   for (std::vector<ObjectiveEntry>::reverse_iterator i = objectives.rbegin(); i != objectives.rend(); ++i) 
-    {
-      out << i->name << ": ";
+  {
+    out << i->name << ": ";
 
-      if (i->complete)
-        out << "complete\n";
-      else
-        out << "incomplete\n";
+    if (i->complete)
+      out << "complete\n";
+    else
+      out << "incomplete\n";
 
-      out << i->text + "\n\n";
-    }
+    out << i->text + "\n\n";
+  }
 
   text_area->set_text(out.str());
 }
@@ -217,12 +217,12 @@
   
   std::ostringstream out;
   for (std::vector<DialogEntry>::reverse_iterator i = dialogs.rbegin(); i != dialogs.rend(); ++i) 
-    {
-      if (i->character == "Jane")
-        out << "<i>" << i->character << ":</i> " << i->text << '\n';
-      else
-        out << "<b>" << i->character << ":</b> " << i->text << '\n';
-    }
+  {
+    if (i->character == "Jane")
+      out << "<i>" << i->character << ":</i> " << i->text << '\n';
+    else
+      out << "<b>" << i->character << ":</b> " << i->text << '\n';
+  }
   text_area->set_text(out.str());
 }
 

Modified: trunk/windstille/src/hud/speech_manager.cpp
===================================================================
--- trunk/windstille/src/hud/speech_manager.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/hud/speech_manager.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -106,34 +106,34 @@
 SpeechManager::draw()
 {
   for(Speeches::iterator i= speeches.begin(); i != speeches.end(); ++i)
-    {
-      if (*i)
-        (*i)->draw();
-    }  
+  {
+    if (*i)
+      (*i)->draw();
+  }  
 }
 
 void
 SpeechManager::update(float delta)
 {
   for(Speeches::iterator i= speeches.begin(); i != speeches.end(); ++i)
-    {
-      if (*i)
-        (*i)->update(delta);
-    }
+  {
+    if (*i)
+      (*i)->update(delta);
+  }
 
   for(Speeches::iterator i= speeches.begin(); i != speeches.end(); ++i)
-    {  
-      if ((*i)->is_done())
-        {
-          ScriptManager::WakeupData event;
-          event.type = ScriptManager::SPEECH_DONE;
-          event.id   = (*i)->id;
-          ScriptManager::current()->fire_wakeup_event(event);
+  {  
+    if ((*i)->is_done())
+    {
+      ScriptManager::WakeupData event;
+      event.type = ScriptManager::SPEECH_DONE;
+      event.id   = (*i)->id;
+      ScriptManager::current()->fire_wakeup_event(event);
 
-          delete *i;
-          *i = 0;
-        }
+      delete *i;
+      *i = 0;
     }
+  }
 
   speeches.erase(std::remove(speeches.begin(), speeches.end(), static_cast<Speech*>(0)),
                  speeches.end());

Modified: trunk/windstille/src/input/controller.cpp
===================================================================
--- trunk/windstille/src/input/controller.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/input/controller.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -33,17 +33,17 @@
 {
   float value = get_axis_state(name)/2.0f + 0.5f;
   if (value < 0.001f)
-    {
-      return 0;
-    }
+  {
+    return 0;
+  }
   else if (value > 0.999f)
-    {
-      return 1.0f;
-    }
+  {
+    return 1.0f;
+  }
   else
-    {
-      return value;
-    }
+  {
+    return value;
+  }
 }
 
 float
@@ -52,16 +52,16 @@
   assert(id < int(states.size()));
 
   if (use_deadzone)
-    {
-      if (fabsf(states[id].axis) > 0.25f) // FIXME: Hardcoded Deadzone
-        return states[id].axis;
-      else
-        return 0.0f;
-    }
+  {
+    if (fabsf(states[id].axis) > 0.25f) // FIXME: Hardcoded Deadzone
+      return states[id].axis;
+    else
+      return 0.0f;
+  }
   else
-    {
-      return states[id].axis;
-    }
+  {
+    return states[id].axis;
+  }
 }      
 
 bool
@@ -125,12 +125,12 @@
 Controller::button_was_pressed(int name) const
 {
   for(InputEventLst::const_iterator i = events.begin(); i != events.end(); ++i)
+  {
+    if (i->type == BUTTON_EVENT && i->button.name == name && i->button.down)
     {
-      if (i->type == BUTTON_EVENT && i->button.name == name && i->button.down)
-        {
-          return true;
-        }
+      return true;
     }
+  }
   return false;
 }
 
@@ -138,12 +138,12 @@
 Controller::axis_was_pressed_up(int name) const
 {
   for(InputEventLst::const_iterator i = events.begin(); i != events.end(); ++i)
+  {
+    if (i->type == AXIS_EVENT && i->axis.name == name && i->axis.pos > 0.5f)
     {
-      if (i->type == AXIS_EVENT && i->axis.name == name && i->axis.pos > 0.5f)
-        {
-          return true;
-        }
+      return true;
     }
+  }
   return false;  
 }
 
@@ -151,12 +151,12 @@
 Controller::axis_was_pressed_down(int name) const
 {
   for(InputEventLst::const_iterator i = events.begin(); i != events.end(); ++i)
+  {
+    if (i->type == AXIS_EVENT && i->axis.name == name && i->axis.pos < -0.5f)
     {
-      if (i->type == AXIS_EVENT && i->axis.name == name && i->axis.pos < -0.5f)
-        {
-          return true;
-        }
+      return true;
     }
+  }
   return false;
 }
 

Modified: trunk/windstille/src/input/input_configurator.cpp
===================================================================
--- trunk/windstille/src/input/input_configurator.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/input/input_configurator.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -97,22 +97,22 @@
 InputConfigurator::print_item()
 {
   if (!items.empty())
+  {
+    const ConfigureItem& item = items.back();
+      
+    if (item.mode == ConfigureItem::CONFIGURE_AXIS)
     {
-      const ConfigureItem& item = items.back();
-      
-      if (item.mode == ConfigureItem::CONFIGURE_AXIS)
-        {
-          out << "Configuring " 
-              << InputManagerSDL::current()->get_controller_description().get_definition(item.event_id).name
-              << ": " << std::endl;
-        }
-      else if (item.mode == ConfigureItem::CONFIGURE_BUTTON)
-        {
-          out << "Configuring " 
-              << InputManagerSDL::current()->get_controller_description().get_definition(item.event_id).name 
-              << ": " << std::endl;
-        }
+      out << "Configuring " 
+          << InputManagerSDL::current()->get_controller_description().get_definition(item.event_id).name
+          << ": " << std::endl;
     }
+    else if (item.mode == ConfigureItem::CONFIGURE_BUTTON)
+    {
+      out << "Configuring " 
+          << InputManagerSDL::current()->get_controller_description().get_definition(item.event_id).name 
+          << ": " << std::endl;
+    }
+  }
 
   area.set_text(out.str());
 }
@@ -124,9 +124,9 @@
   items.pop_back();
 
   if (items.empty())
-    {
-      out << "Controller configuration is done, pressy any key to continue" << std::endl;
-    }
+  {
+    out << "Controller configuration is done, pressy any key to continue" << std::endl;
+  }
 
   print_item();
 
@@ -137,29 +137,29 @@
 InputConfigurator::handle_event(const SDL_Event& event)
 {
   if (items.empty())
-    {
-      std::cout << "InputConfigurator: done" << std::endl;
-      ScreenManager::current()->pop_overlay();
-      return; 
-    }
+  {
+    std::cout << "InputConfigurator: done" << std::endl;
+    ScreenManager::current()->pop_overlay();
+    return; 
+  }
   
 
   switch(event.type)
-    {        
+  {        
     case SDL_MOUSEMOTION:
       // event.motion:      
       break;
 
     case SDL_MOUSEBUTTONDOWN:
       if (items.back().mode == ConfigureItem::CONFIGURE_BUTTON)
-        {
-          InputManagerSDL::current()->bind_mouse_button(items.back().event_id,
-                                                        0, // SDL only supports one mouse
-                                                        event.button.button);
-          out << "(mouse-button (device " << 0 << ")\n"
-              << "              (button " << int(event.button.button) << "))" << std::endl;
-          next_item();
-        }
+      {
+        InputManagerSDL::current()->bind_mouse_button(items.back().event_id,
+                                                      0, // SDL only supports one mouse
+                                                      event.button.button);
+        out << "(mouse-button (device " << 0 << ")\n"
+            << "              (button " << int(event.button.button) << "))" << std::endl;
+        next_item();
+      }
       break;
 
     case SDL_MOUSEBUTTONUP:
@@ -168,15 +168,15 @@
 
     case SDL_JOYAXISMOTION:
       if (items.back().mode == ConfigureItem::CONFIGURE_AXIS && (event.jaxis.value > 16384 || event.jaxis.value < -16384))
-        { // FIXME: This doesn't work well with analog Axis!
-          InputManagerSDL::current()->bind_joystick_axis(items.back().event_id, event.jaxis.which, event.jaxis.axis, false);
-          out << "(joystick-axis (device " << int(event.jaxis.which) << ")\n"
-              << "               (axis   " << int(event.jaxis.axis) << "))" << std::endl;
-          next_item();
-        }
+      { // FIXME: This doesn't work well with analog Axis!
+        InputManagerSDL::current()->bind_joystick_axis(items.back().event_id, event.jaxis.which, event.jaxis.axis, false);
+        out << "(joystick-axis (device " << int(event.jaxis.which) << ")\n"
+            << "               (axis   " << int(event.jaxis.axis) << "))" << std::endl;
+        next_item();
+      }
       else
-        {
-        }
+      {
+      }
       break;
 
     case SDL_JOYBALLMOTION:
@@ -192,31 +192,31 @@
 
     case SDL_JOYBUTTONDOWN:
       if (items.back().mode == ConfigureItem::CONFIGURE_BUTTON)
+      {
+        InputManagerSDL::current()->bind_joystick_button(items.back().event_id, event.jbutton.which, event.jbutton.button);
+        out << "(joystick-button (device " << int(event.jbutton.which) << ")\n"
+            << "                 (button " << int(event.jbutton.button) << "))" << std::endl;
+        next_item();
+      }
+      else if (items.back().mode == ConfigureItem::CONFIGURE_AXIS)
+      {
+        if (wait_for_plus && minus.type == SDL_JOYBUTTONDOWN)
         {
-          InputManagerSDL::current()->bind_joystick_button(items.back().event_id, event.jbutton.which, event.jbutton.button);
-          out << "(joystick-button (device " << int(event.jbutton.which) << ")\n"
-              << "                 (button " << int(event.jbutton.button) << "))" << std::endl;
+          out << "(joystick-axis-button (minus " << InputManagerSDL::current()->keyid_to_string(minus.key.keysym.sym) << ") "
+              << "(plus  " << InputManagerSDL::current()->keyid_to_string(event.key.keysym.sym) << "))" << std::endl;
+          InputManagerSDL::current()->bind_joystick_button_axis(items.back().event_id, event.jbutton.which, 
+                                                                minus.jbutton.button, event.jbutton.button);
           next_item();
+          wait_for_plus = false;
         }
-      else if (items.back().mode == ConfigureItem::CONFIGURE_AXIS)
+        else if (!wait_for_plus)
         {
-          if (wait_for_plus && minus.type == SDL_JOYBUTTONDOWN)
-            {
-              out << "(joystick-axis-button (minus " << InputManagerSDL::current()->keyid_to_string(minus.key.keysym.sym) << ") "
-                  << "(plus  " << InputManagerSDL::current()->keyid_to_string(event.key.keysym.sym) << "))" << std::endl;
-              InputManagerSDL::current()->bind_joystick_button_axis(items.back().event_id, event.jbutton.which, 
-                                                                    minus.jbutton.button, event.jbutton.button);
-              next_item();
-              wait_for_plus = false;
-            }
-          else if (!wait_for_plus)
-            {
-              out << "Press key for other direction" << std::endl;
-              area.set_text(out.str());
-              minus = event;
-              wait_for_plus = true;
-            }
+          out << "Press key for other direction" << std::endl;
+          area.set_text(out.str());
+          minus = event;
+          wait_for_plus = true;
         }
+      }
       break;
 
     case SDL_KEYUP:
@@ -224,44 +224,44 @@
 
     case SDL_KEYDOWN:
       if (event.key.keysym.sym == SDLK_ESCAPE)
-        {
-          std::cout << "InputConfigurator: abort" << std::endl;
-          ScreenManager::current()->pop_overlay();
-          //next_item();
-        }
+      {
+        std::cout << "InputConfigurator: abort" << std::endl;
+        ScreenManager::current()->pop_overlay();
+        //next_item();
+      }
       else if (event.key.keysym.sym == SDLK_RETURN)
+      {
+        std::cout << "Binding the enter key is not allowed" << std::endl;
+      }
+      else
+      {
+        if (items.back().mode == ConfigureItem::CONFIGURE_BUTTON)
         {
-          std::cout << "Binding the enter key is not allowed" << std::endl;
+          InputManagerSDL::current()->bind_keyboard_button(items.back().event_id, event.key.keysym.sym);
+          out << "(keyboard-button (key " << InputManagerSDL::current()->keyid_to_string(event.key.keysym.sym) << "))" << std::endl;
+          next_item();
         }
-      else
+        else if (items.back().mode == ConfigureItem::CONFIGURE_AXIS)
         {
-          if (items.back().mode == ConfigureItem::CONFIGURE_BUTTON)
-            {
-              InputManagerSDL::current()->bind_keyboard_button(items.back().event_id, event.key.keysym.sym);
-              out << "(keyboard-button (key " << InputManagerSDL::current()->keyid_to_string(event.key.keysym.sym) << "))" << std::endl;
-              next_item();
-            }
-          else if (items.back().mode == ConfigureItem::CONFIGURE_AXIS)
-            {
-              if (wait_for_plus && minus.type == SDL_KEYDOWN)
-                {
-                  out << "(keyboard-axis (minus " << InputManagerSDL::current()->keyid_to_string(minus.key.keysym.sym) << ") "
-                      << "(plus  " << InputManagerSDL::current()->keyid_to_string(event.key.keysym.sym) << "))" << std::endl;
-                  InputManagerSDL::current()->bind_keyboard_axis(items.back().event_id, minus.key.keysym.sym, event.key.keysym.sym);
-                  next_item();
-                  wait_for_plus = false;
-                }
-              else if (!wait_for_plus)
-                {
-                  out << "Print key for other direction" << std::endl;
-                  area.set_text(out.str());
-                  minus = event;
-                  wait_for_plus = true;
-                }
-            }
+          if (wait_for_plus && minus.type == SDL_KEYDOWN)
+          {
+            out << "(keyboard-axis (minus " << InputManagerSDL::current()->keyid_to_string(minus.key.keysym.sym) << ") "
+                << "(plus  " << InputManagerSDL::current()->keyid_to_string(event.key.keysym.sym) << "))" << std::endl;
+            InputManagerSDL::current()->bind_keyboard_axis(items.back().event_id, minus.key.keysym.sym, event.key.keysym.sym);
+            next_item();
+            wait_for_plus = false;
+          }
+          else if (!wait_for_plus)
+          {
+            out << "Print key for other direction" << std::endl;
+            area.set_text(out.str());
+            minus = event;
+            wait_for_plus = true;
+          }
         }
+      }
       break;
-    }
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/input/input_manager_sdl.cpp
===================================================================
--- trunk/windstille/src/input/input_manager_sdl.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/input/input_manager_sdl.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -85,16 +85,16 @@
     impl->joysticks.resize(device + 1, 0);
 
   if (!impl->joysticks[device])
+  {
+    if (SDL_Joystick* joystick = SDL_JoystickOpen(device))
     {
-      if (SDL_Joystick* joystick = SDL_JoystickOpen(device))
-        {
-          impl->joysticks[device] = joystick;
-        }
-      else
-        {
-          std::cout << "InputManagerSDL: Couldn't open joystick device " << device << std::endl;
-        }
+      impl->joysticks[device] = joystick;
     }
+    else
+    {
+      std::cout << "InputManagerSDL: Couldn't open joystick device " << device << std::endl;
+    }
+  }
   
 }
 
@@ -120,110 +120,110 @@
   std::vector<FileReader> sections = reader.get_sections();
   
   for(std::vector<FileReader>::iterator i = sections.begin(); i != sections.end(); ++i)
+  {
+    if (has_suffix(i->get_name(), "-button"))
     {
-      if (has_suffix(i->get_name(), "-button"))
+      std::vector<FileReader> dev_sections = i->get_sections();
+      for(std::vector<FileReader>::iterator j = dev_sections.begin(); j != dev_sections.end(); ++j)
+      {
+        if (j->get_name() == "joystick-button")
         {
-          std::vector<FileReader> dev_sections = i->get_sections();
-          for(std::vector<FileReader>::iterator j = dev_sections.begin(); j != dev_sections.end(); ++j)
-            {
-              if (j->get_name() == "joystick-button")
-                {
-                  int device = 0;
-                  int button = 0;
+          int device = 0;
+          int button = 0;
 
-                  j->get("device", device);
-                  j->get("button", button);
+          j->get("device", device);
+          j->get("button", button);
 
-                  bind_joystick_button(controller_description.get_definition(i->get_name()).id,
-                                       device, button);
-                }
-              else if (j->get_name() == "joystick-axis-button")
-                {
-                  int  device;
-                  int  axis;
-                  bool up;
+          bind_joystick_button(controller_description.get_definition(i->get_name()).id,
+                               device, button);
+        }
+        else if (j->get_name() == "joystick-axis-button")
+        {
+          int  device;
+          int  axis;
+          bool up;
 
-                  j->get("device", device);
-                  j->get("axis", axis);
-                  j->get("up", up);
+          j->get("device", device);
+          j->get("axis", axis);
+          j->get("up", up);
 
-                  bind_joystick_axis_button(controller_description.get_definition(i->get_name()).id,
-                                            device, axis, up);
-                }
-              else if (j->get_name() == "wiimote-button")
-                {
-                  int device = 0;
-                  int button = 0;
+          bind_joystick_axis_button(controller_description.get_definition(i->get_name()).id,
+                                    device, axis, up);
+        }
+        else if (j->get_name() == "wiimote-button")
+        {
+          int device = 0;
+          int button = 0;
 
-                  j->get("device", device);
-                  j->get("button", button);
+          j->get("device", device);
+          j->get("button", button);
 
-                  bind_wiimote_button(controller_description.get_definition(i->get_name()).id,
-                                      device, button);
-                }
-              else if (j->get_name() == "keyboard-button")
-                {
-                  std::string key;
+          bind_wiimote_button(controller_description.get_definition(i->get_name()).id,
+                              device, button);
+        }
+        else if (j->get_name() == "keyboard-button")
+        {
+          std::string key;
 
-                  j->get("key", key);
+          j->get("key", key);
 
-                  bind_keyboard_button(controller_description.get_definition(i->get_name()).id,
-                                       string_to_keyid(key));
-                }
-              else
-                {
-                  std::cout << "InputManagerSDL: Unknown tag: " << j->get_name() << std::endl;
-                }
-            }
+          bind_keyboard_button(controller_description.get_definition(i->get_name()).id,
+                               string_to_keyid(key));
         }
-      else if (has_suffix(i->get_name(), "-axis"))
+        else
         {
-          std::vector<FileReader> dev_sections = i->get_sections();
-          for(std::vector<FileReader>::iterator j = dev_sections.begin(); j != dev_sections.end(); ++j)
-            {
-              if (j->get_name() == "joystick-axis")
-                {
-                  int  device = 0;
-                  int  axis   = 0;
-                  bool invert = false;
+          std::cout << "InputManagerSDL: Unknown tag: " << j->get_name() << std::endl;
+        }
+      }
+    }
+    else if (has_suffix(i->get_name(), "-axis"))
+    {
+      std::vector<FileReader> dev_sections = i->get_sections();
+      for(std::vector<FileReader>::iterator j = dev_sections.begin(); j != dev_sections.end(); ++j)
+      {
+        if (j->get_name() == "joystick-axis")
+        {
+          int  device = 0;
+          int  axis   = 0;
+          bool invert = false;
 
-                  j->get("device", device);
-                  j->get("axis",   axis);
-                  j->get("invert", invert);
+          j->get("device", device);
+          j->get("axis",   axis);
+          j->get("invert", invert);
 
-                  bind_joystick_axis(controller_description.get_definition(i->get_name()).id,
-                                     device, axis, invert);
-                }
-              else if (j->get_name() == "keyboard-axis")
-                {
-                  std::string minus;
-                  std::string plus;
+          bind_joystick_axis(controller_description.get_definition(i->get_name()).id,
+                             device, axis, invert);
+        }
+        else if (j->get_name() == "keyboard-axis")
+        {
+          std::string minus;
+          std::string plus;
 
-                  j->get("minus", minus);
-                  j->get("plus",  plus);
+          j->get("minus", minus);
+          j->get("plus",  plus);
 
-                  bind_keyboard_axis(controller_description.get_definition(i->get_name()).id, 
-                                     string_to_keyid(minus), string_to_keyid(plus));
-                }
-              else if (j->get_name() == "wiimote-axis")
-                {
-                  int  device = 0;
-                  int  axis   = 0;
+          bind_keyboard_axis(controller_description.get_definition(i->get_name()).id, 
+                             string_to_keyid(minus), string_to_keyid(plus));
+        }
+        else if (j->get_name() == "wiimote-axis")
+        {
+          int  device = 0;
+          int  axis   = 0;
                   
-                  j->get("device", device);
-                  j->get("axis",   axis);
+          j->get("device", device);
+          j->get("axis",   axis);
                   
-                  bind_wiimote_axis(controller_description.get_definition(i->get_name()).id,
-                                    device, axis);
-                }
-              else
-                {
-                  std::cout << "InputManagerSDL: Unknown tag: " << j->get_name() << std::endl;
-                }
-            }
+          bind_wiimote_axis(controller_description.get_definition(i->get_name()).id,
+                            device, axis);
+        }
+        else
+        {
+          std::cout << "InputManagerSDL: Unknown tag: " << j->get_name() << std::endl;
+        }
+      }
 
-        }
     }
+  }
 }
 
 InputManagerSDL::InputManagerSDL(const ControllerDescription& controller_description_)
@@ -259,66 +259,66 @@
 {
   // Hardcoded defaults
   if (event.keysym.sym == SDLK_RETURN)
-    {
-      add_button_event(ENTER_BUTTON, event.state);
-    }
+  {
+    add_button_event(ENTER_BUTTON, event.state);
+  }
   else if (event.keysym.sym == SDLK_ESCAPE)
-    {
-      add_button_event(ESCAPE_BUTTON, event.state);
-    }
+  {
+    add_button_event(ESCAPE_BUTTON, event.state);
+  }
   else if (event.keysym.sym == SDLK_LEFT)
-    {
-      add_button_event(MENU_LEFT_BUTTON, event.state);
-    }
+  {
+    add_button_event(MENU_LEFT_BUTTON, event.state);
+  }
   else if (event.keysym.sym == SDLK_RIGHT)
-    {
-      add_button_event(MENU_RIGHT_BUTTON, event.state);
-    }
+  {
+    add_button_event(MENU_RIGHT_BUTTON, event.state);
+  }
   else if (event.keysym.sym == SDLK_UP)
-    {
-      add_button_event(MENU_UP_BUTTON, event.state);
-    }
+  {
+    add_button_event(MENU_UP_BUTTON, event.state);
+  }
   else if (event.keysym.sym == SDLK_DOWN)
-    {
-      add_button_event(MENU_DOWN_BUTTON, event.state);
-    }
+  {
+    add_button_event(MENU_DOWN_BUTTON, event.state);
+  }
 
   // Dynamic bindings
   for (std::vector<KeyboardButtonBinding>::const_iterator i = impl->keyboard_button_bindings.begin();
        i != impl->keyboard_button_bindings.end();
        ++i)
+  {
+    if (event.keysym.sym == i->key)
     {
-      if (event.keysym.sym == i->key)
-        {
-          add_button_event(i->event, event.state);
-        }
+      add_button_event(i->event, event.state);
     }
+  }
 
   Uint8* keystate = SDL_GetKeyState(0);
 
   for (std::vector<KeyboardAxisBinding>::const_iterator i = impl->keyboard_axis_bindings.begin();
        i != impl->keyboard_axis_bindings.end();
        ++i)
+  {
+    if (event.keysym.sym == i->minus)
     {
-      if (event.keysym.sym == i->minus)
-        {
-          if (event.state)
-            add_axis_event(i->event, -1.0f);
-          else if (!keystate[i->plus])
-            add_axis_event(i->event, 0.0f);
-        }
-      else if (event.keysym.sym == i->plus)
-        {
-          if (event.state)
-            {
-              add_axis_event(i->event, 1.0f);
-            }
-          else if (!keystate[i->minus])
-            {
-              add_axis_event(i->event, 0.0f);
-            }
-        }
+      if (event.state)
+        add_axis_event(i->event, -1.0f);
+      else if (!keystate[i->plus])
+        add_axis_event(i->event, 0.0f);
     }
+    else if (event.keysym.sym == i->plus)
+    {
+      if (event.state)
+      {
+        add_axis_event(i->event, 1.0f);
+      }
+      else if (!keystate[i->minus])
+      {
+        add_axis_event(i->event, 0.0f);
+      }
+    }
+  }
 }
 
 void
@@ -327,12 +327,12 @@
   for (std::vector<MouseButtonBinding>::const_iterator i = impl->mouse_button_bindings.begin();
        i != impl->mouse_button_bindings.end();
        ++i)
+  {
+    if (button.button == i->button)
     {
-      if (button.button == i->button)
-        {
-          add_button_event(i->event, button.state);
-        }
+      add_button_event(i->event, button.state);
     }
+  }
 }
 
 void
@@ -341,30 +341,30 @@
   for (std::vector<JoystickButtonBinding>::const_iterator i = impl->joystick_button_bindings.begin();
        i != impl->joystick_button_bindings.end();
        ++i)
+  {
+    if (button.which  == i->device &&
+        button.button == i->button)
     {
-      if (button.which  == i->device &&
-          button.button == i->button)
-        {
-          add_button_event(i->event, button.state);
-        }
+      add_button_event(i->event, button.state);
     }
+  }
 
   for (std::vector<JoystickButtonAxisBinding>::const_iterator i = impl->joystick_button_axis_bindings.begin();
        i != impl->joystick_button_axis_bindings.end();
        ++i)
+  {
+    if (button.which  == i->device)
     {
-      if (button.which  == i->device)
-        {
-          if (button.button == i->minus)
-            {
-              add_axis_event(i->event, button.state ? -1.0f : 0.0f);
-            }
-          else if (button.button == i->plus)
-            {
-              add_axis_event(i->event, button.state ?  1.0f : 0.0f);
-            }
-        }
+      if (button.button == i->minus)
+      {
+        add_axis_event(i->event, button.state ? -1.0f : 0.0f);
+      }
+      else if (button.button == i->plus)
+      {
+        add_axis_event(i->event, button.state ?  1.0f : 0.0f);
+      }
     }
+  }
 }
 
 void
@@ -373,69 +373,69 @@
   for (std::vector<JoystickAxisBinding>::const_iterator i = impl->joystick_axis_bindings.begin();
        i != impl->joystick_axis_bindings.end();
        ++i)
+  {
+    if (event.which  == i->device &&
+        event.axis   == i->axis)
     {
-      if (event.which  == i->device &&
-          event.axis   == i->axis)
-        {
-          if (abs(event.value) > dead_zone)
-            {
-              add_axis_event(i->event, static_cast<float>(event.value) / (i->invert ? -32768.0f : 32768.0f));
-            }
-          else
-            {
-              add_axis_event(i->event, 0);
-            }
-        }
+      if (abs(event.value) > dead_zone)
+      {
+        add_axis_event(i->event, static_cast<float>(event.value) / (i->invert ? -32768.0f : 32768.0f));
+      }
+      else
+      {
+        add_axis_event(i->event, 0);
+      }
     }
+  }
 
   for(std::vector<JoystickAxisButtonBinding>::const_iterator i = impl->joystick_axis_button_bindings.begin();
       i != impl->joystick_axis_button_bindings.end();
       ++i)
+  {
+    if (event.which == i->device &&
+        event.axis  == i->axis)
     {
-      if (event.which == i->device &&
-          event.axis  == i->axis)
-        {
-          if (i->up)
-            { // signal button press when axis is up
-              if (event.value < -dead_zone)
-                add_button_event(i->event, true);
-              else 
-                add_button_event(i->event, false);
-            }
-          else
-            { // signal button press when axis is down
-              if (event.value > dead_zone)
-                add_button_event(i->event, true);
-              else
-                add_button_event(i->event, false);
-            }
-        }
+      if (i->up)
+      { // signal button press when axis is up
+        if (event.value < -dead_zone)
+          add_button_event(i->event, true);
+        else 
+          add_button_event(i->event, false);
+      }
+      else
+      { // signal button press when axis is down
+        if (event.value > dead_zone)
+          add_button_event(i->event, true);
+        else
+          add_button_event(i->event, false);
+      }
     }
+  }
 }
 
 void
 InputManagerSDL::on_event(const SDL_Event& event)
 {
   switch(event.type)
-    {        
+  {        
     case SDL_KEYUP:
     case SDL_KEYDOWN:
+    {
+      if (event.key.state)
       {
-        if (event.key.state)
-          {
-            if ((event.key.keysym.unicode > 0 && event.key.keysym.unicode < 128)
-                && (isgraph(event.key.keysym.unicode) || event.key.keysym.unicode == ' '))
-              {
-                add_keyboard_event(0, KeyboardEvent::LETTER, event.key.keysym.unicode);
-              }
-            else
-              {
-                add_keyboard_event(0, KeyboardEvent::SPECIAL, event.key.keysym.sym);
-              }
-          }
+        if ((event.key.keysym.unicode > 0 && event.key.keysym.unicode < 128)
+            && (isgraph(event.key.keysym.unicode) || event.key.keysym.unicode == ' '))
+        {
+          add_keyboard_event(0, KeyboardEvent::LETTER, event.key.keysym.unicode);
+        }
+        else
+        {
+          add_keyboard_event(0, KeyboardEvent::SPECIAL, event.key.keysym.sym);
+        }
       }
-      on_key_event(event.key);
-      break;
+    }
+    on_key_event(event.key);
+    break;
 
     case SDL_MOUSEMOTION:
       // event.motion
@@ -473,7 +473,7 @@
     default:
       std::cout << "InputManagerSDL: unknown event" << std::endl;
       break;
-    }
+  }
 }
 
 void
@@ -481,73 +481,73 @@
 {
 #ifdef HAVE_CWIID
   if (wiimote && wiimote->is_connected())
+  {
+    // Check for new events from the Wiimote
+    std::vector<WiimoteEvent> events = wiimote->pop_events();
+    for(std::vector<WiimoteEvent>::iterator i = events.begin(); i != events.end(); ++i)
     {
-      // Check for new events from the Wiimote
-      std::vector<WiimoteEvent> events = wiimote->pop_events();
-      for(std::vector<WiimoteEvent>::iterator i = events.begin(); i != events.end(); ++i)
+      WiimoteEvent& event = *i;
+      if (event.type == WiimoteEvent::WIIMOTE_BUTTON_EVENT)
+      {
+        //std::cout << "WiimoteButton: " << event.button.button << " " << event.button.down << std::endl;
+
+        for (std::vector<WiimoteButtonBinding>::const_iterator j = impl->wiimote_button_bindings.begin();
+             j != impl->wiimote_button_bindings.end();
+             ++j)
         {
-          WiimoteEvent& event = *i;
-          if (event.type == WiimoteEvent::WIIMOTE_BUTTON_EVENT)
-            {
-              //std::cout << "WiimoteButton: " << event.button.button << " " << event.button.down << std::endl;
+          if (event.button.device == j->device &&
+              event.button.button == j->button)
+          {
+            add_button_event(j->event, event.button.down);
+          }
+        }
+      }
+      else if (event.type == WiimoteEvent::WIIMOTE_AXIS_EVENT)
+      {
+        //std::cout << "WiimoteAxis: " << event.axis.axis << " " << event.axis.pos << std::endl;
 
-              for (std::vector<WiimoteButtonBinding>::const_iterator j = impl->wiimote_button_bindings.begin();
-                   j != impl->wiimote_button_bindings.end();
-                   ++j)
-                {
-                  if (event.button.device == j->device &&
-                      event.button.button == j->button)
-                    {
-                      add_button_event(j->event, event.button.down);
-                    }
-                }
-            }
-          else if (event.type == WiimoteEvent::WIIMOTE_AXIS_EVENT)
-            {
-              //std::cout << "WiimoteAxis: " << event.axis.axis << " " << event.axis.pos << std::endl;
-
-              for (std::vector<WiimoteAxisBinding>::const_iterator j = impl->wiimote_axis_bindings.begin();
-                   j != impl->wiimote_axis_bindings.end();
-                   ++j)
-                {
-                  if (event.axis.device == j->device &&
-                      event.axis.axis == j->axis)
-                    {
-                      add_axis_event(j->event, event.axis.pos);
-                    }
-                }
-            }
-          else if (event.type == WiimoteEvent::WIIMOTE_ACC_EVENT)
-            {
-              if (event.acc.accelerometer == 0)
-                {
-                  if (0)
-                    printf("%d - %6.3f %6.3f %6.3f\n",  
-                           event.acc.accelerometer,
-                           event.acc.x,
-                           event.acc.y,
-                           event.acc.z);
+        for (std::vector<WiimoteAxisBinding>::const_iterator j = impl->wiimote_axis_bindings.begin();
+             j != impl->wiimote_axis_bindings.end();
+             ++j)
+        {
+          if (event.axis.device == j->device &&
+              event.axis.axis == j->axis)
+          {
+            add_axis_event(j->event, event.axis.pos);
+          }
+        }
+      }
+      else if (event.type == WiimoteEvent::WIIMOTE_ACC_EVENT)
+      {
+        if (event.acc.accelerometer == 0)
+        {
+          if (0)
+            printf("%d - %6.3f %6.3f %6.3f\n",  
+                   event.acc.accelerometer,
+                   event.acc.x,
+                   event.acc.y,
+                   event.acc.z);
                  
-                  float roll = atanf(static_cast<float>(event.acc.x / event.acc.z));
-                  if (event.acc.z <= 0.0) {
-                    roll += math::pi * ((event.acc.x > 0.0f) ? 1.0f : -1.0f);
-                  }
-                  roll *= -1;
+          float roll = atanf(static_cast<float>(event.acc.x / event.acc.z));
+          if (event.acc.z <= 0.0) {
+            roll += math::pi * ((event.acc.x > 0.0f) ? 1.0f : -1.0f);
+          }
+          roll *= -1;
 
-                  float pitch = atanf(event.acc.y / event.acc.z * cosf(roll));
+          float pitch = atanf(event.acc.y / event.acc.z * cosf(roll));
 
-                  add_axis_event(X2_AXIS, math::mid(-1.0f, -float(pitch / M_PI), 1.0f));
-                  add_axis_event(Y2_AXIS, math::mid(-1.0f, -float(roll  / M_PI), 1.0f));
+          add_axis_event(X2_AXIS, math::mid(-1.0f, -float(pitch / M_PI), 1.0f));
+          add_axis_event(Y2_AXIS, math::mid(-1.0f, -float(roll  / M_PI), 1.0f));
 
-                  std::cout << boost::format("%|6.3f| %|6.3f|") % pitch % roll << std::endl;
-                }
-            }
-          else
-            {
-              assert(!"Never reached");
-            }
+          std::cout << boost::format("%|6.3f| %|6.3f|") % pitch % roll << std::endl;
         }
+      }
+      else
+      {
+        assert(!"Never reached");
+      }
     }
+  }
 #endif
 }
 
@@ -703,53 +703,53 @@
   // FIXME: need state info
   float old_pos = controller.get_axis_state(name);
   if (name == X_AXIS)
+  {
+    if (controller.get_button_state(MENU_LEFT_BUTTON) == 0 &&
+        pos < -click_threshold && old_pos > -click_threshold) 
     {
-      if (controller.get_button_state(MENU_LEFT_BUTTON) == 0 &&
-          pos < -click_threshold && old_pos > -click_threshold) 
-        {
-          add_button_event(MENU_LEFT_BUTTON, 1);
-        } 
-      else if (controller.get_button_state(MENU_LEFT_BUTTON) == 1 &&
-               old_pos < -release_threshold && pos > -release_threshold) 
-        {
-          add_button_event(MENU_LEFT_BUTTON, 0);
-        } 
+      add_button_event(MENU_LEFT_BUTTON, 1);
+    } 
+    else if (controller.get_button_state(MENU_LEFT_BUTTON) == 1 &&
+             old_pos < -release_threshold && pos > -release_threshold) 
+    {
+      add_button_event(MENU_LEFT_BUTTON, 0);
+    } 
       
-      else if (controller.get_button_state(MENU_RIGHT_BUTTON) == 0 &&
-               pos > click_threshold && old_pos < click_threshold) 
-        {
-          add_button_event(MENU_RIGHT_BUTTON, 1);
-        } 
-      else  if (controller.get_button_state(MENU_RIGHT_BUTTON) == 1 &&
-                old_pos > release_threshold && pos < release_threshold) 
-        {
-          add_button_event(MENU_RIGHT_BUTTON, 0);
-        }
+    else if (controller.get_button_state(MENU_RIGHT_BUTTON) == 0 &&
+             pos > click_threshold && old_pos < click_threshold) 
+    {
+      add_button_event(MENU_RIGHT_BUTTON, 1);
+    } 
+    else  if (controller.get_button_state(MENU_RIGHT_BUTTON) == 1 &&
+              old_pos > release_threshold && pos < release_threshold) 
+    {
+      add_button_event(MENU_RIGHT_BUTTON, 0);
     }
+  }
   else if (name == Y_AXIS)
+  {
+    if (controller.get_button_state(MENU_UP_BUTTON) == 0 &&
+        pos < -click_threshold && old_pos > -click_threshold) 
     {
-      if (controller.get_button_state(MENU_UP_BUTTON) == 0 &&
-          pos < -click_threshold && old_pos > -click_threshold) 
-        {
-          add_button_event(MENU_UP_BUTTON, 1);
-        } 
-      else if (controller.get_button_state(MENU_UP_BUTTON) == 1 &&
-               old_pos < -release_threshold && pos > -release_threshold) 
-        {
-          add_button_event(MENU_UP_BUTTON, 0);
-        }
+      add_button_event(MENU_UP_BUTTON, 1);
+    } 
+    else if (controller.get_button_state(MENU_UP_BUTTON) == 1 &&
+             old_pos < -release_threshold && pos > -release_threshold) 
+    {
+      add_button_event(MENU_UP_BUTTON, 0);
+    }
 
-      else  if (controller.get_button_state(MENU_DOWN_BUTTON) == 0 &&
-                pos > click_threshold && old_pos < click_threshold) 
-        {
-          add_button_event(MENU_DOWN_BUTTON, 1);
-        } 
-      else  if (controller.get_button_state(MENU_DOWN_BUTTON) == 1 &&
-                old_pos > release_threshold && pos < release_threshold) 
-        {
-          add_button_event(MENU_DOWN_BUTTON, 0);
-        }
+    else  if (controller.get_button_state(MENU_DOWN_BUTTON) == 0 &&
+              pos > click_threshold && old_pos < click_threshold) 
+    {
+      add_button_event(MENU_DOWN_BUTTON, 1);
+    } 
+    else  if (controller.get_button_state(MENU_DOWN_BUTTON) == 1 &&
+              old_pos > release_threshold && pos < release_threshold) 
+    {
+      add_button_event(MENU_DOWN_BUTTON, 0);
     }
+  }
 
   InputManager::add_axis_event(name, pos);
 }

Modified: trunk/windstille/src/input/wiimote.cpp
===================================================================
--- trunk/windstille/src/input/wiimote.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/input/wiimote.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -82,100 +82,100 @@
   printf("Put Wiimote in discoverable mode now (press 1+2)...\n");
 
   if (!(m_wiimote = cwiid_connect(&bdaddr, CWIID_FLAG_MESG_IFC))) 
+  {
+    fprintf(stderr, "Unable to connect to wiimote\n");
+  }
+  else 
+  {
+    std::cout << "Wiimote connected: " << m_wiimote << std::endl;
+    if (cwiid_set_mesg_callback(m_wiimote, &Wiimote::mesg_callback)) {
+      std::cerr << "Unable to set message callback" << std::endl;
+    }
+
+    if (cwiid_command(m_wiimote, CWIID_CMD_RPT_MODE, 
+                      CWIID_RPT_STATUS  |
+                      CWIID_RPT_NUNCHUK |
+                      CWIID_RPT_ACC     |
+                      CWIID_RPT_BTN))
     {
-      fprintf(stderr, "Unable to connect to wiimote\n");
+      std::cerr << "Wiimote: Error setting report mode" << std::endl;
     }
-  else 
-    {
-      std::cout << "Wiimote connected: " << m_wiimote << std::endl;
-      if (cwiid_set_mesg_callback(m_wiimote, &Wiimote::mesg_callback)) {
-        std::cerr << "Unable to set message callback" << std::endl;
-      }
 
-      if (cwiid_command(m_wiimote, CWIID_CMD_RPT_MODE, 
-                        CWIID_RPT_STATUS  |
-                        CWIID_RPT_NUNCHUK |
-                        CWIID_RPT_ACC     |
-                        CWIID_RPT_BTN))
-        {
-          std::cerr << "Wiimote: Error setting report mode" << std::endl;
-        }
+    { // read calibration data
+      uint8_t buf[7];
 
-      { // read calibration data
-	uint8_t buf[7];
+      if (cwiid_read(m_wiimote, CWIID_RW_EEPROM, 0x16, 7, buf))
+      {
+        std::cout << "Wiimote: Unable to retrieve accelerometer calibration" << std::endl;
+      }
+      else
+      {
+        wiimote_zero.x = buf[0];
+        wiimote_zero.y = buf[1];
+        wiimote_zero.z = buf[2];
 
-        if (cwiid_read(m_wiimote, CWIID_RW_EEPROM, 0x16, 7, buf))
-          {
-            std::cout << "Wiimote: Unable to retrieve accelerometer calibration" << std::endl;
-          }
-        else
-          {
-            wiimote_zero.x = buf[0];
-            wiimote_zero.y = buf[1];
-            wiimote_zero.z = buf[2];
+        wiimote_one.x  = buf[4];
+        wiimote_one.y  = buf[5];
+        wiimote_one.z  = buf[6];
+      }
 
-            wiimote_one.x  = buf[4];
-            wiimote_one.y  = buf[5];
-            wiimote_one.z  = buf[6];
-          }
-
-        if (cwiid_read(m_wiimote, CWIID_RW_REG | CWIID_RW_DECODE, 0xA40020, 7, buf))
-          {
-            std::cout << "Wiimote: Unable to retrieve wiimote accelerometer calibration" << std::endl;
-          }
-        else
-          {
-            nunchuk_zero.x = buf[0];
-            nunchuk_zero.y = buf[1];
-            nunchuk_zero.z = buf[2];
+      if (cwiid_read(m_wiimote, CWIID_RW_REG | CWIID_RW_DECODE, 0xA40020, 7, buf))
+      {
+        std::cout << "Wiimote: Unable to retrieve wiimote accelerometer calibration" << std::endl;
+      }
+      else
+      {
+        nunchuk_zero.x = buf[0];
+        nunchuk_zero.y = buf[1];
+        nunchuk_zero.z = buf[2];
             
-            nunchuk_one.x  = buf[4];
-            nunchuk_one.y  = buf[5];
-            nunchuk_one.z  = buf[6];
-          }
+        nunchuk_one.x  = buf[4];
+        nunchuk_one.y  = buf[5];
+        nunchuk_one.z  = buf[6];
+      }
 
-        std::cout << "Wiimote Calibration: "
-                  << static_cast<int>(wiimote_zero.x) << ", "
-                  << static_cast<int>(wiimote_zero.x) << ", "
-                  << static_cast<int>(wiimote_zero.x) << " - "
-                  << static_cast<int>(wiimote_one.x) << ", "
-                  << static_cast<int>(wiimote_one.x) << ", "
-                  << static_cast<int>(wiimote_one.x) << std::endl;
+      std::cout << "Wiimote Calibration: "
+                << static_cast<int>(wiimote_zero.x) << ", "
+                << static_cast<int>(wiimote_zero.x) << ", "
+                << static_cast<int>(wiimote_zero.x) << " - "
+                << static_cast<int>(wiimote_one.x) << ", "
+                << static_cast<int>(wiimote_one.x) << ", "
+                << static_cast<int>(wiimote_one.x) << std::endl;
 
-        std::cout << "Nunchuk Calibration: "
-                  << static_cast<int>(nunchuk_zero.x) << ", "
-                  << static_cast<int>(nunchuk_zero.x) << ", "
-                  << static_cast<int>(nunchuk_zero.x) << " - "
-                  << static_cast<int>(nunchuk_one.x) << ", "
-                  << static_cast<int>(nunchuk_one.x) << ", "
-                  << static_cast<int>(nunchuk_one.x) << std::endl;
+      std::cout << "Nunchuk Calibration: "
+                << static_cast<int>(nunchuk_zero.x) << ", "
+                << static_cast<int>(nunchuk_zero.x) << ", "
+                << static_cast<int>(nunchuk_zero.x) << " - "
+                << static_cast<int>(nunchuk_one.x) << ", "
+                << static_cast<int>(nunchuk_one.x) << ", "
+                << static_cast<int>(nunchuk_one.x) << std::endl;
           
-      }
     }
+  }
 }
 
 void
 Wiimote::disconnect()
 {
   if (m_wiimote)
-    {
-      cwiid_disconnect(m_wiimote);
-      m_wiimote = 0;
-    }
+  {
+    cwiid_disconnect(m_wiimote);
+    m_wiimote = 0;
+  }
 }
 
 void
 Wiimote::set_led(unsigned char led_state)
 {
   if (m_led_state != led_state)
-    {
-      //std::cout << "Wiimote: " << static_cast<int>(m_led_state) << std::endl;
-      m_led_state = led_state;
+  {
+    //std::cout << "Wiimote: " << static_cast<int>(m_led_state) << std::endl;
+    m_led_state = led_state;
 
-      if (cwiid_command(m_wiimote, CWIID_CMD_LED, m_led_state)) {
-        fprintf(stderr, "Error setting LEDs \n");
-      }
+    if (cwiid_command(m_wiimote, CWIID_CMD_LED, m_led_state)) {
+      fprintf(stderr, "Error setting LEDs \n");
     }
+  }
 }
 
 void
@@ -196,13 +196,13 @@
 Wiimote::set_rumble(bool r)
 {
   if (r != m_rumble)
-    {
-      m_rumble = r;
+  {
+    m_rumble = r;
 
-      if (cwiid_command(m_wiimote, CWIID_CMD_RUMBLE, m_rumble)) {
-        std::cerr << "Error setting rumble" << std::endl;
-      }
+    if (cwiid_command(m_wiimote, CWIID_CMD_RUMBLE, m_rumble)) {
+      std::cerr << "Error setting rumble" << std::endl;
     }
+  }
 }
 
 void
@@ -255,7 +255,7 @@
 {
   printf("Status Report: battery=%d extension=", msg.battery);
   switch (msg.ext_type)
-    {
+  {
     case CWIID_EXT_NONE:
       printf("none");
       break;
@@ -271,7 +271,7 @@
     default:
       printf("Unknown Extension");
       break;
-    }
+  }
   printf("\n");
 }
 
@@ -281,13 +281,13 @@
   std::cout << "On Error" << std::endl;
 
   if (m_wiimote)
+  {
+    if (cwiid_disconnect(m_wiimote)) 
     {
-      if (cwiid_disconnect(m_wiimote)) 
-        {
-          fprintf(stderr, "Error on wiimote disconnect\n");
-          m_wiimote = 0;
-        }
+      fprintf(stderr, "Error on wiimote disconnect\n");
+      m_wiimote = 0;
     }
+  }
 }
 
 void
@@ -330,11 +330,11 @@
 {
   printf("IR Report: ");
   for (int i = 0; i < CWIID_IR_SRC_COUNT; ++i)
-    {
-      if (msg.src[i].valid) {
-        printf("(%d,%d) ", msg.src[i].pos[0], msg.src[i].pos[1]);
-      }
+  {
+    if (msg.src[i].valid) {
+      printf("(%d,%d) ", msg.src[i].pos[0], msg.src[i].pos[1]);
     }
+  }
 }
 
 /** Convert value to float while taking calibration data, left/center/right into account */
@@ -344,17 +344,17 @@
                       uint8_t value)
 {
   if (value < center)
-    {
-      return math::mid(-1.0f, -static_cast<float>(center - value) / static_cast<float>(center - min), 1.0f);
-    }
+  {
+    return math::mid(-1.0f, -static_cast<float>(center - value) / static_cast<float>(center - min), 1.0f);
+  }
   else if (value > center)
-    {
-      return math::mid(-1.0f, static_cast<float>(value - center) / static_cast<float>(max - center), 1.0f);
-    }
+  {
+    return math::mid(-1.0f, static_cast<float>(value - center) / static_cast<float>(max - center), 1.0f);
+  }
   else 
-    {
-      return 0.0f;
-    }
+  {
+    return 0.0f;
+  }
 }
 
 void
@@ -374,16 +374,16 @@
   float nunchuk_stick_y = -to_float(22, 119, 213, msg.stick[1]);
 
   if (m_nunchuk_stick_x != nunchuk_stick_x)
-    {
-      m_nunchuk_stick_x = nunchuk_stick_x;
-      add_axis_event(0, 0, m_nunchuk_stick_x);
-    } 
+  {
+    m_nunchuk_stick_x = nunchuk_stick_x;
+    add_axis_event(0, 0, m_nunchuk_stick_x);
+  } 
 
   if (m_nunchuk_stick_y != nunchuk_stick_y)
-    {
-      m_nunchuk_stick_y = nunchuk_stick_y;
-      add_axis_event(0, 1, m_nunchuk_stick_y);
-    }
+  {
+    m_nunchuk_stick_y = nunchuk_stick_y;
+    add_axis_event(0, 1, m_nunchuk_stick_y);
+  }
 
   add_acc_event(0, 1, 
                 static_cast<float>(msg.acc[0] - nunchuk_zero.x) / static_cast<float>(nunchuk_one.x - nunchuk_zero.x),
@@ -442,42 +442,42 @@
 
   //std::cout << "StatusCallback: " << w << " " << mesg_count << std::endl;
   for (int i=0; i < mesg_count; i++)
+  {
+    switch (msg[i].type) 
     {
-      switch (msg[i].type) 
-        {
-        case CWIID_MESG_STATUS:
-          wiimote->on_status(msg[i].status_mesg);
-          break;
+      case CWIID_MESG_STATUS:
+        wiimote->on_status(msg[i].status_mesg);
+        break;
 
-        case CWIID_MESG_BTN:
-          wiimote->on_button(msg[i].btn_mesg);
-          break;
+      case CWIID_MESG_BTN:
+        wiimote->on_button(msg[i].btn_mesg);
+        break;
 
-        case CWIID_MESG_ACC:
-          wiimote->on_acc(msg[i].acc_mesg);
-          break;
+      case CWIID_MESG_ACC:
+        wiimote->on_acc(msg[i].acc_mesg);
+        break;
 
-        case CWIID_MESG_IR:
-          wiimote->on_ir(msg[i].ir_mesg);
-          break;
+      case CWIID_MESG_IR:
+        wiimote->on_ir(msg[i].ir_mesg);
+        break;
 
-        case CWIID_MESG_NUNCHUK:
-          wiimote->on_nunchuck(msg[i].nunchuk_mesg);
-          break;
+      case CWIID_MESG_NUNCHUK:
+        wiimote->on_nunchuck(msg[i].nunchuk_mesg);
+        break;
 
-        case CWIID_MESG_CLASSIC:
-          wiimote->on_classic(msg[i].classic_mesg);
-          break;
+      case CWIID_MESG_CLASSIC:
+        wiimote->on_classic(msg[i].classic_mesg);
+        break;
 
-        case CWIID_MESG_ERROR:
-          wiimote->on_error(msg[i].error_mesg);
-          break;
+      case CWIID_MESG_ERROR:
+        wiimote->on_error(msg[i].error_mesg);
+        break;
 
-        default:
-          printf("Wiimote: Unknown Report");
-          break;
-        }
+      default:
+        printf("Wiimote: Unknown Report");
+        break;
     }
+  }
 
   pthread_mutex_unlock(&mutex);
 }

Modified: trunk/windstille/src/lisp/lexer.cpp
===================================================================
--- trunk/windstille/src/lisp/lexer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/lisp/lexer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -28,8 +28,8 @@
 {
 };
 
-Lexer::Lexer(std::istream& newstream)
-  : stream(newstream), eof(false), linenumber(0), bufend(0), c(0), token_length(0)
+Lexer::Lexer(std::istream& newstream) :
+  stream(newstream), eof(false), linenumber(0), bufend(0), c(0), token_length(0)
 {
   try {
     // trigger a refill of the buffer
@@ -125,7 +125,7 @@
         } catch(EOFException& ) {
           std::stringstream msg;
           msg << "Parse error in line " << startline << ": "
-            << "EOF while parsing string.";
+              << "EOF while parsing string.";
           throw std::runtime_error(msg.str());
         }
         nextChar();
@@ -144,7 +144,7 @@
         } catch(EOFException& ) {
           std::stringstream msg;
           msg << "Parse Error in line " << linenumber << ": "
-            << "EOF while parsing constant.";
+              << "EOF while parsing constant.";
           throw std::runtime_error(msg.str());
         }
 
@@ -158,7 +158,7 @@
         {
           std::stringstream msg;
           msg << "Parse Error in line " << linenumber << ": "
-            << "Unknown constant '" << token_string << "'.";
+              << "Unknown constant '" << token_string << "'.";
           throw std::runtime_error(msg.str());
         }
 

Modified: trunk/windstille/src/lisp/lisp.cpp
===================================================================
--- trunk/windstille/src/lisp/lisp.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/lisp/lisp.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -23,35 +23,35 @@
 namespace lisp
 {
     
-Lisp::Lisp(int val)
-  : v(),
-    type(TYPE_INT)    
+Lisp::Lisp(int val) :
+  v(),
+  type(TYPE_INT)    
 {
   v.int_ = val;
 }
 
-Lisp::Lisp(float val)
-  : type(TYPE_FLOAT)
+Lisp::Lisp(float val) :
+  type(TYPE_FLOAT)
 {
   v.float_ = val;
 }
 
-Lisp::Lisp(bool val)
-  : type(TYPE_BOOL)
+Lisp::Lisp(bool val) :
+  type(TYPE_BOOL)
 {
   v.bool_ = val;
 }
 
-Lisp::Lisp(LispType newtype, const std::string& str)
-  : type(newtype)
+Lisp::Lisp(LispType newtype, const std::string& str) :
+  type(newtype)
 {
   assert(newtype == TYPE_SYMBOL || type == TYPE_STRING);
   v.string = new char[str.size()+1];
   memcpy(v.string, str.c_str(), str.size()+1);
 }
 
-Lisp::Lisp(const std::vector<Lisp*>& list_elements)
-  : type(TYPE_LIST)
+Lisp::Lisp(const std::vector<Lisp*>& list_elements) :
+  type(TYPE_LIST)
 {
   v.list.size = list_elements.size();
   v.list.entries = new Lisp* [v.list.size];
@@ -82,11 +82,11 @@
       out << "(";
 
       for(size_t i = 0; i < v.list.size; ++i)
-        {
-          v.list.entries[i]->print(out, indent);
-          if (i != v.list.size-1)
-            out << ' ';
-        }
+      {
+        v.list.entries[i]->print(out, indent);
+        if (i != v.list.size-1)
+          out << ' ';
+      }
 
       out << ")";
       break;

Modified: trunk/windstille/src/lisp/parser.cpp
===================================================================
--- trunk/windstille/src/lisp/parser.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/lisp/parser.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -37,7 +37,7 @@
   {
     std::ostringstream msg;
     msg << "Parse error in file '" << parser->filename << "' line "
-      << parser->lexer->getLineNumber() << ": " << message;
+        << parser->lexer->getLineNumber() << ": " << message;
     string = msg.str();
   }
   ~ParseError() throw()
@@ -52,10 +52,10 @@
   std::string string;
 };
 
-Parser::Parser()
-  : filename(),
-    lexer(0),
-    token()
+Parser::Parser() :
+  filename(),
+  lexer(0),
+  token()
 {
 }
 
@@ -112,7 +112,7 @@
         
           // Handle (_ "blup") strings that need to be translated
           if(token == Lexer::TOKEN_SYMBOL
-              && strcmp(lexer->getString(), "_") == 0) {
+             && strcmp(lexer->getString(), "_") == 0) {
             token = lexer->getNextToken();
             if(token != Lexer::TOKEN_STRING)
               throw ParseError(this, "Expected string after '(_' sequence");

Modified: trunk/windstille/src/lisp/properties.cpp
===================================================================
--- trunk/windstille/src/lisp/properties.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/lisp/properties.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -7,26 +7,26 @@
 Properties::Properties(const Lisp* lisp)
 {
   if (lisp)
-    {
-      if(lisp->get_type() != Lisp::TYPE_LIST)
-        throw std::runtime_error("Lisp is not a list");
+  {
+    if(lisp->get_type() != Lisp::TYPE_LIST)
+      throw std::runtime_error("Lisp is not a list");
 
-      for(size_t i = 0; i < lisp->get_list_size(); ++i) {
-        const Lisp* child = lisp->get_list_elem(i);
-        if(i == 0 && child->get_type() == Lisp::TYPE_SYMBOL)
-          continue;
-        if(child->get_type() != Lisp::TYPE_LIST)
-          throw std::runtime_error("child of properties lisp is not a list");
-        if(child->get_list_size() > 1)
-          {    
-            const Lisp* name = child->get_list_elem(0);
-            if(name->get_type() != Lisp::TYPE_SYMBOL)
-              throw std::runtime_error("property has no symbol as name");
-            properties.insert(std::make_pair(
-                                             std::string(name->get_symbol()), ListEntry(child)));
-          }
+    for(size_t i = 0; i < lisp->get_list_size(); ++i) {
+      const Lisp* child = lisp->get_list_elem(i);
+      if(i == 0 && child->get_type() == Lisp::TYPE_SYMBOL)
+        continue;
+      if(child->get_type() != Lisp::TYPE_LIST)
+        throw std::runtime_error("child of properties lisp is not a list");
+      if(child->get_list_size() > 1)
+      {    
+        const Lisp* name = child->get_list_elem(0);
+        if(name->get_type() != Lisp::TYPE_SYMBOL)
+          throw std::runtime_error("property has no symbol as name");
+        properties.insert(std::make_pair(
+                            std::string(name->get_symbol()), ListEntry(child)));
       }
     }
+  }
 }
 
 Properties::~Properties()

Modified: trunk/windstille/src/lisp/writer.cpp
===================================================================
--- trunk/windstille/src/lisp/writer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/lisp/writer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -25,22 +25,22 @@
 namespace lisp
 {
 
-Writer::Writer(const Pathname& filename)
-  : out(),
-    out_owned(),
-    indent_depth(),
-    lists()
+Writer::Writer(const Pathname& filename) :
+  out(),
+  out_owned(),
+  indent_depth(),
+  lists()
 {
   out = new std::ofstream(filename.get_sys_path().c_str());
   out_owned = true;
   indent_depth = 0;
 }
   
-Writer::Writer(std::ostream* newout)
-  : out(),
-    out_owned(),
-    indent_depth(),
-    lists()
+Writer::Writer(std::ostream* newout) :
+  out(),
+  out_owned(),
+  indent_depth(),
+  lists()
 {
   out = newout;
   out_owned = false;
@@ -108,7 +108,7 @@
 
 void
 Writer::write_string(const std::string& name, const std::string& value,
-    bool translatable)
+                     bool translatable)
 {
   indent();
   *out << '(' << name;
@@ -128,7 +128,7 @@
 
 void
 Writer::write_int_vector(const std::string& name,
-    const std::vector<int>& value)
+                         const std::vector<int>& value)
 {
   indent();
   *out << '(' << name;
@@ -139,7 +139,7 @@
 
 void
 Writer::write_int_vector(const std::string& name,
-    const std::vector<unsigned int>& value)
+                         const std::vector<unsigned int>& value)
 {
   indent();
   *out << '(' << name;

Modified: trunk/windstille/src/math/line.cpp
===================================================================
--- trunk/windstille/src/math/line.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/math/line.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -55,17 +55,17 @@
   float quotient = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
 
   if (quotient == 0.0f)
-    {
-      return false; // FIXME
-    }
+  {
+    return false; // FIXME
+  }
   else
-    {
-      ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / quotient;
-      ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / quotient;
+  {
+    ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / quotient;
+    ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / quotient;
 
-      return (ua >= 0.0f && ua <= 1.0f &&
-              ub >= 0.0f && ub <= 1.0f);
-    }
+    return (ua >= 0.0f && ua <= 1.0f &&
+            ub >= 0.0f && ub <= 1.0f);
+  }
 }
 
 bool
@@ -73,14 +73,14 @@
 {
   float ua, ub;
   if (intersect(line, ua, ub))
-    {
-      colpos = p1 + ((p2 - p1) * ua);
-      return true;
-    }
+  {
+    colpos = p1 + ((p2 - p1) * ua);
+    return true;
+  }
   else
-    {
-      return false;
-    }
+  {
+    return false;
+  }
 }
 
 float
@@ -100,20 +100,20 @@
     (length() * length());
   
   if (u < 0.0f)
-    {
-      return (p1 - p3).length();
-    }
+  {
+    return (p1 - p3).length();
+  }
   else if (u > 1.0f)
-    {
-      return (p2 - p3).length();
-    }
+  {
+    return (p2 - p3).length();
+  }
   else // (u >= 0.0f && u <= 1.0f)
-    {
-      Vector2f p4(x1 + u * (x2 - x1),
+  {
+    Vector2f p4(x1 + u * (x2 - x1),
                 y1 + u * (y2 - y1));
 
-      return (p4 - p3).length();
-    }
+    return (p4 - p3).length();
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/math/matrix.cpp
===================================================================
--- trunk/windstille/src/math/matrix.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/math/matrix.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -51,7 +51,7 @@
   matrix.matrix[5]  = 1.0;
   matrix.matrix[10] = 1.0;
   matrix.matrix[15] = 1.0;
-	
+        
   return matrix;
 }
 
@@ -141,16 +141,16 @@
 {
   Matrix result;
   for (int x=0; x<4; x++)
+  {
+    for (int y=0; y<4; y++)
     {
-      for (int y=0; y<4; y++)
-        {
-          result.matrix[x+y*4] =
-            matrix[x   ] * mult.matrix[y*4  ] +
-            matrix[x+ 4] * mult.matrix[y*4+1] +
-            matrix[x+ 8] * mult.matrix[y*4+2] +
-            matrix[x+12] * mult.matrix[y*4+3];
-        }
+      result.matrix[x+y*4] =
+        matrix[x   ] * mult.matrix[y*4  ] +
+        matrix[x+ 4] * mult.matrix[y*4+1] +
+        matrix[x+ 8] * mult.matrix[y*4+2] +
+        matrix[x+12] * mult.matrix[y*4+3];
     }
+  }
   return result;
 }
 
@@ -196,12 +196,12 @@
 {
   float len2 = x*x+y*y+z*z;
   if (len2 != 1.0)
-    {
-      float len = sqrtf(len2);
-      x /= len;
-      y /= len;
-      z /= len;
-    }
+  {
+    float len = sqrtf(len2);
+    x /= len;
+    y /= len;
+    z /= len;
+  }
 
   float c = cosf(angle * 3.14159265f / 180.0f);
   float s = sinf(angle * 3.14159265f / 180.0f);
@@ -229,38 +229,38 @@
 {
   float det = determinat();
   if (det != 0)
-    {
-      Matrix b;
+  {
+    Matrix b;
 #if 0
-      const Matrix& m = *this;
+    const Matrix& m = *this;
 
-      // FIXME: wrong start index, should be 0, is 1
-      b(0,0) = m(2,2)*m(3,3)*m(4,4) + m(2,3)*m(3,4)*m(4,2) + m(2,4)*m(3,2)*m(4,3) - m(2,2)*m(3,4)*m(4,3) - m(2,3)*m(3,2)*m(4,4) - m(2,4)*m(3,3)*m(4,2);
-      b(0,1) = m(1,2)*m(3,4)*m(4,3) + m(1,3)*m(3,2)*m(4,4) + m(1,4)*m(3,3)*m(4,2) - m(1,2)*m(3,3)*m(4,4) - m(1,3)*m(3,4)*m(4,2) - m(1,4)*m(3,2)*m(4,3);
-      b(0,2) = m(1,2)*m(2,3)*m(4,4) + m(1,3)*m(2,4)*m(4,2) + m(1,4)*m(2,2)*m(4,3) - m(1,2)*m(2,4)*m(4,3) - m(1,3)*m(2,2)*m(4,4) - m(1,4)*m(2,3)*m(4,2);
-      b(0,3) = m(1,2)*m(2,4)*m(3,3) + m(1,3)*m(2,2)*m(3,4) + m(1,4)*m(2,3)*m(3,2) - m(1,2)*m(2,3)*m(3,4) - m(1,3)*m(2,4)*m(3,2) - m(1,4)*m(2,2)*m(3,3);
+    // FIXME: wrong start index, should be 0, is 1
+    b(0,0) = m(2,2)*m(3,3)*m(4,4) + m(2,3)*m(3,4)*m(4,2) + m(2,4)*m(3,2)*m(4,3) - m(2,2)*m(3,4)*m(4,3) - m(2,3)*m(3,2)*m(4,4) - m(2,4)*m(3,3)*m(4,2);
+    b(0,1) = m(1,2)*m(3,4)*m(4,3) + m(1,3)*m(3,2)*m(4,4) + m(1,4)*m(3,3)*m(4,2) - m(1,2)*m(3,3)*m(4,4) - m(1,3)*m(3,4)*m(4,2) - m(1,4)*m(3,2)*m(4,3);
+    b(0,2) = m(1,2)*m(2,3)*m(4,4) + m(1,3)*m(2,4)*m(4,2) + m(1,4)*m(2,2)*m(4,3) - m(1,2)*m(2,4)*m(4,3) - m(1,3)*m(2,2)*m(4,4) - m(1,4)*m(2,3)*m(4,2);
+    b(0,3) = m(1,2)*m(2,4)*m(3,3) + m(1,3)*m(2,2)*m(3,4) + m(1,4)*m(2,3)*m(3,2) - m(1,2)*m(2,3)*m(3,4) - m(1,3)*m(2,4)*m(3,2) - m(1,4)*m(2,2)*m(3,3);
                                                                                                                                                               
-      b(1,0) = m(2,1)*m(3,4)*m(4,3) + m(2,3)*m(3,1)*m(4,4) + m(2,4)*m(3,3)*m(4,1) - m(2,1)*m(3,3)*m(4,4) - m(2,3)*m(3,4)*m(4,1) - m(2,4)*m(3,1)*m(4,3);
-      b(1,1) = m(1,1)*m(3,3)*m(4,4) + m(1,3)*m(3,4)*m(4,1) + m(1,4)*m(3,1)*m(4,3) - m(1,1)*m(3,4)*m(4,3) - m(1,3)*m(3,1)*m(4,4) - m(1,4)*m(3,3)*m(4,1);
-      b(1,2) = m(1,1)*m(2,4)*m(4,3) + m(1,3)*m(2,1)*m(4,4) + m(1,4)*m(2,3)*m(4,1) - m(1,1)*m(2,3)*m(4,4) - m(1,3)*m(2,4)*m(4,1) - m(1,4)*m(2,1)*m(4,3);
-      b(1,3) = m(1,1)*m(2,3)*m(3,4) + m(1,3)*m(2,4)*m(3,1) + m(1,4)*m(2,1)*m(3,3) - m(1,1)*m(2,4)*m(3,3) - m(1,3)*m(2,1)*m(3,4) - m(1,4)*m(2,3)*m(3,1);
+    b(1,0) = m(2,1)*m(3,4)*m(4,3) + m(2,3)*m(3,1)*m(4,4) + m(2,4)*m(3,3)*m(4,1) - m(2,1)*m(3,3)*m(4,4) - m(2,3)*m(3,4)*m(4,1) - m(2,4)*m(3,1)*m(4,3);
+    b(1,1) = m(1,1)*m(3,3)*m(4,4) + m(1,3)*m(3,4)*m(4,1) + m(1,4)*m(3,1)*m(4,3) - m(1,1)*m(3,4)*m(4,3) - m(1,3)*m(3,1)*m(4,4) - m(1,4)*m(3,3)*m(4,1);
+    b(1,2) = m(1,1)*m(2,4)*m(4,3) + m(1,3)*m(2,1)*m(4,4) + m(1,4)*m(2,3)*m(4,1) - m(1,1)*m(2,3)*m(4,4) - m(1,3)*m(2,4)*m(4,1) - m(1,4)*m(2,1)*m(4,3);
+    b(1,3) = m(1,1)*m(2,3)*m(3,4) + m(1,3)*m(2,4)*m(3,1) + m(1,4)*m(2,1)*m(3,3) - m(1,1)*m(2,4)*m(3,3) - m(1,3)*m(2,1)*m(3,4) - m(1,4)*m(2,3)*m(3,1);
                                                                                                                                                               
-      b(2,0) = m(2,1)*m(3,2)*m(4,4) + m(2,2)*m(3,4)*m(4,1) + m(2,4)*m(3,1)*m(4,2) - m(2,1)*m(3,4)*m(4,2) - m(2,2)*m(3,1)*m(4,1) - m(2,4)*m(3,2)*m(4,1);
-      b(2,1) = m(1,1)*m(3,4)*m(4,2) + m(1,2)*m(3,1)*m(4,4) + m(1,4)*m(3,2)*m(4,1) - m(1,1)*m(3,2)*m(4,4) - m(1,2)*m(3,4)*m(4,1) - m(1,4)*m(3,1)*m(4,2);
-      b(2,2) = m(1,1)*m(2,2)*m(4,4) + m(1,2)*m(2,4)*m(4,1) + m(1,4)*m(2,1)*m(4,2) - m(1,1)*m(2,4)*m(4,2) - m(1,2)*m(2,1)*m(4,4) - m(1,4)*m(2,2)*m(4,1);
-      b(2,3) = m(1,1)*m(2,4)*m(3,2) + m(1,2)*m(2,1)*m(3,4) + m(1,4)*m(2,2)*m(3,1) - m(1,1)*m(2,2)*m(3,4) - m(1,2)*m(2,4)*m(3,1) - m(1,4)*m(2,1)*m(3,2);
+    b(2,0) = m(2,1)*m(3,2)*m(4,4) + m(2,2)*m(3,4)*m(4,1) + m(2,4)*m(3,1)*m(4,2) - m(2,1)*m(3,4)*m(4,2) - m(2,2)*m(3,1)*m(4,1) - m(2,4)*m(3,2)*m(4,1);
+    b(2,1) = m(1,1)*m(3,4)*m(4,2) + m(1,2)*m(3,1)*m(4,4) + m(1,4)*m(3,2)*m(4,1) - m(1,1)*m(3,2)*m(4,4) - m(1,2)*m(3,4)*m(4,1) - m(1,4)*m(3,1)*m(4,2);
+    b(2,2) = m(1,1)*m(2,2)*m(4,4) + m(1,2)*m(2,4)*m(4,1) + m(1,4)*m(2,1)*m(4,2) - m(1,1)*m(2,4)*m(4,2) - m(1,2)*m(2,1)*m(4,4) - m(1,4)*m(2,2)*m(4,1);
+    b(2,3) = m(1,1)*m(2,4)*m(3,2) + m(1,2)*m(2,1)*m(3,4) + m(1,4)*m(2,2)*m(3,1) - m(1,1)*m(2,2)*m(3,4) - m(1,2)*m(2,4)*m(3,1) - m(1,4)*m(2,1)*m(3,2);
                                                                                                                                                               
-      b(3,0) = m(2,1)*m(3,3)*m(4,2) + m(2,2)*m(3,1)*m(4,3) + m(2,3)*m(3,2)*m(4,1) - m(2,1)*m(3,2)*m(4,3) - m(2,2)*m(3,3)*m(4,1) - m(2,3)*m(3,1)*m(4,2);
-      b(3,1) = m(1,1)*m(3,2)*m(4,3) + m(1,2)*m(3,3)*m(4,1) + m(1,3)*m(3,1)*m(4,2) - m(1,1)*m(3,3)*m(4,2) - m(1,2)*m(3,1)*m(4,3) - m(1,3)*m(3,2)*m(4,1);
-      b(3,2) = m(1,1)*m(2,3)*m(4,2) + m(1,2)*m(2,1)*m(4,3) + m(1,3)*m(2,2)*m(4,1) - m(1,1)*m(2,2)*m(4,3) - m(1,2)*m(2,3)*m(4,1) - m(1,3)*m(2,1)*m(4,2);
-      b(3,3) = m(1,1)*m(2,2)*m(3,3) + m(1,2)*m(2,3)*m(3,1) + m(1,3)*m(2,1)*m(3,2) - m(1,1)*m(2,3)*m(3,2) - m(1,2)*m(2,1)*m(3,3) - m(1,3)*m(2,2)*m(3,1);
+    b(3,0) = m(2,1)*m(3,3)*m(4,2) + m(2,2)*m(3,1)*m(4,3) + m(2,3)*m(3,2)*m(4,1) - m(2,1)*m(3,2)*m(4,3) - m(2,2)*m(3,3)*m(4,1) - m(2,3)*m(3,1)*m(4,2);
+    b(3,1) = m(1,1)*m(3,2)*m(4,3) + m(1,2)*m(3,3)*m(4,1) + m(1,3)*m(3,1)*m(4,2) - m(1,1)*m(3,3)*m(4,2) - m(1,2)*m(3,1)*m(4,3) - m(1,3)*m(3,2)*m(4,1);
+    b(3,2) = m(1,1)*m(2,3)*m(4,2) + m(1,2)*m(2,1)*m(4,3) + m(1,3)*m(2,2)*m(4,1) - m(1,1)*m(2,2)*m(4,3) - m(1,2)*m(2,3)*m(4,1) - m(1,3)*m(2,1)*m(4,2);
+    b(3,3) = m(1,1)*m(2,2)*m(3,3) + m(1,2)*m(2,3)*m(3,1) + m(1,3)*m(2,1)*m(3,2) - m(1,1)*m(2,3)*m(3,2) - m(1,2)*m(2,1)*m(3,3) - m(1,3)*m(2,2)*m(3,1);
 #endif
-      return b;
-    }
+    return b;
+  }
   else
-    {
-      assert(!"Matrix can't be inverted");
-    }
+  {
+    assert(!"Matrix can't be inverted");
+  }
 }
 
 float

Modified: trunk/windstille/src/math/origin.cpp
===================================================================
--- trunk/windstille/src/math/origin.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/math/origin.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -31,72 +31,72 @@
 
 Point calc_origin(Origin origin, const Size &size)
 {
-	switch(origin)
-	{
-	case origin::top_left:
-	default:
-		return Point(0, 0);
-		break;
-	case origin::top_center:
-		return Point(size.width / 2, 0);
-		break;
-	case origin::top_right:
-		return Point(size.width, 0);
-		break;
-	case origin::center_left:
-		return Point(0, size.height / 2);
-		break;
-	case origin::center:
-		return Point(size.width / 2, size.height / 2);
-		break;
-	case origin::center_right:
-		return Point(size.width, size.height / 2);
-		break;
-	case origin::bottom_left:
-		return Point(0, size.height);
-		break;
-	case origin::bottom_center:
-		return Point(size.width / 2, size.height);
-		break;
-	case origin::bottom_right:
-		return Point(size.width, size.height);
-		break;
-	}
+  switch(origin)
+  {
+    case origin::top_left:
+    default:
+      return Point(0, 0);
+      break;
+    case origin::top_center:
+      return Point(size.width / 2, 0);
+      break;
+    case origin::top_right:
+      return Point(size.width, 0);
+      break;
+    case origin::center_left:
+      return Point(0, size.height / 2);
+      break;
+    case origin::center:
+      return Point(size.width / 2, size.height / 2);
+      break;
+    case origin::center_right:
+      return Point(size.width, size.height / 2);
+      break;
+    case origin::bottom_left:
+      return Point(0, size.height);
+      break;
+    case origin::bottom_center:
+      return Point(size.width / 2, size.height);
+      break;
+    case origin::bottom_right:
+      return Point(size.width, size.height);
+      break;
+  }
 }
 
 Vector2f calc_origin(Origin origin, const Sizef &size)
 {
-	switch(origin)
-	{
-	case origin::top_left:
-	default:
-		return Vector2f(0, 0);
-		break;
-	case origin::top_center:
-		return Vector2f(size.width / 2, 0);
-		break;
-	case origin::top_right:
-		return Vector2f(size.width, 0);
-		break;
-	case origin::center_left:
-		return Vector2f(0, size.height / 2);
-		break;
-	case origin::center:
-		return Vector2f(size.width / 2, size.height / 2);
-		break;
-	case origin::center_right:
-		return Vector2f(size.width, size.height / 2);
-		break;
-	case origin::bottom_left:
-		return Vector2f(0, size.height);
-		break;
-	case origin::bottom_center:
-		return Vector2f(size.width / 2, size.height);
-		break;
-	case origin::bottom_right:
-		return Vector2f(size.width, size.height);
-		break;
-	}
+  switch(origin)
+  {
+    case origin::top_left:
+    default:
+      return Vector2f(0, 0);
+      break;
+    case origin::top_center:
+      return Vector2f(size.width / 2, 0);
+      break;
+    case origin::top_right:
+      return Vector2f(size.width, 0);
+      break;
+    case origin::center_left:
+      return Vector2f(0, size.height / 2);
+      break;
+    case origin::center:
+      return Vector2f(size.width / 2, size.height / 2);
+      break;
+    case origin::center_right:
+      return Vector2f(size.width, size.height / 2);
+      break;
+    case origin::bottom_left:
+      return Vector2f(0, size.height);
+      break;
+    case origin::bottom_center:
+      return Vector2f(size.width / 2, size.height);
+      break;
+    case origin::bottom_right:
+      return Vector2f(size.width, size.height);
+      break;
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/math/origin.hpp
===================================================================
--- trunk/windstille/src/math/origin.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/math/origin.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -43,15 +43,15 @@
 //- !header=core.h!
 enum Origin
 {
-	top_left,
-	top_center,
-	top_right,
-	center_left,
-	center,
-	center_right,
-	bottom_left,
-	bottom_center,
-	bottom_right
+  top_left,
+  top_center,
+  top_right,
+  center_left,
+  center,
+  center_right,
+  bottom_left,
+  bottom_center,
+  bottom_right
 };
 
 }

Modified: trunk/windstille/src/math/point.hpp
===================================================================
--- trunk/windstille/src/math/point.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/math/point.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -81,13 +81,13 @@
   {
     //Move the hotspot to 0,0
     Point r(x - hotspot.x, y - hotspot.y);
-		
+                
     //Do some Grumbel voodoo.
 
     // Because MSVC sucks ass wrt standards compliance, it gets it own special function calls
 #ifdef _MSC_VER
     const float c = static_cast<float>sqrt(static_cast<float>(r.x)*static_cast<float>(r.x) + 
-                                 static_cast<float>(r.y)*static_cast<float>(r.y));
+                                           static_cast<float>(r.y)*static_cast<float>(r.y));
     const float nw = static_cast<float>(atan2(static_cast<float>(r.y), static_cast<float>(r.x)) + ((angle + 180) * math::pi / 180));
     r.x = (int)((sin(1.5 * M_PI - nw) * c) + 0.5) + hotspot.x;
     r.y = -(int)((sin(nw) * c) + 0.5) + hotspot.y;
@@ -112,7 +112,7 @@
     return int(std::sqrt(double((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y))) + 0.5f);
 #endif
   }
-	
+        
   //: Translate point.
   Point &operator+=(const Point &p)
   { x += p.x; y += p.y; return *this; }
@@ -120,7 +120,7 @@
   //: Translate point negatively.
   Point &operator-=(const Point &p)
   { x -= p.x; y -= p.y; return *this; }
-	
+        
   //: Point + Point operator.
   Point operator+(const Point &p) const
   { return Point(x + p.x, y + p.y); }

Modified: trunk/windstille/src/math/random.cpp
===================================================================
--- trunk/windstille/src/math/random.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/math/random.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -140,9 +140,9 @@
 {
   Random random(5489UL);
   for(int i = 0; i < 1000000; ++i)
-    {
-      std::cout << random.drand(0, 5) << std::endl;
-    }
+  {
+    std::cout << random.drand(0, 5) << std::endl;
+  }
   return 0;
 }
 #endif

Modified: trunk/windstille/src/math/rect.cpp
===================================================================
--- trunk/windstille/src/math/rect.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/math/rect.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -34,27 +34,27 @@
 
 Rect Rect::get_rot_bounds(const Point &hotspot, float angle) const
 {
-	//Find the rotated positions of each corner
-	Rect retVal(*this);
-	Point ul = Point(retVal.left, retVal.top).rotate(hotspot, angle);
-	Point ur = Point(retVal.right, retVal.top).rotate(hotspot, angle);
-	Point ll = Point(retVal.left, retVal.bottom).rotate(hotspot, angle);
-	Point lr = Point(retVal.right, retVal.bottom).rotate(hotspot, angle);
-	
-	//Use the sidemost corners as the bounds of the new rectangle
-	retVal.left = cl_min(cl_min(ul.x, ur.x), cl_min(ll.x, lr.x));
-	retVal.right = cl_max(cl_max(ul.x, ur.x), cl_max(ll.x, lr.x));
-	retVal.top = cl_min(cl_min(ul.y, ur.y), cl_min(ll.y, lr.y));
-	retVal.bottom = cl_max(cl_max(ul.y, ur.y), cl_max(ll.y, lr.y));
-	
-	return retVal;
+  //Find the rotated positions of each corner
+  Rect retVal(*this);
+  Point ul = Point(retVal.left, retVal.top).rotate(hotspot, angle);
+  Point ur = Point(retVal.right, retVal.top).rotate(hotspot, angle);
+  Point ll = Point(retVal.left, retVal.bottom).rotate(hotspot, angle);
+  Point lr = Point(retVal.right, retVal.bottom).rotate(hotspot, angle);
+        
+  //Use the sidemost corners as the bounds of the new rectangle
+  retVal.left = cl_min(cl_min(ul.x, ur.x), cl_min(ll.x, lr.x));
+  retVal.right = cl_max(cl_max(ul.x, ur.x), cl_max(ll.x, lr.x));
+  retVal.top = cl_min(cl_min(ul.y, ur.y), cl_min(ll.y, lr.y));
+  retVal.bottom = cl_max(cl_max(ul.y, ur.y), cl_max(ll.y, lr.y));
+        
+  return retVal;
 }
 
 Rect Rect::get_rot_bounds(Origin origin, int x, int y, float angle) const
 {
-	return get_rot_bounds(
-		Point(left, top) + calc_origin(origin, get_size()) + Point(x, y),
-		angle);
+  return get_rot_bounds(
+    Point(left, top) + calc_origin(origin, get_size()) + Point(x, y),
+    angle);
 }
 
 std::ostream& operator<<(std::ostream& s, const Rect& rect)

Modified: trunk/windstille/src/math/rect.hpp
===================================================================
--- trunk/windstille/src/math/rect.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/math/rect.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -87,7 +87,7 @@
   //: Rect -= Rect operator.
   Rect &operator-=(const Rect &r)
   { left -= r.left; top -= r.top; right -= r.right; bottom -= r.bottom; return *this; }
-	
+        
   //: Rect += Point operator.
   Rect &operator+=(const Point &p)
   { left += p.x; top += p.y; right += p.x; bottom += p.y; return *this; }
@@ -124,25 +124,25 @@
 public:
   //: X1-coordinate.
   int left;
-	
+        
   //: Y1-coordinate.
   int top;
-	
+        
   //: X2-coordinate.
   int right;
-	
+        
   //: Y2-coordinate.
   int bottom;
-	
+        
   //: Returns the width of the rectangle.
   int get_width() const { return right - left; }
-	
+        
   //: Returns the height of the rectangle.
   int get_height() const { return bottom - top; }
 
   //: Returns the size of the rectangle.
   Size get_size() const { return Size(right - left, bottom - top); }
-	
+        
   //: Returns true if point is inside the rectangle.
   bool is_inside(const Point &p) const { return (p.x >= left && p.y >= top && p.x <= right && p.y <= bottom); }
 
@@ -151,7 +151,7 @@
   {
     return (r.left < right && r.right > left && r.top < bottom && r.bottom > top);
   }
-	
+        
   //: Returns another Rect containing a rotated version of this one.
   //param hotspot: Point to rotate around.
   //param origin: Determines the hotspot point within the rectangle
@@ -159,7 +159,7 @@
   //param angle: Angle to rotate in degrees.
   Rect get_rot_bounds(const Point &hotspot, float angle) const;
   Rect get_rot_bounds(Origin origin, int x, int y, float angle) const;
-	
+        
   //! Operations:
 public:
   //: Sets the size of the rectangle, maintaining top/left position.
@@ -184,20 +184,20 @@
   void normalize()
   {
     if (left > right)
-      {
-        int temp = right;
-        right = left;
-        left = temp;
-      }
+    {
+      int temp = right;
+      right = left;
+      left = temp;
+    }
 
     if (top > bottom)
-      {
-        int temp = bottom;
-        bottom = top;
-        top = temp;
-      }
+    {
+      int temp = bottom;
+      bottom = top;
+      top = temp;
+    }
   }
-	
+        
   //: Applies an origin and offset pair to this rectangle
   //param origin: The new origin to adjust to from default upper-left position
   //param x, y: Offsets applied negatively to each corner of the rectangle
@@ -206,7 +206,7 @@
     Point offset = calc_origin(origin, get_size());
     offset.x -= x;
     offset.y -= y;
-		
+                
     left += offset.x;
     top += offset.y;
     right += offset.x;
@@ -276,7 +276,7 @@
   //: Rect -= Rect operator.
   Rectf &operator-=(const Rectf &r)
   { left -= r.left; top -= r.top; right -= r.right; bottom -= r.bottom; return *this; }
-	
+        
   //: Rect += Point operator.
   Rectf &operator+=(const Vector2f &p)
   { left += p.x; top += p.y; right += p.x; bottom += p.y; return *this; }
@@ -313,28 +313,28 @@
 public:
   //: X1-coordinate.
   float left;
-	
+        
   //: Y1-coordinate.
   float top;
-	
+        
   //: X2-coordinate.
   float right;
-	
+        
   //: Y2-coordinate.
   float bottom;
-	
+        
   //: Returns the width of the rectangle.
   float get_width() const { return right - left; }
-	
+        
   //: Returns the height of the rectangle.
   float get_height() const { return bottom - top; }
 
   //: Returns the size of the rectangle.
   Sizef get_size() const { return Sizef(right - left, bottom - top); }
-	
+        
   //: Returns true if point is inside the rectangle.
   bool is_inside(const Vector2f &p) const { return (p.x >= left && p.y >= top && p.x <= right && p.y <= bottom); }
-	
+        
   //: Returns true if rectangle passed is overlapping or inside this rectangle.
   bool is_overlapped(const Rectf &r) const 
   {
@@ -346,7 +346,7 @@
     return rect.left >= left && rect.right <= right &&
       rect.top >= top && rect.bottom <= bottom;
   }
-	
+        
   //! Operations:
 public:
   //: Sets the size of the rectangle, maintaining top/left position.
@@ -371,20 +371,20 @@
   void normalize()
   {
     if (left > right)
-      {
-        float temp = right;
-        right = left;
-        left = temp;
-      }
+    {
+      float temp = right;
+      right = left;
+      left = temp;
+    }
 
     if (top > bottom)
-      {
-        float temp = bottom;
-        bottom = top;
-        top = temp;
-      }
+    {
+      float temp = bottom;
+      bottom = top;
+      top = temp;
+    }
   }
-	
+        
   //: Applies an origin and offset pair to this rectangle
   //param origin: The new origin to adjust to from default upper-left position
   //param x, y: Offsets applied negatively to each corner of the rectangle
@@ -393,7 +393,7 @@
     Vector2f offset = calc_origin(origin, get_size());
     offset.x -= x;
     offset.y -= y;
-		
+                
     left += offset.x;
     top += offset.y;
     right += offset.x;

Modified: trunk/windstille/src/math/size.hpp
===================================================================
--- trunk/windstille/src/math/size.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/math/size.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -84,7 +84,7 @@
   //: Size -= Size operator.
   Size &operator-=(const Size &s)
   { width -= s.width; height -= s.height; return *this; }
-	
+        
   //: Size + Size operator.
   Size operator+(const Size &s) const
   { return Size(width + s.width, height + s.height); }
@@ -148,7 +148,7 @@
   //: Size -= Size operator.
   Sizef &operator-=(const Sizef &s)
   { width -= s.width; height -= s.height; return *this; }
-	
+        
   //: Size + Size operator.
   Sizef operator+(const Sizef &s) const
   { return Sizef(width + s.width, height + s.height); }

Modified: trunk/windstille/src/navigation/edge.cpp
===================================================================
--- trunk/windstille/src/navigation/edge.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/navigation/edge.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,10 +22,10 @@
 
 #include "navigation/node.hpp"
 
-Edge::Edge(Node* node1_, Node* node2_, Properties props_)
-  : node1(node1_), 
-    node2(node2_),
-    properties(props_)
+Edge::Edge(Node* node1_, Node* node2_, Properties props_) :
+  node1(node1_), 
+  node2(node2_),
+  properties(props_)
 {
   node1->add_edge(EdgePosition(this, 0.0f));
   node2->add_edge(EdgePosition(this, 1.0f));

Modified: trunk/windstille/src/navigation/edge_position.cpp
===================================================================
--- trunk/windstille/src/navigation/edge_position.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/navigation/edge_position.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -24,15 +24,15 @@
 #include "navigation/node.hpp"
 #include "display/display.hpp"
 
-EdgePosition::EdgePosition()
-  : edge(0),
-    pos(0.0f)
+EdgePosition::EdgePosition() :
+  edge(0),
+  pos(0.0f)
 {
 }
 
-EdgePosition::EdgePosition(Edge* edge_, float pos_)
-  : edge(edge_),
-    pos(pos_)
+EdgePosition::EdgePosition(Edge* edge_, float pos_) :
+  edge(edge_),
+  pos(pos_)
 {  
 }
 
@@ -55,27 +55,27 @@
   float adv_01 = adv / length;
 
   if (adv_01 > 0)
-    {
-      pos += adv_01;
-      if (pos > 1.0f) {
-        adv = (pos - 1.0f) * length;
-        pos = 1.0f;
-        next_node = edge->get_node2();
-      } else {
-        adv = 0;
-      }
+  {
+    pos += adv_01;
+    if (pos > 1.0f) {
+      adv = (pos - 1.0f) * length;
+      pos = 1.0f;
+      next_node = edge->get_node2();
+    } else {
+      adv = 0;
     }
+  }
   else
-    {
-      pos += adv_01;
-      if (pos < 0.0f) {
-        adv = pos * length;
-        pos = 0;
-        next_node = edge->get_node1();
-      } else {
-        adv = 0;
-      }
+  {
+    pos += adv_01;
+    if (pos < 0.0f) {
+      adv = pos * length;
+      pos = 0;
+      next_node = edge->get_node1();
+    } else {
+      adv = 0;
     }
+  }
 }
 
 void

Modified: trunk/windstille/src/navigation/navigation_graph.cpp
===================================================================
--- trunk/windstille/src/navigation/navigation_graph.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/navigation/navigation_graph.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -28,9 +28,9 @@
 
 #include "navigation/navigation_graph.hpp"
 
-NavigationGraph::NavigationGraph()
-  : nodes(),
-    edges()
+NavigationGraph::NavigationGraph() :
+  nodes(),
+  edges()
 {  
 }
 
@@ -59,10 +59,10 @@
   // FIXME: Slow
   Edges::iterator i = std::find(edges.begin(), edges.end(), edge.get());
   if (i != edges.end())
-    {
-      edges.erase(i);
-      delete edge.get();
-    }
+  {
+    edges.erase(i);
+    delete edge.get();
+  }
 
   // FIXME: Throw exception here
 }
@@ -74,43 +74,43 @@
 
   // Remove all edges that would get invalid by removing the node
   for(Edges::iterator i = edges.begin(); i != edges.end(); ++i)
+  {
+    if ((*i)->get_node1() == node.get() ||
+        (*i)->get_node2() == node.get())
     {
-      if ((*i)->get_node1() == node.get() ||
-          (*i)->get_node2() == node.get())
-        {
-          delete *i;
-          *i = 0;
-        }
+      delete *i;
+      *i = 0;
     }
+  }
 
   Edges::iterator new_end = std::remove(edges.begin(), edges.end(), static_cast<Edge*>(0));
   if (new_end != edges.end())
-    { 
-      edges.erase(new_end, edges.end());
-    }
+  { 
+    edges.erase(new_end, edges.end());
+  }
   
   // Remove the node itself 
   Nodes::iterator j = std::find(nodes.begin(), nodes.end(), node.get());
   if (j != nodes.end())
-    {
-      nodes.erase(j);
-      delete node.get();
-    }  
+  {
+    nodes.erase(j);
+    delete node.get();
+  }  
 }
 
 EdgeHandle
 NavigationGraph::add_edge(NodeHandle node1, NodeHandle node2)
 {
   if (node1.get() != node2.get()) // node links to themself are forbidden
-    { // FIXME: Find a way to figure out if the given edge already exists
-      Edge* edge = new Edge(node1.get(), node2.get());
-      edges.push_back(edge);
-      return EdgeHandle(edge);
-    }
+  { // FIXME: Find a way to figure out if the given edge already exists
+    Edge* edge = new Edge(node1.get(), node2.get());
+    edges.push_back(edge);
+    return EdgeHandle(edge);
+  }
   else
-    {
-      return EdgeHandle();
-    }
+  {
+    return EdgeHandle();
+  }
 }
 
 void
@@ -133,16 +133,16 @@
   std::vector<EdgePosition> ret;
  
   for(Edges::iterator i = edges.begin(); i != edges.end(); ++i)
+  {
+    Line seg_line((*i)->get_node1()->get_pos(),
+                  (*i)->get_node2()->get_pos());
+      
+    float ua, ub;
+    if (line.intersect(seg_line, ua, ub))
     {
-      Line seg_line((*i)->get_node1()->get_pos(),
-                    (*i)->get_node2()->get_pos());
-      
-      float ua, ub;
-      if (line.intersect(seg_line, ua, ub))
-        {
-          ret.push_back(EdgePosition(*i, ub));
-        }
+      ret.push_back(EdgePosition(*i, ub));
     }
+  }
 
   return ret;
 }
@@ -154,13 +154,13 @@
   std::vector<NodeHandle> ret;
 
   for(Nodes::iterator i = nodes.begin(); i != nodes.end(); ++i)
+  {
+    float distance = (pos - (*i)->get_pos()).length();
+    if (distance < radius)
     {
-      float distance = (pos - (*i)->get_pos()).length();
-      if (distance < radius)
-        {
-          ret.push_back(NodeHandle(*i));
-        }
+      ret.push_back(NodeHandle(*i));
     }
+  }
   
   return ret;
 }
@@ -171,12 +171,12 @@
   std::vector<NodeHandle> ret;
 
   for(Nodes::iterator i = nodes.begin(); i != nodes.end(); ++i)
-    {  
-      if (rect.is_inside((*i)->get_pos()))
-        {
-          ret.push_back(NodeHandle(*i));
-        }
+  {  
+    if (rect.is_inside((*i)->get_pos()))
+    {
+      ret.push_back(NodeHandle(*i));
     }
+  }
 
   return ret;
 }
@@ -187,14 +187,14 @@
   std::vector<EdgeHandle> ret;
  
   for(Edges::iterator i = edges.begin(); i != edges.end(); ++i)
+  {
+    float distance = Line((*i)->get_node1()->get_pos(),
+                          (*i)->get_node2()->get_pos()).distance(pos);
+    if (distance < radius)
     {
-      float distance = Line((*i)->get_node1()->get_pos(),
-                            (*i)->get_node2()->get_pos()).distance(pos);
-      if (distance < radius)
-        {
-          ret.push_back(EdgeHandle(*i));
-        }
+      ret.push_back(EdgeHandle(*i));
     }
+  }
 
   return ret;
 }
@@ -207,14 +207,14 @@
   float min_distance = radius;
 
   for(Nodes::iterator i = nodes.begin(); i != nodes.end(); ++i)
+  {
+    float current_distance = (pos - (*i)->get_pos()).length();
+    if (current_distance < min_distance)
     {
-      float current_distance = (pos - (*i)->get_pos()).length();
-      if (current_distance < min_distance)
-        {
-          min_distance = current_distance;
-          node = *i;
-        }
+      min_distance = current_distance;
+      node = *i;
     }
+  }
   
   return NodeHandle(node);
 }
@@ -226,15 +226,15 @@
   float min_distance = radius;
 
   for(Edges::iterator i = edges.begin(); i != edges.end(); ++i)
+  {
+    float current_distance = Line((*i)->get_node1()->get_pos(),
+                                  (*i)->get_node2()->get_pos()).distance(pos);
+    if (current_distance < min_distance)
     {
-      float current_distance = Line((*i)->get_node1()->get_pos(),
-                                    (*i)->get_node2()->get_pos()).distance(pos);
-      if (current_distance < min_distance)
-        {
-          min_distance = current_distance;
-          edge = *i;
-        }
+      min_distance = current_distance;
+      edge = *i;
     }
+  }
 
   return EdgeHandle(edge);
 }
@@ -243,17 +243,17 @@
 NavigationGraph::draw()
 {
   for(Edges::iterator i = edges.begin(); i != edges.end(); ++i)
-    {
-      Display::draw_line_with_normal(Line((*i)->get_node1()->get_pos(),
-                                          (*i)->get_node2()->get_pos()),
-                                     Color(1.0f, 0.0f, 0.0f));
-    }
+  {
+    Display::draw_line_with_normal(Line((*i)->get_node1()->get_pos(),
+                                        (*i)->get_node2()->get_pos()),
+                                   Color(1.0f, 0.0f, 0.0f));
+  }
 
   for(Nodes::iterator i = nodes.begin(); i != nodes.end(); ++i)
-    {
-      Display::fill_rect(Rectf((*i)->get_pos() - Vector2f(4,4), Sizef(9, 9)),
-                         Color(1.0f, 1.0f, 0.0f));
-    }
+  {
+    Display::fill_rect(Rectf((*i)->get_pos() - Vector2f(4,4), Sizef(9, 9)),
+                       Color(1.0f, 1.0f, 0.0f));
+  }
 }
 
 void
@@ -267,72 +267,72 @@
 
   FileReader nodes_group_reader;
   if (reader.get("nodes", nodes_group_reader))
+  {
+    std::vector<FileReader> nodes_reader = nodes_group_reader.get_sections();
+    for(std::vector<FileReader>::iterator i = nodes_reader.begin(); i != nodes_reader.end(); ++i)
     {
-      std::vector<FileReader> nodes_reader = nodes_group_reader.get_sections();
-      for(std::vector<FileReader>::iterator i = nodes_reader.begin(); i != nodes_reader.end(); ++i)
+      if (i->get_name() == "node")
+      {
+        Vector2f pos;
+        if (i->get("pos", pos))
         {
-          if (i->get_name() == "node")
-            {
-              Vector2f pos;
-              if (i->get("pos", pos))
-                {
-                  Node* node = new Node(pos);
-                  id2ptr[id_count++] = node;
-                  nodes.push_back(node);
-                }
-              else
-                {
-                  std::cout << "NavigationGraph:load: nodes: node: Couldn't read pos attribute" << std::endl;
-                }
-            }
-          else
-            {
-              std::cout << "NavigationGraph:load: nodes: Unknown tag: " << i->get_name() << std::endl;
-            }
+          Node* node = new Node(pos);
+          id2ptr[id_count++] = node;
+          nodes.push_back(node);
         }
+        else
+        {
+          std::cout << "NavigationGraph:load: nodes: node: Couldn't read pos attribute" << std::endl;
+        }
+      }
+      else
+      {
+        std::cout << "NavigationGraph:load: nodes: Unknown tag: " << i->get_name() << std::endl;
+      }
     }
+  }
   
   FileReader edges_group_reader;
   if (reader.get("edges", edges_group_reader))
+  {
+    std::vector<FileReader> edges_reader = edges_group_reader.get_sections();
+    for(std::vector<FileReader>::iterator i = edges_reader.begin(); i != edges_reader.end(); ++i)
     {
-      std::vector<FileReader> edges_reader = edges_group_reader.get_sections();
-      for(std::vector<FileReader>::iterator i = edges_reader.begin(); i != edges_reader.end(); ++i)
+      if (i->get_name() == "edge")
+      {
+        int node_left;
+        int node_right;
+        int properties;
+
+        if (i->get("node1", node_left) &&
+            i->get("node2", node_right) &&
+            i->get("properties", properties)) // FIXME: we might want to read a unsigned int instead
         {
-          if (i->get_name() == "edge")
-            {
-              int node_left;
-              int node_right;
-              int properties;
+          std::map<int, Node*>::iterator node_left_ptr  = id2ptr.find(node_left);
+          std::map<int, Node*>::iterator node_right_ptr = id2ptr.find(node_right);
 
-              if (i->get("node1", node_left) &&
-                  i->get("node2", node_right) &&
-                  i->get("properties", properties)) // FIXME: we might want to read a unsigned int instead
-                {
-                  std::map<int, Node*>::iterator node_left_ptr  = id2ptr.find(node_left);
-                  std::map<int, Node*>::iterator node_right_ptr = id2ptr.find(node_right);
-
-                  if (node_left_ptr != id2ptr.end() && node_right_ptr != id2ptr.end())
-                    {
-                      Edge* edge = new Edge(node_left_ptr->second, node_right_ptr->second, properties);
-                      edges.push_back(edge);
-                    }
-                  else
-                    {
-                      std::cout << "NavigationGraph: edge: Couldn't lookup ids: "
-                                << node_left << " " << node_right << std::endl;
-                    }
-                }
-              else
-                {
-                  std::cout << "NavigationGraph:load: edges: edge: parse error" << std::endl;
-                }
-            }
+          if (node_left_ptr != id2ptr.end() && node_right_ptr != id2ptr.end())
+          {
+            Edge* edge = new Edge(node_left_ptr->second, node_right_ptr->second, properties);
+            edges.push_back(edge);
+          }
           else
-            {
-              std::cout << "NavigationGraph:load: edges: Unknown tag: " << i->get_name() << std::endl;
-            }
-        }      
-    }
+          {
+            std::cout << "NavigationGraph: edge: Couldn't lookup ids: "
+                      << node_left << " " << node_right << std::endl;
+          }
+        }
+        else
+        {
+          std::cout << "NavigationGraph:load: edges: edge: parse error" << std::endl;
+        }
+      }
+      else
+      {
+        std::cout << "NavigationGraph:load: edges: Unknown tag: " << i->get_name() << std::endl;
+      }
+    }      
+  }
 }
 
 void
@@ -378,23 +378,23 @@
 
   writer.start_section("nodes");
   for(Nodes::iterator i = nodes.begin(); i != nodes.end(); ++i)
-    {
-      writer.start_section("node");
-      writer.write("id", ptr2id[*i]);
-      writer.write("pos", (*i)->get_pos());
-      writer.end_section();
-    }
+  {
+    writer.start_section("node");
+    writer.write("id", ptr2id[*i]);
+    writer.write("pos", (*i)->get_pos());
+    writer.end_section();
+  }
   writer.end_section();
 
   writer.start_section("edges");
   for(Edges::iterator i = edges.begin(); i != edges.end(); ++i)  
-    {
-      writer.start_section("edge");
-      writer.write("node1", ptr2id[(*i)->get_node1()]);
-      writer.write("node2", ptr2id[(*i)->get_node2()]);
-      writer.write("properties", static_cast<int>((*i)->get_properties()));
-      writer.end_section();
-    }
+  {
+    writer.start_section("edge");
+    writer.write("node1", ptr2id[(*i)->get_node1()]);
+    writer.write("node2", ptr2id[(*i)->get_node2()]);
+    writer.write("properties", static_cast<int>((*i)->get_properties()));
+    writer.end_section();
+  }
   writer.end_section();
 }
 

Modified: trunk/windstille/src/navigation/node.cpp
===================================================================
--- trunk/windstille/src/navigation/node.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/navigation/node.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -18,10 +18,10 @@
 
 #include "navigation/node.hpp"
 
-Node::Node(const Vector2f& pos_)
-  : pos(pos_),
-    edges()
-    // FIXME: Do something with id
+Node::Node(const Vector2f& pos_) :
+  pos(pos_),
+  edges()
+  // FIXME: Do something with id
 {
 }
 
@@ -39,13 +39,13 @@
 Node::remove_edge(Edge* edge)
 {
   for(Edges::iterator i = edges.begin(); i != edges.end(); ++i)
+  {
+    if (i->edge == edge)
     {
-      if (i->edge == edge)
-        {
-          edges.erase(i);
-          return;
-        }
+      edges.erase(i);
+      return;
     }
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/objects/background_gradient.cpp
===================================================================
--- trunk/windstille/src/objects/background_gradient.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/background_gradient.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -23,8 +23,8 @@
 #include "scenegraph/vertex_array_drawable.hpp"
 #include "scenegraph/gradient_drawable.hpp"
 
-BackgroundGradient::BackgroundGradient(const FileReader& props)
-  : drawable()
+BackgroundGradient::BackgroundGradient(const FileReader& props) :
+  drawable()
 {
   std::vector<float> colors;
 
@@ -32,21 +32,21 @@
   props.get("colors", colors);
 
   if (colors.size() % (3 + 4 + 4 + 2) != 0)
-    {
-      std::cout << "BackgroundGradient: specified color gradient is invalid" << std::endl;
-      /** Color gradients are in the format:
+  {
+    std::cout << "BackgroundGradient: specified color gradient is invalid" << std::endl;
+    /** Color gradients are in the format:
           
-      (colors start midpoint end R1 G1 B1 A1 R2 G2 B2 A2 I I
-              start midpoint end R1 G1 B1 A1 R2 G2 B2 A2 I I
-              ...)
+        (colors start midpoint end R1 G1 B1 A1 R2 G2 B2 A2 I I
+        start midpoint end R1 G1 B1 A1 R2 G2 B2 A2 I I
+        ...)
 
-              I is ignored
+        I is ignored
 
-          all specified in float, this is similar to Gimps gradients
-          so you can easily copy&paste
-       */
-      colors.clear();
-    }
+        all specified in float, this is similar to Gimps gradients
+        so you can easily copy&paste
+    */
+    colors.clear();
+  }
 
   drawable.reset(new GradientDrawable(colors));
   Sector::current()->get_scene_graph().add_drawable(drawable);

Modified: trunk/windstille/src/objects/bomb.cpp
===================================================================
--- trunk/windstille/src/objects/bomb.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/bomb.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -19,16 +19,16 @@
 #include "app/globals.hpp"
 #include "objects/bomb.hpp"
 
-Bomb::Bomb(int x, int y)
-  : sprite(Pathname("images/bomb.sprite")),
-    explo(Pathname("images/explo.sprite")),
-    light(Pathname("images/bomblight.sprite")),
-    highlight(Pathname("images/bombhighlight.sprite")),
-    explolight(Pathname("images/explolight.sprite")),
-    pos(static_cast<float>(x), static_cast<float>((y / TILE_SIZE + 1) * TILE_SIZE)),
-    count(2.0f),
-    state(COUNTDOWN),
-    exploded(false)
+Bomb::Bomb(int x, int y) :
+  sprite(Pathname("images/bomb.sprite")),
+  explo(Pathname("images/explo.sprite")),
+  light(Pathname("images/bomblight.sprite")),
+  highlight(Pathname("images/bombhighlight.sprite")),
+  explolight(Pathname("images/explolight.sprite")),
+  pos(static_cast<float>(x), static_cast<float>((y / TILE_SIZE + 1) * TILE_SIZE)),
+  count(2.0f),
+  state(COUNTDOWN),
+  exploded(false)
 {
 }
 
@@ -50,42 +50,42 @@
   count -= delta;
 
   if (count < 0 && state != EXPLODE)
+  {
+    state = EXPLODE;
+    count = 0;
+    if (!exploded)
     {
-      state = EXPLODE;
-      count = 0;
-      if (!exploded)
-        {
-          exploded = true;
-          explode();
-        }
+      exploded = true;
+      explode();
+    }
 
-    }
+  }
 }
 
 void
 Bomb::draw(SceneContext& sc)
 {
   if (state == EXPLODE)
-    {
-      sc.color().draw(explo, pos);
-      sc.light().draw(explolight, pos, 0);
+  {
+    sc.color().draw(explo, pos);
+    sc.light().draw(explolight, pos, 0);
 
-      explolight.set_alpha(0.5);
-      explolight.set_scale(0.5);
+    explolight.set_alpha(0.5);
+    explolight.set_scale(0.5);
 
-      sc.highlight().draw(explolight, pos, 0);
+    sc.highlight().draw(explolight, pos, 0);
 
-      explolight.set_alpha(1.0);
-      explolight.set_scale(1.0);
-    }
+    explolight.set_alpha(1.0);
+    explolight.set_scale(1.0);
+  }
   else
-    {
-      sc.color().draw(sprite, pos);
-      if (sprite.is_finished()) {
-        sc.light().draw(light, pos, 0);
-        sc.highlight().draw(highlight, pos, 0);
-      }
+  {
+    sc.color().draw(sprite, pos);
+    if (sprite.is_finished()) {
+      sc.light().draw(light, pos, 0);
+      sc.highlight().draw(highlight, pos, 0);
     }
+  }
 }
 
 void 

Modified: trunk/windstille/src/objects/box.cpp
===================================================================
--- trunk/windstille/src/objects/box.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/box.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,10 +22,10 @@
 
 #include "collision/collision_engine.hpp"
 
-Box::Box(const FileReader& props)
-  : sprite(),
-    colobj(0),
-    gravity()
+Box::Box(const FileReader& props) :
+  sprite(),
+  colobj(0),
+  gravity()
 {
   gravity = 0.0f;
   float width  = 64.0f;
@@ -66,22 +66,22 @@
   //std::cout << this << ": Collision Event" << std::endl;
   if ((data.direction.x > 0 && colobj->get_velocity().x < 0) ||
       (data.direction.x < 0 && colobj->get_velocity().x > 0))
-    {
-      colobj->set_velocity(Vector2f(-colobj->get_velocity().x, colobj->get_velocity().y));
-    }
+  {
+    colobj->set_velocity(Vector2f(-colobj->get_velocity().x, colobj->get_velocity().y));
+  }
   
   if ((data.direction.y > 0 && colobj->get_velocity().y < 0) ||
       (data.direction.y < 0 && colobj->get_velocity().y > 0))
-    {
-      colobj->set_velocity(Vector2f(colobj->get_velocity().x, -colobj->get_velocity().y));
-    }
+  {
+    colobj->set_velocity(Vector2f(colobj->get_velocity().x, -colobj->get_velocity().y));
+  }
 }
 
 void 
 Box::update(float delta)
 {
   colobj->set_velocity(Vector2f(colobj->get_velocity().x, 
-                              colobj->get_velocity().y + gravity * delta));
+                                colobj->get_velocity().y + gravity * delta));
 
   sprite.update(delta);
   pos = colobj->get_pos();

Modified: trunk/windstille/src/objects/character.cpp
===================================================================
--- trunk/windstille/src/objects/character.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/character.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,9 +22,9 @@
 #include "engine/script_manager.hpp"
 #include "app/console.hpp"
 
-Character::Character(const FileReader& props)
-  : sprite(),
-    z_pos(100.0f)
+Character::Character(const FileReader& props) :
+  sprite(),
+  z_pos(100.0f)
 {
   set_useable(true);
   use_verb = "Talk";

Modified: trunk/windstille/src/objects/decal.cpp
===================================================================
--- trunk/windstille/src/objects/decal.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/decal.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -24,9 +24,9 @@
 #include "display/surface_drawing_parameters.hpp"
 #include "display/scene_context.hpp"
 
-Decal::Decal(const FileReader& reader)
-  : drawable(),
-    pos()
+Decal::Decal(const FileReader& reader) :
+  drawable(),
+  pos()
 {
   std::string path;
   Vector2f scale(1.0f, 1.0f);
@@ -64,14 +64,14 @@
   center_offset.y *= scale.y;
 
   drawable.reset(new SurfaceDrawable(surface,
-                                           params
-                                           .set_pos(pos + center_offset)
-                                           .set_angle(angle)
-                                           .set_hflip(hflip)
-                                           .set_vflip(vflip)
-                                           .set_scale(scale),
-                                           0, 
-                                           Matrix::identity()));
+                                     params
+                                     .set_pos(pos + center_offset)
+                                     .set_angle(angle)
+                                     .set_hflip(hflip)
+                                     .set_vflip(vflip)
+                                     .set_scale(scale),
+                                     0, 
+                                     Matrix::identity()));
 
   switch(map_type)
   {

Modified: trunk/windstille/src/objects/doll.cpp
===================================================================
--- trunk/windstille/src/objects/doll.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/doll.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -28,13 +28,13 @@
 
 #include "objects/doll.hpp"
 
-Doll::Doll()
-  : m_drawable(),
-    m_velocity(),
-    m_pos(200, 600),
-    m_last_pos(m_pos),
-    m_edge_position(),
-    m_state(kNoState)
+Doll::Doll() :
+  m_drawable(),
+  m_velocity(),
+  m_pos(200, 600),
+  m_last_pos(m_pos),
+  m_edge_position(),
+  m_state(kNoState)
 {
   Sprite3D sprite(Pathname("models/characters/jane/jane.wsprite"));
   m_drawable.reset(new Sprite3DDrawable(sprite, m_pos, 100.0f, Matrix::identity()));

Modified: trunk/windstille/src/objects/elevator.cpp
===================================================================
--- trunk/windstille/src/objects/elevator.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/elevator.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -20,10 +20,10 @@
 #include "engine/sector.hpp"
 #include "collision/collision_engine.hpp"
 
-Elevator::Elevator(const FileReader& props)
-  : size(),
-    colobject(),
-    sprite()
+Elevator::Elevator(const FileReader& props) :
+  size(),
+  colobject(),
+  sprite()
 {
   std::string spritename;
 

Modified: trunk/windstille/src/objects/grenade.cpp
===================================================================
--- trunk/windstille/src/objects/grenade.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/grenade.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -20,10 +20,10 @@
 #include "collision/collision_engine.hpp"
 #include "objects/grenade.hpp"
 
-Grenade::Grenade()
-  : sprite(Pathname("models/objects/grenade/grenade.wsprite")), 
-    physics(this),
-    c_object(new CollisionObject(this, Rectf(0, 0, 32, 32)))
+Grenade::Grenade() :
+  sprite(Pathname("models/objects/grenade/grenade.wsprite")), 
+  physics(this),
+  c_object(new CollisionObject(this, Rectf(0, 0, 32, 32)))
 {
   physics.register_collobj(*c_object);
 

Modified: trunk/windstille/src/objects/hedgehog.cpp
===================================================================
--- trunk/windstille/src/objects/hedgehog.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/hedgehog.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -19,13 +19,13 @@
 #include "objects/player.hpp"
 #include "objects/hedgehog.hpp"
 
-Hedgehog::Hedgehog(const FileReader& props)
-  : sprite(Pathname("images/hedgehog.sprite")),
-    die_sprite(Pathname("images/hedgehog_die1.sprite")),
-    light(Pathname("images/hedgehog_light.sprite")),
-    highlight(Pathname("images/hedgehog_highlight.sprite")),
-    direction_left(false),
-    state(WALKING)
+Hedgehog::Hedgehog(const FileReader& props) :
+  sprite(Pathname("images/hedgehog.sprite")),
+  die_sprite(Pathname("images/hedgehog_die1.sprite")),
+  light(Pathname("images/hedgehog_light.sprite")),
+  highlight(Pathname("images/hedgehog_highlight.sprite")),
+  direction_left(false),
+  state(WALKING)
 {
   props.get("name", name);
   props.get("pos",  pos);
@@ -63,51 +63,51 @@
 Hedgehog::update(float delta)
 {      
   if (state == DYING)
+  {
+    if (die_sprite.is_finished())
+      remove();
+    die_sprite.update(delta);
+  }
+  else
+  {
+    sprite.update(delta);
+    bool was_on_ground = false;
+      
+    if (on_ground())
     {
-      if (die_sprite.is_finished())
-        remove();
-      die_sprite.update(delta);
+      was_on_ground = true;
+      if (velocity.y > 0.0f)
+      {
+        velocity.y = 0.0f;
+        pos.y = truncf(pos.y / static_cast<float>(TILE_SIZE)) * static_cast<float>(TILE_SIZE) + static_cast<float>(TILE_SIZE) - 1.0f;
+      }
+      if (direction_left)
+        velocity.x = -32.0f;
+      else
+        velocity.x = 32.0f;
     }
-  else
+    else
     {
-      sprite.update(delta);
-      bool was_on_ground = false;
+      velocity.y += GRAVITY * delta;
+    }
       
-      if (on_ground())
-        {
-          was_on_ground = true;
-          if (velocity.y > 0.0f)
-            {
-              velocity.y = 0.0f;
-              pos.y = truncf(pos.y / static_cast<float>(TILE_SIZE)) * static_cast<float>(TILE_SIZE) + static_cast<float>(TILE_SIZE) - 1.0f;
-            }
-          if (direction_left)
-            velocity.x = -32.0f;
-          else
-            velocity.x = 32.0f;
-        }
-      else
-        {
-          velocity.y += GRAVITY * delta;
-        }
+    Vector2f old_pos = pos;
+    pos += velocity * delta;
       
-      Vector2f old_pos = pos;
-      pos += velocity * delta;
-      
-      if ((was_on_ground && !on_ground()) || in_wall())
-        {
-          direction_left = !direction_left;
-          pos = old_pos;
-        }
+    if ((was_on_ground && !on_ground()) || in_wall())
+    {
+      direction_left = !direction_left;
+      pos = old_pos;
     }
+  }
     
   // Check if the player got hit
   // FIXME: Insert pixel perfect collision detection here
   Vector2f player_pos = Player::current()->get_pos();
   if (pos.x - 20 < player_pos.x
-        && pos.x + 20 > player_pos.x
-        && pos.y - 20 < player_pos.y
-        && pos.y + 5  > player_pos.y)
+      && pos.x + 20 > player_pos.x
+      && pos.y - 20 < player_pos.y
+      && pos.y + 5  > player_pos.y)
     Player::current()->hit(5);
 }
 

Modified: trunk/windstille/src/objects/laser_pointer.cpp
===================================================================
--- trunk/windstille/src/objects/laser_pointer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/laser_pointer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,12 +22,12 @@
 #include "tile/tile_map.hpp"
 #include "objects/laser_pointer.hpp"
 
-LaserPointer::LaserPointer()
- : noise(),
-   laserpointer(),
-   laserpointer_light(),
-   progress(),
-   angle()
+LaserPointer::LaserPointer() :
+  noise(),
+  laserpointer(),
+  laserpointer_light(),
+  progress(),
+  angle()
 {
   noise = Texture(Pathname("images/noise2.png"));
   laserpointer = Sprite(Pathname("images/laserpointer.sprite"));
@@ -47,17 +47,17 @@
 static float find_max(float pos, float v)
 {
   if (v == 0)
-    { 
-      return 0;
-    }
+  { 
+    return 0;
+  }
   else if (v < 0)
-    {
-      return fmodf(fmodf(pos, static_cast<float>(TILE_SIZE)) + static_cast<float>(TILE_SIZE), static_cast<float>(TILE_SIZE))/fabsf(v);
-    }
+  {
+    return fmodf(fmodf(pos, static_cast<float>(TILE_SIZE)) + static_cast<float>(TILE_SIZE), static_cast<float>(TILE_SIZE))/fabsf(v);
+  }
   else // if (v > 0)
-    {
-      return fmodf(fmodf(-pos, static_cast<float>(TILE_SIZE)) + static_cast<float>(TILE_SIZE), static_cast<float>(TILE_SIZE))/v;
-    }
+  {
+    return fmodf(fmodf(-pos, static_cast<float>(TILE_SIZE)) + static_cast<float>(TILE_SIZE), static_cast<float>(TILE_SIZE))/v;
+  }
 }
 
 void
@@ -120,7 +120,7 @@
     Vector2f ray = target - pos;
 
     VertexArrayDrawable* array = new VertexArrayDrawable(Vector2f(0,0), 10000,
-                                                                     sc.highlight().get_modelview());
+                                                         sc.highlight().get_modelview());
     array->set_mode(GL_LINES);
     array->set_texture(noise);
     array->set_blend_func(GL_SRC_ALPHA, GL_ONE);

Modified: trunk/windstille/src/objects/layer.cpp
===================================================================
--- trunk/windstille/src/objects/layer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/layer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -23,9 +23,9 @@
 #include "engine/sector.hpp"
 #include "engine/script_manager.hpp"
 
-Layer::Layer(const FileReader& reader)
-  : objects(),
-    new_objects()
+Layer::Layer(const FileReader& reader) :
+  objects(),
+  new_objects()
 {
 #if 0
   FileReader objects_reader;
@@ -96,10 +96,10 @@
   commit_adds();
 
   for(Objects::iterator i = objects.begin(); i != objects.end(); ++i) 
-    {
-      if ((*i)->is_active())
-        (*i)->update(delta);
-    }
+  {
+    if ((*i)->is_active())
+      (*i)->update(delta);
+  }
 
   commit_removes();
 }

Modified: trunk/windstille/src/objects/liquid.cpp
===================================================================
--- trunk/windstille/src/objects/liquid.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/liquid.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -24,15 +24,15 @@
 
 #define SAMPLES 5
 
-Liquid::Liquid(const FileReader& props)
-  : texture(),
-    t(),
-    heightfield_store1(),
-    heightfield_store2(),
-    heightfield1(),
-    heightfield2(),
-    m_water_top(),
-    m_water_body()
+Liquid::Liquid(const FileReader& props) :
+  texture(),
+  t(),
+  heightfield_store1(),
+  heightfield_store2(),
+  heightfield1(),
+  heightfield2(),
+  m_water_top(),
+  m_water_body()
 {
   int width = 10;
   t = 0;
@@ -47,11 +47,11 @@
   heightfield2->resize(width * SAMPLES, 0);
   
   for(std::vector<float>::size_type i = 2; i < heightfield1->size()-2; ++i)
-    {
-      (*heightfield1)[i] = sinf(static_cast<float>(i) / static_cast<float>(heightfield1->size()) * 10.0f) * 0.5f
-        + sinf(static_cast<float>(i) / static_cast<float>(heightfield1->size()) * 5.0f) * .5f;
-      (*heightfield2)[i] = (*heightfield1)[i];
-    }
+  {
+    (*heightfield1)[i] = sinf(static_cast<float>(i) / static_cast<float>(heightfield1->size()) * 10.0f) * 0.5f
+      + sinf(static_cast<float>(i) / static_cast<float>(heightfield1->size()) * 5.0f) * .5f;
+    (*heightfield2)[i] = (*heightfield1)[i];
+  }
 
   for(int i = 50; i < 70 && i < int(heightfield1->size()); ++i)
     (*heightfield1)[i] += 0.0025f;

Modified: trunk/windstille/src/objects/nightvision.cpp
===================================================================
--- trunk/windstille/src/objects/nightvision.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/nightvision.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,9 +22,9 @@
 #include "scenegraph/vertex_array_drawable.hpp"
 #include "math/random.hpp"
 
-Nightvision::Nightvision(const FileReader& props)
-  : nightvision(Pathname("images/nightvision.sprite")),
-    noise(Pathname("images/noise.png"))
+Nightvision::Nightvision(const FileReader& props) :
+  nightvision(Pathname("images/nightvision.sprite")),
+  noise(Pathname("images/noise.png"))
 {
   name = "nightvision";
   noise.set_wrap(GL_REPEAT);
@@ -44,81 +44,81 @@
 
   // try to stay above everything else with large z value
   if (1)
-    {
-      nightvision.set_alpha(1.0f);
-      nightvision.set_blend_func(GL_ONE, GL_ZERO);
-      sc.light().draw(nightvision, Vector2f(0, 0), 10000);
-    }
+  {
+    nightvision.set_alpha(1.0f);
+    nightvision.set_blend_func(GL_ONE, GL_ZERO);
+    sc.light().draw(nightvision, Vector2f(0, 0), 10000);
+  }
 
   if (1)
-    {
-      VertexArrayDrawable* array = new VertexArrayDrawable(Vector2f(0, 0), 10000,
-                                                                       sc.light().get_modelview());
-      array->set_mode(GL_QUADS);
-      array->set_texture(noise);
-      array->set_blend_func(GL_DST_COLOR, GL_ZERO);
+  {
+    VertexArrayDrawable* array = new VertexArrayDrawable(Vector2f(0, 0), 10000,
+                                                         sc.light().get_modelview());
+    array->set_mode(GL_QUADS);
+    array->set_texture(noise);
+    array->set_blend_func(GL_DST_COLOR, GL_ZERO);
 
-      float u = rnd.frand() / 0.5f;
-      float v = rnd.frand() / 0.5f;
-      float w = 4.0f / 6.0f;
-      float h = 3.0f / 6.0f;
+    float u = rnd.frand() / 0.5f;
+    float v = rnd.frand() / 0.5f;
+    float w = 4.0f / 6.0f;
+    float h = 3.0f / 6.0f;
 
-      array->texcoord(u, v);
-      array->vertex(0, 0);
+    array->texcoord(u, v);
+    array->vertex(0, 0);
 
-      array->texcoord(u + w, v);
-      array->vertex(static_cast<float>(Display::get_width()), 0);
+    array->texcoord(u + w, v);
+    array->vertex(static_cast<float>(Display::get_width()), 0);
 
-      array->texcoord(u + w, v + h);
-      array->vertex(static_cast<float>(Display::get_width()), static_cast<float>(Display::get_height()));
+    array->texcoord(u + w, v + h);
+    array->vertex(static_cast<float>(Display::get_width()), static_cast<float>(Display::get_height()));
 
-      array->texcoord(u, v + h);
-      array->vertex(0, static_cast<float>(Display::get_height()));
+    array->texcoord(u, v + h);
+    array->vertex(0, static_cast<float>(Display::get_height()));
       
-      if (0) // second noise level
-        {
-          u = rnd.frand();
-          v = rnd.frand();
-          float size = 4.0f;
+    if (0) // second noise level
+    {
+      u = rnd.frand();
+      v = rnd.frand();
+      float size = 4.0f;
 
-          array->texcoord(u, v);
-          array->vertex(0, 0, 1.0f);
+      array->texcoord(u, v);
+      array->vertex(0, 0, 1.0f);
 
-          array->texcoord(u + size, v);
-          array->vertex(static_cast<float>(Display::get_width()), 0.0f, 1.0f);
+      array->texcoord(u + size, v);
+      array->vertex(static_cast<float>(Display::get_width()), 0.0f, 1.0f);
 
-          array->texcoord(u + size, v + size);
-          array->vertex(static_cast<float>(Display::get_width()), static_cast<float>(Display::get_height()), 1.0f);
+      array->texcoord(u + size, v + size);
+      array->vertex(static_cast<float>(Display::get_width()), static_cast<float>(Display::get_height()), 1.0f);
 
-          array->texcoord(u, v + size);
-          array->vertex(0.0f, static_cast<float>(Display::get_height()), 1.0f);
-        }
+      array->texcoord(u, v + size);
+      array->vertex(0.0f, static_cast<float>(Display::get_height()), 1.0f);
+    }
 
-      sc.light().draw(array);
-    }
+    sc.light().draw(array);
+  }
   sc.light().pop_modelview();
 
   if (1)
-    {
-      // FIXME: might be better to copy the highlight over to the
-      // color layer, however that would require some changes to the
-      // DrawingContext structure
-      sc.highlight().clear();
+  {
+    // FIXME: might be better to copy the highlight over to the
+    // color layer, however that would require some changes to the
+    // DrawingContext structure
+    sc.highlight().clear();
 
-      sc.highlight().push_modelview();
-      sc.highlight().set_modelview(Matrix::identity());
+    sc.highlight().push_modelview();
+    sc.highlight().set_modelview(Matrix::identity());
 
-      nightvision.set_alpha(0.5f);
-      nightvision.set_blend_func(GL_SRC_ALPHA, GL_ONE);
-      nightvision.set_scale(std::max(float(Display::get_width())  / nightvision.get_width(),
-                                     float(Display::get_height()) / nightvision.get_height()));
+    nightvision.set_alpha(0.5f);
+    nightvision.set_blend_func(GL_SRC_ALPHA, GL_ONE);
+    nightvision.set_scale(std::max(float(Display::get_width())  / nightvision.get_width(),
+                                   float(Display::get_height()) / nightvision.get_height()));
 
-      sc.highlight().draw(nightvision, 
-                          Vector2f(static_cast<float>(Display::get_width()) / 2.0f - (nightvision.get_width()  * nightvision.get_scale() / 2.0f),
-                                   static_cast<float>(Display::get_height())/ 2.0f - (nightvision.get_height() * nightvision.get_scale() / 2.0f)),
-                          10000);
-      sc.highlight().pop_modelview();
-    }
+    sc.highlight().draw(nightvision, 
+                        Vector2f(static_cast<float>(Display::get_width()) / 2.0f - (nightvision.get_width()  * nightvision.get_scale() / 2.0f),
+                                 static_cast<float>(Display::get_height())/ 2.0f - (nightvision.get_height() * nightvision.get_scale() / 2.0f)),
+                        10000);
+    sc.highlight().pop_modelview();
+  }
 }
 
 void

Modified: trunk/windstille/src/objects/particle_systems.cpp
===================================================================
--- trunk/windstille/src/objects/particle_systems.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/particle_systems.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -26,9 +26,9 @@
 #include "scenegraph/scene_graph.hpp"
 #include "scenegraph/particle_system_drawable.hpp"
 
-ParticleSystems::ParticleSystems(const FileReader& reader)
-  : m_systems(),
-    m_drawables()
+ParticleSystems::ParticleSystems(const FileReader& reader) :
+  m_systems(),
+  m_drawables()
 {
   std::string filename;
   Vector2f    pos;

Modified: trunk/windstille/src/objects/pistol.cpp
===================================================================
--- trunk/windstille/src/objects/pistol.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/pistol.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -19,9 +19,9 @@
 #include "objects/laser_pointer.hpp"
 #include "objects/pistol.hpp"
 
-Pistol::Pistol()
-  : sprite(Pathname("models/objects/pistol/pistol.wsprite")),
-    laser_pointer(new LaserPointer())
+Pistol::Pistol() :
+  sprite(Pathname("models/objects/pistol/pistol.wsprite")),
+  laser_pointer(new LaserPointer())
 {
 }
 

Modified: trunk/windstille/src/objects/player.cpp
===================================================================
--- trunk/windstille/src/objects/player.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/player.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -36,20 +36,20 @@
 static const float WALK_SPEED = 100.0;
 static const float RUN_SPEED = 256.0;
 
-Player::Player () 
-  : m_drawable(),
-    jumping(),
-    bomb_placed(),
-    hit_count(),
-    energy(),
-    c_object(),
-    laser_pointer(),
-    contact(),
-    weapon(),
-    state(STAND),
-    jump_foot(),
-    reload_time(),
-    z_pos()
+Player::Player () :
+  m_drawable(),
+  jumping(),
+  bomb_placed(),
+  hit_count(),
+  energy(),
+  c_object(),
+  laser_pointer(),
+  contact(),
+  weapon(),
+  state(STAND),
+  jump_foot(),
+  reload_time(),
+  z_pos()
 {
   Sprite3D sprite(Pathname("models/characters/jane/jane.wsprite"));
   pos.x = 320;
@@ -90,21 +90,21 @@
 Player::draw (SceneContext& sc)
 {
   if (1)
-    { // draw the 'stand-on' tile
-      sc.highlight().fill_rect(Rect(Point(int(pos.x)/32 * 32, (int(pos.y)/32 + 1) * 32),
-                                    Size(32, 32)),
-                               Color(1.0f, 0.0f, 0.0f, 0.5f), 10000.0f);
-    }
+  { // draw the 'stand-on' tile
+    sc.highlight().fill_rect(Rect(Point(int(pos.x)/32 * 32, (int(pos.y)/32 + 1) * 32),
+                                  Size(32, 32)),
+                             Color(1.0f, 0.0f, 0.0f, 0.5f), 10000.0f);
+  }
 
   //m_drawable->get_sprite().draw(sc.color(), pos + Vector2f(0.0f, 1.0f), z_pos);
 
   Entity* obj = find_useable_entity();
   if (obj)
-    {
-      // FIXME: Highlight layer is the wrong place for this
-      std::string use_str = "[" + obj->get_use_verb() + "]";
-      sc.highlight().draw(use_str, obj->get_pos().x, obj->get_pos().y - 150, 1000);
-    }
+  {
+    // FIXME: Highlight layer is the wrong place for this
+    std::string use_str = "[" + obj->get_use_verb() + "]";
+    sc.highlight().draw(use_str, obj->get_pos().x, obj->get_pos().y - 150, 1000);
+  }
   
   // Draw weapon at the 'Weapon' attachment point
   Sprite3D::PointID id = m_drawable->get_sprite().get_attachment_point_id("Weapon");
@@ -115,12 +115,12 @@
   sc.pop_modelview();
 
   if (laser_pointer->is_active())
-    {
-      sc.push_modelview();
-      sc.translate(pos.x, pos.y - 80);
-      laser_pointer->draw(sc);
-      sc.pop_modelview();
-    }
+  {
+    sc.push_modelview();
+    sc.translate(pos.x, pos.y - 80);
+    laser_pointer->draw(sc);
+    sc.pop_modelview();
+  }
 }
 
 void
@@ -259,55 +259,55 @@
 Player::update_walk_stand(const Controller& controller)
 {
   if (controller.get_axis_state(Y_AXIS) > 0.5f)
+  {
+    TileMap* tilemap = Sector::current()->get_tilemap2();
+    if (tilemap)
     {
-      TileMap* tilemap = Sector::current()->get_tilemap2();
-      if (tilemap)
-        {
-          Point p(int(pos.x)/32, (int(pos.y)/32 + 1));
-          unsigned int col = tilemap->get_pixel(p.x, p.y);
+      Point p(int(pos.x)/32, (int(pos.y)/32 + 1));
+      unsigned int col = tilemap->get_pixel(p.x, p.y);
 
-          if ((col & TILE_STAIRS) && ((get_direction() == WEST && (col & TILE_LEFT)) ||
-                                      (get_direction() == EAST && (col & TILE_RIGHT))))
-            {
-              delete contact;
-              contact = new StairContact(tilemap, p);
+      if ((col & TILE_STAIRS) && ((get_direction() == WEST && (col & TILE_LEFT)) ||
+                                  (get_direction() == EAST && (col & TILE_RIGHT))))
+      {
+        delete contact;
+        contact = new StairContact(tilemap, p);
 
-              std::cout << "Stair mode" << std::endl;
-              state = STAIRS_DOWN;
-              //c_object->get_check_domains() & (~CollisionObject::DOMAIN_TILEMAP));
-              Sector::current()->get_collision_engine()->remove(c_object);
-              z_pos = -10.0f;
-              return;
-            }
-          else
-            {
-              set_ducking();
-              return;
-            }
-        }
+        std::cout << "Stair mode" << std::endl;
+        state = STAIRS_DOWN;
+        //c_object->get_check_domains() & (~CollisionObject::DOMAIN_TILEMAP));
+        Sector::current()->get_collision_engine()->remove(c_object);
+        z_pos = -10.0f;
+        return;
+      }
+      else
+      {
+        set_ducking();
+        return;
+      }
     }
+  }
   else if (controller.get_axis_state(Y_AXIS) < -0.5f)
+  {
+    TileMap* tilemap = Sector::current()->get_tilemap2();
+    if (tilemap)
     {
-      TileMap* tilemap = Sector::current()->get_tilemap2();
-      if (tilemap)
-        {
-          Point p(int(pos.x)/32 + ((get_direction() == WEST) ? -1 : +1), (int(pos.y)/32));
-          unsigned int col = tilemap->get_pixel(p.x, p.y);
+      Point p(int(pos.x)/32 + ((get_direction() == WEST) ? -1 : +1), (int(pos.y)/32));
+      unsigned int col = tilemap->get_pixel(p.x, p.y);
 
-          if ((col & TILE_STAIRS) && ((get_direction() == EAST && (col & TILE_LEFT)) ||
-                                      (get_direction() == WEST && (col & TILE_RIGHT))))
-            {
-              delete contact;
-              contact = new StairContact(tilemap, p);
+      if ((col & TILE_STAIRS) && ((get_direction() == EAST && (col & TILE_LEFT)) ||
+                                  (get_direction() == WEST && (col & TILE_RIGHT))))
+      {
+        delete contact;
+        contact = new StairContact(tilemap, p);
 
-              state = STAIRS_UP;
-              //c_object->get_check_domains() & (~CollisionObject::DOMAIN_TILEMAP));
-              Sector::current()->get_collision_engine()->remove(c_object);
-              z_pos = -10.0f;
-              return;
-            }
-        }    
-    }
+        state = STAIRS_UP;
+        //c_object->get_check_domains() & (~CollisionObject::DOMAIN_TILEMAP));
+        Sector::current()->get_collision_engine()->remove(c_object);
+        z_pos = -10.0f;
+        return;
+      }
+    }    
+  }
 
   if (state == STAND)
     update_stand(controller);
@@ -322,23 +322,23 @@
 
   if (controller.get_axis_state(X_AXIS) < -0.5f ||
       controller.get_axis_state(Y_AXIS) > 0.5f)
-    {
-      contact->advance(-WALK_SPEED * delta * 0.7f);
-    }
+  {
+    contact->advance(-WALK_SPEED * delta * 0.7f);
+  }
   else if (controller.get_axis_state(X_AXIS) > 0.5f ||
            controller.get_axis_state(Y_AXIS) < -0.5f)
-    {
-      contact->advance(WALK_SPEED * delta * 0.7f);
-    }
+  {
+    contact->advance(WALK_SPEED * delta * 0.7f);
+  }
 
   velocity = Vector2f(0, 0);
   c_object->set_pos(contact->get_pos());
 
   if (!contact->is_active())
-    {
-      Sector::current()->get_collision_engine()->add(c_object);
-      state = STAND;
-    }
+  {
+    Sector::current()->get_collision_engine()->add(c_object);
+    state = STAND;
+  }
 }
 
 Entity*
@@ -347,19 +347,19 @@
   const std::vector<boost::shared_ptr<GameObject> >& objects = Sector::current()->get_objects();
 
   for (std::vector<boost::shared_ptr<GameObject> >::const_iterator i = objects.begin(); i != objects.end(); ++i)
+  {
+    Entity* object = dynamic_cast<Entity*>(i->get());
+
+    if (object && object != this && object->is_useable())
     {
-      Entity* object = dynamic_cast<Entity*>(i->get());
-
-      if (object && object != this && object->is_useable())
-        {
-          //FIXME use proper collision detection
-          if (object->get_pos().x > pos.x - 32 && object->get_pos().x < pos.x + 32 &&
-              object->get_pos().y > pos.y - 256 && object->get_pos().y < pos.y + 256)
-            {
-              return object;
-            }
-        }
+      //FIXME use proper collision detection
+      if (object->get_pos().x > pos.x - 32 && object->get_pos().x < pos.x + 32 &&
+          object->get_pos().y > pos.y - 256 && object->get_pos().y < pos.y + 256)
+      {
+        return object;
+      }
     }
+  }
   return 0;  
 }
 
@@ -367,48 +367,48 @@
 Player::update_stand(const Controller& controller)
 { 
   if (controller.button_was_pressed(USE_BUTTON))
-    {
-      Entity* obj = find_useable_entity();
-      if (obj)
-        obj->use();
-      return;
-    }
+  {
+    Entity* obj = find_useable_entity();
+    if (obj)
+      obj->use();
+    return;
+  }
     
   if (controller.button_was_pressed(JUMP_BUTTON)
       && controller.get_axis_state(Y_AXIS) > 0.5f) 
-    {
-      set_jump_up_begin();
-    } 
+  {
+    set_jump_up_begin();
+  } 
   else if (controller.button_was_pressed(AIM_BUTTON))
+  {
+    if (0)
     {
-      if (0)
-        {
-          // TODO remove me later, just here for testing
-          boost::shared_ptr<Grenade> grenade(new Grenade());
-          grenade->set_pos(get_pos() + Vector2f(50, -300));
-          grenade->set_velocity(Vector2f(20, -10));
-          Sector::current()->add(grenade);
-        }
-      else
-        {
-          m_drawable->get_sprite().set_action("PullGun");
-          state = PULL_GUN;
-        }
+      // TODO remove me later, just here for testing
+      boost::shared_ptr<Grenade> grenade(new Grenade());
+      grenade->set_pos(get_pos() + Vector2f(50, -300));
+      grenade->set_velocity(Vector2f(20, -10));
+      Sector::current()->add(grenade);
     }
-  else if (controller.get_axis_state(X_AXIS) < -0.5f) 
+    else
     {
-      if (get_direction() == WEST)
-        set_walk(WEST);
-      else
-        set_turnaround();
+      m_drawable->get_sprite().set_action("PullGun");
+      state = PULL_GUN;
     }
+  }
+  else if (controller.get_axis_state(X_AXIS) < -0.5f) 
+  {
+    if (get_direction() == WEST)
+      set_walk(WEST);
+    else
+      set_turnaround();
+  }
   else if (controller.get_axis_state(X_AXIS) > 0.5f) 
-    {
-      if (get_direction() == EAST)
-        set_walk(EAST);
-      else
-        set_turnaround();
-    }
+  {
+    if (get_direction() == EAST)
+      set_walk(EAST);
+    else
+      set_turnaround();
+  }
 }
 
 void
@@ -432,26 +432,26 @@
 Player::update_walk(const Controller& controller)
 {
   if (fabsf(controller.get_axis_state(X_AXIS)) < 0.5f) // Hardcoded DEAD_ZONE, somewhat evil 
-    {
-      leave_walk();
-      set_stand();
-      return;
-    }
+  {
+    leave_walk();
+    set_stand();
+    return;
+  }
 
   if ((get_direction() == WEST && controller.get_axis_state(X_AXIS) > 0.5f) ||
       (get_direction() == EAST && controller.get_axis_state(X_AXIS) < -0.5f))
-    {
-      leave_walk();
-      set_turnaround();
-      return;
-    }
+  {
+    leave_walk();
+    set_turnaround();
+    return;
+  }
   
   if (controller.get_button_state(RUN_BUTTON))
-    {
-      leave_walk();
-      set_run();
-      return;
-    }
+  {
+    leave_walk();
+    set_run();
+    return;
+  }
 }
 
 void
@@ -475,25 +475,25 @@
 {
   // ducking
   if (m_drawable->get_sprite().switched_actions()) 
-    {
-      if (m_drawable->get_sprite().get_action() == "Ducking")
-        set_ducked();
-      else
-        set_stand();
-      return;
-    }
+  {
+    if (m_drawable->get_sprite().get_action() == "Ducking")
+      set_ducked();
+    else
+      set_stand();
+    return;
+  }
   
   if (!(controller.get_axis_state(Y_AXIS) > 0.5f) && m_drawable->get_sprite().get_speed() > 0) 
-    {
-      m_drawable->get_sprite().set_speed(-1.0);
-      m_drawable->get_sprite().set_next_action("Stand");
-      state = STAND;
-    } 
+  {
+    m_drawable->get_sprite().set_speed(-1.0);
+    m_drawable->get_sprite().set_next_action("Stand");
+    state = STAND;
+  } 
   else if (controller.get_axis_state(Y_AXIS) > 0.5f && m_drawable->get_sprite().get_speed() < 0) 
-    {
-      m_drawable->get_sprite().set_speed(1.0);
-      m_drawable->get_sprite().set_next_action("Ducking");
-    }
+  {
+    m_drawable->get_sprite().set_speed(1.0);
+    m_drawable->get_sprite().set_next_action("Ducking");
+  }
 }
 
 void
@@ -507,11 +507,11 @@
 Player::update_ducked(const Controller& controller)
 {
   if (!(controller.get_axis_state(Y_AXIS) > 0.5f))
-    {
-      state = DUCKING;
-      m_drawable->get_sprite().set_action("StandToDuck", -1.0);
-      m_drawable->get_sprite().set_next_action("Stand");
-    }  
+  {
+    state = DUCKING;
+    m_drawable->get_sprite().set_action("StandToDuck", -1.0);
+    m_drawable->get_sprite().set_next_action("Stand");
+  }  
 }
 
 void
@@ -528,22 +528,22 @@
 Player::update_turnaround(const Controller& controller)
 {
   if (m_drawable->get_sprite().switched_actions()) 
+  {
+    if (m_drawable->get_sprite().get_rot())
     {
-      if (m_drawable->get_sprite().get_rot())
-        {
-          set_walk(EAST);
-        }
-      else {
-        set_walk(WEST);
-      }
-    } 
+      set_walk(EAST);
+    }
+    else {
+      set_walk(WEST);
+    }
+  } 
   if ((m_drawable->get_sprite().get_rot() && controller.get_axis_state(X_AXIS) > 0.5f) ||
       (!m_drawable->get_sprite().get_rot() && controller.get_axis_state(X_AXIS) < -0.5f)) 
-    {
-      m_drawable->get_sprite().set_speed(-1.0);
-      m_drawable->get_sprite().set_next_action("Walk");
-      state = WALK;
-    }
+  {
+    m_drawable->get_sprite().set_speed(-1.0);
+    m_drawable->get_sprite().set_next_action("Walk");
+    state = WALK;
+  }
 }
 
 void
@@ -551,14 +551,14 @@
 {
   try_set_action("StandtoListen", backwards ? -1.0f : 1.0f);
   if (!backwards) 
-    {
-      m_drawable->get_sprite().set_next_action("Listen");
-      velocity = Vector2f(0, 0);
-    } 
+  {
+    m_drawable->get_sprite().set_next_action("Listen");
+    velocity = Vector2f(0, 0);
+  } 
   else
-    {
-      m_drawable->get_sprite().set_next_action("Stand");
-    }
+  {
+    m_drawable->get_sprite().set_next_action("Stand");
+  }
   state = STAND_TO_LISTEN;
 }
 
@@ -566,12 +566,12 @@
 Player::update_stand_to_listen(const Controller& /*controller*/)
 {
   if (m_drawable->get_sprite().switched_actions()) 
-    {
-      if (m_drawable->get_sprite().get_action() == "Stand")
-        set_stand();
-      else
-        set_listen();
-    }
+  {
+    if (m_drawable->get_sprite().get_action() == "Stand")
+      set_stand();
+    else
+      set_listen();
+  }
 }
 
 void
@@ -607,17 +607,17 @@
 Player::update_run(const Controller& controller)
 {
   if (!controller.get_button_state(RUN_BUTTON)) 
-    {
-      leave_run();
-      set_walk(get_direction());
-      return;
-    }
+  {
+    leave_run();
+    set_walk(get_direction());
+    return;
+  }
   if (controller.get_button_state(JUMP_BUTTON)) 
-    {
-      leave_run();
-      set_jump_begin();
-      return;
-    }
+  {
+    leave_run();
+    set_jump_begin();
+    return;
+  }
 }
 
 void
@@ -630,23 +630,23 @@
 Player::set_jump_begin()
 {
   if (m_drawable->get_sprite().before_marker("RightFoot")) 
-    {
-      m_drawable->get_sprite().set_next_action("JumpRightFoot");
-      m_drawable->get_sprite().abort_at_marker("RightFoot");
-      jump_foot = LEFT_FOOT;
-    } 
+  {
+    m_drawable->get_sprite().set_next_action("JumpRightFoot");
+    m_drawable->get_sprite().abort_at_marker("RightFoot");
+    jump_foot = LEFT_FOOT;
+  } 
   else if (m_drawable->get_sprite().before_marker("LeftFoot")) 
-    {
-      m_drawable->get_sprite().set_next_action("JumpLeftFoot");
-      m_drawable->get_sprite().abort_at_marker("LeftFoot");
-      jump_foot = RIGHT_FOOT;
-    } 
+  {
+    m_drawable->get_sprite().set_next_action("JumpLeftFoot");
+    m_drawable->get_sprite().abort_at_marker("LeftFoot");
+    jump_foot = RIGHT_FOOT;
+  } 
   else 
-    {
-      m_drawable->get_sprite().set_next_action("JumpRightFoot");
-      m_drawable->get_sprite().abort_at_marker("RightFoot");
-      jump_foot = LEFT_FOOT;
-    }
+  {
+    m_drawable->get_sprite().set_next_action("JumpRightFoot");
+    m_drawable->get_sprite().abort_at_marker("RightFoot");
+    jump_foot = LEFT_FOOT;
+  }
   state = JUMP_BEGIN;
 }
 
@@ -654,21 +654,21 @@
 Player::update_jump_begin(const Controller& /*controller*/)
 {
   if (m_drawable->get_sprite().switched_actions()) 
+  {
+    if (m_drawable->get_sprite().get_action() == "JumpLeftFoot") 
     {
-      if (m_drawable->get_sprite().get_action() == "JumpLeftFoot") 
-        {
-          m_drawable->get_sprite().set_next_action("JumpLeftFootAir");
-        } 
-      else if (m_drawable->get_sprite().get_action() == "JumpRightFoot") 
-        {
-          m_drawable->get_sprite().set_next_action("JumpRightFootAir");
-        } 
-      else
-        {
-          set_jump_air();
-          return;
-        }
+      m_drawable->get_sprite().set_next_action("JumpLeftFootAir");
+    } 
+    else if (m_drawable->get_sprite().get_action() == "JumpRightFoot") 
+    {
+      m_drawable->get_sprite().set_next_action("JumpRightFootAir");
+    } 
+    else
+    {
+      set_jump_air();
+      return;
     }
+  }
 }
 
 void
@@ -683,10 +683,10 @@
 Player::update_jump_air(const Controller& /*controller*/)
 {
   if (m_drawable->get_sprite().switched_actions()) 
-    {
-      set_jump_land();
-      return;
-    }
+  {
+    set_jump_land();
+    return;
+  }
 }
 
 void
@@ -700,10 +700,10 @@
 Player::update_jump_land(const Controller& /*controller*/)
 {
   if (m_drawable->get_sprite().switched_actions()) 
-    {
-      set_run();
-      return;
-    }
+  {
+    set_run();
+    return;
+  }
 }
 
 void
@@ -717,10 +717,10 @@
 Player::update_jump_up_begin(const Controller& /*controller*/)
 {
   if (m_drawable->get_sprite().switched_actions()) 
-    {
-      set_jump_up_air();
-      return;
-    }
+  {
+    set_jump_up_air();
+    return;
+  }
 }
 
 void
@@ -735,10 +735,10 @@
 Player::update_jump_up_air(const Controller& /*controller*/)
 {
   if (m_drawable->get_sprite().switched_actions()) 
-    {
-      set_jump_up_land();
-      return;
-    }
+  {
+    set_jump_up_land();
+    return;
+  }
 }
 
 void
@@ -752,20 +752,20 @@
 Player::update_jump_up_land(const Controller& /*controller*/)
 {
   if (m_drawable->get_sprite().switched_actions()) 
-    {
-      set_stand();
-      return;
-    }
+  {
+    set_stand();
+    return;
+  }
 }
 
 void
 Player::update_pull_gun(const Controller& controller)
 {
   if (!controller.get_button_state(AIM_BUTTON))
-    {
-      m_drawable->get_sprite().set_next_action("Stand");      
-      state = STAND;
-    }
+  {
+    m_drawable->get_sprite().set_next_action("Stand");      
+    state = STAND;
+  }
 }
 
 Player::Direction
@@ -797,16 +797,16 @@
 Player::hit(int points)
 {
   if (energy > 0 && hit_count <= 0)
+  {
+    energy -= points;
+    //hit_count = 1.0f;
+
+    if (energy <= 0)
     {
-      energy -= points;
-      //hit_count = 1.0f;
-
-      if (energy <= 0)
-        {
-          //switch_movement_state(KILLED);
-          hit_count = 0;
-        }
+      //switch_movement_state(KILLED);
+      hit_count = 0;
     }
+  }
 }
 
 void
@@ -816,15 +816,15 @@
   // cur_vel is the velocity in the current delta-frame
   Vector2f cur_vel = c_object->get_velocity(); 
   if (data.direction.y != 0)
-    {
-      cur_vel.y = 0;
-      velocity.y = 0; // also reset vertical velocity
-    }
+  {
+    cur_vel.y = 0;
+    velocity.y = 0; // also reset vertical velocity
+  }
   else
-    {
-      // do not reset horizontal velocity, as it's only set, when starting to go/run
-      cur_vel.x = 0;
-    }
+  {
+    // do not reset horizontal velocity, as it's only set, when starting to go/run
+    cur_vel.x = 0;
+  }
   c_object->set_velocity (cur_vel);
 }
 

Modified: trunk/windstille/src/objects/scriptable_object.cpp
===================================================================
--- trunk/windstille/src/objects/scriptable_object.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/scriptable_object.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,11 +22,11 @@
 #include "app/globals.hpp"
 #include "objects/scriptable_object.hpp"
 
-ScriptableObject::ScriptableObject(const FileReader& props)
-  : z_pos(50),
-    target_speed(0),
-    acceleration(0),
-    flash_speed(0)
+ScriptableObject::ScriptableObject(const FileReader& props) :
+  z_pos(50),
+  target_speed(0),
+  acceleration(0),
+  flash_speed(0)
 { 
   std::string spritename;
   std::string highlightname;
@@ -50,16 +50,16 @@
     sprite = Sprite(Pathname(spritename));
   
   if (highlightname != "")
-    {
-      highlight = Sprite(Pathname(highlightname));
-      highlight.set_blend_func(GL_SRC_ALPHA, GL_ONE);
-    }
+  {
+    highlight = Sprite(Pathname(highlightname));
+    highlight.set_blend_func(GL_SRC_ALPHA, GL_ONE);
+  }
 
   if (lightname != "")
-    {
-      light = Sprite(Pathname(lightname));
-      light.set_blend_func(GL_SRC_ALPHA, GL_ONE);
-    }
+  {
+    light = Sprite(Pathname(lightname));
+    light.set_blend_func(GL_SRC_ALPHA, GL_ONE);
+  }
     
   flash_delta = game_time;
   target_x = pos.x;
@@ -88,9 +88,9 @@
     sc.highlight().draw(highlight, tmp_pos, z_pos);
 
   if (light) 
-    {
-      sc.light().draw(light, tmp_pos, z_pos);
-    }
+  {
+    sc.light().draw(light, tmp_pos, z_pos);
+  }
 }
 
 void
@@ -113,18 +113,18 @@
 ScriptableObject::use()
 {
   if (!script_file.empty())
+  {
+    try 
     {
-      try 
-        {
-          Pathname path = Sector::current()->get_directory();
-          path.append_path(name).append_text(".nut");
-          ScriptManager::current()->run_script_file(path);
-        }
-      catch (std::exception& e) 
-        {
-          ConsoleLog << e.what() << std::endl;
-        }
+      Pathname path = Sector::current()->get_directory();
+      path.append_path(name).append_text(".nut");
+      ScriptManager::current()->run_script_file(path);
     }
+    catch (std::exception& e) 
+    {
+      ConsoleLog << e.what() << std::endl;
+    }
+  }
 }
 
 void

Modified: trunk/windstille/src/objects/scriptable_object.hpp
===================================================================
--- trunk/windstille/src/objects/scriptable_object.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/scriptable_object.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -25,12 +25,12 @@
 #include "sprite2d/sprite.hpp"
 
 /** Can represent any generic object that the player may see or interact with that
-does not require collision physics or specialized C++ code. For example doors, trains,
-signs, objects you can pick up, and animations.
+    does not require collision physics or specialized C++ code. For example doors, trains,
+    signs, objects you can pick up, and animations.
 
-TODO: should this provide optional collision detection such that you can use it to make
-crates etc? Or perhaps another object should derive from this which adds collision
-detection?
+    TODO: should this provide optional collision detection such that you can use it to make
+    crates etc? Or perhaps another object should derive from this which adds collision
+    detection?
 */
 class ScriptableObject : public Entity
 {

Modified: trunk/windstille/src/objects/shockwave.cpp
===================================================================
--- trunk/windstille/src/objects/shockwave.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/shockwave.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,11 +22,11 @@
 #include "display/shader_object.hpp"
 #include "scenegraph/shockwave_drawable.hpp"
 
-Shockwave::Shockwave(const FileReader& props)
-  : pos(),
-    noise(Pathname("images/noise3.png")),
-    shader_program(),
-    radius()
+Shockwave::Shockwave(const FileReader& props) :
+  pos(),
+  noise(Pathname("images/noise3.png")),
+  shader_program(),
+  radius()
 {
   props.get("pos", pos);
   
@@ -47,10 +47,10 @@
 Shockwave::draw (SceneContext& sc)
 {
   sc.highlight().draw(new ShockwaveDrawable(pos,
-                                                   noise,
-                                                   shader_program,
-                                                   radius,
-                                                   sc.color().get_modelview()));
+                                            noise,
+                                            shader_program,
+                                            radius,
+                                            sc.color().get_modelview()));
 }
 
 void

Modified: trunk/windstille/src/objects/spider_mine.cpp
===================================================================
--- trunk/windstille/src/objects/spider_mine.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/spider_mine.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -19,15 +19,15 @@
 #include "objects/spider_mine.hpp"
 #include "objects/player.hpp"
 
-SpiderMine::SpiderMine(const FileReader& props)
-  : sprite(),
-    explode(Pathname("images/explosion.sprite")),
-    explode_light(Pathname("images/explolight.sprite")),
-    initial_position(),
-    walk_speed(160),
-    jump_time(0.0),
-    state(WAIT),
-    exploded(false)
+SpiderMine::SpiderMine(const FileReader& props) :
+  sprite(),
+  explode(Pathname("images/explosion.sprite")),
+  explode_light(Pathname("images/explolight.sprite")),
+  initial_position(),
+  walk_speed(160),
+  jump_time(0.0),
+  state(WAIT),
+  exploded(false)
 {
   props.get("name", name);
   props.get("pos",  pos);
@@ -108,15 +108,15 @@
     velocity.y = 0;
     // if close enough to the player hit them
     if ((fabs(player_pos.x - pos.x) < 15) &&
-      ((pos.y - 32 - 15 < player_pos.y) &&
-      (pos.y > player_pos.y - 135 + 15))) {
-        player->hit(1);
+        ((pos.y - 32 - 15 < player_pos.y) &&
+         (pos.y > player_pos.y - 135 + 15))) {
+      player->hit(1);
     }
   }
   // check to see if we should jump
   else if (state != JUMP && (fabs(player_pos.x - pos.x) <= 45)
-            && ((pos.y - 32 < player_pos.y) && (pos.y > player_pos.y - 135))
-            && on_ground()) {
+           && ((pos.y - 32 < player_pos.y) && (pos.y > player_pos.y - 135))
+           && on_ground()) {
     state = JUMP;
     velocity.y = -400;
     jump_time = 0.0;
@@ -135,8 +135,8 @@
   }
   // check to see if we should go back to starting position (ignores y)
   else if (state != JUMP &&
-       fabs(player_pos.x - pos.x) >= 200
-       && fabs(pos.x - initial_position.x) > 15) {
+           fabs(player_pos.x - pos.x) >= 200
+           && fabs(pos.x - initial_position.x) > 15) {
     state = RETURN;
     if (on_ground()) {
       if (initial_position.x < pos.x)
@@ -144,7 +144,7 @@
       else
         velocity.x = walk_speed;
     }
-  // else wait
+    // else wait
   } else if (state != JUMP) {
     state = WAIT;
     velocity.x = 0;

Modified: trunk/windstille/src/objects/swarm.cpp
===================================================================
--- trunk/windstille/src/objects/swarm.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/swarm.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -23,10 +23,10 @@
 
 #include "objects/swarm.hpp"
 
-Swarm::Swarm(const FileReader& props)
-  : agents(),
-    target(),
-    turn_speed()
+Swarm::Swarm(const FileReader& props) :
+  agents(),
+  target(),
+  turn_speed()
 {
   int count = 100;
   turn_speed = 7.0f;
@@ -39,26 +39,26 @@
   agents.resize(count);
 
   for(Agents::iterator i = agents.begin(); i != agents.end(); ++i)
-    {
-      i->pos.x = pos.x + rnd.frand(-100, 100);
-      i->pos.y = pos.y + rnd.frand(-100, 100);
+  {
+    i->pos.x = pos.x + rnd.frand(-100, 100);
+    i->pos.y = pos.y + rnd.frand(-100, 100);
 
-      i->angle = rnd.frand(-math::pi, math::pi);
-      i->speed = rnd.frand(50.0f, 200.0f);
+    i->angle = rnd.frand(-math::pi, math::pi);
+    i->speed = rnd.frand(50.0f, 200.0f);
 
-      i->max_speed = rnd.frand(100.0f, 200.0f);
+    i->max_speed = rnd.frand(100.0f, 200.0f);
 
-      i->turn_speed = i->max_speed/30.0f;
+    i->turn_speed = i->max_speed/30.0f;
 
-      i->last_pos = i->pos;
-    }
+    i->last_pos = i->pos;
+  }
 }
 
 void
 Swarm::draw(SceneContext& sc)
 {
   VertexArrayDrawable* array = new VertexArrayDrawable(Vector2f(0, 0), 
-                                                                   1000.0f, sc.highlight().get_modelview());
+                                                       1000.0f, sc.highlight().get_modelview());
 
   array->set_mode(GL_QUADS);
   array->set_blend_func(GL_ONE, GL_ZERO);
@@ -67,19 +67,19 @@
   Color bottom_color(0.0f, 0.0f, 0.0f);
 
   for(Agents::const_iterator i = agents.begin(); i != agents.end(); ++i)
-    {
-      array->color(color);
-      array->vertex(i->pos.x - 1, i->pos.y - 1);
+  {
+    array->color(color);
+    array->vertex(i->pos.x - 1, i->pos.y - 1);
 
-      array->color(color);
-      array->vertex(i->pos.x + 2, i->pos.y - 1);
+    array->color(color);
+    array->vertex(i->pos.x + 2, i->pos.y - 1);
 
-      array->color(bottom_color);
-      array->vertex(i->pos.x + 2, i->pos.y + 2);
+    array->color(bottom_color);
+    array->vertex(i->pos.x + 2, i->pos.y + 2);
 
-      array->color(bottom_color);
-      array->vertex(i->pos.x - 1, i->pos.y + 2);
-    }
+    array->color(bottom_color);
+    array->vertex(i->pos.x - 1, i->pos.y + 2);
+  }
 
   sc.highlight().draw(array);
 }
@@ -93,41 +93,41 @@
   target = GameSession::current()->get_view()->screen_to_world(Vector2f(static_cast<float>(x), static_cast<float>(y)));
 
   for(Agents::iterator i = agents.begin(); i != agents.end(); ++i)
-    {
-      i->last_pos = i->pos;
+  {
+    i->last_pos = i->pos;
 
-      float dx = target.x - i->pos.x;
-      float dy = target.y - i->pos.y;
+    float dx = target.x - i->pos.x;
+    float dy = target.y - i->pos.y;
 
-      float target_angle   = atan2f(dy, dx);
-      float relative_angle = math::normalize_angle(target_angle - i->angle);
+    float target_angle   = atan2f(dy, dx);
+    float relative_angle = math::normalize_angle(target_angle - i->angle);
       
-      if (sqrt(dx*dx + (dy*dy)*2.0f) > 50.0f) // swarm range
-        {
-          if (fabs(relative_angle) < 0.3f)
-            {
-              //i->angle += rnd.frand(-1.0f, 1.0f) * delta;
-              if (i->speed < i->max_speed) 
-                i->speed += 100.0f * delta;
-            }
-          else
-            {
-              if (relative_angle <= M_PI)
-                i->angle += i->turn_speed * delta;
-              else
-                i->angle -= i->turn_speed * delta;
-            }
-        }
+    if (sqrt(dx*dx + (dy*dy)*2.0f) > 50.0f) // swarm range
+    {
+      if (fabs(relative_angle) < 0.3f)
+      {
+        //i->angle += rnd.frand(-1.0f, 1.0f) * delta;
+        if (i->speed < i->max_speed) 
+          i->speed += 100.0f * delta;
+      }
       else
-        {
-          i->angle += rnd.frand(-15.0f, 15.0f) * delta;
-          //i->speed += 150.0f - fabs(i->angle);
-          i->speed = rnd.frand(50.0f, 100.0f);
-        }
+      {
+        if (relative_angle <= M_PI)
+          i->angle += i->turn_speed * delta;
+        else
+          i->angle -= i->turn_speed * delta;
+      }
+    }
+    else
+    {
+      i->angle += rnd.frand(-15.0f, 15.0f) * delta;
+      //i->speed += 150.0f - fabs(i->angle);
+      i->speed = rnd.frand(50.0f, 100.0f);
+    }
 
-      i->pos.x += i->speed * cosf(i->angle) * delta;
-      i->pos.y += i->speed * sinf(i->angle) * delta;
-    }
+    i->pos.x += i->speed * cosf(i->angle) * delta;
+    i->pos.y += i->speed * sinf(i->angle) * delta;
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/objects/test_object.cpp
===================================================================
--- trunk/windstille/src/objects/test_object.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/test_object.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -20,10 +20,10 @@
 
 #include "objects/test_object.hpp"
 
-TestObject::TestObject(const FileReader& props)
-  : sprite(),
-    attached_sprites(),
-    pos()
+TestObject::TestObject(const FileReader& props) :
+  sprite(),
+  attached_sprites(),
+  pos()
 {
   pos = Vector2f(0, 0);
   std::string spritename;

Modified: trunk/windstille/src/objects/test_object.hpp
===================================================================
--- trunk/windstille/src/objects/test_object.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/test_object.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -39,7 +39,7 @@
   void set_vflip(bool vflip);
   void set_pos(const Vector2f& pos);
   void attach(const std::string& spritename,
-		      const std::string& attachement_point);
+              const std::string& attachement_point);
 
 private:
   Sprite3D sprite;

Modified: trunk/windstille/src/objects/trigger.cpp
===================================================================
--- trunk/windstille/src/objects/trigger.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/trigger.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -21,12 +21,12 @@
 #include "engine/sector.hpp"
 #include "objects/player.hpp"
 
-Trigger::Trigger(const FileReader& props)
-  : area(),
-    callback(),
-    triggered(false), 
-    last_trigger(),
-    one_time_trigger(false)
+Trigger::Trigger(const FileReader& props) :
+  area(),
+  callback(),
+  triggered(false), 
+  last_trigger(),
+  one_time_trigger(false)
 {
   float x = -1;
   float y = -1;
@@ -64,26 +64,26 @@
   //FIXME use proper collision detection
   Player* player = Player::current();
   if(!area.is_inside(player->get_pos())) 
-    {
-      last_trigger = false;
-      return;
-    }
+  {
+    last_trigger = false;
+    return;
+  }
   
   if(triggered && one_time_trigger)
     return;
 
   if(last_trigger == false) 
+  {
+    triggered = true;
+    try 
     {
-      triggered = true;
-      try 
-        {
-          Sector::current()->call_script_function(callback);
-        }
-      catch(std::exception& e) 
-        {
-          std::cerr << "Couldn't run trigger-script: " << e.what() << "\n";
-        }
+      Sector::current()->call_script_function(callback);
     }
+    catch(std::exception& e) 
+    {
+      std::cerr << "Couldn't run trigger-script: " << e.what() << "\n";
+    }
+  }
   last_trigger = true;
 }
 

Modified: trunk/windstille/src/objects/vrdummy.cpp
===================================================================
--- trunk/windstille/src/objects/vrdummy.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/objects/vrdummy.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -19,11 +19,11 @@
 #include "math/random.hpp"
 #include "objects/vrdummy.hpp"
 
-VRDummy::VRDummy(const FileReader& props)
-  : sprite(),
-    highlight(),
-    rotation(),
-    jump_time()
+VRDummy::VRDummy(const FileReader& props) :
+  sprite(),
+  highlight(),
+  rotation(),
+  jump_time()
 {
   props.get("name", name);
   props.get("pos",  pos);
@@ -62,17 +62,17 @@
   jump_time += delta;
   
   if (jump_time >= 1.0f && velocity == Vector2f(0, 0)) 
-    {
-      velocity = Vector2f(rnd.frand(-300.0f, 300.0f),
-                          rnd.frand(-300.0f, 300.0f));
-    }
+  {
+    velocity = Vector2f(rnd.frand(-300.0f, 300.0f),
+                        rnd.frand(-300.0f, 300.0f));
+  }
 
   if (jump_time >= 1.5f)
-    {
-      jump_time = 0.0f;
+  {
+    jump_time = 0.0f;
       
-      velocity = Vector2f(0, 0);
-    }
+    velocity = Vector2f(0, 0);
+  }
 
   pos += velocity * delta;
 }

Modified: trunk/windstille/src/particles/deform_drawer.cpp
===================================================================
--- trunk/windstille/src/particles/deform_drawer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/particles/deform_drawer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -96,45 +96,45 @@
 
     glBegin(GL_QUADS);
     for(ParticleSystem::Particles::iterator i = psys.begin(); i != psys.end(); ++i)
+    {
+      if (i->t != -1.0f)
       {
-        if (i->t != -1.0f)
-          {
-            float p = 1.0f - psys.get_progress(i->t);
-            Color color(psys.get_color_start().r * p + psys.get_color_stop().r * (1.0f - p),
-                        psys.get_color_start().g * p + psys.get_color_stop().g * (1.0f - p),
-                        psys.get_color_start().b * p + psys.get_color_stop().b * (1.0f - p),
-                        psys.get_color_start().a * p + psys.get_color_stop().a * (1.0f - p));
+        float p = 1.0f - psys.get_progress(i->t);
+        Color color(psys.get_color_start().r * p + psys.get_color_stop().r * (1.0f - p),
+                    psys.get_color_start().g * p + psys.get_color_stop().g * (1.0f - p),
+                    psys.get_color_start().b * p + psys.get_color_stop().b * (1.0f - p),
+                    psys.get_color_start().a * p + psys.get_color_stop().a * (1.0f - p));
 
-            // scale
-            float scale  = psys.get_size_start() + 
-              psys.get_progress(i->t) * (psys.get_size_stop() - psys.get_size_start());
+        // scale
+        float scale  = psys.get_size_start() + 
+          psys.get_progress(i->t) * (psys.get_size_stop() - psys.get_size_start());
           
-            float width  = surface.get_width()  * scale;
-            float height = surface.get_height() * scale;
+        float width  = surface.get_width()  * scale;
+        float height = surface.get_height() * scale;
               
-            // rotate
-            float x_rot = width/2;
-            float y_rot = height/2; 
+        // rotate
+        float x_rot = width/2;
+        float y_rot = height/2; 
 
-            if (i->angle != 0)
-              {
-                float s = sinf(math::pi * i->angle/180.0f);
-                float c = cosf(math::pi * i->angle/180.0f);
-                x_rot = (width/2) * c - (height/2) * s;
-                y_rot = (width/2) * s + (height/2) * c;
-              }
+        if (i->angle != 0)
+        {
+          float s = sinf(math::pi * i->angle/180.0f);
+          float c = cosf(math::pi * i->angle/180.0f);
+          x_rot = (width/2) * c - (height/2) * s;
+          y_rot = (width/2) * s + (height/2) * c;
+        }
 
-            glColor4f(color.r, color.g, color.b, color.a);
-            glTexCoord2f(0, 0);
-            glVertex2f(i->x - x_rot, i->y - y_rot);
-            glTexCoord2f(1, 0);
-            glVertex2f(i->x + y_rot, i->y - x_rot);
-            glTexCoord2f(1, 1);
-            glVertex2f(i->x + x_rot, i->y + y_rot);
-            glTexCoord2f(0, 1);
-            glVertex2f(i->x - y_rot, i->y + x_rot);
-          }
+        glColor4f(color.r, color.g, color.b, color.a);
+        glTexCoord2f(0, 0);
+        glVertex2f(i->x - x_rot, i->y - y_rot);
+        glTexCoord2f(1, 0);
+        glVertex2f(i->x + y_rot, i->y - x_rot);
+        glTexCoord2f(1, 1);
+        glVertex2f(i->x + x_rot, i->y + y_rot);
+        glTexCoord2f(0, 1);
+        glVertex2f(i->x - y_rot, i->y + x_rot);
       }
+    }
     glEnd();
 
     glPopMatrix();

Modified: trunk/windstille/src/particles/particle_system.cpp
===================================================================
--- trunk/windstille/src/particles/particle_system.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/particles/particle_system.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -93,93 +93,93 @@
   {
     std::string layer_str;
     if (props.get("layer", layer_str))
-      {
-        if (layer_str == "highlight")
-          layer = SceneContext::HIGHLIGHTMAP;
-        else if (layer_str == "light")
-          layer = SceneContext::LIGHTMAP;
-        else if (layer_str == "color")
-          layer = SceneContext::COLORMAP;
-        else
-          std::cout << "ParticleSystem: Unknown layer type: '" << layer_str << "'" << std::endl;
-      }
+    {
+      if (layer_str == "highlight")
+        layer = SceneContext::HIGHLIGHTMAP;
+      else if (layer_str == "light")
+        layer = SceneContext::LIGHTMAP;
+      else if (layer_str == "color")
+        layer = SceneContext::COLORMAP;
+      else
+        std::cout << "ParticleSystem: Unknown layer type: '" << layer_str << "'" << std::endl;
+    }
   }
 
   {
     FileReader drawer_reader;
     if (props.get("drawer", drawer_reader))
-      {
-        std::vector<FileReader> sections = drawer_reader.get_sections();
+    {
+      std::vector<FileReader> sections = drawer_reader.get_sections();
 
-        if (sections.size() > 1)
-          std::cout << "ParticleSystem: Only one drawer allowed" << std::endl;
+      if (sections.size() > 1)
+        std::cout << "ParticleSystem: Only one drawer allowed" << std::endl;
         
-        if (sections.size() == 0)
-          std::cout << "ParticleSystem: You must specify a drawer" << std::endl;
+      if (sections.size() == 0)
+        std::cout << "ParticleSystem: You must specify a drawer" << std::endl;
 
-        if (sections.size() >= 1)
-          {
-            FileReader& reader  = sections.front();
-            if (reader.get_name() == "surface-drawer") 
-              {
-                set_drawer(new SurfaceDrawer(reader));
-              } 
-            else if (reader.get_name() == "spark-drawer") 
-              {
-                set_drawer(new SparkDrawer(reader));
-              } 
-            else if (reader.get_name() == "deform-drawer")
-              {
-                set_drawer(new DeformDrawer(reader));
-              }
-            else 
-              {
-                std::cout << "Unknown drawer: " << reader.get_name() << std::endl;
-              }
-          }
+      if (sections.size() >= 1)
+      {
+        FileReader& reader  = sections.front();
+        if (reader.get_name() == "surface-drawer") 
+        {
+          set_drawer(new SurfaceDrawer(reader));
+        } 
+        else if (reader.get_name() == "spark-drawer") 
+        {
+          set_drawer(new SparkDrawer(reader));
+        } 
+        else if (reader.get_name() == "deform-drawer")
+        {
+          set_drawer(new DeformDrawer(reader));
+        }
+        else 
+        {
+          std::cout << "Unknown drawer: " << reader.get_name() << std::endl;
+        }
       }
+    }
   }
 
   {
     FileReader distribution_reader;
     if (props.get("distribution", distribution_reader))
-      {
-        std::vector<FileReader> sections = distribution_reader.get_sections();
+    {
+      std::vector<FileReader> sections = distribution_reader.get_sections();
 
-        if (sections.size() > 1)
-          std::cout << "ParticleSystem: Only one distribution allowed" << std::endl;
+      if (sections.size() > 1)
+        std::cout << "ParticleSystem: Only one distribution allowed" << std::endl;
         
-        if (sections.size() == 0)
-          std::cout << "ParticleSystem: You must specify a distribution" << std::endl;
+      if (sections.size() == 0)
+        std::cout << "ParticleSystem: You must specify a distribution" << std::endl;
 
-        if (sections.size() >= 1)
-          {
-            FileReader& reader  = sections.front();
+      if (sections.size() >= 1)
+      {
+        FileReader& reader  = sections.front();
 
-            if (reader.get_name() == "point-distribution") {
-              set_point_distribution();
-            } else if (reader.get_name() == "line-distribution") {
-              float x1, y1, x2, y2;
-              reader.get("x1", x1);
-              reader.get("y1", y1);
-              reader.get("x2", x2);
-              reader.get("y2", y2);
+        if (reader.get_name() == "point-distribution") {
+          set_point_distribution();
+        } else if (reader.get_name() == "line-distribution") {
+          float x1, y1, x2, y2;
+          reader.get("x1", x1);
+          reader.get("y1", y1);
+          reader.get("x2", x2);
+          reader.get("y2", y2);
           
-              set_line_distribution(x1, y1, x2, y2);
-            } else if (reader.get_name() == "rect-distribution") {
-              Rectf rect;
-              reader.get("x1", rect.left);
-              reader.get("y1", rect.top);
-              reader.get("x2", rect.right);
-              reader.get("y2", rect.bottom);
+          set_line_distribution(x1, y1, x2, y2);
+        } else if (reader.get_name() == "rect-distribution") {
+          Rectf rect;
+          reader.get("x1", rect.left);
+          reader.get("y1", rect.top);
+          reader.get("x2", rect.right);
+          reader.get("y2", rect.bottom);
           
-              set_rect_distribution(rect);
+          set_rect_distribution(rect);
 
-            } else {
-              std::cout << "Unknown distribution: " << reader.get_name() << std::endl;
-            }
-          }
+        } else {
+          std::cout << "Unknown distribution: " << reader.get_name() << std::endl;
+        }
       }
+    }
   }
   
   int p_count = 70;
@@ -232,13 +232,13 @@
 ParticleSystem::draw() const
 {
   if (drawer.get())
-    {
-      drawer->draw(*this);
-    }
+  {
+    drawer->draw(*this);
+  }
   else
-    {
-      std::cout << "ParticleSystem: No drawer set" << std::endl;
-    } 
+  {
+    std::cout << "ParticleSystem: No drawer set" << std::endl;
+  } 
 }
 
 void
@@ -266,22 +266,22 @@
 ParticleSystem::update(float delta)
 {
   for(Particles::iterator i = particles.begin(); i != particles.end(); ++i)
+  {
+    if (i->t > life_time)
     {
-      if (i->t > life_time)
-        {
-          spawn(*i);
-        }
-      else
-        {
-          i->t += delta;
+      spawn(*i);
+    }
+    else
+    {
+      i->t += delta;
           
-          i->x += i->v_x * delta;
-          i->y += i->v_y * delta;
+      i->x += i->v_x * delta;
+      i->y += i->v_y * delta;
 
-          i->v_x += gravity_x;
-          i->v_y += gravity_y;
-        }
+      i->v_x += gravity_x;
+      i->v_y += gravity_y;
     }
+  }
 }
 
 int
@@ -295,15 +295,15 @@
 {
   int old_size = particles.size();
   if (old_size != num)
+  {
+    particles.resize(num);
+
+    for(Particles::size_type i = old_size; i < particles.size(); ++i)
     {
-      particles.resize(num);
-
-      for(Particles::size_type i = old_size; i < particles.size(); ++i)
-        {
-          spawn(particles[i]);
-          particles[i].t = life_time * bunching * static_cast<float>(i) / static_cast<float>(particles.size());
-        }
+      spawn(particles[i]);
+      particles[i].t = life_time * bunching * static_cast<float>(i) / static_cast<float>(particles.size());
     }
+  }
 }
   
 void

Modified: trunk/windstille/src/particles/spark_drawer.cpp
===================================================================
--- trunk/windstille/src/particles/spark_drawer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/particles/spark_drawer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -40,47 +40,47 @@
   buffer->set_pos(Vector2f(psys.get_x_pos(), psys.get_y_pos()));
 
   if (width == 1.0f)
+  {
+    buffer->set_mode(GL_LINES);
+    buffer->set_blend_func(GL_SRC_ALPHA, GL_ONE);
+    for(ParticleSystem::const_iterator i = psys.begin(); i != psys.end(); ++i)
     {
-      buffer->set_mode(GL_LINES);
-      buffer->set_blend_func(GL_SRC_ALPHA, GL_ONE);
-      for(ParticleSystem::const_iterator i = psys.begin(); i != psys.end(); ++i)
-        {
-          buffer->color(Color(color.r, color.g, color.b, color.a - (color.a * psys.get_progress(i->t))));
-          buffer->vertex(i->x + i->v_x/10.0f, i->y + i->v_y/10.0f); 
+      buffer->color(Color(color.r, color.g, color.b, color.a - (color.a * psys.get_progress(i->t))));
+      buffer->vertex(i->x + i->v_x/10.0f, i->y + i->v_y/10.0f); 
 
-          buffer->color(Color(0, 0, 0, 0));
-          buffer->vertex(i->x, i->y);
-        }
+      buffer->color(Color(0, 0, 0, 0));
+      buffer->vertex(i->x, i->y);
     }
+  }
   else
+  {
+    buffer->set_mode(GL_QUADS);
+    buffer->set_blend_func(GL_SRC_ALPHA, GL_ONE);
+    for(ParticleSystem::const_iterator i = psys.begin(); i != psys.end(); ++i)
     {
-      buffer->set_mode(GL_QUADS);
-      buffer->set_blend_func(GL_SRC_ALPHA, GL_ONE);
-      for(ParticleSystem::const_iterator i = psys.begin(); i != psys.end(); ++i)
-        {
-          const float len = sqrtf(i->v_x * i->v_x  +  i->v_y * i->v_y);
+      const float len = sqrtf(i->v_x * i->v_x  +  i->v_y * i->v_y);
 
-          const float o_x = i->v_y/len * width;
-          const float o_y = i->v_x/len * width;
+      const float o_x = i->v_y/len * width;
+      const float o_y = i->v_x/len * width;
 
-          const float x1 = i->x;
-          const float y1 = i->y;
-          const float x2 = i->x + i->v_x/10.0f;
-          const float y2 = i->y + i->v_y/10.0f;
+      const float x1 = i->x;
+      const float y1 = i->y;
+      const float x2 = i->x + i->v_x/10.0f;
+      const float y2 = i->y + i->v_y/10.0f;
 
-          buffer->color(Color(0, 0, 0, 0));
-          buffer->vertex(x1 + o_x, y1 - o_y);
+      buffer->color(Color(0, 0, 0, 0));
+      buffer->vertex(x1 + o_x, y1 - o_y);
 
-          buffer->color(Color(0, 0, 0, 0));
-          buffer->vertex(x1 - o_x, y1 + o_y);
+      buffer->color(Color(0, 0, 0, 0));
+      buffer->vertex(x1 - o_x, y1 + o_y);
 
-          buffer->color(Color(color.r, color.g, color.b, color.a - (color.a * psys.get_progress(i->t))));
-          buffer->vertex(x2 - o_x, y2 + o_y); 
+      buffer->color(Color(color.r, color.g, color.b, color.a - (color.a * psys.get_progress(i->t))));
+      buffer->vertex(x2 - o_x, y2 + o_y); 
 
-          buffer->color(Color(color.r, color.g, color.b, color.a - (color.a * psys.get_progress(i->t))));
-          buffer->vertex(x2 + o_x, y2 - o_y); 
-        }
+      buffer->color(Color(color.r, color.g, color.b, color.a - (color.a * psys.get_progress(i->t))));
+      buffer->vertex(x2 + o_x, y2 - o_y); 
     }
+  }
 
   buffer->render(~0u);
 }

Modified: trunk/windstille/src/particles/surface_drawer.cpp
===================================================================
--- trunk/windstille/src/particles/surface_drawer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/particles/surface_drawer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -116,49 +116,49 @@
   buffer->set_blend_func(blendfunc_src, blendfunc_dest);
 
   for(ParticleSystem::const_iterator i = psys.begin(); i != psys.end(); ++i)
+  {
+    if (i->t != -1.0f)
     {
-      if (i->t != -1.0f)
-        {
-          float p = 1.0f - psys.get_progress(i->t);
-          Color color(psys.get_color_start().r * p + psys.get_color_stop().r * (1.0f - p),
-                      psys.get_color_start().g * p + psys.get_color_stop().g * (1.0f - p),
-                      psys.get_color_start().b * p + psys.get_color_stop().b * (1.0f - p),
-                      psys.get_color_start().a * p + psys.get_color_stop().a * (1.0f - p));
+      float p = 1.0f - psys.get_progress(i->t);
+      Color color(psys.get_color_start().r * p + psys.get_color_stop().r * (1.0f - p),
+                  psys.get_color_start().g * p + psys.get_color_stop().g * (1.0f - p),
+                  psys.get_color_start().b * p + psys.get_color_stop().b * (1.0f - p),
+                  psys.get_color_start().a * p + psys.get_color_stop().a * (1.0f - p));
 
-          // scale
-          float scale  = psys.get_size_start() + 
-            psys.get_progress(i->t) * (psys.get_size_stop() - psys.get_size_start());
+      // scale
+      float scale  = psys.get_size_start() + 
+        psys.get_progress(i->t) * (psys.get_size_stop() - psys.get_size_start());
           
-          float width  = surface.get_width()  * scale;
-          float height = surface.get_height() * scale;
+      float width  = surface.get_width()  * scale;
+      float height = surface.get_height() * scale;
               
-          // rotate
-          float x_rot = width/2;
-          float y_rot = height/2; 
+      // rotate
+      float x_rot = width/2;
+      float y_rot = height/2; 
 
-          if (i->angle != 0)
-            {
-              float s = sinf(math::pi * i->angle/180.0f);
-              float c = cosf(math::pi * i->angle/180.0f);
-              x_rot = (width/2) * c - (height/2) * s;
-              y_rot = (width/2) * s + (height/2) * c;
-            }
+      if (i->angle != 0)
+      {
+        float s = sinf(math::pi * i->angle/180.0f);
+        float c = cosf(math::pi * i->angle/180.0f);
+        x_rot = (width/2) * c - (height/2) * s;
+        y_rot = (width/2) * s + (height/2) * c;
+      }
 
-          buffer->add_texcoords(surface.get_uv());
+      buffer->add_texcoords(surface.get_uv());
 
-          buffer->color(color);
-          buffer->vertex(i->x - x_rot, i->y - y_rot);
+      buffer->color(color);
+      buffer->vertex(i->x - x_rot, i->y - y_rot);
 
-          buffer->color(color);
-          buffer->vertex(i->x + y_rot, i->y - x_rot);
+      buffer->color(color);
+      buffer->vertex(i->x + y_rot, i->y - x_rot);
 
-          buffer->color(color);
-          buffer->vertex(i->x + x_rot, i->y + y_rot);
+      buffer->color(color);
+      buffer->vertex(i->x + x_rot, i->y + y_rot);
 
-          buffer->color(color);
-          buffer->vertex(i->x - y_rot, i->y + x_rot);
-        }
+      buffer->color(color);
+      buffer->vertex(i->x - y_rot, i->y + x_rot);
     }
+  }
 
   buffer->render(~0u);
 }

Modified: trunk/windstille/src/properties/properties.cpp
===================================================================
--- trunk/windstille/src/properties/properties.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/properties/properties.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,9 +22,9 @@
 #include "properties/property_set.hpp"
 #include "properties/properties.hpp"
 
-Properties::Properties(PropertySet* pset_, void* object_)
-  : pset(pset_),
-    object(object_)
+Properties::Properties(PropertySet* pset_, void* object_) :
+  pset(pset_),
+  object(object_)
 {
 }
 
@@ -33,15 +33,15 @@
 {
   Property* prop = pset->get(name);
   if (!prop)
-    {
-      std::ostringstream str;
-      str << "Properties: " << pset->get_name() << ": property " << name << " not found";
-      throw std::runtime_error(str.str());
-    }
+  {
+    std::ostringstream str;
+    str << "Properties: " << pset->get_name() << ": property " << name << " not found";
+    throw std::runtime_error(str.str());
+  }
   else
-    {
-      return *prop;
-    }
+  {
+    return *prop;
+  }
 }
 
 int

Modified: trunk/windstille/src/properties/property_set.cpp
===================================================================
--- trunk/windstille/src/properties/property_set.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/properties/property_set.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -21,19 +21,19 @@
 
 #include "properties/property_set.hpp"
 
-PropertySet::PropertySet(const std::string& name_, PropertySet* parent_)
-  : parent(parent_),
-    name(name_),
-    properties()
+PropertySet::PropertySet(const std::string& name_, PropertySet* parent_) :
+  parent(parent_),
+  name(name_),
+  properties()
 {  
 }
 
 PropertySet::~PropertySet()
 {
   for(std::map<std::string, Property*>::iterator i = properties.begin(); i != properties.end(); ++i)
-    {
-      delete i->second;
-    }
+  {
+    delete i->second;
+  }
 }
   
 void
@@ -41,15 +41,15 @@
 {
   Property*& i = properties[name_];
   if (i)
-    {
-      std::ostringstream str;
-      str << "PropertySet::add: Name conflict: '" << name_ << "' already used";
-      throw std::runtime_error(str.str());
-    }
+  {
+    std::ostringstream str;
+    str << "PropertySet::add: Name conflict: '" << name_ << "' already used";
+    throw std::runtime_error(str.str());
+  }
   else
-    {
-      i = property;
-    }
+  {
+    i = property;
+  }
 }
 
 Property*
@@ -57,16 +57,16 @@
 {
   std::map<std::string, Property*>::const_iterator i = properties.find(name_);
   if (i == properties.end())
-    {
-      if (parent)
-        return parent->get(name_);
-      else
-        return 0;
-    }
+  {
+    if (parent)
+      return parent->get(name_);
+    else
+      return 0;
+  }
   else
-    {
-      return i->second;
-    }
+  {
+    return i->second;
+  }
 }
 
 void
@@ -76,9 +76,9 @@
     parent->get_properties(lst);
   
   for(std::map<std::string, Property*>::const_iterator i = properties.begin(); i != properties.end(); ++i)
-    {
-      lst.push_back(i->first);
-    }
+  {
+    lst.push_back(i->first);
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/scenegraph/control_drawable.hpp
===================================================================
--- trunk/windstille/src/scenegraph/control_drawable.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/scenegraph/control_drawable.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -27,7 +27,7 @@
 
 public:
   ControlDrawable(Surface surface_, const Vector2f& pos_, float angle_, float z_pos_,
-                        const Matrix& modelview_)
+                  const Matrix& modelview_)
     : Drawable(pos_, z_pos_, modelview_), 
       surface(surface_), 
       angle(angle_)

Modified: trunk/windstille/src/scenegraph/shockwave_drawable.hpp
===================================================================
--- trunk/windstille/src/scenegraph/shockwave_drawable.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/scenegraph/shockwave_drawable.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -29,10 +29,10 @@
   float radius;
 
   ShockwaveDrawable(const Vector2f& pos_, 
-                          const Texture&       noise_,
-                          const ShaderProgram& shader_program_,
-                          float r,
-                          const Matrix& modelview_) 
+                    const Texture&       noise_,
+                    const ShaderProgram& shader_program_,
+                    float r,
+                    const Matrix& modelview_) 
     : Drawable(pos_, 500.0f, modelview_),
       noise(noise_),
       shader_program(shader_program_),
@@ -85,32 +85,32 @@
   
     glBegin(GL_QUADS);
     for (int i = 0; i < segments; ++i)
-      {
-        float angel = 2.0f * math::pi / static_cast<float>(segments);
+    {
+      float angel = 2.0f * math::pi / static_cast<float>(segments);
 
-        float x1 =  sinf(angel*static_cast<float>(i))*rad;
-        float y1 = -cosf(angel*static_cast<float>(i))*rad;
+      float x1 =  sinf(angel*static_cast<float>(i))*rad;
+      float y1 = -cosf(angel*static_cast<float>(i))*rad;
 
-        float x2 =  sinf(angel*(static_cast<float>(i)+1))*rad;
-        float y2 = -cosf(angel*(static_cast<float>(i)+1))*rad;
+      float x2 =  sinf(angel*(static_cast<float>(i)+1))*rad;
+      float y2 = -cosf(angel*(static_cast<float>(i)+1))*rad;
 
-        glTexCoord2f(x1+256, (y1+256));
-        glVertex3f(x1+256, y1+256, 0);
+      glTexCoord2f(x1+256, (y1+256));
+      glVertex3f(x1+256, y1+256, 0);
 
-        glTexCoord2f(x2+256, (y2+256));
-        glVertex3f(x2+256, y2+256, 0);
+      glTexCoord2f(x2+256, (y2+256));
+      glVertex3f(x2+256, y2+256, 0);
 
-        float x3 =  sinf(angel*static_cast<float>(i))*minradius;
-        float y3 = -cosf(angel*static_cast<float>(i))*minradius;
+      float x3 =  sinf(angel*static_cast<float>(i))*minradius;
+      float y3 = -cosf(angel*static_cast<float>(i))*minradius;
 
-        float x4 =  sinf(angel*(static_cast<float>(i)+1))*minradius;
-        float y4 = -cosf(angel*(static_cast<float>(i)+1))*minradius;
+      float x4 =  sinf(angel*(static_cast<float>(i)+1))*minradius;
+      float y4 = -cosf(angel*(static_cast<float>(i)+1))*minradius;
 
-        glTexCoord2f(x4+256, (y4+256));
-        glVertex3f(x4+256, y4+256, 0);
-        glTexCoord2f(x3+256, (y3+256));
-        glVertex3f(x3+256, y3+256, 0);
-      }
+      glTexCoord2f(x4+256, (y4+256));
+      glVertex3f(x4+256, y4+256, 0);
+      glTexCoord2f(x3+256, (y3+256));
+      glVertex3f(x3+256, y3+256, 0);
+    }
     glEnd();
 
     glMatrixMode(GL_TEXTURE);
@@ -128,45 +128,45 @@
     glMultMatrixf(modelview.matrix);
     glTranslatef(pos.x, pos.y, 0);
     if (0)
-      {
-        Rectf rect(0, 0, 800, 600);
-        // Render the screen framebuffer to the actual screen 
-        OpenGLState state;
-        state.bind_texture(tmp_texture, 0);
-        state.activate();
+    {
+      Rectf rect(0, 0, 800, 600);
+      // Render the screen framebuffer to the actual screen 
+      OpenGLState state;
+      state.bind_texture(tmp_texture, 0);
+      state.activate();
 
-        glBegin(GL_QUADS);
+      glBegin(GL_QUADS);
     
-        glTexCoord2f(rect.left, rect.bottom);
-        glVertex2f(rect.left/2.0f, rect.bottom/2.0f);
+      glTexCoord2f(rect.left, rect.bottom);
+      glVertex2f(rect.left/2.0f, rect.bottom/2.0f);
 
-        glTexCoord2f(rect.right, rect.bottom);
-        glVertex2f(rect.right/2.0f, rect.bottom/2.0f);
+      glTexCoord2f(rect.right, rect.bottom);
+      glVertex2f(rect.right/2.0f, rect.bottom/2.0f);
 
-        glTexCoord2f(rect.right, rect.top);
-        glVertex2f(rect.right/2.0f, rect.top/2.0f);
+      glTexCoord2f(rect.right, rect.top);
+      glVertex2f(rect.right/2.0f, rect.top/2.0f);
 
-        glTexCoord2f(rect.left, rect.top);
-        glVertex2f(rect.left/2.0f, rect.top/2.0f);
+      glTexCoord2f(rect.left, rect.top);
+      glVertex2f(rect.left/2.0f, rect.top/2.0f);
     
-        glEnd();
-      }
+      glEnd();
+    }
     else
-      {
-        OpenGLState state;
-        state.bind_texture(tmp_texture, 0);
-        state.bind_texture(noise, 1);
-        state.enable(GL_BLEND);
-        state.set_blend_func(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-        state.activate();
+    {
+      OpenGLState state;
+      state.bind_texture(tmp_texture, 0);
+      state.bind_texture(noise, 1);
+      state.enable(GL_BLEND);
+      state.set_blend_func(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+      state.activate();
 
-        glUseProgram(shader_program.get_handle());    
-        shader_program.set_uniform1f("radius",   radius/512.0f*2.0f);
-        shader_program.set_uniform1i("background_tex", 0);
-        shader_program.set_uniform1i("noise_tex",   1);
-        draw_disc(int(radius));
-        glUseProgram(0);
-      }
+      glUseProgram(shader_program.get_handle());    
+      shader_program.set_uniform1f("radius",   radius/512.0f*2.0f);
+      shader_program.set_uniform1i("background_tex", 0);
+      shader_program.set_uniform1i("noise_tex",   1);
+      draw_disc(int(radius));
+      glUseProgram(0);
+    }
     glPopMatrix();
 #endif
   }
@@ -182,34 +182,34 @@
   
     glBegin(GL_QUADS);
     for (int i = 0; i < segments; ++i)
-      {
-        float angel = 2.0f * math::pi / static_cast<float>(segments);
+    {
+      float angel = 2.0f * math::pi / static_cast<float>(segments);
 
-        float x1 =  sinf(angel*static_cast<float>(i))*rad;
-        float y1 = -cosf(angel*static_cast<float>(i))*rad;
+      float x1 =  sinf(angel*static_cast<float>(i))*rad;
+      float y1 = -cosf(angel*static_cast<float>(i))*rad;
 
-        float x2 =  sinf(angel*(static_cast<float>(i)+1))*rad;
-        float y2 = -cosf(angel*(static_cast<float>(i)+1))*rad;
+      float x2 =  sinf(angel*(static_cast<float>(i)+1))*rad;
+      float y2 = -cosf(angel*(static_cast<float>(i)+1))*rad;
 
-        glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
-        glTexCoord2f(x1/512.0f+0.5f, y1/512.0f+0.5f);
-        glVertex3f(x1+256, y1+256, 0);
+      glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
+      glTexCoord2f(x1/512.0f+0.5f, y1/512.0f+0.5f);
+      glVertex3f(x1+256, y1+256, 0);
 
-        glTexCoord2f(x2/512.0f+0.5f, y2/512.0f+0.5f);
-        glVertex3f(x2+256, y2+256, 0);
+      glTexCoord2f(x2/512.0f+0.5f, y2/512.0f+0.5f);
+      glVertex3f(x2+256, y2+256, 0);
 
-        float x3 =  sinf(angel*static_cast<float>(i))*minradius;
-        float y3 = -cosf(angel*static_cast<float>(i))*minradius;
+      float x3 =  sinf(angel*static_cast<float>(i))*minradius;
+      float y3 = -cosf(angel*static_cast<float>(i))*minradius;
 
-        float x4 =  sinf(angel*(static_cast<float>(i)+1))*minradius;
-        float y4 = -cosf(angel*(static_cast<float>(i)+1))*minradius;
+      float x4 =  sinf(angel*(static_cast<float>(i)+1))*minradius;
+      float y4 = -cosf(angel*(static_cast<float>(i)+1))*minradius;
 
-        glColor4f(1.0f, 1.0f, 1.0f, 0.0f);
-        glTexCoord2f(x4/512.0f+0.5f, y4/512.0f+0.5f);
-        glVertex3f(x4+256, y4+256, 0);
-        glTexCoord2f(x3/512.0f+0.5f, y3/512.0f+0.5f);
-        glVertex3f(x3+256, y3+256, 0);
-      }
+      glColor4f(1.0f, 1.0f, 1.0f, 0.0f);
+      glTexCoord2f(x4/512.0f+0.5f, y4/512.0f+0.5f);
+      glVertex3f(x4+256, y4+256, 0);
+      glTexCoord2f(x3/512.0f+0.5f, y3/512.0f+0.5f);
+      glVertex3f(x3+256, y3+256, 0);
+    }
     glEnd();
   }
 };

Modified: trunk/windstille/src/screen/armature_test.cpp
===================================================================
--- trunk/windstille/src/screen/armature_test.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/screen/armature_test.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -107,38 +107,38 @@
 
   if (controller.button_was_pressed(ESCAPE_BUTTON) ||
       controller.button_was_pressed(PAUSE_BUTTON))
-    {
-      ScreenManager::current()->pop_screen();
-    }
+  {
+    ScreenManager::current()->pop_screen();
+  }
 
   if (controller.button_was_pressed(PRIMARY_BUTTON))
-    {
-      xrot = 90;
-      yrot = 0;
-      zrot = 0;
-    }
+  {
+    xrot = 90;
+    yrot = 0;
+    zrot = 0;
+  }
   else if (controller.button_was_pressed(SECONDARY_BUTTON))
-      {
-      xrot = 0;
-      yrot = 90;
-      zrot = 0;
-      }
+  {
+    xrot = 0;
+    yrot = 90;
+    zrot = 0;
+  }
   else if (controller.button_was_pressed(TERTIARY_BUTTON))
-    {
-      xrot = 0;
-      yrot = 0;
-      zrot = 90;
-    }
+  {
+    xrot = 0;
+    yrot = 0;
+    zrot = 90;
+  }
   else
-    { 
-      yrot += controller.get_axis_state(X_AXIS) * 90 * delta;
-      xrot += controller.get_axis_state(Y_AXIS) * 90 * delta;
-      zrot += controller.get_axis_state(X2_AXIS) * 90 * delta;
-    }
+  { 
+    yrot += controller.get_axis_state(X_AXIS) * 90 * delta;
+    xrot += controller.get_axis_state(Y_AXIS) * 90 * delta;
+    zrot += controller.get_axis_state(X2_AXIS) * 90 * delta;
+  }
 
   if (controller.button_was_pressed(AIM_BUTTON))
-    {
-    }
+  {
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/screen/game_session.cpp
===================================================================
--- trunk/windstille/src/screen/game_session.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/screen/game_session.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -148,33 +148,33 @@
   compositor.render(sc, &sector->get_scene_graph(), view.get_gc_state());
 
   if (cutscene_mode || cutscene_value > 0.0f)
-    {
-      int border_size = static_cast<int>(75 * cutscene_value);
-      Display::fill_rect(Rect(Point(0, 0), Size(Display::get_width(), border_size)), 
-                         Color(0.0f, 0.0f, 0.0f, cutscene_value));
-      Display::fill_rect(Rect(Point(0, Display::get_height() - border_size), Size(Display::get_width(), border_size)), 
-                         Color(0.0f, 0.0f, 0.0f, cutscene_value));
-    }
+  {
+    int border_size = static_cast<int>(75 * cutscene_value);
+    Display::fill_rect(Rect(Point(0, 0), Size(Display::get_width(), border_size)), 
+                       Color(0.0f, 0.0f, 0.0f, cutscene_value));
+    Display::fill_rect(Rect(Point(0, Display::get_height() - border_size), Size(Display::get_width(), border_size)), 
+                       Color(0.0f, 0.0f, 0.0f, cutscene_value));
+  }
 
   if (current_gui)
     current_gui->draw();
 
   if (fade_state == FADEOUT || fade_state == FADEIN)
-    {
-      Display::fill_rect(Rect(0, 0, 
-                              Display::get_width(), Display::get_height()),
-                         Color(fade_color.r, fade_color.g, fade_color.b, fadeout_value));
-    }
+  {
+    Display::fill_rect(Rect(0, 0, 
+                            Display::get_width(), Display::get_height()),
+                       Color(fade_color.r, fade_color.g, fade_color.b, fadeout_value));
+  }
 
   speech_manager.draw();
 
   if (pause)
-    {
-      if ((SDL_GetTicks() / 1000) % 2)
-        Fonts::current()->vera20->draw(Vector2f(static_cast<float>(Display::get_width())  / 2.0f,
-                                                static_cast<float>(Display::get_height()) / 2.0f), 
-                                       "Pause");
-    }
+  {
+    if ((SDL_GetTicks() / 1000) % 2)
+      Fonts::current()->vera20->draw(Vector2f(static_cast<float>(Display::get_width())  / 2.0f,
+                                              static_cast<float>(Display::get_height()) / 2.0f), 
+                                     "Pause");
+  }
 }
 
 void
@@ -220,49 +220,49 @@
   speech_manager.update(delta);
   
   switch (fade_state)
-    {
-      case FADEIN:
-        if (fadeout_value <= 0.0f)
-          {
-            fade_state = RUNNING;
-            fadeout_value = 0.0f;
-            ScriptManager::current()->fire_wakeup_event(ScriptManager::FADE_DONE);
-          }
-        else
-          {
-            fadeout_value -= delta * fade_time;
-          }
-        break;
+  {
+    case FADEIN:
+      if (fadeout_value <= 0.0f)
+      {
+        fade_state = RUNNING;
+        fadeout_value = 0.0f;
+        ScriptManager::current()->fire_wakeup_event(ScriptManager::FADE_DONE);
+      }
+      else
+      {
+        fadeout_value -= delta * fade_time;
+      }
+      break;
 
-      case FADEOUT:
-        if (fadeout_value >= 1.0f)
-          { 
-            fadeout_value = 1.0f;
-            ScriptManager::current()->fire_wakeup_event(ScriptManager::FADE_DONE);
+    case FADEOUT:
+      if (fadeout_value >= 1.0f)
+      { 
+        fadeout_value = 1.0f;
+        ScriptManager::current()->fire_wakeup_event(ScriptManager::FADE_DONE);
 
-            switch(next_action)
-              {
-                case CHANGE_SECTOR_ACTION:
-                  GameSession::current()->set_sector(filename);
-                  break;
+        switch(next_action)
+        {
+          case CHANGE_SECTOR_ACTION:
+            GameSession::current()->set_sector(filename);
+            break;
 
-                case QUIT_ACTION:
-                  ScreenManager::current()->quit();
-                  break;
+          case QUIT_ACTION:
+            ScreenManager::current()->quit();
+            break;
 
-                default:
-                  break;
-              }
-          }
-        else
-          {
-            fadeout_value += delta * fade_time;
-          }
-        break;
+          default:
+            break;
+        }
+      }
+      else
+      {
+        fadeout_value += delta * fade_time;
+      }
+      break;
 
-      case RUNNING:
-        break;
-    }
+    case RUNNING:
+      break;
+  }
 }
 
 void
@@ -270,43 +270,43 @@
 { 
   // Handle key presses
   if (controller.button_was_pressed(PDA_BUTTON))
-    {
-      if (current_gui == &pda)
-        current_gui = 0;
-      else
-        current_gui = &pda;
-    }
+  {
+    if (current_gui == &pda)
+      current_gui = 0;
+    else
+      current_gui = &pda;
+  }
   else if (controller.button_was_pressed(INVENTORY_BUTTON))
-    {
-      if (current_gui == &inventory)
-        current_gui = 0;
-      else
-        current_gui = &inventory;
-    }
+  {
+    if (current_gui == &inventory)
+      current_gui = 0;
+    else
+      current_gui = &inventory;
+  }
   else if (controller.button_was_pressed(ESCAPE_BUTTON) ||
            controller.button_was_pressed(PAUSE_BUTTON))
-    {
-      MenuManager::display_pause_menu();
-    }
+  {
+    MenuManager::display_pause_menu();
+  }
   else
+  {
+    if (!current_gui)
     {
-      if (!current_gui)
-      {
-        if (Player::current())
-          Player::current()->update(controller, delta);
-        else if (Doll::current())
-          Doll::current()->update(controller, delta);
-      }
+      if (Player::current())
+        Player::current()->update(controller, delta);
+      else if (Doll::current())
+        Doll::current()->update(controller, delta);
     }
+  }
 
   if (current_gui)
-    {
-      current_gui->update(delta, controller);
-    }
+  {
+    current_gui->update(delta, controller);
+  }
   else
-    {
-      // FIXME: route controller to player
-    }
+  {
+    // FIXME: route controller to player
+  }
 }
 
 void
@@ -318,9 +318,9 @@
 
   // Update the game
   if (!pause)
-    {
-      update_game(delta);
-    }
+  {
+    update_game(delta);
+  }
   
   update_controller(delta, controller);
 }
@@ -333,15 +333,15 @@
   SoundManager::current()->stop_music();
 
   if (impl->fade_state == GameSessionImpl::FADEOUT)
-    {
-      GameSession::current()->set_sector(impl->filename);
-    }
+  {
+    GameSession::current()->set_sector(impl->filename);
+  }
   else
-    {
-      impl->fade_time     = 1.0f;
-      impl->fade_state    = GameSessionImpl::FADEOUT;
-      impl->next_action   = GameSessionImpl::CHANGE_SECTOR_ACTION;
-    }
+  {
+    impl->fade_time     = 1.0f;
+    impl->fade_state    = GameSessionImpl::FADEOUT;
+    impl->next_action   = GameSessionImpl::CHANGE_SECTOR_ACTION;
+  }
 }
 
 void
@@ -356,72 +356,72 @@
 GameSessionImpl::handle_event(const SDL_Event& event)
 {
   switch(event.type)
-    {
-      case SDL_KEYDOWN:
-      case SDL_KEYUP:
-        if (event.key.state)
-          {    
-            switch (event.key.keysym.sym)
-              {
-                case SDLK_1:
-                  sc.set_render_mask(sc.get_render_mask() ^ SceneContext::COLORMAP);
-                  ConsoleLog << "Toggled COLORMAP: " << ((sc.get_render_mask() & SceneContext::COLORMAP) > 0) << std::endl;
-                  break;
+  {
+    case SDL_KEYDOWN:
+    case SDL_KEYUP:
+      if (event.key.state)
+      {    
+        switch (event.key.keysym.sym)
+        {
+          case SDLK_1:
+            sc.set_render_mask(sc.get_render_mask() ^ SceneContext::COLORMAP);
+            ConsoleLog << "Toggled COLORMAP: " << ((sc.get_render_mask() & SceneContext::COLORMAP) > 0) << std::endl;
+            break;
 
-                case SDLK_2:
-                  sc.set_render_mask(sc.get_render_mask() ^ SceneContext::LIGHTMAP);
-                  ConsoleLog << "Toggled LIGHTMAP: " << ((sc.get_render_mask() & SceneContext::LIGHTMAP) > 0) << std::endl;
-                  break;
+          case SDLK_2:
+            sc.set_render_mask(sc.get_render_mask() ^ SceneContext::LIGHTMAP);
+            ConsoleLog << "Toggled LIGHTMAP: " << ((sc.get_render_mask() & SceneContext::LIGHTMAP) > 0) << std::endl;
+            break;
       
-                case SDLK_3:
-                  sc.set_render_mask(sc.get_render_mask() ^ SceneContext::HIGHLIGHTMAP);
-                  ConsoleLog << "Toggled HIGHLIGHTMAP: " << ((sc.get_render_mask() & SceneContext::HIGHLIGHTMAP) > 0) << std::endl;
-                  break;      
+          case SDLK_3:
+            sc.set_render_mask(sc.get_render_mask() ^ SceneContext::HIGHLIGHTMAP);
+            ConsoleLog << "Toggled HIGHLIGHTMAP: " << ((sc.get_render_mask() & SceneContext::HIGHLIGHTMAP) > 0) << std::endl;
+            break;      
 
-                case SDLK_4:
-                  sc.set_render_mask(sc.get_render_mask() ^ SceneContext::CONTROLMAP);
-                  ConsoleLog << "Toggled CONTROLMAP: " << ((sc.get_render_mask() & SceneContext::CONTROLMAP) > 0) << std::endl;
-                  break;
+          case SDLK_4:
+            sc.set_render_mask(sc.get_render_mask() ^ SceneContext::CONTROLMAP);
+            ConsoleLog << "Toggled CONTROLMAP: " << ((sc.get_render_mask() & SceneContext::CONTROLMAP) > 0) << std::endl;
+            break;
   
-                case SDLK_5:
-                  sc.set_render_mask(sc.get_render_mask() ^ SceneContext::LIGHTMAPSCREEN);
-                  ConsoleLog << "Toggled LIGHTMAP: " << ((sc.get_render_mask() & SceneContext::LIGHTMAPSCREEN) > 0) << std::endl;
-                  break;
+          case SDLK_5:
+            sc.set_render_mask(sc.get_render_mask() ^ SceneContext::LIGHTMAPSCREEN);
+            ConsoleLog << "Toggled LIGHTMAP: " << ((sc.get_render_mask() & SceneContext::LIGHTMAPSCREEN) > 0) << std::endl;
+            break;
 
-                case SDLK_c:
-                  collision_debug = !collision_debug;
-                  ConsoleLog << "Collision Debugging " << (collision_debug ? "enabled" : "disabled") << std::endl;
-                  break;
+          case SDLK_c:
+            collision_debug = !collision_debug;
+            ConsoleLog << "Collision Debugging " << (collision_debug ? "enabled" : "disabled") << std::endl;
+            break;
 
-                case SDLK_F2:
-                  MenuManager::display_debug_menu();
-                  break;
+          case SDLK_F2:
+            MenuManager::display_debug_menu();
+            break;
         
-                default:
-                  break;
-              }
-          }
-        break;
+          default:
+            break;
+        }
+      }
+      break;
         
-      case SDL_MOUSEBUTTONDOWN:
-        {
-          Vector2f real_pos = view.screen_to_world(Vector2f(event.button.x, event.button.y));
-          ConsoleLog << "Click at: " << int(real_pos.x) << ", " << int(real_pos.y) << std::endl;
-        }
-        break;
+    case SDL_MOUSEBUTTONDOWN:
+    {
+      Vector2f real_pos = view.screen_to_world(Vector2f(event.button.x, event.button.y));
+      ConsoleLog << "Click at: " << int(real_pos.x) << ", " << int(real_pos.y) << std::endl;
     }
+    break;
+  }
 }
 
 void
 GameSession::quit()
 {
   if (impl->fade_state != GameSessionImpl::FADEOUT)
-    {
-      SoundManager::current()->stop_music();
-      impl->fade_state  = GameSessionImpl::FADEOUT;
-      impl->fade_time   = 1.0f;
-      impl->next_action = GameSessionImpl::QUIT_ACTION;
-    }
+  {
+    SoundManager::current()->stop_music();
+    impl->fade_state  = GameSessionImpl::FADEOUT;
+    impl->fade_time   = 1.0f;
+    impl->next_action = GameSessionImpl::QUIT_ACTION;
+  }
 }
 
 PDA&
@@ -458,19 +458,19 @@
 GameSession::set_control_state(ControlState state) 
 {
   switch(state)
-    {
-      case DIALOG:
-        impl->current_gui = &impl->dialog_manager;
-        break;
+  {
+    case DIALOG:
+      impl->current_gui = &impl->dialog_manager;
+      break;
 
-      case CONVERSATION:
-        impl->current_gui = &impl->conversation;
-        break;
+    case CONVERSATION:
+      impl->current_gui = &impl->conversation;
+      break;
 
-      case GAME:
-        impl->current_gui = 0;
-        break;
-    }
+    case GAME:
+      impl->current_gui = 0;
+      break;
+  }
 }
 
 bool
@@ -483,28 +483,28 @@
 GameSession::set_cutscene_mode(bool t)
 {
   if (t != impl->cutscene_mode)
-    {
-      impl->cutscene_mode  = t;
-    }
+  {
+    impl->cutscene_mode  = t;
+  }
 }
 
 void
 GameSession::fadeout(float time, const Color& color)
 {
   if (time == 0.0)
-    { // directly go to a state of solid color, no fading
-      impl->fadeout_value  = 1.0f;
-      impl->fade_color  = color;
-      impl->fade_state  = GameSessionImpl::FADEOUT;
-      impl->next_action = GameSessionImpl::NO_ACTION;
-    }
+  { // directly go to a state of solid color, no fading
+    impl->fadeout_value  = 1.0f;
+    impl->fade_color  = color;
+    impl->fade_state  = GameSessionImpl::FADEOUT;
+    impl->next_action = GameSessionImpl::NO_ACTION;
+  }
   else
-    {
-      impl->fade_time   = 1.0f/time;
-      impl->fade_color  = color;
-      impl->fade_state  = GameSessionImpl::FADEOUT;
-      impl->next_action = GameSessionImpl::NO_ACTION;
-    }
+  {
+    impl->fade_time   = 1.0f/time;
+    impl->fade_color  = color;
+    impl->fade_state  = GameSessionImpl::FADEOUT;
+    impl->next_action = GameSessionImpl::NO_ACTION;
+  }
 }
 
 void

Modified: trunk/windstille/src/screen/geometry_test.cpp
===================================================================
--- trunk/windstille/src/screen/geometry_test.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/screen/geometry_test.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -72,9 +72,9 @@
 {
   if (controller.button_was_pressed(ESCAPE_BUTTON) ||
       controller.button_was_pressed(PAUSE_BUTTON))
-    {
-      MenuManager::display_pause_menu();
-    }
+  {
+    MenuManager::display_pause_menu();
+  }
 
   cursor.x += controller.get_axis_state(X_AXIS) * 500.0f * delta;
   cursor.y += controller.get_axis_state(Y_AXIS) * 500.0f * delta;
@@ -83,44 +83,44 @@
   cursor2.y += controller.get_axis_state(Y2_AXIS) * 500.0f * delta;
 
   if (controller.button_was_pressed(PRIMARY_BUTTON))
-    {
-      if (point_count == 0) {
-        cursor  = line2.p1;
-        cursor2 = line2.p2;
-      } else {
-        cursor  = line1.p1;
-        cursor2 = line1.p2;
-      }
-
-      point_count += 1;
-      if (point_count > 1)
-        point_count = 0;
+  {
+    if (point_count == 0) {
+      cursor  = line2.p1;
+      cursor2 = line2.p2;
+    } else {
+      cursor  = line1.p1;
+      cursor2 = line1.p2;
     }
 
+    point_count += 1;
+    if (point_count > 1)
+      point_count = 0;
+  }
+
   if (point_count == 0)
-    {
-      line1.p1 = cursor;
-      line1.p2 = cursor2;
-    }
+  {
+    line1.p1 = cursor;
+    line1.p2 = cursor2;
+  }
   else if (point_count == 1)
-    {
-      line2.p1 = cursor;
-      line2.p2 = cursor2;
-    }
+  {
+    line2.p1 = cursor;
+    line2.p2 = cursor2;
+  }
 
   if (line1.intersect(line2, collision_point))
-    {
-      if (!had_prev_collision)
-        ConsoleLog << "Collision" << std::endl;
-      had_prev_collision = true;
-    }
+  {
+    if (!had_prev_collision)
+      ConsoleLog << "Collision" << std::endl;
+    had_prev_collision = true;
+  }
   else
-    {
-      if (had_prev_collision)
-        ConsoleLog << "No Collision" << std::endl;
-      had_prev_collision = false;
-      collision_point = Vector2f(32, 32);
-    }
+  {
+    if (had_prev_collision)
+      ConsoleLog << "No Collision" << std::endl;
+    had_prev_collision = false;
+    collision_point = Vector2f(32, 32);
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/screen/navigation_test.cpp
===================================================================
--- trunk/windstille/src/screen/navigation_test.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/screen/navigation_test.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -71,16 +71,16 @@
 
   std::vector<NodeHandle> nodes = graph->find_nodes(cursor, 128.0f);
   for(std::vector<NodeHandle>::iterator i = nodes.begin(); i != nodes.end(); ++i)
-    {
-      Display::draw_circle((*i)->get_pos(), 12.0f, Color(1.0f, 1.0f, 1.0f, 0.5f));
-    }
+  {
+    Display::draw_circle((*i)->get_pos(), 12.0f, Color(1.0f, 1.0f, 1.0f, 0.5f));
+  }
 
   if (node_to_connect)
-    {
-      Display::fill_rect(Rectf(node_to_connect->get_pos() - Vector2f(2,2), Sizef(5,5)),  
-                         Color(1.0f, 1.0f, 1.0f));
-      Display::draw_line(node_to_connect->get_pos(), cursor, Color(1.0f, 1.0f, 1.0f, 0.5f));
-    }
+  {
+    Display::fill_rect(Rectf(node_to_connect->get_pos() - Vector2f(2,2), Sizef(5,5)),  
+                       Color(1.0f, 1.0f, 1.0f));
+    Display::draw_line(node_to_connect->get_pos(), cursor, Color(1.0f, 1.0f, 1.0f, 0.5f));
+  }
 
   if (selected_node)
     Display::draw_circle(selected_node->get_pos(), 12.0f, Color(1.0f, 1.0f, 1.0f, 1.0f));
@@ -91,13 +91,13 @@
   Display::fill_circle(player, 12.0f, Color(0.0f, 0.0f, 1.0f, 1.0f));
 
   if (connection.get())
-    {
-      Display::fill_circle(connection->get_pos(), 16.0f, Color(0.0f, 0.0f, 1.0f, 0.5f));
-      Display::fill_circle(connection->get_pos(), 8.0f, Color(0.0f, 1.0f, 1.0f));
+  {
+    Display::fill_circle(connection->get_pos(), 16.0f, Color(0.0f, 0.0f, 1.0f, 0.5f));
+    Display::fill_circle(connection->get_pos(), 8.0f, Color(0.0f, 1.0f, 1.0f));
      
-      Display::draw_line(connection->get_pos(), connection->get_pos() + 100.0f*stick,
-                         Color(1.0f, 1.0f, 1.0f, 1.0f));
-    }
+    Display::draw_line(connection->get_pos(), connection->get_pos() + 100.0f*stick,
+                       Color(1.0f, 1.0f, 1.0f, 1.0f));
+  }
 }
 
 void
@@ -105,9 +105,9 @@
 {
   if (controller.button_was_pressed(ESCAPE_BUTTON) ||
       controller.button_was_pressed(PAUSE_BUTTON))
-    {
-      MenuManager::display_pause_menu();
-    }
+  {
+    MenuManager::display_pause_menu();
+  }
 
   cursor += Vector2f(controller.get_axis_state(X_AXIS) * 500.0f * delta,
                      controller.get_axis_state(Y_AXIS) * 500.0f * delta);
@@ -116,137 +116,137 @@
                    controller.get_axis_state(Y2_AXIS));
 
   if (controller.button_was_pressed(PRIMARY_BUTTON))
+  {
+    if (node_to_connect)
     {
-      if (node_to_connect)
-        {
-          if (selected_node)
-            graph->add_edge(node_to_connect, selected_node);
+      if (selected_node)
+        graph->add_edge(node_to_connect, selected_node);
           
-          node_to_connect = 0;
-        }
-      else if (selected_node)
-        {
-          node_to_connect = selected_node;
-        }
-      else if (selected_edge)
-        {
-          graph->split_edge(selected_edge);
-          selected_edge = 0;
-        }
-      else
-        {
-          graph->add_node(cursor);
-        }
+      node_to_connect = 0;
     }
+    else if (selected_node)
+    {
+      node_to_connect = selected_node;
+    }
+    else if (selected_edge)
+    {
+      graph->split_edge(selected_edge);
+      selected_edge = 0;
+    }
+    else
+    {
+      graph->add_node(cursor);
+    }
+  }
 
   if (controller.get_button_state(TERTIARY_BUTTON))
-    { // Move node
-      if (selected_node)
-        {
-          selected_node->set_pos(cursor);
-        }
+  { // Move node
+    if (selected_node)
+    {
+      selected_node->set_pos(cursor);
     }
+  }
 
   if (controller.button_was_pressed(SECONDARY_BUTTON))
-    { // Set player
-      player = old_player = cursor;
-    }
+  { // Set player
+    player = old_player = cursor;
+  }
 
   if (connection.get())
-    { 
-      // Handle the movement of the connection
-      Node* next_node;
-      //float advance = 512.0f * controller.get_axis_state(X2_AXIS) * delta;
+  { 
+    // Handle the movement of the connection
+    Node* next_node;
+    //float advance = 512.0f * controller.get_axis_state(X2_AXIS) * delta;
       
-      Vector2f advance = delta * 512.0f * stick;
-      connection->advance(advance, next_node);
+    Vector2f advance = delta * 512.0f * stick;
+    connection->advance(advance, next_node);
 
-      player = connection->get_pos();
+    player = connection->get_pos();
       
-      if (!advance.is_null())
-        { // Not all advancement got used up, which means we have hit
-          // the end of a edge
+    if (!advance.is_null())
+    { // Not all advancement got used up, which means we have hit
+      // the end of a edge
 
-          // FIXME: This should be a while loop, currently we are just
-          // discarding the rest movement
+      // FIXME: This should be a while loop, currently we are just
+      // discarding the rest movement
 
-          EdgePosition next_edge;
-          float length = 0;
-          for(Node::Edges::iterator i = next_node->edges.begin(); i != next_node->edges.end(); ++i)
-            {
-              if (connection->get_edge() != i->edge)
-                { // Find out into the direction of which edge the stick is pointing
-                  Vector2f proj = stick.project(i->edge->get_vector());
+      EdgePosition next_edge;
+      float length = 0;
+      for(Node::Edges::iterator i = next_node->edges.begin(); i != next_node->edges.end(); ++i)
+      {
+        if (connection->get_edge() != i->edge)
+        { // Find out into the direction of which edge the stick is pointing
+          Vector2f proj = stick.project(i->edge->get_vector());
                   
-                  if (proj.length() > length)
-                    {
-                      next_edge = *i;
-                      length       = proj.length();
-                    }
-                }
-            }
+          if (proj.length() > length)
+          {
+            next_edge = *i;
+            length       = proj.length();
+          }
+        }
+      }
               
-          if (!next_edge.edge)
-            {
-              std::cout << "Dead End" << std::endl;
-              connection.reset();
+      if (!next_edge.edge)
+      {
+        std::cout << "Dead End" << std::endl;
+        connection.reset();
 
-              // FIXME: Voodoo to fix connection/deadend cicles
-              player += stick;
-              old_player = player;
-            }
-          else
-            {
-              std::cout << "transition" << std::endl;
-              *connection = next_edge;
-            }
-        }
+        // FIXME: Voodoo to fix connection/deadend cicles
+        player += stick;
+        old_player = player;
+      }
+      else
+      {
+        std::cout << "transition" << std::endl;
+        *connection = next_edge;
+      }
+    }
 
-      if (controller.get_button_state(AIM_BUTTON))
-        {         
-          connection.reset();
+    if (controller.get_button_state(AIM_BUTTON))
+    {         
+      connection.reset();
 
-          // FIXME: Voodoo to fix connection/dedaend cicles
-          player += stick;
-          old_player = player;
-        }
+      // FIXME: Voodoo to fix connection/dedaend cicles
+      player += stick;
+      old_player = player;
     }
+  }
   else
-    { // handle non connection based movement
-      player += Vector2f(0.0f, 100.0f) * delta;
+  { // handle non connection based movement
+    player += Vector2f(0.0f, 100.0f) * delta;
       
-      player.x += 512.0f * stick.x * delta;
+    player.x += 512.0f * stick.x * delta;
 
-      if (controller.get_button_state(AIM_BUTTON))
-        {
-          player.y -= 0.5f * 512.0f * delta;
-        }
+    if (controller.get_button_state(AIM_BUTTON))
+    {
+      player.y -= 0.5f * 512.0f * delta;
+    }
 
-      std::vector<EdgePosition> positions = graph->find_intersections(Line(old_player, player));
-      if (!positions.empty()) 
-        {
-          std::cout << "Doing connection" << std::endl;
-          connection.reset(new EdgePosition(positions.front()));
-        }
+    std::vector<EdgePosition> positions = graph->find_intersections(Line(old_player, player));
+    if (!positions.empty()) 
+    {
+      std::cout << "Doing connection" << std::endl;
+      connection.reset(new EdgePosition(positions.front()));
     }
+  }
   
   if (controller.button_was_pressed(SELECT_BUTTON))
-    {
-      graph->save(std::cout);
-    }
+  {
+    graph->save(std::cout);
+  }
 
   if (controller.button_was_pressed(QUATERNARY_BUTTON))
-    {
-      if (selected_node) {
-        graph->remove_node(selected_node);
-        selected_node = 0;
-      } 
+  {
+    if (selected_node) {
+      graph->remove_node(selected_node);
+      selected_node = 0;
+    } 
       
-      if (selected_edge) {
-        graph->remove_edge(selected_edge);
-        selected_edge = 0;
-      }      
-    }
+    if (selected_edge) {
+      graph->remove_edge(selected_edge);
+      selected_edge = 0;
+    }      
+  }
 
   selected_node = graph->find_closest_node(cursor, 32.0f);
   if (!selected_node)
@@ -255,9 +255,9 @@
     selected_edge = 0;
 
   if (connection.get() && !graph->valid(connection->get_edge()))
-    {
-      connection.reset();
-    }
+  {
+    connection.reset();
+  }
 
   old_player = player;
 }

Modified: trunk/windstille/src/screen/particle_viewer.cpp
===================================================================
--- trunk/windstille/src/screen/particle_viewer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/screen/particle_viewer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -116,9 +116,9 @@
 
   if (controller.button_was_pressed(PAUSE_BUTTON) ||
       controller.button_was_pressed(ESCAPE_BUTTON))
-    {
-      MenuManager::display_pause_menu();
-    }
+  {
+    MenuManager::display_pause_menu();
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/screen/screen_manager.cpp
===================================================================
--- trunk/windstille/src/screen/screen_manager.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/screen/screen_manager.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -120,7 +120,7 @@
     overlay_screens.back()->draw();
 
   if (show_controller_help_window)
-     controller_help_window->draw();
+    controller_help_window->draw();
 
   Console::current()->draw();
 
@@ -192,141 +192,141 @@
 {
   SDL_Event event;
   while(SDL_PollEvent(&event))
+  {
+    switch(event.type)
     {
-      switch(event.type)
-        {
-          case SDL_QUIT:
-            // FIXME: This should be a bit more gentle, but will do for now
-            std::cout << "Ctrl-c or Window-close pressed, game is going to quit" << std::endl;
-            quit();
-            break;
+      case SDL_QUIT:
+        // FIXME: This should be a bit more gentle, but will do for now
+        std::cout << "Ctrl-c or Window-close pressed, game is going to quit" << std::endl;
+        quit();
+        break;
           
-          case SDL_ACTIVEEVENT:
-            // event.active
-            break;
+      case SDL_ACTIVEEVENT:
+        // event.active
+        break;
           
-          case SDL_VIDEORESIZE:
-            // event.resize
-            break;
+      case SDL_VIDEORESIZE:
+        // event.resize
+        break;
               
-          case SDL_VIDEOEXPOSE:
-            // event.expose
-            break;
+      case SDL_VIDEOEXPOSE:
+        // event.expose
+        break;
                 
-          case SDL_USEREVENT:
-            // event.user
-            break;
+      case SDL_USEREVENT:
+        // event.user
+        break;
                     
-          case SDL_SYSWMEVENT:
-            // event.syswm
-            break;
+      case SDL_SYSWMEVENT:
+        // event.syswm
+        break;
 
-          case SDL_KEYDOWN:
-          case SDL_KEYUP:
-            if (event.key.state)
-              {    
-                switch (event.key.keysym.sym)
-                  {
-                    case SDLK_F6:
-                      SDL_ShowCursor(SDL_ENABLE);   // SDL_ENABLE to show the mouse cursor (default)
-                      SDL_WM_GrabInput(SDL_GRAB_OFF); // SDL_GRAB_OFF to not grab input (default)
-                      break;
+      case SDL_KEYDOWN:
+      case SDL_KEYUP:
+        if (event.key.state)
+        {    
+          switch (event.key.keysym.sym)
+          {
+            case SDLK_F6:
+              SDL_ShowCursor(SDL_ENABLE);   // SDL_ENABLE to show the mouse cursor (default)
+              SDL_WM_GrabInput(SDL_GRAB_OFF); // SDL_GRAB_OFF to not grab input (default)
+              break;
 
-                    case SDLK_F7:
-                      SDL_ShowCursor(SDL_DISABLE);   // SDL_ENABLE to show the mouse cursor (default)
-                      SDL_WM_GrabInput(SDL_GRAB_ON); // SDL_GRAB_OFF to not grab input (default)
-                      break;
+            case SDLK_F7:
+              SDL_ShowCursor(SDL_DISABLE);   // SDL_ENABLE to show the mouse cursor (default)
+              SDL_WM_GrabInput(SDL_GRAB_ON); // SDL_GRAB_OFF to not grab input (default)
+              break;
                   
-                    case SDLK_F8:
-                      show_controller_help_window = !show_controller_help_window;
-                      break;
+            case SDLK_F8:
+              show_controller_help_window = !show_controller_help_window;
+              break;
 
-                    case SDLK_F9:
-                      push_overlay(new InputConfigurator());
-                      break;
+            case SDLK_F9:
+              push_overlay(new InputConfigurator());
+              break;
 
-                    case SDLK_F10:
-                      config.set_bool("show-fps", !config.get_bool("show-fps"));
-                      break;
+            case SDLK_F10:
+              config.set_bool("show-fps", !config.get_bool("show-fps"));
+              break;
               
-                    case SDLK_F11:
-                      config.set_bool("fullscreen", !config.get_bool("fullscreen"));
-                      OpenGLWindow::current()->set_fullscreen(config.get_bool("fullscreen"));
-                      break;
+            case SDLK_F11:
+              config.set_bool("fullscreen", !config.get_bool("fullscreen"));
+              OpenGLWindow::current()->set_fullscreen(config.get_bool("fullscreen"));
+              break;
               
-                    case SDLK_F12:
-                      {
-                        // FIXME: Replace this with Physfs stuff
-                        int count = 0;
-                        Pathname filename;
-                        do {
-                          filename = Pathname((boost::format("screenshots/windstille%04d.png") % count).str(), Pathname::kUserPath);
-                          count += 1;
-                        } while(filename.exists());
+            case SDLK_F12:
+            {
+              // FIXME: Replace this with Physfs stuff
+              int count = 0;
+              Pathname filename;
+              do {
+                filename = Pathname((boost::format("screenshots/windstille%04d.png") % count).str(), Pathname::kUserPath);
+                count += 1;
+              } while(filename.exists());
 
-                        Display::save_screenshot(filename);
-                        ConsoleLog << "Writing screenshot to: '" << filename << "'" << std::endl;
-                      }
-                      break;
+              Display::save_screenshot(filename);
+              ConsoleLog << "Writing screenshot to: '" << filename << "'" << std::endl;
+            }
+            break;
               
-                    default:
-                      if (!Console::current()->is_active())
-                        {
-                          if (!overlay_screens.empty())
-                            overlay_screens.back()->handle_event(event);
-                          else if (!screens.empty())
-                            screens.back()->handle_event(event);
-                        }
-                      break;
-                  }
+            default:
+              if (!Console::current()->is_active())
+              {
+                if (!overlay_screens.empty())
+                  overlay_screens.back()->handle_event(event);
+                else if (!screens.empty())
+                  screens.back()->handle_event(event);
               }
+              break;
+          }
+        }
               
-            if (!Console::current()->is_active() && event.key.state && event.key.keysym.sym == SDLK_F1)
-              {
-                Console::current()->activate();
-              }
-            else
-              {
-                if (InputManagerSDL::current())
-                  InputManagerSDL::current()->on_event(event);
-              }
-            break;
+        if (!Console::current()->is_active() && event.key.state && event.key.keysym.sym == SDLK_F1)
+        {
+          Console::current()->activate();
+        }
+        else
+        {
+          if (InputManagerSDL::current())
+            InputManagerSDL::current()->on_event(event);
+        }
+        break;
 
-          case SDL_MOUSEBUTTONUP:
-          case SDL_MOUSEBUTTONDOWN:
-          case SDL_MOUSEMOTION:
-          case SDL_JOYAXISMOTION:
-          case SDL_JOYBALLMOTION:
-          case SDL_JOYHATMOTION:
-          case SDL_JOYBUTTONUP:
-          case SDL_JOYBUTTONDOWN:
-            if (InputManagerSDL::current())
-              InputManagerSDL::current()->on_event(event);
+      case SDL_MOUSEBUTTONUP:
+      case SDL_MOUSEBUTTONDOWN:
+      case SDL_MOUSEMOTION:
+      case SDL_JOYAXISMOTION:
+      case SDL_JOYBALLMOTION:
+      case SDL_JOYHATMOTION:
+      case SDL_JOYBUTTONUP:
+      case SDL_JOYBUTTONDOWN:
+        if (InputManagerSDL::current())
+          InputManagerSDL::current()->on_event(event);
 
-            if (!overlay_screens.empty())
-              overlay_screens.back()->handle_event(event);
-            break;
+        if (!overlay_screens.empty())
+          overlay_screens.back()->handle_event(event);
+        break;
         
-          default:
-            if (!overlay_screens.empty())
-              overlay_screens.back()->handle_event(event);
-            else if (!screens.empty())
-              screens.back()->handle_event(event);
-            break;
-        }
+      default:
+        if (!overlay_screens.empty())
+          overlay_screens.back()->handle_event(event);
+        else if (!screens.empty())
+          screens.back()->handle_event(event);
+        break;
     }
+  }
 }
 
 void 
 ScreenManager::draw_fps()
 {
   if(time_counter > 1) 
-    {
-      last_fps = int(static_cast<float>(frame_counter) / time_counter);
+  {
+    last_fps = int(static_cast<float>(frame_counter) / time_counter);
 
-      time_counter  = fmodf(static_cast<float>(time_counter), 1.0f);
-      frame_counter = 0;
-    }
+    time_counter  = fmodf(static_cast<float>(time_counter), 1.0f);
+    frame_counter = 0;
+  }
   
   std::ostringstream out;
   out << "FPS: " << last_fps;

Modified: trunk/windstille/src/screen/sprite2dview.cpp
===================================================================
--- trunk/windstille/src/screen/sprite2dview.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/screen/sprite2dview.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -120,122 +120,122 @@
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 
   switch(mode)
-    {
+  {
     case SLIDESHOW:
       if (aspect > 4.0/3.0)
-        {
-          sprite.draw(Vector2f(-offset, 0));
-        }
+      {
+        sprite.draw(Vector2f(-offset, 0));
+      }
       else
-        {
-          sprite.draw(Vector2f(0, -offset));
-        }
+      {
+        sprite.draw(Vector2f(0, -offset));
+      }
 
       if (new_sprite)
-        {
-          new_sprite.draw(Vector2f(0,0));
-        }
+      {
+        new_sprite.draw(Vector2f(0,0));
+      }
 
       if (show_thumbnail)
+      {
+        Sprite small = sprite;
+        small.set_alpha(1.0f);
+        float w  = small.get_width();
+        float h = small.get_height();
+        float s;
+        if (w > h)
         {
-          Sprite small = sprite;
-          small.set_alpha(1.0f);
-          float w  = small.get_width();
-          float h = small.get_height();
-          float s;
-          if (w > h)
-            {
-              s = 125.0f / w;
+          s = 125.0f / w;
 
-              w  *= s;
-              h *= s;
-              small.set_scale(s);
+          w  *= s;
+          h *= s;
+          small.set_scale(s);
 
-              small.draw(Vector2f(DISPLAY_W - w,
-                                  DISPLAY_H - h));
-            }
-          else
-            {
-              s = 125.0f / h;
+          small.draw(Vector2f(DISPLAY_W - w,
+                              DISPLAY_H - h));
+        }
+        else
+        {
+          s = 125.0f / h;
 
-              w  *= s;
-              h *= s;
-              small.set_scale(s);
+          w  *= s;
+          h *= s;
+          small.set_scale(s);
 
-              small.draw(Vector2f(DISPLAY_W - w,
-                                DISPLAY_H - h));
-            }
-        }        
+          small.draw(Vector2f(DISPLAY_W - w,
+                              DISPLAY_H - h));
+        }
+      }        
       break;
       
     case MANUAL:
       sprite.set_scale(zoom);
       sprite.draw(pos);
       break;
-    }
+  }
 }
 
 void
 Sprite2DView::update_slideshow(float delta, const Controller& controller)
 {
   if (!new_sprite)
-    {
-      width  = sprite.get_width();
-      height = sprite.get_height();
-      aspect = width/height;
+  {
+    width  = sprite.get_width();
+    height = sprite.get_height();
+    aspect = width/height;
 
-      if (aspect > 4.0/3.0)
-        { // expand vertical
-          float s = DISPLAY_H/height;
-          width  *= s;
-          height *= s;
-          sprite.set_scale(s);
+    if (aspect > 4.0/3.0)
+    { // expand vertical
+      float s = DISPLAY_H/height;
+      width  *= s;
+      height *= s;
+      sprite.set_scale(s);
 
-          if (offset - (width - DISPLAY_W) > 0)
-            {
-              offset = (width - DISPLAY_W);
+      if (offset - (width - DISPLAY_W) > 0)
+      {
+        offset = (width - DISPLAY_W);
 
-              if (auto_scroll && display_time > 3.0f)
-                next_image();
-            }
-          else
-            {
-              offset += delta * 50.0f + controller.get_axis_state(X_AXIS) * 200.0f * delta;
-            }
-
-          offset +=  controller.get_ball_state(MOUSE_MOTION_Y);
-        }
+        if (auto_scroll && display_time > 3.0f)
+          next_image();
+      }
       else
-        { // expand horizontal
-          float s = 800.0f/width;
-          width  *= s;
-          height *= s;
-          sprite.set_scale(s);
+      {
+        offset += delta * 50.0f + controller.get_axis_state(X_AXIS) * 200.0f * delta;
+      }
 
-          if (offset - (height - DISPLAY_H) > 0)
-            {
-              offset = (width - DISPLAY_H);
+      offset +=  controller.get_ball_state(MOUSE_MOTION_Y);
+    }
+    else
+    { // expand horizontal
+      float s = 800.0f/width;
+      width  *= s;
+      height *= s;
+      sprite.set_scale(s);
 
-              if (auto_scroll && display_time > 3.0f)
-                next_image();
-            }
-          else
-            {
-              offset += delta * 50.0f +   controller.get_axis_state(X_AXIS) * 200.0f * delta;
-            }
+      if (offset - (height - DISPLAY_H) > 0)
+      {
+        offset = (width - DISPLAY_H);
 
-          offset += controller.get_ball_state(MOUSE_MOTION_Y);
-        }
+        if (auto_scroll && display_time > 3.0f)
+          next_image();
+      }
+      else
+      {
+        offset += delta * 50.0f +   controller.get_axis_state(X_AXIS) * 200.0f * delta;
+      }
+
+      offset += controller.get_ball_state(MOUSE_MOTION_Y);
     }
+  }
 
   if (controller.button_was_pressed(PRIMARY_BUTTON))
-    {
-      next_image();
-    }
+  {
+    next_image();
+  }
   else if (controller.button_was_pressed(SECONDARY_BUTTON))
-    {
-      prev_image();
-    }
+  {
+    prev_image();
+  }
 }
 
 void
@@ -300,19 +300,19 @@
   float a = w/h;
 
   if (a > 4.0/3.0)
-    { // expand vertical
-      float s = DISPLAY_H/h;
-      w *= s;
-      h *= s;
-      sprite_.set_scale(s);
-    }
+  { // expand vertical
+    float s = DISPLAY_H/h;
+    w *= s;
+    h *= s;
+    sprite_.set_scale(s);
+  }
   else
-    { // expand horizontal
-      float s = DISPLAY_W/w;
-      w *= s;
-      h *= s;
-      sprite_.set_scale(s);
-    }  
+  { // expand horizontal
+    float s = DISPLAY_W/w;
+    w *= s;
+    h *= s;
+    sprite_.set_scale(s);
+  }  
 }
 
 void
@@ -334,47 +334,47 @@
 Sprite2DView::update(float delta, const Controller& controller)
 {  
   if (ignore_delta)
-    {
-      ignore_delta = false;
-      delta = 0.0f;
-    }
+  {
+    ignore_delta = false;
+    delta = 0.0f;
+  }
   
   display_time += delta * 0.5f;
 
   switch(mode) {
-  case SLIDESHOW:
-    update_slideshow(delta, controller);
-    break;
-  case MANUAL:
-    update_manual(delta, controller);
-    break;
+    case SLIDESHOW:
+      update_slideshow(delta, controller);
+      break;
+    case MANUAL:
+      update_manual(delta, controller);
+      break;
   }
 
   if (controller.button_was_pressed(PDA_BUTTON))
+  {
+    if (shuffle)
     {
-      if (shuffle)
-        {
-          std::vector<Pathname>::iterator i = std::find(directory.begin(), directory.end(),
-                                                        shuffle_directory[index]);
-          if (i != directory.end())
-            {
-              index = i - directory.begin() ;
-            }
-        }
-      else
-        {
-          std::vector<Pathname>::iterator i = std::find(shuffle_directory.begin(), shuffle_directory.end(),
-                                                           directory[index]);
-          if (i != shuffle_directory.end())
-            {
-              index = i - shuffle_directory.begin();
-            }
-        }
+      std::vector<Pathname>::iterator i = std::find(directory.begin(), directory.end(),
+                                                    shuffle_directory[index]);
+      if (i != directory.end())
+      {
+        index = i - directory.begin() ;
+      }
+    }
+    else
+    {
+      std::vector<Pathname>::iterator i = std::find(shuffle_directory.begin(), shuffle_directory.end(),
+                                                    directory[index]);
+      if (i != shuffle_directory.end())
+      {
+        index = i - shuffle_directory.begin();
+      }
+    }
 
-      shuffle = !shuffle;
+    shuffle = !shuffle;
 
-      std::cout << shuffle << " " << index << std::endl;
-    }
+    std::cout << shuffle << " " << index << std::endl;
+  }
 
   //  if (controller.button_was_pressed(INVENTORY_BUTTON))
   //std::random_shuffle(shuffle_directory.begin(), shuffle_directory.end());
@@ -383,28 +383,28 @@
     show_thumbnail = !show_thumbnail;
 
   if (controller.button_was_pressed(AIM_BUTTON))
-    {
-      if (mode == SLIDESHOW) mode = MANUAL; 
-      else if (mode == MANUAL) mode = SLIDESHOW; 
-    }
+  {
+    if (mode == SLIDESHOW) mode = MANUAL; 
+    else if (mode == MANUAL) mode = SLIDESHOW; 
+  }
 
   if (new_sprite)
+  {
+    fadein += delta;
+
+    if (fadein > 1.0f)
     {
-      fadein += delta;
-
-      if (fadein > 1.0f)
-        {
-          sprite = new_sprite;
-          sprite.set_alpha(1.0f);
-          new_sprite = Sprite();
-          offset = 0;
-          display_time = 0;
-        }
-      else
-        {
-          new_sprite.set_alpha(fadein);
-        }
+      sprite = new_sprite;
+      sprite.set_alpha(1.0f);
+      new_sprite = Sprite();
+      offset = 0;
+      display_time = 0;
     }
+    else
+    {
+      new_sprite.set_alpha(fadein);
+    }
+  }
 }
 
 void

Modified: trunk/windstille/src/screen/sprite3dview.cpp
===================================================================
--- trunk/windstille/src/screen/sprite3dview.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/screen/sprite3dview.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -90,21 +90,21 @@
   int line_height = Fonts::current()->vera12->get_height()+5;
 
   for(int i = 0; i < int(actions.size()); ++i)
+  {
+    if (i == current_action)
+      Fonts::current()->vera12->draw(Vector2f(x, y),
+                                     actions[i], Color(1.0f, 1.0f, 1.0f));
+    else
+      Fonts::current()->vera12->draw(Vector2f(x, y),
+                                     actions[i], Color(0.7f, 0.7f, 0.7f));
+
+    y += static_cast<float>(line_height);
+    if (y > 580.0f)
     {
-      if (i == current_action)
-        Fonts::current()->vera12->draw(Vector2f(x, y),
-                            actions[i], Color(1.0f, 1.0f, 1.0f));
-      else
-        Fonts::current()->vera12->draw(Vector2f(x, y),
-                            actions[i], Color(0.7f, 0.7f, 0.7f));
-
-      y += static_cast<float>(line_height);
-      if (y > 580.0f)
-        {
-          x += 200.0f;
-          y =  static_cast<float>(Fonts::current()->vera12->get_height()) + 5.0f;
-        }
+      x += 200.0f;
+      y =  static_cast<float>(Fonts::current()->vera12->get_height()) + 5.0f;
     }
+  }
 }
 
 void
@@ -115,33 +115,33 @@
 
   int last_action = current_action;
   if (controller.button_was_pressed(MENU_DOWN_BUTTON))
-    {
-      if (current_action == int(actions.size())-1)
-        current_action = 0;
-      else
-        current_action += 1;
-    }
+  {
+    if (current_action == int(actions.size())-1)
+      current_action = 0;
+    else
+      current_action += 1;
+  }
   else if (controller.button_was_pressed(MENU_UP_BUTTON))
-    {
-      if (current_action == 0)
-        current_action = actions.size()-1;
-      else
-        current_action -= 1;
-    }
+  {
+    if (current_action == 0)
+      current_action = actions.size()-1;
+    else
+      current_action -= 1;
+  }
 
   if (controller.get_button_state(RIGHT_SHOULDER_BUTTON))
-    {
-      scale *= 1.0f + 0.6f * delta;
-    }
+  {
+    scale *= 1.0f + 0.6f * delta;
+  }
   else if (controller.get_button_state(LEFT_SHOULDER_BUTTON))
-    {
-      scale /= 1.0f + 0.6f * delta;
-    }
+  {
+    scale /= 1.0f + 0.6f * delta;
+  }
   
   if (last_action != current_action && !actions.empty())
-    {
-      sprite.set_action(actions[current_action]);
-    }
+  {
+    sprite.set_action(actions[current_action]);
+  }
 
   rotation = Quaternion(Vector3(0.0f, 1.0f, 0.0f),
                         -controller.get_axis_state(X2_AXIS) * delta * 4.0f) * rotation;
@@ -151,15 +151,15 @@
                         controller.get_axis_state(X_AXIS) * delta * 4.0f) * rotation;
 
   if (controller.get_button_state(VIEW_CENTER_BUTTON))
-    {
-      rotation = Quaternion::identity();
-    }
+  {
+    rotation = Quaternion::identity();
+  }
 
   if (controller.button_was_pressed(ESCAPE_BUTTON) ||
       controller.button_was_pressed(PAUSE_BUTTON))
-    {
-      MenuManager::display_pause_menu();
-    }
+  {
+    MenuManager::display_pause_menu();
+  }
 }
 
 void

Modified: trunk/windstille/src/screen/view.cpp
===================================================================
--- trunk/windstille/src/screen/view.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/screen/view.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -65,16 +65,16 @@
   const Controller& controller = InputManagerSDL::current()->get_controller();
 
   if (controller.get_button_state(DEBUG_BUTTON))
+  {
+    if (controller.get_button_state(VIEW_CENTER_BUTTON)) 
     {
-      if (controller.get_button_state(VIEW_CENTER_BUTTON)) 
-        {
-          m_debug_transform = Vector2f(0, 0);
-          m_debug_zoom = 1.0;
-        }
+      m_debug_transform = Vector2f(0, 0);
+      m_debug_zoom = 1.0;
+    }
 
-      m_debug_transform.x += 1000.0f * controller.get_axis_state(X2_AXIS) * delta / m_debug_zoom;
-      m_debug_transform.y += 1000.0f * controller.get_axis_state(Y2_AXIS) * delta / m_debug_zoom;
-    }
+    m_debug_transform.x += 1000.0f * controller.get_axis_state(X2_AXIS) * delta / m_debug_zoom;
+    m_debug_transform.y += 1000.0f * controller.get_axis_state(Y2_AXIS) * delta / m_debug_zoom;
+  }
 }
 
 Rectf

Modified: trunk/windstille/src/scripting/game_objects.cpp
===================================================================
--- trunk/windstille/src/scripting/game_objects.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/scripting/game_objects.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -51,12 +51,12 @@
 GameObject::set_parent(const std::string& name)
 {
   if (::Entity* entity = dynamic_cast<Entity*>(object.lock().get()))
+  {
+    if (::GameObject* obj = Sector::current()->get_object(name))
     {
-      if (::GameObject* obj = Sector::current()->get_object(name))
-        {
-          entity->set_parent(dynamic_cast<Entity*>(obj));
-        }
+      entity->set_parent(dynamic_cast<Entity*>(obj));
     }
+  }
 }
 
 void
@@ -85,7 +85,7 @@
 
 void
 TestObject::attach(const std::string& spritename,
-		           const std::string& attachement_point)
+                   const std::string& attachement_point)
 {
   obj()->attach(spritename, attachement_point);
 }

Modified: trunk/windstille/src/scripting/game_objects.hpp
===================================================================
--- trunk/windstille/src/scripting/game_objects.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/scripting/game_objects.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -73,7 +73,7 @@
   void set_pos(float x, float y);
   void set_vflip(bool vflip);
   void attach(const std::string& spritename,
-		      const std::string& attachement_point);
+              const std::string& attachement_point);
 };
 
 class Player : public GameObject

Modified: trunk/windstille/src/scripting/squirrel_error.cpp
===================================================================
--- trunk/windstille/src/scripting/squirrel_error.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/scripting/squirrel_error.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -24,8 +24,8 @@
 
 namespace Scripting {
 
-SquirrelError::SquirrelError(HSQUIRRELVM v, const Pathname& path, const std::string& message_) throw()
-  : message()
+SquirrelError::SquirrelError(HSQUIRRELVM v, const Pathname& path, const std::string& message_) throw() :
+  message()
 {
   std::ostringstream msg;
   msg << "Squirrel error: " << path << ": " << message_ << " (";
@@ -44,8 +44,8 @@
   message = msg.str();
 }
 
-SquirrelError::SquirrelError(HSQUIRRELVM v, const std::string& context, const std::string& message_) throw()
-  : message()
+SquirrelError::SquirrelError(HSQUIRRELVM v, const std::string& context, const std::string& message_) throw() :
+  message()
 {
   std::ostringstream msg;
   msg << "Squirrel error: " << context << ": " << message_ << " (";
@@ -64,8 +64,8 @@
   message = msg.str();
 }
 
-SquirrelError::SquirrelError(HSQUIRRELVM v, const std::string& message_) throw()
-  : message()
+SquirrelError::SquirrelError(HSQUIRRELVM v, const std::string& message_) throw() :
+  message()
 {
   std::ostringstream msg;
   msg << "Squirrel error: " << message_ << " (";

Modified: trunk/windstille/src/scripting/util.cpp
===================================================================
--- trunk/windstille/src/scripting/util.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/scripting/util.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -33,10 +33,10 @@
 std::string sq_to_lisp_string(std::string sq_str)
 {
   for (unsigned i = 0; i != sq_str.size(); ++i)
-    {
-      if (sq_str[i] == '_')
-        sq_str[i] = '-';
-    }
+  {
+    if (sq_str[i] == '_')
+      sq_str[i] = '-';
+  }
   
   return sq_str;
 }
@@ -44,40 +44,40 @@
 void sq_to_lisp(HSQUIRRELVM v, std::vector<lisp::Lisp*>& entries)
 {
   switch(sq_gettype(v, -1))
-    {
-      case OT_INTEGER: {
-        SQInteger val;
-        sq_getinteger(v, -1, &val);
-        entries.push_back(new lisp::Lisp(static_cast<int>(val)));
-        break;
-      }
-      case OT_FLOAT: {
-        float val;
-        sq_getfloat(v, -1, &val);
-        entries.push_back(new lisp::Lisp(val));
-        break;
-      }
-      case OT_STRING: {
-        const char* str;
-        sq_getstring(v, -1, &str);      
-        entries.push_back(new lisp::Lisp(lisp::Lisp::TYPE_STRING, str));
-        break;
-      }                                                    
-      case OT_BOOL: {
-        SQBool boolean;
-        sq_getbool(v, -1, &boolean);
-        entries.push_back(new lisp::Lisp(static_cast<bool>(boolean)));
-        break;
-      }
-      case OT_ARRAY:
-      case OT_TABLE: {
-        table_to_lisp(v, -1, entries);
-        break;
-      }
-      default:
-        std::cerr << "Unsupported value type in table\n";
-        break;
+  {
+    case OT_INTEGER: {
+      SQInteger val;
+      sq_getinteger(v, -1, &val);
+      entries.push_back(new lisp::Lisp(static_cast<int>(val)));
+      break;
     }
+    case OT_FLOAT: {
+      float val;
+      sq_getfloat(v, -1, &val);
+      entries.push_back(new lisp::Lisp(val));
+      break;
+    }
+    case OT_STRING: {
+      const char* str;
+      sq_getstring(v, -1, &str);      
+      entries.push_back(new lisp::Lisp(lisp::Lisp::TYPE_STRING, str));
+      break;
+    }                                                    
+    case OT_BOOL: {
+      SQBool boolean;
+      sq_getbool(v, -1, &boolean);
+      entries.push_back(new lisp::Lisp(static_cast<bool>(boolean)));
+      break;
+    }
+    case OT_ARRAY:
+    case OT_TABLE: {
+      table_to_lisp(v, -1, entries);
+      break;
+    }
+    default:
+      std::cerr << "Unsupported value type in table\n";
+      break;
+  }
 }
 
 void table_to_lisp(HSQUIRRELVM v, int idx, std::vector<lisp::Lisp*>& entries)
@@ -85,231 +85,231 @@
   SQObjectType type = sq_gettype(v, idx);
 
   if (type != OT_TABLE && type != OT_ARRAY)
-    {
-      print_squirrel_stack(v, "table_to_lisp");
-      throw std::runtime_error("table_to_lisp: no table or array at the given index");
-    }
+  {
+    print_squirrel_stack(v, "table_to_lisp");
+    throw std::runtime_error("table_to_lisp: no table or array at the given index");
+  }
   else
+  {
+    sq_push(v, idx);
+
+    // iterate table
+    sq_pushnull(v);
+    while (SQ_SUCCEEDED(sq_next(v, -2)))
     {
-      sq_push(v, idx);
-
-      // iterate table
-      sq_pushnull(v);
-      while (SQ_SUCCEEDED(sq_next(v, -2)))
+      if (type == OT_ARRAY)
+      {
+        sq_to_lisp(v, entries);
+      }
+      else if (type == OT_TABLE)
+      {
+        // table/array is -3, key is -2, value -1 now
+        if (sq_gettype(v, -2) != OT_STRING)
         {
-          if (type == OT_ARRAY)
-            {
-              sq_to_lisp(v, entries);
-            }
-          else if (type == OT_TABLE)
-            {
-              // table/array is -3, key is -2, value -1 now
-              if (sq_gettype(v, -2) != OT_STRING)
-                {
-                  std::cerr << "Table contains a non string key\n";
-                }
-              else
-                {
-                  const char* key = 0;
-                  sq_getstring(v, -2, &key);
-                  std::string lisp_key = sq_to_lisp_string(key);
+          std::cerr << "Table contains a non string key\n";
+        }
+        else
+        {
+          const char* key = 0;
+          sq_getstring(v, -2, &key);
+          std::string lisp_key = sq_to_lisp_string(key);
 
-                  std::vector<lisp::Lisp*> childs;
-                  childs.push_back(new lisp::Lisp(lisp::Lisp::TYPE_SYMBOL, lisp_key));
-                  sq_to_lisp(v, childs);
-                  entries.push_back(new lisp::Lisp(childs));
-                }
-            }
+          std::vector<lisp::Lisp*> childs;
+          childs.push_back(new lisp::Lisp(lisp::Lisp::TYPE_SYMBOL, lisp_key));
+          sq_to_lisp(v, childs);
+          entries.push_back(new lisp::Lisp(childs));
+        }
+      }
     
-          // pop key and value
-          sq_pop(v, 2);
-        }
-
-      // pop iterator and table
+      // pop key and value
       sq_pop(v, 2);
     }
+
+    // pop iterator and table
+    sq_pop(v, 2);
+  }
 }
 
 std::string squirrel2string(HSQUIRRELVM v, int i)
 {
   std::ostringstream os;
   switch(sq_gettype(v, i))
+  {
+    case OT_NULL:
+      os << "<null>";        
+      break;
+    case OT_BOOL: {
+      SQBool p;
+      sq_getbool(v, i, &p);
+      if (p) 
+        os << "true";
+      else
+        os << "false";
+      break;
+    }
+    case OT_INTEGER: {
+      SQInteger val;
+      sq_getinteger(v, i, &val);
+      os << val;
+      break;
+    }
+    case OT_FLOAT: {
+      float val;
+      sq_getfloat(v, i, &val);
+      os << val;
+      break;
+    }
+    case OT_STRING: {
+      const char* val;
+      sq_getstring(v, i, &val);
+      os << "\"" << val << "\"";
+      break;    
+    }
+    case OT_TABLE: {
+      bool first = true;
+      os << "{";
+      sq_pushnull(v);  //null iterator
+      while(SQ_SUCCEEDED(sq_next(v,i-1)))
+      {
+        if (!first)
+        {
+          os << ", \n";
+        }
+        first = false;
+
+        //here -1 is the value and -2 is the key
+        os << squirrel2string(v, -2) << " => " 
+           << squirrel2string(v, -1);
+                              
+        sq_pop(v,2); //pops key and val before the nex iteration
+      }
+      sq_pop(v, 1);
+      os << "}";
+      break;
+    }
+    case OT_ARRAY: {
+      bool first = true;
+      os << "[";
+      sq_pushnull(v);  //null iterator
+      while(SQ_SUCCEEDED(sq_next(v,i-1)))
+      {
+        if (!first)
+        {
+          os << ", ";
+        }
+        first = false;
+
+        //here -1 is the value and -2 is the key
+        // we ignore the key, since that is just the index in an array
+        os << squirrel2string(v, -1);
+                              
+        sq_pop(v,2); //pops key and val before the nex iteration
+      }
+      sq_pop(v, 1);
+      os << "]";
+      break;
+    }
+    case OT_USERDATA:
+      os << "<userdata>";
+      break;
+    case OT_CLOSURE:        
+      os << "<closure (function)>";
+      break;
+    case OT_NATIVECLOSURE:
+      os << "<native closure (C function)>";
+      break;
+    case OT_GENERATOR:
+      os << "<generator>";
+      break;
+    case OT_USERPOINTER:
+      os << "userpointer";
+      break;
+    case OT_THREAD:
+      os << "<thread>";
+      break;
+    case OT_CLASS:
+      os << "<class>";
+      break;
+    case OT_INSTANCE:
+      os << "<instance>";
+      break;
+    default:
+      os << "<unknown>";
+      break;
+  }
+  return os.str();
+}
+
+void print_squirrel_stack(HSQUIRRELVM v, const std::string& context)
+{
+  if (context.empty())
+    printf(",-------------------------------------------------------------\n");
+  else
+    printf(",-------------[ %s ]---------------------------------------\n", context.c_str());
+
+  int count = sq_gettop(v);
+  for(int i = 1; i <= count; ++i) 
+  {
+    printf("| %d: ",i);
+    switch(sq_gettype(v, i))
     {
       case OT_NULL:
-        os << "<null>";        
+        printf("null");        
         break;
-      case OT_BOOL: {
-        SQBool p;
-        sq_getbool(v, i, &p);
-        if (p) 
-          os << "true";
-        else
-          os << "false";
-        break;
-      }
       case OT_INTEGER: {
         SQInteger val;
         sq_getinteger(v, i, &val);
-        os << val;
+        printf("integer (%d)", static_cast<int>(val));
         break;
       }
       case OT_FLOAT: {
         float val;
         sq_getfloat(v, i, &val);
-        os << val;
+        printf("float (%f)", val);
         break;
       }
       case OT_STRING: {
         const char* val;
         sq_getstring(v, i, &val);
-        os << "\"" << val << "\"";
+        printf("string (%s)", val);
         break;    
       }
-      case OT_TABLE: {
-        bool first = true;
-        os << "{";
-        sq_pushnull(v);  //null iterator
-        while(SQ_SUCCEEDED(sq_next(v,i-1)))
-          {
-            if (!first)
-              {
-                os << ", \n";
-              }
-            first = false;
-
-            //here -1 is the value and -2 is the key
-            os << squirrel2string(v, -2) << " => " 
-               << squirrel2string(v, -1);
-                              
-            sq_pop(v,2); //pops key and val before the nex iteration
-          }
-        sq_pop(v, 1);
-        os << "}";
+      case OT_TABLE:
+        printf("table");
         break;
-      }
-      case OT_ARRAY: {
-        bool first = true;
-        os << "[";
-        sq_pushnull(v);  //null iterator
-        while(SQ_SUCCEEDED(sq_next(v,i-1)))
-          {
-            if (!first)
-              {
-                os << ", ";
-              }
-            first = false;
-
-            //here -1 is the value and -2 is the key
-            // we ignore the key, since that is just the index in an array
-            os << squirrel2string(v, -1);
-                              
-            sq_pop(v,2); //pops key and val before the nex iteration
-          }
-        sq_pop(v, 1);
-        os << "]";
+      case OT_ARRAY:
+        printf("array");
         break;
-      }
       case OT_USERDATA:
-        os << "<userdata>";
+        printf("userdata");
         break;
       case OT_CLOSURE:        
-        os << "<closure (function)>";
+        printf("closure(function)");    
         break;
       case OT_NATIVECLOSURE:
-        os << "<native closure (C function)>";
+        printf("native closure(C function)");
         break;
       case OT_GENERATOR:
-        os << "<generator>";
+        printf("generator");
         break;
       case OT_USERPOINTER:
-        os << "userpointer";
+        printf("userpointer");
         break;
       case OT_THREAD:
-        os << "<thread>";
+        printf("thread");
         break;
       case OT_CLASS:
-        os << "<class>";
+        printf("class");
         break;
       case OT_INSTANCE:
-        os << "<instance>";
+        printf("instance");
         break;
       default:
-        os << "<unknown>";
+        printf("unknown?!?");
         break;
     }
-  return os.str();
-}
-
-void print_squirrel_stack(HSQUIRRELVM v, const std::string& context)
-{
-  if (context.empty())
-    printf(",-------------------------------------------------------------\n");
-  else
-    printf(",-------------[ %s ]---------------------------------------\n", context.c_str());
-
-  int count = sq_gettop(v);
-  for(int i = 1; i <= count; ++i) 
-    {
-      printf("| %d: ",i);
-      switch(sq_gettype(v, i))
-        {
-          case OT_NULL:
-            printf("null");        
-            break;
-          case OT_INTEGER: {
-            SQInteger val;
-            sq_getinteger(v, i, &val);
-            printf("integer (%d)", static_cast<int>(val));
-            break;
-          }
-          case OT_FLOAT: {
-            float val;
-            sq_getfloat(v, i, &val);
-            printf("float (%f)", val);
-            break;
-          }
-          case OT_STRING: {
-            const char* val;
-            sq_getstring(v, i, &val);
-            printf("string (%s)", val);
-            break;    
-          }
-          case OT_TABLE:
-            printf("table");
-            break;
-          case OT_ARRAY:
-            printf("array");
-            break;
-          case OT_USERDATA:
-            printf("userdata");
-            break;
-          case OT_CLOSURE:        
-            printf("closure(function)");    
-            break;
-          case OT_NATIVECLOSURE:
-            printf("native closure(C function)");
-            break;
-          case OT_GENERATOR:
-            printf("generator");
-            break;
-          case OT_USERPOINTER:
-            printf("userpointer");
-            break;
-          case OT_THREAD:
-            printf("thread");
-            break;
-          case OT_CLASS:
-            printf("class");
-            break;
-          case OT_INSTANCE:
-            printf("instance");
-            break;
-          default:
-            printf("unknown?!?");
-            break;
-        }
-      printf("\n");
-    }
+    printf("\n");
+  }
   printf("'-------------------------------------------------------------\n");
 }
 
@@ -320,41 +320,41 @@
   Properties props(lisp);
   PropertyIterator<const lisp::Lisp*> iter = props.get_iter();
   while(iter.next())
+  {
+    sq_pushstring(v, iter.item().c_str(), iter.item().size());
+    switch((*iter)->get_type())
     {
-      sq_pushstring(v, iter.item().c_str(), iter.item().size());
-      switch((*iter)->get_type())
-        {
-          case lisp::Lisp::TYPE_LIST:
-            sq_newtable(v);
-            load_squirrel_table(v, sq_gettop(v), *iter);
-            break;
-          case lisp::Lisp::TYPE_INT:
-            sq_pushinteger(v, (*iter)->get_int());
-            break;
-          case lisp::Lisp::TYPE_FLOAT:
-            sq_pushfloat(v, (*iter)->get_float());
-            break;
-          case lisp::Lisp::TYPE_STRING:
-            sq_pushstring(v, (*iter)->get_string(), -1);
-            break;
-          case lisp::Lisp::TYPE_BOOL:
-            sq_pushbool(v, (*iter)->get_bool());
-            break;
-          case lisp::Lisp::TYPE_SYMBOL:
-            std::cerr << "Unexpected symbol in lisp file...";
-            sq_pushnull(v);
-            break;
-          default:
-            assert(false);
-            break;
-        }
-      if (table_idx < 0)
-        {
-          sq_createslot(v, table_idx - 2);
-        } else {
-        sq_createslot(v, table_idx);
-      }
+      case lisp::Lisp::TYPE_LIST:
+        sq_newtable(v);
+        load_squirrel_table(v, sq_gettop(v), *iter);
+        break;
+      case lisp::Lisp::TYPE_INT:
+        sq_pushinteger(v, (*iter)->get_int());
+        break;
+      case lisp::Lisp::TYPE_FLOAT:
+        sq_pushfloat(v, (*iter)->get_float());
+        break;
+      case lisp::Lisp::TYPE_STRING:
+        sq_pushstring(v, (*iter)->get_string(), -1);
+        break;
+      case lisp::Lisp::TYPE_BOOL:
+        sq_pushbool(v, (*iter)->get_bool());
+        break;
+      case lisp::Lisp::TYPE_SYMBOL:
+        std::cerr << "Unexpected symbol in lisp file...";
+        sq_pushnull(v);
+        break;
+      default:
+        assert(false);
+        break;
     }
+    if (table_idx < 0)
+    {
+      sq_createslot(v, table_idx - 2);
+    } else {
+      sq_createslot(v, table_idx);
+    }
+  }
 }
 
 void load_squirrel_table(HSQUIRRELVM v, int table_idx, const std::string& file)
@@ -379,57 +379,57 @@
   //iterator table
   sq_pushnull(v);
   while(SQ_SUCCEEDED(sq_next(v, table_idx)))
+  {
+    if (sq_gettype(v, -2) != OT_STRING)
     {
-      if (sq_gettype(v, -2) != OT_STRING)
-        {
-          std::cerr << "Table contains non-string key\n";
-          continue;
-        }
-      const char* key;
-      sq_getstring(v, -2, &key);
+      std::cerr << "Table contains non-string key\n";
+      continue;
+    }
+    const char* key;
+    sq_getstring(v, -2, &key);
 
-      switch(sq_gettype(v, -1))
-        {
-          case OT_INTEGER: {
-            SQInteger val;
-            sq_getinteger(v, -1, &val);
-            writer.write_int(key, val);
-            break;
-          }
-          case OT_FLOAT: {
-            float val;
-            sq_getfloat(v, -1, &val);
-            writer.write_float(key, val);
-            break;
-          }
-          case OT_BOOL: {
-            SQBool val;
-            sq_getbool(v, -1, &val);
-            writer.write_bool(key, val);
-            break;
-          }
-          case OT_STRING: {
-            const char* str;
-            sq_getstring(v, -1, &str);
-            writer.write_string(key, str);
-            break;
-          }
-          case OT_TABLE: {
-            writer.start_list(key);
-            save_squirrel_table(v, -1, writer);
-            writer.end_list(key);
-            break;
-          }
-          case OT_CLOSURE:
-            break; // ignore
-          case OT_NATIVECLOSURE:
-            break;
-          default:
-            std::cerr << "Can't serialize key '" << key << "' in table.\n";
-            break;
-        }
-      sq_pop(v, 2);
+    switch(sq_gettype(v, -1))
+    {
+      case OT_INTEGER: {
+        SQInteger val;
+        sq_getinteger(v, -1, &val);
+        writer.write_int(key, val);
+        break;
+      }
+      case OT_FLOAT: {
+        float val;
+        sq_getfloat(v, -1, &val);
+        writer.write_float(key, val);
+        break;
+      }
+      case OT_BOOL: {
+        SQBool val;
+        sq_getbool(v, -1, &val);
+        writer.write_bool(key, val);
+        break;
+      }
+      case OT_STRING: {
+        const char* str;
+        sq_getstring(v, -1, &str);
+        writer.write_string(key, str);
+        break;
+      }
+      case OT_TABLE: {
+        writer.start_list(key);
+        save_squirrel_table(v, -1, writer);
+        writer.end_list(key);
+        break;
+      }
+      case OT_CLOSURE:
+        break; // ignore
+      case OT_NATIVECLOSURE:
+        break;
+      default:
+        std::cerr << "Can't serialize key '" << key << "' in table.\n";
+        break;
     }
+    sq_pop(v, 2);
+  }
   sq_pop(v, 1);
 }
 

Modified: trunk/windstille/src/sound/sound_channel.cpp
===================================================================
--- trunk/windstille/src/sound/sound_channel.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/sound/sound_channel.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -50,13 +50,13 @@
   switch(type)
   {
     case kStreamSoundSource:
-      {
-        SoundSourcePtr source(new StreamSoundSource(*this, sound_file));
-        source->update_gain();
-        m_sound_sources.push_back(SoundSourcePtr(source));
-        return source;
-      }
-      break;
+    {
+      SoundSourcePtr source(new StreamSoundSource(*this, sound_file));
+      source->update_gain();
+      m_sound_sources.push_back(SoundSourcePtr(source));
+      return source;
+    }
+    break;
 
     case kStaticSoundSource:
       // FIXME: not implemented

Modified: trunk/windstille/src/sound/sound_manager.cpp
===================================================================
--- trunk/windstille/src/sound/sound_manager.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/sound/sound_manager.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -143,31 +143,31 @@
     switch(type)
     {
       case kStaticSoundSource:
+      {
+        ALuint buffer;
+  
+        // reuse an existing static sound buffer            
+        SoundBuffers::iterator i = m_buffers.find(filename);
+        if (i != m_buffers.end()) 
         {
-          ALuint buffer;
-  
-          // reuse an existing static sound buffer            
-          SoundBuffers::iterator i = m_buffers.find(filename);
-          if (i != m_buffers.end()) 
-          {
-            buffer = i->second;
-          } 
-          else 
-          {
-            buffer = load_file_into_buffer(filename);
-            m_buffers.insert(std::make_pair(filename, buffer));
-          }
-
-          return SoundSourcePtr(new StaticSoundSource(channel, buffer));
+          buffer = i->second;
+        } 
+        else 
+        {
+          buffer = load_file_into_buffer(filename);
+          m_buffers.insert(std::make_pair(filename, buffer));
         }
-        break;
 
+        return SoundSourcePtr(new StaticSoundSource(channel, buffer));
+      }
+      break;
+
       case kStreamSoundSource:
-        {
-          std::auto_ptr<SoundFile> sound_file = SoundFile::load(filename);
-          return SoundSourcePtr(new StreamSoundSource(channel, sound_file));
-        }
-        break;
+      {
+        std::auto_ptr<SoundFile> sound_file = SoundFile::load(filename);
+        return SoundSourcePtr(new StreamSoundSource(channel, sound_file));
+      }
+      break;
 
       default:
         assert(!"never reached");

Modified: trunk/windstille/src/sprite2d/data.cpp
===================================================================
--- trunk/windstille/src/sprite2d/data.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/sprite2d/data.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -23,8 +23,8 @@
 
 #include "display/surface_manager.hpp"
 
-SpriteData::SpriteData(const Pathname& pathname)
-  : actions()
+SpriteData::SpriteData(const Pathname& pathname) :
+  actions()
 {
   if (pathname.exists())
   {
@@ -123,43 +123,43 @@
   FileReader grid_reader;
   std::vector<std::string> image_files;
   if(reader.get("images", image_files))
+  {
+    //parse_images(action.get(), dir, images);
+
+    for(std::vector<std::string>::iterator file = image_files.begin(); file != image_files.end(); ++file)
     {
-      //parse_images(action.get(), dir, images);
-
-      for(std::vector<std::string>::iterator file = image_files.begin(); file != image_files.end(); ++file)
-        {
-          Pathname path = dir;
-          path.append_path(*file);
-          action->surfaces.push_back(SurfaceManager::current()->get(path));
-        }
+      Pathname path = dir;
+      path.append_path(*file);
+      action->surfaces.push_back(SurfaceManager::current()->get(path));
     }
+  }
   else if(reader.get("image-grid", grid_reader)) 
-    {
-      std::string filename;
-      int x_size = -1;
-      int y_size = -1;
+  {
+    std::string filename;
+    int x_size = -1;
+    int y_size = -1;
       
-      grid_reader.get("file", filename);
-      grid_reader.get("x-size", x_size);
-      grid_reader.get("y-size", y_size);
+    grid_reader.get("file", filename);
+    grid_reader.get("x-size", x_size);
+    grid_reader.get("y-size", y_size);
 
-      if(filename.empty() || x_size <= 0 || y_size <= 0)
-        throw std::runtime_error("Invalid or too few data in image-grid");
+    if(filename.empty() || x_size <= 0 || y_size <= 0)
+      throw std::runtime_error("Invalid or too few data in image-grid");
       
-      Pathname path = dir;
-      path.append_path(filename);
-      SurfaceManager::current()->load_grid(path, action->surfaces, x_size, y_size);
-    }
+    Pathname path = dir;
+    path.append_path(filename);
+    SurfaceManager::current()->load_grid(path, action->surfaces, x_size, y_size);
+  }
     
   if(action->name == "")
     throw std::runtime_error("No Name defined for action");
 
   if(action->surfaces.size() == 0) 
-    {
-      std::ostringstream msg;
-      msg << "Action '" << action->name << "' contains no images";
-      throw std::runtime_error(msg.str());
-    }
+  {
+    std::ostringstream msg;
+    msg << "Action '" << action->name << "' contains no images";
+    throw std::runtime_error(msg.str());
+  }
   return action.release();
 }
  

Modified: trunk/windstille/src/sprite2d/manager.cpp
===================================================================
--- trunk/windstille/src/sprite2d/manager.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/sprite2d/manager.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -21,8 +21,8 @@
 
 #include "sprite2d/data.hpp"
 
-SpriteManager::SpriteManager()
-  : datas()
+SpriteManager::SpriteManager() :
+  datas()
 {
 }
 
@@ -35,27 +35,27 @@
 {
   Datas::iterator i = datas.find(filename);
   if(i != datas.end())
-    {
-      return i->second;
-    }
+  {
+    return i->second;
+  }
   else
-    {  
-      SpriteDataPtr data(new SpriteData(filename));
-      datas.insert(std::make_pair(filename, data));
-      return data;
-    }
+  {  
+    SpriteDataPtr data(new SpriteData(filename));
+    datas.insert(std::make_pair(filename, data));
+    return data;
+  }
 }
 
 void
 SpriteManager::cleanup()
 {
   for(Datas::iterator i = datas.begin(); i != datas.end(); ++i)
+  {
+    if (i->second.use_count() == 1)
     {
-      if (i->second.use_count() == 1)
-        {
-          datas.erase(i);
-        }
+      datas.erase(i);
     }
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/sprite2d/sprite.cpp
===================================================================
--- trunk/windstille/src/sprite2d/sprite.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/sprite2d/sprite.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -24,33 +24,33 @@
 #include "sprite2d/data.hpp"
 #include "display/surface_drawing_parameters.hpp"
 
-Sprite::Sprite()
-  : data(),
-    current_action(0),
-    frame(0),
-    speed(0),
-    pingpong(),
-    reverse(),
-    vflip(),
-    blend_sfactor(),
-    blend_dfactor(),
-    scale(),
-    color()
+Sprite::Sprite() :
+  data(),
+  current_action(0),
+  frame(0),
+  speed(0),
+  pingpong(),
+  reverse(),
+  vflip(),
+  blend_sfactor(),
+  blend_dfactor(),
+  scale(),
+  color()
 {
 }
 
-Sprite::Sprite(const Pathname& filename)
-  : data(),
-    current_action(0),
-    frame(0),
-    speed(0),
-    pingpong(),
-    reverse(),
-    vflip(),
-    blend_sfactor(),
-    blend_dfactor(),
-    scale(),
-    color()
+Sprite::Sprite(const Pathname& filename) :
+  data(),
+  current_action(0),
+  frame(0),
+  speed(0),
+  pingpong(),
+  reverse(),
+  vflip(),
+  blend_sfactor(),
+  blend_dfactor(),
+  scale(),
+  color()
 {
   data = SpriteManager::current()->create_data(filename);
 
@@ -66,18 +66,18 @@
   blend_dfactor = GL_ONE_MINUS_SRC_ALPHA;
 }
 
-Sprite::Sprite(const SpriteDataPtr data_)
-  : data(data_),
-    current_action(0),
-    frame(0),
-    speed(0),
-    pingpong(),
-    reverse(),
-    vflip(),
-    blend_sfactor(),
-    blend_dfactor(),
-    scale(),
-    color()
+Sprite::Sprite(const SpriteDataPtr data_) :
+  data(data_),
+  current_action(0),
+  frame(0),
+  speed(0),
+  pingpong(),
+  reverse(),
+  vflip(),
+  blend_sfactor(),
+  blend_dfactor(),
+  scale(),
+  color()
 {
   current_action = data->actions[0];
   vflip = false;
@@ -91,18 +91,18 @@
   blend_dfactor = GL_ONE_MINUS_SRC_ALPHA;
 }
 
-Sprite::Sprite(const Sprite& rhs)
-  : data(rhs.data),
-    current_action(rhs.current_action),
-    frame(rhs.frame),
-    speed(rhs.speed),
-    pingpong(rhs.pingpong),
-    reverse(rhs.reverse),
-    vflip(rhs.vflip),
-    blend_sfactor(rhs.blend_sfactor),
-    blend_dfactor(rhs.blend_dfactor),
-    scale(rhs.scale),
-    color(rhs.color)
+Sprite::Sprite(const Sprite& rhs) :
+  data(rhs.data),
+  current_action(rhs.current_action),
+  frame(rhs.frame),
+  speed(rhs.speed),
+  pingpong(rhs.pingpong),
+  reverse(rhs.reverse),
+  vflip(rhs.vflip),
+  blend_sfactor(rhs.blend_sfactor),
+  blend_dfactor(rhs.blend_dfactor),
+  scale(rhs.scale),
+  color(rhs.color)
 {
 }
 
@@ -146,24 +146,24 @@
 {
   for(SpriteData::Actions::const_iterator i = data->actions.begin();
       i != data->actions.end(); ++i) 
+  {
+    const SpriteAction* action = *i;
+    if(action->name == name) 
     {
-      const SpriteAction* action = *i;
-      if(action->name == name) 
-        {
-          // FIXME: This should be per-action and not get reset, shouldn't they?
-          current_action = action;
-          pingpong = false;
-          reverse  = false;
-          speed    = 1.0;
-          frame    = 0;
-          vflip    = false;
-          scale    = current_action->scale;
-          color    = Color(1.0f, 1.0f, 1.0f);
-          blend_sfactor = GL_SRC_ALPHA;
-          blend_dfactor = GL_ONE_MINUS_SRC_ALPHA;
-          return;
-        }
+      // FIXME: This should be per-action and not get reset, shouldn't they?
+      current_action = action;
+      pingpong = false;
+      reverse  = false;
+      speed    = 1.0;
+      frame    = 0;
+      vflip    = false;
+      scale    = current_action->scale;
+      color    = Color(1.0f, 1.0f, 1.0f);
+      blend_sfactor = GL_SRC_ALPHA;
+      blend_dfactor = GL_ONE_MINUS_SRC_ALPHA;
+      return;
     }
+  }
 
   std::ostringstream msg;
   msg << "No action '" << name << "' defined";

Modified: trunk/windstille/src/sprite3d/manager.cpp
===================================================================
--- trunk/windstille/src/sprite3d/manager.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/sprite3d/manager.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -22,8 +22,8 @@
 
 namespace sprite3d {
 
-Manager::Manager()
-  : datas()
+Manager::Manager() :
+  datas()
 {
 }
 

Modified: trunk/windstille/src/sprite3d/sprite3d.cpp
===================================================================
--- trunk/windstille/src/sprite3d/sprite3d.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/sprite3d/sprite3d.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -27,31 +27,31 @@
 
 using namespace sprite3d;
 
-Sprite3D::Sprite3D()
-  : data(0), 
-    actions_switched(false),
-    frame1(),
-    frame2(),
-    blend_time(0.0f),
-    next_frame(),
-    next_action(),
-    abort_at_frame(),
-    blend_sfactor(GL_ONE),
-    blend_dfactor(GL_ZERO)
+Sprite3D::Sprite3D() :
+  data(0), 
+  actions_switched(false),
+  frame1(),
+  frame2(),
+  blend_time(0.0f),
+  next_frame(),
+  next_action(),
+  abort_at_frame(),
+  blend_sfactor(GL_ONE),
+  blend_dfactor(GL_ZERO)
 {
 }
 
-Sprite3D::Sprite3D(const Pathname& filename)
-  : data(sprite3d::Manager::current()->create_data(filename)),
-    actions_switched(false),
-    frame1(),
-    frame2(),
-    blend_time(0.0f),
-    next_frame(),
-    next_action(),
-    abort_at_frame(),
-    blend_sfactor(GL_ONE),
-    blend_dfactor(GL_ZERO)
+Sprite3D::Sprite3D(const Pathname& filename) :
+  data(sprite3d::Manager::current()->create_data(filename)),
+  actions_switched(false),
+  frame1(),
+  frame2(),
+  blend_time(0.0f),
+  next_frame(),
+  next_action(),
+  abort_at_frame(),
+  blend_sfactor(GL_ONE),
+  blend_dfactor(GL_ZERO)
 {
   frame1.action         = &data->actions[0];
   frame1.frame          = 0;
@@ -63,17 +63,17 @@
   next_action.action    = 0;
 }
 
-Sprite3D::Sprite3D(const Sprite3D& rhs)
-  : data(rhs.data),
-    actions_switched(rhs.actions_switched),
-    frame1(rhs.frame1),
-    frame2(rhs.frame2),
-    blend_time(rhs.blend_time),
-    next_frame(rhs.next_frame),
-    next_action(rhs.next_action),
-    abort_at_frame(rhs.abort_at_frame),
-    blend_sfactor(rhs.blend_sfactor),
-    blend_dfactor(rhs.blend_dfactor)
+Sprite3D::Sprite3D(const Sprite3D& rhs) :
+  data(rhs.data),
+  actions_switched(rhs.actions_switched),
+  frame1(rhs.frame1),
+  frame2(rhs.frame2),
+  blend_time(rhs.blend_time),
+  next_frame(rhs.next_frame),
+  next_action(rhs.next_action),
+  abort_at_frame(rhs.abort_at_frame),
+  blend_sfactor(rhs.blend_sfactor),
+  blend_dfactor(rhs.blend_dfactor)
 {
 }
 
@@ -134,9 +134,9 @@
   for(std::vector<Action>::const_iterator i = data->actions.begin(); 
       i != data->actions.end(); 
       ++i)
-    {
-      actions.push_back(i->name);
-    }
+  {
+    actions.push_back(i->name);
+  }
   return actions;
 }
 
@@ -207,10 +207,10 @@
 {
   if ((speed <  0.0f && frame1.speed >= 0.0f) ||
       (speed >= 0.0f && frame1.speed <  0.0f)) 
-    {
-      blend_time = 1.0f - blend_time;
-      std::swap(frame1, frame2);
-    }
+  {
+    blend_time = 1.0f - blend_time;
+    std::swap(frame1, frame2);
+  }
 
   frame1.speed = speed;
   frame2.speed = speed;
@@ -247,9 +247,9 @@
 Sprite3D::get_attachment_point_matrix(PointID id) const
 {
   const AttachmentPointPosition& point1 
-	  = frame1.action->frames[frame1.frame].attachment_points[id];
+    = frame1.action->frames[frame1.frame].attachment_points[id];
   const AttachmentPointPosition& point2 
-	  = frame2.action->frames[frame2.frame].attachment_points[id];
+    = frame2.action->frames[frame2.frame].attachment_points[id];
 
   Quaternion rotquat = Quaternion(0, 0, 1, 0);
   Quaternion quat1 = point1.quat;

Modified: trunk/windstille/src/tile/tile.cpp
===================================================================
--- trunk/windstille/src/tile/tile.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/tile/tile.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -18,13 +18,13 @@
 
 #include "tile/tile.hpp"
 
-Tile::Tile(unsigned int arg_colmap)
-  : id(),
-    packer(-1),
-    uv(),
-    texture(),
-    colmap(arg_colmap),
-    desc(0)
+Tile::Tile(unsigned int arg_colmap) :
+  id(),
+  packer(-1),
+  uv(),
+  texture(),
+  colmap(arg_colmap),
+  desc(0)
 {
 }
 

Modified: trunk/windstille/src/tile/tile_description.cpp
===================================================================
--- trunk/windstille/src/tile/tile_description.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/tile/tile_description.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -24,12 +24,12 @@
 #include "math/rect.hpp"
 #include "tile/tile_factory.hpp"
 
-TileDescription::TileDescription(FileReader& props)
- : ids(),
-   colmap(),
-   filename(),
-   width(0), 
-   height(0)
+TileDescription::TileDescription(FileReader& props) :
+  ids(),
+  colmap(),
+  filename(),
+  width(0), 
+  height(0)
 {
   props.get("ids",    ids);
   props.get("image",  filename);
@@ -49,35 +49,35 @@
 
   int num_tiles = width * height; //(image->w/TILE_RESOLUTION) * (image->h/TILE_RESOLUTION);
   if (int(colmap.size()) != num_tiles)
-    {
-      std::ostringstream str;
-      str << "'colmap' information and num_tiles mismatch (" 
-          << colmap.size() << " != " << num_tiles << ") for image '" << filename << "'";
-      throw std::runtime_error(str.str());
-    }
+  {
+    std::ostringstream str;
+    str << "'colmap' information and num_tiles mismatch (" 
+        << colmap.size() << " != " << num_tiles << ") for image '" << filename << "'";
+    throw std::runtime_error(str.str());
+  }
 
   if (int(ids.size()) != num_tiles)
-    {
-      std::ostringstream str;
-      str << "'ids' information and num_tiles mismatch (" 
-          << ids.size() << " != " << num_tiles << ") for image '" << filename << "'";
-      throw std::runtime_error(str.str());
-    }
+  {
+    std::ostringstream str;
+    str << "'ids' information and num_tiles mismatch (" 
+        << ids.size() << " != " << num_tiles << ") for image '" << filename << "'";
+    throw std::runtime_error(str.str());
+  }
     
   int i = 0;
   for (int y = 0; y < height*TILE_RESOLUTION; y += TILE_RESOLUTION)
+  {
+    for (int x = 0; x < width*TILE_RESOLUTION; x += TILE_RESOLUTION)
     {
-      for (int x = 0; x < width*TILE_RESOLUTION; x += TILE_RESOLUTION)
-        {
-          if(ids[i] != -1)
-            {
-              factory->pack(ids[i], colmap[i], image,
-                            Rect(x, y, x+TILE_RESOLUTION, y+TILE_RESOLUTION));
-            }
+      if(ids[i] != -1)
+      {
+        factory->pack(ids[i], colmap[i], image,
+                      Rect(x, y, x+TILE_RESOLUTION, y+TILE_RESOLUTION));
+      }
 
-          i += 1; 
-        }
+      i += 1; 
     }
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/tile/tile_factory.cpp
===================================================================
--- trunk/windstille/src/tile/tile_factory.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/tile/tile_factory.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -33,21 +33,21 @@
   
   for(int y = sy; y < sy + h; ++y)
     for(int x = sx; x < sx + w; ++x)
-      {
-        if (data[y * image.get_pitch() + 4*x + 3] != 0)
-          { 
-            return false;
-          }
+    {
+      if (data[y * image.get_pitch() + 4*x + 3] != 0)
+      { 
+        return false;
       }
+    }
 
   return true;
 }
 
-TileFactory::TileFactory(const Pathname& filename)
-  : tiles(),
-    packers(),
-    color_packer(),
-    descriptions()
+TileFactory::TileFactory(const Pathname& filename) :
+  tiles(),
+  packers(),
+  color_packer(),
+  descriptions()
 {
   packers.push_back(new TilePacker(1024, 1024));
   packers.push_back(new TilePacker(1024, 1024));
@@ -55,21 +55,21 @@
 
   FileReader reader = FileReader::parse(filename);
   if(reader.get_name() != "windstille-tiles")
-    {
-      std::ostringstream msg;
-      msg << "'" << filename << "' is not a windstille tiles file";
-      throw std::runtime_error(msg.str());
-    }
+  {
+    std::ostringstream msg;
+    msg << "'" << filename << "' is not a windstille tiles file";
+    throw std::runtime_error(msg.str());
+  }
   
   std::vector<FileReader> sections = reader.get_sections();
   for(std::vector<FileReader>::iterator i = sections.begin(); i != sections.end(); ++i)
-    {
-      if (i->get_name() == "tiles") {
-        parse_tiles(*i);
-      } else if (i->get_name() == "tilegroup") {
-        // ignore
-      }
+  {
+    if (i->get_name() == "tiles") {
+      parse_tiles(*i);
+    } else if (i->get_name() == "tilegroup") {
+      // ignore
     }
+  }
 }
 
 TileFactory::~TileFactory()
@@ -95,25 +95,25 @@
   TileDescription& desc = *descriptions.back();
   
   if (0)
-    { // Load all on startup
-      desc.load(this);
-    }
+  { // Load all on startup
+    desc.load(this);
+  }
   else
-    { // Load on demand
-      for(std::vector<int>::size_type i = 0; i < desc.ids.size(); ++i)
-        { 
-          int& id = desc.ids[i];
-          if (id != 0)
-            {
-              if (id >= int(tiles.size()))
-                tiles.resize(id + 1, 0);
+  { // Load on demand
+    for(std::vector<int>::size_type i = 0; i < desc.ids.size(); ++i)
+    { 
+      int& id = desc.ids[i];
+      if (id != 0)
+      {
+        if (id >= int(tiles.size()))
+          tiles.resize(id + 1, 0);
     
-              delete tiles[id];
-              tiles[id] = new Tile(desc.colmap[i]);
-              tiles[id]->desc = &desc;
-            }
-        }
+        delete tiles[id];
+        tiles[id] = new Tile(desc.colmap[i]);
+        tiles[id]->desc = &desc;
+      }
     }
+  }
 }
 
 void
@@ -122,51 +122,51 @@
   if(id < int(tiles.size())
      && tiles[id] != 0
      && tiles[id]->desc == 0)
-    {
-      std::cout << "Warning: Duplicate tile id '" << id << "' ignoring" << std::endl;
-    }
+  {
+    std::cout << "Warning: Duplicate tile id '" << id << "' ignoring" << std::endl;
+  }
   else
-    {      
-      if (id >= int(tiles.size()))
-        tiles.resize(id + 1, 0);
+  {      
+    if (id >= int(tiles.size()))
+      tiles.resize(id + 1, 0);
 
-      delete tiles[id];
-      tiles[id]  = new Tile(colmap);
-      tiles[id]->desc  = 0;
-      tiles[id]->id    = id;
+    delete tiles[id];
+    tiles[id]  = new Tile(colmap);
+    tiles[id]->desc  = 0;
+    tiles[id]->id    = id;
 
-      if (!surface_empty(image, rect.left, rect.top, rect.get_width(), rect.get_height()))
-        {
-          if(packers[color_packer]->is_full())
-            {
-              packers.push_back(new TilePacker(1024, 1024));
-              color_packer = packers.size() - 1;
-            }
+    if (!surface_empty(image, rect.left, rect.top, rect.get_width(), rect.get_height()))
+    {
+      if(packers[color_packer]->is_full())
+      {
+        packers.push_back(new TilePacker(1024, 1024));
+        color_packer = packers.size() - 1;
+      }
           
-          Rectf uv = packers[color_packer]->pack(image, 
-                                                 rect.left, rect.top,
-                                                 rect.get_width(), rect.get_height());
-          tiles[id]->uv      = uv;
-          tiles[id]->packer  = color_packer;
-          tiles[id]->texture = packers[color_packer]->get_texture();
-        }
+      Rectf uv = packers[color_packer]->pack(image, 
+                                             rect.left, rect.top,
+                                             rect.get_width(), rect.get_height());
+      tiles[id]->uv      = uv;
+      tiles[id]->packer  = color_packer;
+      tiles[id]->texture = packers[color_packer]->get_texture();
     }
+  }
 }
 
 Tile*
 TileFactory::create(int id)
 {
   if(id < 0 || id >= static_cast<int>(tiles.size()))
-    {
-      return 0;
-    }
+  {
+    return 0;
+  }
   else
-    {
-      if (tiles[id] && tiles[id]->desc)
-        tiles[id]->desc->load(this);
+  {
+    if (tiles[id] && tiles[id]->desc)
+      tiles[id]->desc->load(this);
 
-      return tiles[id];
-    }
+    return tiles[id];
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/tile/tile_map.cpp
===================================================================
--- trunk/windstille/src/tile/tile_map.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/tile/tile_map.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -28,10 +28,10 @@
 #include "screen/view.hpp"
 #include "scenegraph/vertex_array_drawable.hpp"
 
-TileMap::TileMap(const FileReader& props)
-  : field(),
-    z_pos(),
-    total_time()
+TileMap::TileMap(const FileReader& props) :
+  field(),
+  z_pos(),
+  total_time()
 {
   int width = -1;
   int height = -1;
@@ -44,16 +44,16 @@
   props.get("height", height);
 
   if(width <= 0 || height <= 0) 
-    {
-      throw std::runtime_error("Invalid width or height defined or "
-                               "data defined before width and height");  
-    }
+  {
+    throw std::runtime_error("Invalid width or height defined or "
+                             "data defined before width and height");  
+  }
  
   if(width <= 0 || height <= 0) 
-    {
-      throw std::runtime_error("Invalid width or height defined or "
-                               "data defined before width and height");
-    }
+  {
+    throw std::runtime_error("Invalid width or height defined or "
+                             "data defined before width and height");
+  }
 
   Field<int> tmpfield(width, height);
   
@@ -95,45 +95,45 @@
   std::vector<VertexArrayDrawable*> requests;
   for (int y = rect.top;   y < rect.bottom; ++y)
     for (int x = rect.left; x < rect.right; ++x)
+    {
+      Tile* tile = field(x, y);
+
+      if (!(tile == 0 || tile->packer < 0))
       {
-        Tile* tile = field(x, y);
+        int packer = tile->packer; 
 
-        if (!(tile == 0 || tile->packer < 0))
-          {
-            int packer = tile->packer; 
+        if(packer >= int(requests.size()))
+          requests.resize(packer+1);
 
-            if(packer >= int(requests.size()))
-              requests.resize(packer+1);
-
-            VertexArrayDrawable*& request = requests[packer];
-            if (!request)
-              {
-                request = new VertexArrayDrawable(Vector2f(0, 0), z_pos,
-                                                        sc.color().get_modelview());
-                request->set_mode(GL_QUADS);
-                request->set_blend_func(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-                request->set_texture(tile->texture);
-              }
+        VertexArrayDrawable*& request = requests[packer];
+        if (!request)
+        {
+          request = new VertexArrayDrawable(Vector2f(0, 0), z_pos,
+                                            sc.color().get_modelview());
+          request->set_mode(GL_QUADS);
+          request->set_blend_func(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+          request->set_texture(tile->texture);
+        }
             
-            request->texcoord(tile->uv.left, tile->uv.top);
-            request->vertex(static_cast<float>(x * TILE_SIZE), static_cast<float>(y * TILE_SIZE));
+        request->texcoord(tile->uv.left, tile->uv.top);
+        request->vertex(static_cast<float>(x * TILE_SIZE), static_cast<float>(y * TILE_SIZE));
 
-            request->texcoord(tile->uv.right, tile->uv.top);
-            request->vertex(static_cast<float>(x * TILE_SIZE + TILE_SIZE), static_cast<float>(y * TILE_SIZE));
+        request->texcoord(tile->uv.right, tile->uv.top);
+        request->vertex(static_cast<float>(x * TILE_SIZE + TILE_SIZE), static_cast<float>(y * TILE_SIZE));
             
-            request->texcoord(tile->uv.right, tile->uv.bottom);
-            request->vertex(static_cast<float>(x * TILE_SIZE + TILE_SIZE), static_cast<float>(y * TILE_SIZE + TILE_SIZE));
+        request->texcoord(tile->uv.right, tile->uv.bottom);
+        request->vertex(static_cast<float>(x * TILE_SIZE + TILE_SIZE), static_cast<float>(y * TILE_SIZE + TILE_SIZE));
             
-            request->texcoord(tile->uv.left, tile->uv.bottom);
-            request->vertex(static_cast<float>(x * TILE_SIZE), static_cast<float>(y * TILE_SIZE + TILE_SIZE)); 
-          }
+        request->texcoord(tile->uv.left, tile->uv.bottom);
+        request->vertex(static_cast<float>(x * TILE_SIZE), static_cast<float>(y * TILE_SIZE + TILE_SIZE)); 
       }
+    }
 
   for(std::vector<VertexArrayDrawable*>::iterator i = requests.begin(); i != requests.end(); ++i)
-    {
-      if (*i)
-        sc.color().draw(*i);
-    }
+  {
+    if (*i)
+      sc.color().draw(*i);
+  }
 }
 
 unsigned int
@@ -142,19 +142,19 @@
   if (x < 0 || y < 0 
       || x >= int(field.get_width())
       || y >= int(field.get_height()))
-    {
-      //std::cout << "Out of bounce: " << x << ", " << y << std::endl;
-      return 0;
-    }
+  {
+    //std::cout << "Out of bounce: " << x << ", " << y << std::endl;
+    return 0;
+  }
   else
-    {
-      Tile* tile = field(x, y);
+  {
+    Tile* tile = field(x, y);
       
-      if (tile)
-        return tile->get_colmap();
-      else
-        return 0;     
-    }
+    if (tile)
+      return tile->get_colmap();
+    else
+      return 0;     
+  }
 }
 
 bool
@@ -164,14 +164,14 @@
   int y_pos = int(y) / TILE_SIZE;
 
   if (x < 0 || x_pos >= field.get_width())
-    {
-      //std::cout << "TileMap::is_ground (): Out of range: " << x_pos << " " << y_pos << std::endl;
-      return 1;
-    }
+  {
+    //std::cout << "TileMap::is_ground (): Out of range: " << x_pos << " " << y_pos << std::endl;
+    return 1;
+  }
   else if (y < 0 || y_pos >= field.get_height())
-    {
-      return 0;
-    }
+  {
+    return 0;
+  }
 
   if (field(x_pos, y_pos))
     return field(x_pos, y_pos)->get_colmap() != 0;
@@ -222,27 +222,27 @@
 
   while(x >= 0 && x < get_width() &&
         y >= 0 && y < get_height())
+  {
+    Tile* tile = field(x, y);  
+    if (tile && tile->colmap)
     {
-      Tile* tile = field(x, y);  
-      if (tile && tile->colmap)
-        {
-          return pos + Vector2f(t * direction.x, t * direction.y);
-        }
+      return pos + Vector2f(t * direction.x, t * direction.y);
+    }
 
-      // move one tile
-      if (tMaxX < tMaxY)
-        {
-          t = tMaxX;
-          tMaxX += tDeltaX;
-          x = x + step_x;
-        }
-      else 
-        {
-          t = tMaxY;
-          tMaxY += tDeltaY;
-          y = y + step_y;
-        }
+    // move one tile
+    if (tMaxX < tMaxY)
+    {
+      t = tMaxX;
+      tMaxX += tDeltaX;
+      x = x + step_x;
     }
+    else 
+    {
+      t = tMaxY;
+      tMaxY += tDeltaY;
+      y = y + step_y;
+    }
+  }
 
   // Ray got out of the map
   return pos + Vector2f(t * direction.x, t * direction.y);

Modified: trunk/windstille/src/tile/tile_packer.cpp
===================================================================
--- trunk/windstille/src/tile/tile_packer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/tile/tile_packer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -46,8 +46,8 @@
   {}
 };
 
-TilePacker::TilePacker(int width, int height)
-  : impl(new TilePackerImpl())
+TilePacker::TilePacker(int width, int height) :
+  impl(new TilePackerImpl())
 {
   impl->x_pos = 0;
   impl->y_pos = 0;
@@ -103,10 +103,10 @@
   // when blending
   impl->x_pos += TILE_RESOLUTION + 2; 
   if (impl->x_pos + TILE_RESOLUTION > impl->width)
-    {
-      impl->x_pos = 0;
-      impl->y_pos += TILE_RESOLUTION + 2;
-    }
+  {
+    impl->x_pos = 0;
+    impl->y_pos += TILE_RESOLUTION + 2;
+  }
 
   return rect;
 }

Modified: trunk/windstille/src/util/baby_xml.cpp
===================================================================
--- trunk/windstille/src/util/baby_xml.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/util/baby_xml.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -40,29 +40,29 @@
     std::string content;
     
     while(!eof())
+    {
+      char c = look_ahead();
+      switch(c)
       {
-        char c = look_ahead();
-        switch(c)
+        case '<':
+          if (!content.empty())
           {
-          case '<':
-            if (!content.empty())
-              {
-                xml->add_node(BabyXML::Node(BabyXML::Node::TEXT, content));
-                content = "";
-              }
-            read_element();
-            break;
+            xml->add_node(BabyXML::Node(BabyXML::Node::TEXT, content));
+            content = "";
+          }
+          read_element();
+          break;
 
-          case '&':
-            content += read_entity();
-            break;
+        case '&':
+          content += read_entity();
+          break;
 
-          default:
-            content += c;
-            incr_cursor();
-            break;
-          }
+        default:
+          content += c;
+          incr_cursor();
+          break;
       }
+    }
 
     if (!content.empty())
       xml->add_node(BabyXML::Node(BabyXML::Node::TEXT, content));
@@ -71,30 +71,30 @@
   void skip_space()
   {
     while(true) 
-      {
-        char c = look_ahead();
-        if (c != ' ' && c != '\t') {
-          break;
-        } else {
-          incr_cursor();
-        }
+    {
+      char c = look_ahead();
+      if (c != ' ' && c != '\t') {
+        break;
+      } else {
+        incr_cursor();
       }
+    }
   }
 
   void read_char(char expect)
   {
     char c = look_ahead();
     if (c != expect)
-      {
-        std::ostringstream str;
-        str << "Syntax Error:" << line_no << ":" << column_no 
-            << ": Syntax error: read_char(): expected '" << expect << "' got '" << c << "'";
-        throw std::runtime_error(str.str());
-      }
+    {
+      std::ostringstream str;
+      str << "Syntax Error:" << line_no << ":" << column_no 
+          << ": Syntax error: read_char(): expected '" << expect << "' got '" << c << "'";
+      throw std::runtime_error(str.str());
+    }
     else
-      {
-        incr_cursor();
-      }
+    {
+      incr_cursor();
+    }
   }
 
   void read_element()
@@ -103,17 +103,17 @@
 
     read_char('<');
     if (look_ahead() == '/') 
-      {
-        node.type = BabyXML::Node::END_TAG;
-        incr_cursor();
-        node.content = read_identifer();
-      }
+    {
+      node.type = BabyXML::Node::END_TAG;
+      incr_cursor();
+      node.content = read_identifer();
+    }
     else
-      {
-        node.type = BabyXML::Node::START_TAG;
-        node.content    = read_identifer();
-        node.attributes = read_attributes();
-      }
+    {
+      node.type = BabyXML::Node::START_TAG;
+      node.content    = read_identifer();
+      node.attributes = read_attributes();
+    }
     
     skip_space();
     read_char('>');
@@ -126,40 +126,40 @@
   {
     char start = look_ahead();
     if (start != '\'' && start != '"')
-      {
-        std::ostringstream str;
-        str << "Syntax Error:" << line_no << ":" << column_no 
-            << ": Syntax error: read_string(): expected ' or \" got '" << start << "'";
-        throw std::runtime_error(str.str());
-      }
+    {
+      std::ostringstream str;
+      str << "Syntax Error:" << line_no << ":" << column_no 
+          << ": Syntax error: read_string(): expected ' or \" got '" << start << "'";
+      throw std::runtime_error(str.str());
+    }
     incr_cursor();
     
     std::string content;
     while(true)
+    {
+      char c = look_ahead();
+      if (c == '"' || c == '\'') 
       {
-        char c = look_ahead();
-        if (c == '"' || c == '\'') 
-          {
-            if (c != start)
-              {
-                std::ostringstream str;
-                str << "Syntax Error:" << line_no << ":" << column_no 
-                    << ": Syntax error: read_string(): quote mismatch";
-                throw std::runtime_error(str.str());
-              }
-            incr_cursor();
-            break;
-          } 
-        else if (c == '&') 
-          {
-            content += read_entity();
-          }
-        else 
-          {
-            incr_cursor();
-            content += c;
-          }
+        if (c != start)
+        {
+          std::ostringstream str;
+          str << "Syntax Error:" << line_no << ":" << column_no 
+              << ": Syntax error: read_string(): quote mismatch";
+          throw std::runtime_error(str.str());
+        }
+        incr_cursor();
+        break;
+      } 
+      else if (c == '&') 
+      {
+        content += read_entity();
       }
+      else 
+      {
+        incr_cursor();
+        content += c;
+      }
+    }
     return content;
   }
 
@@ -176,32 +176,32 @@
     else if (identifer == "lt")
       return '<';
     else
-      {
-        std::ostringstream str;
-        str << "Syntax Error:" << line_no << ":" << column_no << ": Unknown entity: '&" + identifer + ";'";
-        throw std::runtime_error(str.str());
-      }
+    {
+      std::ostringstream str;
+      str << "Syntax Error:" << line_no << ":" << column_no << ": Unknown entity: '&" + identifer + ";'";
+      throw std::runtime_error(str.str());
+    }
   }
   
   std::vector<BabyXML::Attribute> read_attributes()
   {
     std::vector<BabyXML::Attribute> attributes;
     while(true) 
+    {
+      skip_space();
+
+      char c = look_ahead();
+      if (c == '>' || c == '&' || c == '<' || c == ';')
       {
-        skip_space();
+        break;
+      }
 
-        char c = look_ahead();
-        if (c == '>' || c == '&' || c == '<' || c == ';')
-          {
-            break;
-          }
+      attributes.push_back(BabyXML::Attribute());
 
-        attributes.push_back(BabyXML::Attribute());
-
-        attributes.back().name = read_identifer();
-        read_char('=');
-        attributes.back().value = read_string();
-      }
+      attributes.back().name = read_identifer();
+      read_char('=');
+      attributes.back().value = read_string();
+    }
     return attributes;
   }
 
@@ -209,22 +209,22 @@
   {
     std::string identifer;
     while(true) 
-      {
-        char c = look_ahead();
-        if (c == '<' || c == '>' || c == '&' || c == ';' || c == ' ' || c == '\t' || c == '=') {
-          break;
-        } else {
-          identifer += c;
-          incr_cursor();
-        }
+    {
+      char c = look_ahead();
+      if (c == '<' || c == '>' || c == '&' || c == ';' || c == ' ' || c == '\t' || c == '=') {
+        break;
+      } else {
+        identifer += c;
+        incr_cursor();
       }
+    }
 
     if (identifer.empty())
-      {
-        std::ostringstream str;
-        str << "Syntax Error:" << line_no << ":" << column_no << ": Identifer is empty";
-        throw std::runtime_error(str.str());
-      }
+    {
+      std::ostringstream str;
+      str << "Syntax Error:" << line_no << ":" << column_no << ": Identifer is empty";
+      throw std::runtime_error(str.str());
+    }
 
     return identifer;
   }
@@ -237,11 +237,11 @@
   char look_ahead()
   {
     if (cursor >= int(text.size()))
-      {
-        std::ostringstream str;
-        str << "Syntax Error:" << line_no << ":" << column_no << ": Premature end of text";
-        throw std::runtime_error(str.str());
-      }
+    {
+      std::ostringstream str;
+      str << "Syntax Error:" << line_no << ":" << column_no << ": Premature end of text";
+      throw std::runtime_error(str.str());
+    }
 
     return text[cursor];
   }
@@ -250,14 +250,14 @@
   {
     cursor += 1;
     if (text[cursor] == '\n')
-      {
-        line_no += 1;
-        column_no = 0;
-      }
+    {
+      line_no += 1;
+      column_no = 0;
+    }
     else
-      {
-        column_no += 1;
-      }
+    {
+      column_no += 1;
+    }
   }
 
 private:
@@ -288,33 +288,33 @@
 int main(int argc, char** argv)
 {
   if (argc != 2)
-    {
-      std::cout << "Usage: " << argv[0] << " STRING" << std::endl;
-    }
+  {
+    std::cout << "Usage: " << argv[0] << " STRING" << std::endl;
+  }
   else
+  {
+    // BabyXML xml("<strong size='10'>Hello &lt; World&gt; <b>&quot;blabla&quot;</b> Blablub</strong>");
+    BabyXML xml(argv[1]);
+
+    for(BabyXML::iterator i = xml.begin(); i != xml.end(); ++i)
     {
-      // BabyXML xml("<strong size='10'>Hello &lt; World&gt; <b>&quot;blabla&quot;</b> Blablub</strong>");
-      BabyXML xml(argv[1]);
+      if (i->type == BabyXML::Node::START_TAG)
+        std::cout << "STARTTAG: ";
+      else if (i->type == BabyXML::Node::END_TAG)
+        std::cout << "ENDTAG: ";
+      else if (i->type == BabyXML::Node::TEXT)
+        std::cout << "TEXT: ";
 
-      for(BabyXML::iterator i = xml.begin(); i != xml.end(); ++i)
-        {
-          if (i->type == BabyXML::Node::START_TAG)
-            std::cout << "STARTTAG: ";
-          else if (i->type == BabyXML::Node::END_TAG)
-            std::cout << "ENDTAG: ";
-          else if (i->type == BabyXML::Node::TEXT)
-            std::cout << "TEXT: ";
+      std::cout << "'" << i->content << "'";
 
-          std::cout << "'" << i->content << "'";
+      for(std::vector<BabyXML::Attribute>::iterator j = i->attributes.begin(); j != i->attributes.end(); ++j)
+      {
+        std::cout << " " << j->name << "='" << j->value << "'";
+      }
 
-          for(std::vector<BabyXML::Attribute>::iterator j = i->attributes.begin(); j != i->attributes.end(); ++j)
-            {
-              std::cout << " " << j->name << "='" << j->value << "'";
-            }
-
-          std::cout << std::endl;
-        }
+      std::cout << std::endl;
     }
+  }
 }
 #endif
 

Modified: trunk/windstille/src/util/command_line.cpp
===================================================================
--- trunk/windstille/src/util/command_line.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/util/command_line.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -36,60 +36,60 @@
 
 CommandLine::~CommandLine()
 {
-	delete impl;
+  delete impl;
 }
 
 void CommandLine::parse_args(int argc, char** argv)
 {
-	impl->parse_args(argc, argv);
+  impl->parse_args(argc, argv);
 }
 
 void CommandLine::print_help()
 {
-	impl->print_help();
+  impl->print_help();
 }
 
 void CommandLine::set_help_indent(int i)
 {
-	impl->set_help_indent(i);
+  impl->set_help_indent(i);
 }
 
 void CommandLine::add_usage(const std::string& usage)
 {
-	impl->add_usage(usage);
+  impl->add_usage(usage);
 }
 
 void CommandLine::add_doc(const std::string& doc)
 {
-	impl->add_doc(doc);
+  impl->add_doc(doc);
 }
 
 void CommandLine::add_group(const std::string& grouptopic)
 {
-	impl->add_group(grouptopic);
+  impl->add_group(grouptopic);
 }
 
 void CommandLine::add_option(
-	int key, 
-	const std::string& long_option, 
-	const std::string& argument,
-	const std::string& help,
-	bool visible)
+  int key, 
+  const std::string& long_option, 
+  const std::string& argument,
+  const std::string& help,
+  bool visible)
 {
-	impl->add_option(key, long_option, argument, help, visible);
+  impl->add_option(key, long_option, argument, help, visible);
 }
 
 bool CommandLine::next()
 {
-	return impl->next();
+  return impl->next();
 }
 
 int CommandLine::get_key()
 {
-	return impl->get_key();
+  return impl->get_key();
 }
 
 std::string CommandLine::get_argument()
 {
-	return impl->get_argument();
+  return impl->get_argument();
 }

Modified: trunk/windstille/src/util/command_line.hpp
===================================================================
--- trunk/windstille/src/util/command_line.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/util/command_line.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -81,77 +81,77 @@
 //- (aka filenames in most programs).</p>
 class CommandLine
 {
-//! Construction:
+  //! Construction:
 public:
-	CommandLine();
+  CommandLine();
 
-	~CommandLine();
+  ~CommandLine();
 
-//! Attributes:
+  //! Attributes:
 public:
-	enum
-	{
-		REST_ARG  = -2
-	};
+  enum
+  {
+    REST_ARG  = -2
+  };
 
-	//: Return the key of the current option
-	int get_key();
+  //: Return the key of the current option
+  int get_key();
 
-	//: Return the argument to the current option
-	std::string get_argument();
+  //: Return the argument to the current option
+  std::string get_argument();
 
-//! Operations:
+  //! Operations:
 public:
-	//: Change the indention used for the help message, default is 18
-	void set_help_indent(int i);
+  //: Change the indention used for the help message, default is 18
+  void set_help_indent(int i);
 
-	//: Add a usage line to the help output, usage is for example
-	//: "[OPTIONS]... FILE", the program name will get appended
-	//: automatically
-	void add_usage(const std::string& usage);
+  //: Add a usage line to the help output, usage is for example
+  //: "[OPTIONS]... FILE", the program name will get appended
+  //: automatically
+  void add_usage(const std::string& usage);
 
-	//: Adds extra documentation to the help output, should only be
-	//: used at the beginning or at the end, to
-	void add_doc(const std::string& doc);
-	
-	//: Starts a new group of options, the grouptopic gets printed
-	//: above the group of options in the print_help() output
-	void add_group(const std::string& grouptopic);
+  //: Adds extra documentation to the help output, should only be
+  //: used at the beginning or at the end, to
+  void add_doc(const std::string& doc);
+        
+  //: Starts a new group of options, the grouptopic gets printed
+  //: above the group of options in the print_help() output
+  void add_group(const std::string& grouptopic);
   
-	//: Adds a option to the parser
-	//param key: a letter for a short-option or a numeric value
-	//param key: larger than 255 that identifies the option
-	//param long_option: the long name of this option or "" if non
-	//param long_option: should be used for this option
-	//param argument: the type of the argument that this option
-	//param argument: requires (i.e. FILE, SIZE, WIDTH, etc.) or "" if no argument is
-	//param argument: required
-	//param help: the help string for this option
-	//param visible: true if the option should be listed in the help
-	//param visible: output, false will not list it in the help output which might
-	//param visible: be usefull for cheat-options or backward-compability options
-	//param visible: than would only clutter the help output
-	void add_option(
-		int key,
-		const std::string& long_option, 
-		const std::string& argument,
-		const std::string& help,
-		bool visible = true);
-	
-	//: Parse the options arcording to the options added with
-	//: add_option(), result of the parsing is accessible via
-	//: next() and get_key()/get_argument()
-	void parse_args(int argc, char** argv);
+  //: Adds a option to the parser
+  //param key: a letter for a short-option or a numeric value
+  //param key: larger than 255 that identifies the option
+  //param long_option: the long name of this option or "" if non
+  //param long_option: should be used for this option
+  //param argument: the type of the argument that this option
+  //param argument: requires (i.e. FILE, SIZE, WIDTH, etc.) or "" if no argument is
+  //param argument: required
+  //param help: the help string for this option
+  //param visible: true if the option should be listed in the help
+  //param visible: output, false will not list it in the help output which might
+  //param visible: be usefull for cheat-options or backward-compability options
+  //param visible: than would only clutter the help output
+  void add_option(
+    int key,
+    const std::string& long_option, 
+    const std::string& argument,
+    const std::string& help,
+    bool visible = true);
+        
+  //: Parse the options arcording to the options added with
+  //: add_option(), result of the parsing is accessible via
+  //: next() and get_key()/get_argument()
+  void parse_args(int argc, char** argv);
 
-	//: Print the help output, normaly done via a --help option
-	void print_help();
+  //: Print the help output, normaly done via a --help option
+  void print_help();
 
-	//: Goto the next option
-	bool next();
+  //: Goto the next option
+  bool next();
 
-//! Implementation:
+  //! Implementation:
 private:
-	CommandLine_Generic* impl;
+  CommandLine_Generic* impl;
 
 private:
   CommandLine(const CommandLine&);

Modified: trunk/windstille/src/util/command_line_generic.cpp
===================================================================
--- trunk/windstille/src/util/command_line_generic.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/util/command_line_generic.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -53,124 +53,124 @@
   programm = argv[0];
 
   for(int i = 1; i < argc; ++i) 
+  {
+    if (argv[i][0] == '-') 
     {
-      if (argv[i][0] == '-') 
+      if (argv[i][1] == '-') 
+      {
+        // We got a long option
+        if (argv[i][2] == '\0') { 
+          // Got a '--', so we stop evaluating arguments
+          ++i;
+          while(i < argc) 
+          {
+            read_option(CommandLine::REST_ARG, argv[i]);
+            ++i;
+          }
+        } 
+        else
         {
-          if (argv[i][1] == '-') 
-            {
-              // We got a long option
-              if (argv[i][2] == '\0') { 
-                // Got a '--', so we stop evaluating arguments
-                ++i;
-                while(i < argc) 
-                  {
-                    read_option(CommandLine::REST_ARG, argv[i]);
-                    ++i;
-                  }
-              } 
-              else
-                {
-                  std::string opt = argv[i] + 2;
-                  std::string long_opt;
-                  std::string long_opt_arg;
+          std::string opt = argv[i] + 2;
+          std::string long_opt;
+          std::string long_opt_arg;
 
-                  std::string::size_type pos = opt.find('=');
+          std::string::size_type pos = opt.find('=');
 
-                  if (pos != std::string::npos) 
-                    {
-                      long_opt = opt.substr(0, pos);
-                      long_opt_arg = opt.substr(pos+1);
-                    }
-                  else 
-                    {
-                      long_opt = opt;
-                    }
+          if (pos != std::string::npos) 
+          {
+            long_opt = opt.substr(0, pos);
+            long_opt_arg = opt.substr(pos+1);
+          }
+          else 
+          {
+            long_opt = opt;
+          }
 
-                  // Long Option
-                  Option* option = lookup_long_option(long_opt);
+          // Long Option
+          Option* option = lookup_long_option(long_opt);
 
-                  if (option) 
-                    {
-                      if (option->argument.empty()) 
-                        {
-                          read_option(option->key, "");
-                        } 
-                      else
-                        {
-                          if (pos != std::string::npos) 
-                            {
-                              read_option(option->key, long_opt_arg);
-                            }
-                          else
-                            {            
-                              if (i == argc - 1) 
-                                {
-                                  throw std::runtime_error("option '" + std::string(argv[i]) + "' requires an argument");
-                                }
-                              else 
-                                {
-                                  read_option(option->key, argv[i + 1]);
-                                  ++i;
-                                }
-                            }
-                        }
-                    }
-                  else
-                    {
-                      throw std::runtime_error("unrecognized option '" + std::string(argv[i]) + "'");
-                    }
-                }
+          if (option) 
+          {
+            if (option->argument.empty()) 
+            {
+              read_option(option->key, "");
             } 
-          else 
+            else
             {
-              // We got a short option
-              char* p = argv[i] + 1;
+              if (pos != std::string::npos) 
+              {
+                read_option(option->key, long_opt_arg);
+              }
+              else
+              {            
+                if (i == argc - 1) 
+                {
+                  throw std::runtime_error("option '" + std::string(argv[i]) + "' requires an argument");
+                }
+                else 
+                {
+                  read_option(option->key, argv[i + 1]);
+                  ++i;
+                }
+              }
+            }
+          }
+          else
+          {
+            throw std::runtime_error("unrecognized option '" + std::string(argv[i]) + "'");
+          }
+        }
+      } 
+      else 
+      {
+        // We got a short option
+        char* p = argv[i] + 1;
           
-              if (*p != '\0') {
-                // Handle option chains
-                while (*p) 
-                  {
-                    // Short option(s)
-                    Option* option = lookup_short_option(*p);
+        if (*p != '\0') {
+          // Handle option chains
+          while (*p) 
+          {
+            // Short option(s)
+            Option* option = lookup_short_option(*p);
 
-                    if (option) 
-                      {
-                        if (option->argument.empty()) 
-                          {
-                            read_option(option->key, "");
-                          } 
-                        else 
-                          {
-                            if (i == argc - 1 || *(p+1) != '\0') 
-                              {
-                                // No more arguments
-                                throw std::runtime_error("option requires an argument -- " + std::string(1, *p));
-                              }
-                            else
-                              {
-                                read_option(option->key, argv[i + 1]);
-                                ++i;
-                              }
-                          }
-                      } 
-                    else 
-                      {
-                        throw std::runtime_error("invalid option -- " + std::string(1, *p));
-                      }
-                    ++p; 
-                  }
+            if (option) 
+            {
+              if (option->argument.empty()) 
+              {
+                read_option(option->key, "");
               } 
-              else
+              else 
+              {
+                if (i == argc - 1 || *(p+1) != '\0') 
                 {
-                  read_option(CommandLine::REST_ARG, "-");
-                } 
+                  // No more arguments
+                  throw std::runtime_error("option requires an argument -- " + std::string(1, *p));
+                }
+                else
+                {
+                  read_option(option->key, argv[i + 1]);
+                  ++i;
+                }
+              }
+            } 
+            else 
+            {
+              throw std::runtime_error("invalid option -- " + std::string(1, *p));
             }
+            ++p; 
+          }
         } 
-      else
+        else
         {
-          read_option(CommandLine::REST_ARG, argv[i]);
-        }
+          read_option(CommandLine::REST_ARG, "-");
+        } 
+      }
+    } 
+    else
+    {
+      read_option(CommandLine::REST_ARG, argv[i]);
     }
+  }
 
   current_option = parsed_options.end();
 }
@@ -178,20 +178,20 @@
 CommandLine_Generic::Option *CommandLine_Generic::lookup_short_option(char short_option)
 {
   for(Options::iterator i = options.begin(); i != options.end(); ++i)
-    {
-      if (i->key == short_option)
-        return &(*i);
-    }
+  {
+    if (i->key == short_option)
+      return &(*i);
+  }
   return 0;
 }
 
 CommandLine_Generic::Option *CommandLine_Generic::lookup_long_option(const std::string& long_option)
 {
   for(Options::iterator i = options.begin(); i != options.end(); ++i)
-    {
-      if (i->long_option == long_option)
-        return &*i;
-    }
+  {
+    if (i->long_option == long_option)
+      return &*i;
+  }
   return 0;
 }
 
@@ -209,60 +209,60 @@
 {
   bool first_usage = true;
   for(Options::iterator i = options.begin(); i != options.end(); ++i)
+  {
+    if (i->visible)
     {
-      if (i->visible)
+      if (i->key == USAGE) 
+      {
+        if (first_usage) 
         {
-          if (i->key == USAGE) 
-            {
-              if (first_usage) 
-                {
-                  std::cout << "Usage: " << programm << " " <<  i->help << std::endl; 
-                  first_usage = false;
-                }
-              else
-                {
-                  std::cout << "or:    " << programm << " " << i->help << std::endl; 
-                }
-            } 
-          else if (i->key == GROUP) 
-            {
-              if (i != options.begin())
-                std::cout << std::endl;
-              std::cout << i->help << std::endl;
-            }
-          else if (i->key == DOC) 
-            {
-              if (i != options.begin())
-                std::cout << std::endl;
-              std::cout << i->help << std::endl;
-            }
-          else 
-            {
-              char option[256]   = { 0 };
-              char argument[256] = { 0 };
+          std::cout << "Usage: " << programm << " " <<  i->help << std::endl; 
+          first_usage = false;
+        }
+        else
+        {
+          std::cout << "or:    " << programm << " " << i->help << std::endl; 
+        }
+      } 
+      else if (i->key == GROUP) 
+      {
+        if (i != options.begin())
+          std::cout << std::endl;
+        std::cout << i->help << std::endl;
+      }
+      else if (i->key == DOC) 
+      {
+        if (i != options.begin())
+          std::cout << std::endl;
+        std::cout << i->help << std::endl;
+      }
+      else 
+      {
+        char option[256]   = { 0 };
+        char argument[256] = { 0 };
 
-              if (i->key > 255 || i->key < 0)
-                snprintf(option, 256, "--%s", i->long_option.c_str());
-              else if (i->long_option.empty())
-                snprintf(option, 256, "-%c", char(i->key));
-              else
-                snprintf(option, 256, "-%c, --%s", char(i->key), i->long_option.c_str());
+        if (i->key > 255 || i->key < 0)
+          snprintf(option, 256, "--%s", i->long_option.c_str());
+        else if (i->long_option.empty())
+          snprintf(option, 256, "-%c", char(i->key));
+        else
+          snprintf(option, 256, "-%c, --%s", char(i->key), i->long_option.c_str());
 
-              if (!i->argument.empty())
-                {
-                  if (i->long_option.empty())
-                    snprintf(argument, 256, " %s", i->argument.c_str());
-                  else
-                    snprintf(argument, 256, "=%s", i->argument.c_str());
-                }
+        if (!i->argument.empty())
+        {
+          if (i->long_option.empty())
+            snprintf(argument, 256, " %s", i->argument.c_str());
+          else
+            snprintf(argument, 256, "=%s", i->argument.c_str());
+        }
 
-              std::cout << "  " 
-                        << std::setiosflags(std::ios::left) << std::setw(help_indent)
-                        << (std::string(option) + std::string(argument)) << std::setw(0)
-                        << " " << i->help << std::endl;
-            }
-        }
+        std::cout << "  " 
+                  << std::setiosflags(std::ios::left) << std::setw(help_indent)
+                  << (std::string(option) + std::string(argument)) << std::setw(0)
+                  << " " << i->help << std::endl;
+      }
     }
+  }
   std::cout << std::endl;
 }
 
@@ -300,10 +300,10 @@
 }
 
 void CommandLine_Generic::add_option(int key, 
-                                        const std::string& long_option, 
-                                        const std::string& argument,
-                                        const std::string& help,
-                                        bool visible)
+                                     const std::string& long_option, 
+                                     const std::string& argument,
+                                     const std::string& help,
+                                     bool visible)
 {
   Option option;
 
@@ -319,14 +319,14 @@
 bool CommandLine_Generic::next()
 {
   if (current_option == parsed_options.end()) 
-    {
-      (current_option = parsed_options.begin());
-      return current_option != parsed_options.end();
-    }
+  {
+    (current_option = parsed_options.begin());
+    return current_option != parsed_options.end();
+  }
   else
-    {
-      return (++current_option) != parsed_options.end();
-    }
+  {
+    return (++current_option) != parsed_options.end();
+  }
 }
 
 int CommandLine_Generic::get_key()

Modified: trunk/windstille/src/util/command_line_generic.hpp
===================================================================
--- trunk/windstille/src/util/command_line_generic.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/util/command_line_generic.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -39,82 +39,82 @@
 class CommandLine_Generic
 {
 private:
-	int help_indent;
+  int help_indent;
 
-	std::string programm;
+  std::string programm;
 
-	struct Option 
-	{
-		int key;
-		std::string help;
-		std::string long_option;
-		std::string argument;
-		bool visible;
+  struct Option 
+  {
+    int key;
+    std::string help;
+    std::string long_option;
+    std::string argument;
+    bool visible;
 
-          Option()
-            : key(),
-              help(),
-              long_option(),
-              argument(),
-              visible()
-          {}
-	};
+    Option()
+      : key(),
+        help(),
+        long_option(),
+        argument(),
+        visible()
+    {}
+  };
   
-	typedef std::vector<Option> Options;
-	Options options;
+  typedef std::vector<Option> Options;
+  Options options;
 
-	struct ParsedOption
-	{
-		int key;
-		std::string argument;
+  struct ParsedOption
+  {
+    int key;
+    std::string argument;
 
-          ParsedOption()
-            : key(),
-              argument()
-          {}
-	};
+    ParsedOption()
+      : key(),
+        argument()
+    {}
+  };
 
-	typedef std::vector<ParsedOption> ParsedOptions;
-	ParsedOptions parsed_options;
-	ParsedOptions::iterator current_option;
+  typedef std::vector<ParsedOption> ParsedOptions;
+  ParsedOptions parsed_options;
+  ParsedOptions::iterator current_option;
 
-	enum
-	{
-		GROUP     = -3,
-		DOC       = -4,
-		USAGE     = -5
-	};
+  enum
+  {
+    GROUP     = -3,
+    DOC       = -4,
+    USAGE     = -5
+  };
 
 public:  
-	CommandLine_Generic();
+  CommandLine_Generic();
 
-	void set_help_indent(int i) { help_indent = i; }
+  void set_help_indent(int i) { help_indent = i; }
 
-	void add_usage(const std::string& usage);
-	void add_doc(const std::string& doc);
-	void add_group(const std::string& grouptopic);
+  void add_usage(const std::string& usage);
+  void add_doc(const std::string& doc);
+  void add_group(const std::string& grouptopic);
   
-	void add_option(int key,
-						 const std::string& long_option, 
-						 const std::string& argument,
-						 const std::string& help,
-						 bool visible = true);
+  void add_option(int key,
+                  const std::string& long_option, 
+                  const std::string& argument,
+                  const std::string& help,
+                  bool visible = true);
 
-	void parse_args(int argc, char** argv);
-	void print_help();
+  void parse_args(int argc, char** argv);
+  void print_help();
   
-	bool next();
-	int get_key();
-	std::string get_argument();
+  bool next();
+  int get_key();
+  std::string get_argument();
 
 private:
-	void read_option(int id, const std::string& argument);
+  void read_option(int id, const std::string& argument);
 
-	/** Find the Option structure that matches \a short_option */
-	Option* lookup_short_option(char short_option);
+  /** Find the Option structure that matches \a short_option */
+  Option* lookup_short_option(char short_option);
 
-	/** Find the Option structure that matches \a long_option */
-	Option* lookup_long_option (const std::string& long_option);
+  /** Find the Option structure that matches \a long_option */
+  Option* lookup_long_option (const std::string& long_option);
 };
 
 #endif

Modified: trunk/windstille/src/util/file_reader.cpp
===================================================================
--- trunk/windstille/src/util/file_reader.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/util/file_reader.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -48,21 +48,21 @@
 {
   lisp::Lisp* root = lisp::Parser::parse(stream, filename);
   if (!root)
-    {
-      std::ostringstream msg;
-      msg << "'" << filename << "': file not found";
-      throw std::runtime_error(msg.str());
-    }
+  {
+    std::ostringstream msg;
+    msg << "'" << filename << "': file not found";
+    throw std::runtime_error(msg.str());
+  }
   else if (root && root->get_type() == lisp::Lisp::TYPE_LIST && root->get_list_size() >= 1)
-    {
-      return SExprFileReader(root, root->get_list_elem(0));
-    }
+  {
+    return SExprFileReader(root, root->get_list_elem(0));
+  }
   else
-    {
-      std::ostringstream msg;
-      msg << "'" << filename << "': not a valid sexpr file";
-      throw std::runtime_error(msg.str());
-    }  
+  {
+    std::ostringstream msg;
+    msg << "'" << filename << "': not a valid sexpr file";
+    throw std::runtime_error(msg.str());
+  }  
 }
 
 FileReader::FileReader(boost::shared_ptr<FileReaderImpl> impl_)

Modified: trunk/windstille/src/util/file_reader.hpp
===================================================================
--- trunk/windstille/src/util/file_reader.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/util/file_reader.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -58,10 +58,10 @@
   {
     std::string str;
     if (get(name, str))
-      {
-        value = enum2string(str);
-        return true;
-      }
+    {
+      value = enum2string(str);
+      return true;
+    }
 
     return false;
   }

Modified: trunk/windstille/src/util/file_writer.cpp
===================================================================
--- trunk/windstille/src/util/file_writer.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/util/file_writer.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -93,14 +93,14 @@
 {
   std::ostringstream str;
   for(std::string::const_iterator i = in.begin(); i != in.end(); ++i)
-    {
-      if (*i == '"')
-        str << "\\\"";
-      else if (*i == '\\')
-        str << "\\\\";
-      else
-        str << *i;
-    }
+  {
+    if (*i == '"')
+      str << "\\\"";
+    else if (*i == '\\')
+      str << "\\\\";
+    else
+      str << *i;
+  }
   return str.str();
 }
 

Modified: trunk/windstille/src/util/getter.cpp
===================================================================
--- trunk/windstille/src/util/getter.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/util/getter.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -92,25 +92,25 @@
   std::vector<float> floats;
   if (reader.get(name, floats)) {
     if (floats.size() == 3)
-      {
-        value.r = floats[0];
-        value.g = floats[1];
-        value.b = floats[2];
-        value.a = 1.0f;
-        return true;
-      }
+    {
+      value.r = floats[0];
+      value.g = floats[1];
+      value.b = floats[2];
+      value.a = 1.0f;
+      return true;
+    }
     else if (floats.size() == 4)
-      {
-        value.r = floats[0];
-        value.g = floats[1];
-        value.b = floats[2];
-        value.a = floats[3];
-        return true;
-      }
+    {
+      value.r = floats[0];
+      value.g = floats[1];
+      value.b = floats[2];
+      value.a = floats[3];
+      return true;
+    }
     else
-      {
-        return false;
-      }
+    {
+      return false;
+    }
   } else {
     return false;
   } 

Modified: trunk/windstille/src/util/handle.hpp
===================================================================
--- trunk/windstille/src/util/handle.hpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/util/handle.hpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -34,8 +34,8 @@
 
 public:
   Handle(HandleManager<Data>* manager_, 
-             unsigned int index_,
-             unsigned int magic_)
+         unsigned int index_,
+         unsigned int magic_)
     : manager(manager_),
       index(index_),
       magic(magic_)
@@ -77,37 +77,37 @@
   Handle<Data> aquire(const Data& data)
   {
     if (free_list.empty()) 
-      {
-        data_lst.push_back(data);
-        magic_lst.push_back(next_magic);
+    {
+      data_lst.push_back(data);
+      magic_lst.push_back(next_magic);
 
-        return Handle<Data>(this, next_magic++);
-      }
+      return Handle<Data>(this, next_magic++);
+    }
     else
-      {
-        unsigned int index = free_list.back();
-        free_list.pop_back();
+    {
+      unsigned int index = free_list.back();
+      free_list.pop_back();
 
-        data_lst[index]  = data;
-        magic_lst[index] = next_magic;
+      data_lst[index]  = data;
+      magic_lst[index] = next_magic;
 
-        return Handle<Data>(this, next_magic++);
-      }
+      return Handle<Data>(this, next_magic++);
+    }
   }
 
   void release(const Handle<Data>& handle)
   {
     if (valid(handle))
-      {
-        delete data_lst[handle.index];
-        data_lst[handle.index] = 0;
+    {
+      delete data_lst[handle.index];
+      data_lst[handle.index] = 0;
 
-        free_list.push_back(handle.index);
-      }
+      free_list.push_back(handle.index);
+    }
     else
-      {
-        // invalid handle
-      }
+    {
+      // invalid handle
+    }
   }
   
   bool valid(const Handle<Data>& handle)
@@ -119,13 +119,13 @@
   Data& dereference(const Handle<Data>& handle)
   {
     if (valid)
-      {
-        return data_lst[handle.index];
-      }
+    {
+      return data_lst[handle.index];
+    }
     else
-      {
-        // invalid handle
-      }
+    {
+      // invalid handle
+    }
   }
 };
 

Modified: trunk/windstille/src/util/pathname.cpp
===================================================================
--- trunk/windstille/src/util/pathname.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/util/pathname.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -32,7 +32,7 @@
 }
 
 static void add_overrides(const boost::filesystem::path& path, const boost::filesystem::path& base, 
-                         Pathname::Overrides* overrides)
+                          Pathname::Overrides* overrides)
 {
   boost::filesystem::directory_iterator end_i; // default construction yields past-the-end
 

Modified: trunk/windstille/src/util/response_curve.cpp
===================================================================
--- trunk/windstille/src/util/response_curve.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/util/response_curve.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -36,22 +36,22 @@
 ResponseCurve::get(float v)
 {
   if (samples.size() == 1)
-    {
-      return samples[0];
-    }
+  {
+    return samples[0];
+  }
   else
-    {
-      v = math::mid(i_min, v, i_max);
+  {
+    v = math::mid(i_min, v, i_max);
 
-      int   bucket_count = samples.size() - 1;
-      float bucket_size  = (i_max - i_min) / static_cast<float>(bucket_count);
+    int   bucket_count = samples.size() - 1;
+    float bucket_size  = (i_max - i_min) / static_cast<float>(bucket_count);
       
-      int bucket_index = int((v - i_min) / bucket_size);
+    int bucket_index = int((v - i_min) / bucket_size);
 
-      float t = ((v - i_min) - (static_cast<float>(bucket_index) * bucket_size)) / bucket_size;
+    float t = ((v - i_min) - (static_cast<float>(bucket_index) * bucket_size)) / bucket_size;
       
-      return ((1.0f - t) * samples[bucket_index]) + (t * samples[bucket_index + 1]);
-    }
+    return ((1.0f - t) * samples[bucket_index]) + (t * samples[bucket_index + 1]);
+  }
 }
 
 #ifdef __TEST__
@@ -61,20 +61,20 @@
 int main(int argc, char** argv)
 {
   if (argc != 2)
-    {
-      std::cout << "Usage: " << argv[0] << " FLOAT" << std::endl;
-    }
+  {
+    std::cout << "Usage: " << argv[0] << " FLOAT" << std::endl;
+  }
   else
-    {
-      float samples[] = { 0.0f, 0.25f, 0.75f, 1.0f };
-      std::vector<float> samples_vec(samples, samples+4);
+  {
+    float samples[] = { 0.0f, 0.25f, 0.75f, 1.0f };
+    std::vector<float> samples_vec(samples, samples+4);
 
-      std::cout << "Samples: " << samples_vec.size() << std::endl;
+    std::cout << "Samples: " << samples_vec.size() << std::endl;
 
-      ResponseCurve curve(0.0f, 1.0f, samples_vec);
+    ResponseCurve curve(0.0f, 1.0f, samples_vec);
 
-      std::cout << curve.get(static_cast<float>(atof(argv[1]))) << std::endl;
-    }
+    std::cout << curve.get(static_cast<float>(atof(argv[1]))) << std::endl;
+  }
   return 0;
 }
 #endif

Modified: trunk/windstille/src/util/sexpr_file_reader.cpp
===================================================================
--- trunk/windstille/src/util/sexpr_file_reader.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/util/sexpr_file_reader.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -70,10 +70,10 @@
   {
     lisp::Lisp* item = get_subsection_item(name);
     if (item && item->get_type() == lisp::Lisp::TYPE_INT)
-      {
-        v = item->get_int();
-        return true;
-      }
+    {
+      v = item->get_int();
+      return true;
+    }
     return false;
   }
 
@@ -81,11 +81,11 @@
   {
     lisp::Lisp* item = get_subsection_item(name);
     if (item && item->get_type() == lisp::Lisp::TYPE_INT)
-      {
-        // FIXME: Not good: overflow
-        v = item->get_int();
-        return true;
-      }
+    {
+      // FIXME: Not good: overflow
+      v = item->get_int();
+      return true;
+    }
     return false;
   }
 
@@ -93,22 +93,22 @@
   {
     lisp::Lisp* item = get_subsection_item(name);
     if (item)
+    {
+      if (item->get_type() == lisp::Lisp::TYPE_FLOAT)
       {
-        if (item->get_type() == lisp::Lisp::TYPE_FLOAT)
-          {
-            v = item->get_float();
-            return true;
-          }
-        else if (item->get_type() == lisp::Lisp::TYPE_INT)
-          {
-            v = static_cast<float>(item->get_int());
-            return true;
-          }
-        else
-          {
-            return false;
-          }
+        v = item->get_float();
+        return true;
       }
+      else if (item->get_type() == lisp::Lisp::TYPE_INT)
+      {
+        v = static_cast<float>(item->get_int());
+        return true;
+      }
+      else
+      {
+        return false;
+      }
+    }
     return false;
   }
 
@@ -116,10 +116,10 @@
   {
     lisp::Lisp* item = get_subsection_item(name);
     if (item && item->get_type() == lisp::Lisp::TYPE_BOOL)
-      {
-        v = item->get_bool();
-        return true;
-      }
+    {
+      v = item->get_bool();
+      return true;
+    }
     return false;
   }
 
@@ -127,22 +127,22 @@
   {
     lisp::Lisp* sub = get_subsection(name);
     if (sub)
+    {
+      v = "";
+      for(size_t i = 1; i < sub->get_list_size(); ++i)
       {
-        v = "";
-        for(size_t i = 1; i < sub->get_list_size(); ++i)
-          {
-            lisp::Lisp* item = sub->get_list_elem(i);
-            if (item->get_type() == lisp::Lisp::TYPE_STRING)
-              {
-                v += item->get_string();
-              }
-            else if (item->get_type() == lisp::Lisp::TYPE_SYMBOL)
-              {
-                v += item->get_symbol();
-              }
-          }
-        return true;
+        lisp::Lisp* item = sub->get_list_elem(i);
+        if (item->get_type() == lisp::Lisp::TYPE_STRING)
+        {
+          v += item->get_string();
+        }
+        else if (item->get_type() == lisp::Lisp::TYPE_SYMBOL)
+        {
+          v += item->get_symbol();
+        }
       }
+      return true;
+    }
     return false;
   }
 
@@ -186,10 +186,10 @@
   {
     lisp::Lisp* cur = get_subsection(name);
     if (cur)
-      {
-        v = SExprFileReader(cur);
-        return true;
-      }
+    {
+      v = SExprFileReader(cur);
+      return true;
+    }
     return false;
   }
 
@@ -197,9 +197,9 @@
   {
     std::vector<FileReader> lst;
     for(size_t i = 1; i < sexpr->get_list_size(); ++i)
-      { // iterate over subsections
-        lst.push_back(SExprFileReader(sexpr->get_list_elem(i)));
-      }
+    { // iterate over subsections
+      lst.push_back(SExprFileReader(sexpr->get_list_elem(i)));
+    }
     return lst;
   }
 
@@ -208,10 +208,10 @@
     std::vector<std::string> lst;
 
     for(size_t i = 1; i < sexpr->get_list_size(); ++i)
-      { // iterate over subsections
-        lisp::Lisp* sub = sexpr->get_list_elem(i);
-        lst.push_back(sub->get_list_elem(0)->get_symbol());
-      }
+    { // iterate over subsections
+      lisp::Lisp* sub = sexpr->get_list_elem(i);
+      lst.push_back(sub->get_list_elem(0)->get_symbol());
+    }
 
     return lst;
   }
@@ -221,20 +221,20 @@
   {
     lisp::Lisp* sub = get_subsection(name);
     if (sub && sub->get_list_size() == 2)
-      {
-        return sub->get_list_elem(1);
-      }
+    {
+      return sub->get_list_elem(1);
+    }
     return 0;
   }
 
   lisp::Lisp* get_subsection(const char* name) const
   {
     for(size_t i = 1; i < sexpr->get_list_size(); ++i)
-      { // iterate over subsections
-        lisp::Lisp* sub = sexpr->get_list_elem(i);
-        if (strcmp(sub->get_list_elem(0)->get_symbol(), name) == 0)
-          return sub;
-      }
+    { // iterate over subsections
+      lisp::Lisp* sub = sexpr->get_list_elem(i);
+      if (strcmp(sub->get_list_elem(0)->get_symbol(), name) == 0)
+        return sub;
+    }
     return 0;
   } 
 

Modified: trunk/windstille/src/util/system.cpp
===================================================================
--- trunk/windstille/src/util/system.cpp	2010-07-25 03:01:28 UTC (rev 3336)
+++ trunk/windstille/src/util/system.cpp	2010-07-25 03:20:18 UTC (rev 3337)
@@ -79,9 +79,9 @@
   char* xdg_config_home = getenv("XDG_CONFIG_HOME");
   if (xdg_config_home)
   {
-      std::ostringstream out;
-      out << xdg_config_home << "/windstille/";
-      return out.str();   
+    std::ostringstream out;
+    out << xdg_config_home << "/windstille/";
+    return out.str();   
   }
   else
   {



