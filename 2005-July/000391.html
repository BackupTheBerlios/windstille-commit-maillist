<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Windstille-commit] r738 - in trunk: data/controller data/levels data/scripts src src/display src/input src/lisp src/scripting src/sprite2d src/sprite3d tools
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/windstille-commit/2005-July/index.html" >
   <LINK REL="made" HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r738%20-%20in%20trunk%3A%20data/controller%20data/levels%20data/scripts%20src%20src/display%20src/input%20src/lisp%20src/scripting%20src/sprite2d%20src/sprite3d%20tools&In-Reply-To=%3C200507242216.j6OMGrgT022092%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000390.html">
   <LINK REL="Next"  HREF="000392.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Windstille-commit] r738 - in trunk: data/controller data/levels data/scripts src src/display src/input src/lisp src/scripting src/sprite2d src/sprite3d tools</H1>
    <B>Matthias Braun at BerliOS</B> 
    <A HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r738%20-%20in%20trunk%3A%20data/controller%20data/levels%20data/scripts%20src%20src/display%20src/input%20src/lisp%20src/scripting%20src/sprite2d%20src/sprite3d%20tools&In-Reply-To=%3C200507242216.j6OMGrgT022092%40sheep.berlios.de%3E"
       TITLE="[Windstille-commit] r738 - in trunk: data/controller data/levels data/scripts src src/display src/input src/lisp src/scripting src/sprite2d src/sprite3d tools">matzebraun at berlios.de
       </A><BR>
    <I>Mon Jul 25 00:16:53 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000390.html">[Windstille-commit] r737 - trunk/src
</A></li>
        <LI>Next message: <A HREF="000392.html">[Windstille-commit] r739 - trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#391">[ date ]</a>
              <a href="thread.html#391">[ thread ]</a>
              <a href="subject.html#391">[ subject ]</a>
              <a href="author.html#391">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: matzebraun
Date: 2005-07-25 00:16:51 +0200 (Mon, 25 Jul 2005)
New Revision: 738

Added:
   trunk/src/color.hpp
   trunk/src/lisp/getters.cpp
   trunk/src/lisp/getters.hpp
   trunk/src/lisp/properties.cpp
   trunk/src/lisp/properties.hpp
   trunk/src/lisp/property_iterator.hpp
   trunk/src/windstille_getters.cpp
   trunk/src/windstille_getters.hpp
Removed:
   trunk/src/lisp/list_iterator.cpp
   trunk/src/lisp/list_iterator.hpp
   trunk/src/lisp_util.hpp
Modified:
   trunk/data/controller/keyboard.scm
   trunk/data/levels/newformat2.wst
   trunk/data/scripts/init_script_vars.nut
   trunk/data/scripts/windstille.nut
   trunk/src/Jamfile
   trunk/src/box.cpp
   trunk/src/character.cpp
   trunk/src/display/drawing_context.cpp
   trunk/src/display/drawing_context.hpp
   trunk/src/entity.cpp
   trunk/src/entity.hpp
   trunk/src/flashing_sign.cpp
   trunk/src/gameconfig.cpp
   trunk/src/input/axis_factory.cpp
   trunk/src/input/button_factory.cpp
   trunk/src/input/input_manager.cpp
   trunk/src/input/input_manager_custom.cpp
   trunk/src/lisp/Jamfile
   trunk/src/lisp/lexer.cpp
   trunk/src/lisp/lisp.cpp
   trunk/src/lisp/lisp.hpp
   trunk/src/lisp/parser.cpp
   trunk/src/lisp/parser.hpp
   trunk/src/player.cpp
   trunk/src/scripting/serialize.cpp
   trunk/src/scripting/spawn_object.cpp
   trunk/src/sector.cpp
   trunk/src/sector.hpp
   trunk/src/spawnpoint.cpp
   trunk/src/spawnpoint.hpp
   trunk/src/spider_mine.cpp
   trunk/src/sprite2d/data.cpp
   trunk/src/sprite3d/sprite.cpp
   trunk/src/test_object.cpp
   trunk/src/tile_factory.cpp
   trunk/src/tile_map.cpp
   trunk/src/trigger.cpp
   trunk/src/useable_object.cpp
   trunk/tools/windstille_export.py
Log:
Rewrote lisp code:
- Now Lisp class only holds basic data
- Data is structured as list of lists now and no strange cons/cdr pointers
  anymore.
- New properties class handles parsing of property lists, no need to use
  iterators anymore unless you need them. Most code looks like
  props.get(&quot;name&quot;, name); again
  you can query for unused properties now, so that you can still print out
  warnings about unknown properties even if not using iterators
- You can overload get() and property_get() functions to handle custom data
  types now



Modified: trunk/data/controller/keyboard.scm
===================================================================
--- trunk/data/controller/keyboard.scm	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/data/controller/keyboard.scm	2005-07-24 22:16:51 UTC (rev 738)
@@ -7,7 +7,6 @@
  (fire  (keyboard-button &quot;space&quot;))
  (use   (keyboard-button &quot;s&quot;))
  (run   (keyboard-button &quot;e&quot;))
- (keyboard)
  )
  
 ;; EOF ;;

Modified: trunk/data/levels/newformat2.wst
===================================================================
--- trunk/data/levels/newformat2.wst	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/data/levels/newformat2.wst	2005-07-24 22:16:51 UTC (rev 738)
@@ -3,73 +3,61 @@
   (version 2)
   (name   &quot;&quot;)
   (music  &quot;music/techdemo.ogg&quot;)
-  (ambient-color 170 170 170)
+  (ambient-color .666 .666 .666)
   (init-script &quot;levels/newformat2.nut&quot;)
   (spawnpoint
     (name &quot;default&quot;)
-    (x 300)
-    (y 650)
+    (pos 300 650)
   )
   (objects
     (flashing-sign
       (name &quot;Block0Sign&quot;)
-      (x 550)
-      (y 370)
+      (pos 550 370)
       (flashspeed 0.7)
       (sprite &quot;images/arrow.sprite&quot;)
       (enabled #f)
     )
     (box
       (name &quot;Box0&quot;)
-      (x 350)
-      (y 700)
-        (vx 10)
+      (pos 350 700)
+      (vel 10 0)
     )
     (box
       (name &quot;Box1&quot;)
-      (x 555)
-      (y 700)
-                (vx -10)
+      (pos 555 700)
+      (vel -10 0)
       (light &quot;bomblight&quot;)
     )
     (character
       (name &quot;bob&quot;)
-      (x 50)
-      (y 831)
+      (pos 50 831)
     )
     (character
       (name &quot;frank&quot;)
-      (x 200)
-      (y 831)
+      (pos 200 831)
     )
     (spider_mine
       (name &quot;spider2&quot;)
-      (x 550)
-      (y 550)
+      (pos 550 550)
     )
     (spider_mine
       (name &quot;spider1&quot;)
-      (x 500)
-      (y 831)
+      (pos 500 831)
     )
     (spider_mine
       (name &quot;spider3&quot;)
-      (x 1100)
-      (y 550)
+      (pos 1100 550)
     )
     (useable-object
-      (x 768)
-      (y 192)
+      (pos 768 192)
       (script &quot;&quot;)
     )
     (useable-object
-      (x 1024)
-      (y 448)
+      (pos 1024 448)
       (script &quot;&quot;)
     )
     (useable-object
-      (x 256)
-      (y 704)
+      (pos 256 704)
       (script &quot;set_sector(\&quot;levels/newformat2.wst\&quot;)&quot;)
     )
 
@@ -138,7 +126,7 @@
       34 35 52 35 51 36 36 51 36 52 35 51 36 36 51 36 52 35 51 36 36 51 36 36 36 39 40 4 4 41 42 36 36 51 36 36 51 36 36 36 39 40 4 4 41 42 36 36 36 36 51 36 36 36 39 40 4 4 41 42 36 36 36 36 51 36 36 51 36 36 36 39 40 4 4 41 42 36 36 51 36 35 36 52 52 36 36 36 51 36 51 35 36 39 3 3 3 41 42 51 
       50 51 52 51 51 52 52 51 52 52 51 51 52 52 51 52 52 51 51 52 52 51 52 52 52 55 56 20 20 57 58 52 51 52 52 52 51 52 52 52 55 56 20 20 57 58 52 51 52 52 51 52 52 52 55 56 20 20 57 58 52 51 52 52 51 52 52 51 52 52 52 55 56 20 20 57 58 52 51 52 52 51 52 36 35 52 52 52 36 52 36 51 51 55 19 19 19 57 58 35 
       66 67 68 67 67 68 68 67 68 68 67 67 68 68 67 68 68 67 67 68 68 67 68 68 68 68 68 67 68 67 68 68 67 68 68 68 67 68 68 68 68 68 67 68 67 68 68 67 68 68 67 68 68 68 68 68 67 68 67 68 68 67 68 68 67 68 68 67 68 68 68 68 68 67 68 67 68 68 67 68 68 67 68 68 67 68 68 68 68 67 68 68 67 68 68 67 68 68 67 68 
-     ))
+     )
    )
 
   (tilemap (name &quot;foreground&quot;) (width 100) (height 30)

Modified: trunk/data/scripts/init_script_vars.nut
===================================================================
--- trunk/data/scripts/init_script_vars.nut	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/data/scripts/init_script_vars.nut	2005-07-24 22:16:51 UTC (rev 738)
@@ -3,13 +3,3 @@
 bob_knows_your_mercenary &lt;- false;
 bob_knows_job &lt;- false;
 
-/* Some debugging/testing stuff */
-function testo(spritename)
-{
-  spawn_object(&quot;test-object&quot;, {
-      name=&quot;Test&quot;,
-      x = 435,
-      y = 709,
-      sprite = spritename
-      });
-}

Modified: trunk/data/scripts/windstille.nut
===================================================================
--- trunk/data/scripts/windstille.nut	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/data/scripts/windstille.nut	2005-07-24 22:16:51 UTC (rev 738)
@@ -11,7 +11,7 @@
       } 
       else if (vargv[0]) 
         {
-          ::spawn_object(&quot;nightvision&quot;, {x=5});
+          ::spawn_object(&quot;nightvision&quot;, {});
           ::has_nightvision = true;
         }
     } else {
@@ -42,4 +42,15 @@
         wait_for_dialog();
 }
 
+/* Some debugging/testing stuff */
+function testo(spritename)
+{
+  spawn_object(&quot;test-object&quot;, {
+      name=&quot;Test&quot;,
+      x = 435,
+      y = 709,
+      sprite = spritename
+      });
+}
+
 /* EOF */

Modified: trunk/src/Jamfile
===================================================================
--- trunk/src/Jamfile	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/Jamfile	2005-07-24 22:16:51 UTC (rev 738)
@@ -107,6 +107,8 @@
         water_splash.hpp
         windstille_error.cpp
         windstille_error.hpp
+        windstille_getters.hpp
+        windstille_getters.cpp
         windstille_main.cpp
         windstille_main.hpp
         windstille_menu.cpp

Modified: trunk/src/box.cpp
===================================================================
--- trunk/src/box.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/box.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -16,11 +16,15 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#include &lt;config.h&gt;
 
 #include &quot;box.hpp&quot;
 #include &quot;globals.hpp&quot;
-#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;lisp/lisp.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
+#include &quot;windstille_getters.hpp&quot;
 #include &quot;collision/collision_engine.hpp&quot;
+#include &quot;math/vector.hpp&quot;
 #include &quot;tile_map.hpp&quot;
 #include &quot;random.hpp&quot;
 
@@ -32,41 +36,25 @@
   gravity = 0.0f;
   float width  = 64.0f;
   float height = 64.0f;
-
   std::string spritename = &quot;box&quot;;
-  CL_Vector vel;
-  lisp::ListIterator iter(lisp);
-  while(iter.next()) {
-    if(iter.item() == &quot;sprite&quot;) {
-      spritename = iter.value().get_string();
-    } else if(iter.item() == &quot;x&quot;) {
-      pos.x = iter.value().get_float();
-    } else if(iter.item() == &quot;y&quot;) {
-      pos.y = iter.value().get_float();
-    } else if(iter.item() == &quot;width&quot;) {
-      width = iter.value().get_float();
-    } else if(iter.item() == &quot;height&quot;) {
-      height = iter.value().get_float();
-    } else if (iter.item() == &quot;vx&quot;) {
-      vel.x = iter.value().get_float();
-    } else if (iter.item() == &quot;vy&quot;) {
-      vel.y = iter.value().get_float();
-    } else if(iter.item() == &quot;name&quot;) {
-      name = iter.value().get_string();
-    } else if(iter.item() == &quot;gravity&quot;) {
-      gravity = iter.value().get_float();
-    } else {
-      std::cerr &lt;&lt; &quot;Skipping unknown attribute '&quot; 
-                &lt;&lt; iter.item() &lt;&lt; &quot;' in Box\n&quot;;
-    }
-  }
+  Vector vel;
 
+  lisp::Properties props(lisp);
+  props.get(&quot;sprite&quot;, spritename);
+  props.get(&quot;pos&quot;, pos);
+  props.get(&quot;width&quot;, width);
+  props.get(&quot;height&quot;, height);
+  props.get(&quot;vel&quot;, vel);
+  props.get(&quot;name&quot;, name);
+  props.get(&quot;gravity&quot;, gravity);
+  props.print_unused_warnings(&quot;box object&quot;);
+
   if (!spritename.empty())
     sprite = CL_Sprite(spritename, resources);
 
   colobj = new CollisionObject(CL_Rectf(0, 0, width, height));
   colobj-&gt;set_velocity(vel);
-  colobj-&gt;set_pos(CL_Vector(pos.x, pos.y));
+  colobj-&gt;set_pos(Vector(pos.x, pos.y));
 
   Sector::current()-&gt;get_collision_engine()-&gt;add(colobj);
 
@@ -82,21 +70,21 @@
   if ((data.direction.x &gt; 0 &amp;&amp; colobj-&gt;get_velocity().x &lt; 0) ||
       (data.direction.x &lt; 0 &amp;&amp; colobj-&gt;get_velocity().x &gt; 0))
     {
-      colobj-&gt;set_velocity(CL_Vector(-colobj-&gt;get_velocity().x, colobj-&gt;get_velocity().y));
+      colobj-&gt;set_velocity(Vector(-colobj-&gt;get_velocity().x, colobj-&gt;get_velocity().y));
     }
   
   if ((data.direction.y &gt; 0 &amp;&amp; colobj-&gt;get_velocity().y &lt; 0) ||
       (data.direction.y &lt; 0 &amp;&amp; colobj-&gt;get_velocity().y &gt; 0))
     {
-      colobj-&gt;set_velocity(CL_Vector(colobj-&gt;get_velocity().x, -colobj-&gt;get_velocity().y));
+      colobj-&gt;set_velocity(Vector(colobj-&gt;get_velocity().x, -colobj-&gt;get_velocity().y));
     }
 }
 
 void 
 Box::update(float delta)
 {
-  colobj-&gt;set_velocity(CL_Vector(colobj-&gt;get_velocity().x, 
-                                 colobj-&gt;get_velocity().y + gravity * delta));
+  colobj-&gt;set_velocity(Vector(colobj-&gt;get_velocity().x, 
+                              colobj-&gt;get_velocity().y + gravity * delta));
 
   sprite.update(delta);
   pos = colobj-&gt;get_pos();

Modified: trunk/src/character.cpp
===================================================================
--- trunk/src/character.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/character.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -16,6 +16,7 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#include &lt;config.h&gt;
 
 #include &quot;character.hpp&quot;
 #include &quot;sector.hpp&quot;
@@ -27,7 +28,8 @@
 #include &quot;console.hpp&quot;
 #include &quot;sprite3d/manager.hpp&quot;
 #include &quot;util.hpp&quot;
-#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
+#include &quot;windstille_getters.hpp&quot;
 
 #include &lt;exception&gt;
 
@@ -36,19 +38,11 @@
   set_useable(true);
 
   pos.z = 100;
-  lisp::ListIterator iter(lisp);
-  while(iter.next()) {
-    if(iter.item() == &quot;name&quot;) {
-      name = iter.value().get_string();
-    } else if(iter.item() == &quot;x&quot;) {
-      pos.x = iter.value().get_float();
-    } else if(iter.item() == &quot;y&quot;) {
-      pos.y = iter.value().get_float();
-    } else {
-      std::cerr &lt;&lt; &quot;Skipping unknown attribute '&quot; 
-                &lt;&lt; iter.item() &lt;&lt; &quot;' in Character\n&quot;;
-    }
-  }
+
+  lisp::Properties props(lisp);
+  props.get(&quot;name&quot;, name);
+  props.get(&quot;pos&quot;, pos);
+  props.print_unused_warnings(&quot;character&quot;);
   
   sprite = sprite3d_manager-&gt;create(&quot;3dsprites/heroken.wsprite&quot;);
   sprite-&gt;set_action(&quot;Stand&quot;);

Added: trunk/src/color.hpp
===================================================================
--- trunk/src/color.hpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/color.hpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -0,0 +1,18 @@
+#ifndef __COLOR_HPP__
+#define __COLOR_HPP__
+
+class Color
+{
+public:
+  Color()
+    : r(0), g(0), b(0), a(1.0)
+  { }
+  Color(float r, float g, float b, float a = 1.0)
+    : r(r), g(g), b(b), a(a)
+  { }
+
+  float r, g, b, a;
+};
+
+#endif
+

Modified: trunk/src/display/drawing_context.cpp
===================================================================
--- trunk/src/display/drawing_context.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/display/drawing_context.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -47,16 +47,20 @@
 class FillScreenDrawingRequest : public DrawingRequest
 {
 private:
-  CL_Color color;
+  Color color;
 public:
-  FillScreenDrawingRequest(const CL_Color&amp; color_) 
+  FillScreenDrawingRequest(const Color&amp; color_) 
     : DrawingRequest(CL_Vector(0, 0, -1000.0f)), color(color_)
   {
   }
   virtual ~FillScreenDrawingRequest() {}
 
   void draw(CL_GraphicContext* gc) {
-    gc-&gt;clear(color);
+    gc-&gt;clear(CL_Color(
+                static_cast&lt;unsigned int&gt; (color.r * 255.0),
+                static_cast&lt;unsigned int&gt; (color.g * 255.0),
+                static_cast&lt;unsigned int&gt; (color.b * 255.0),
+                static_cast&lt;unsigned int&gt; (color.a * 255.0)));
   }
 };
 
@@ -189,44 +193,8 @@
 }
 
 void
-DrawingContext::draw_line (float , float , float , float , 
-                           const CL_Color&amp; )
+DrawingContext::fill_screen(const Color&amp; color)
 {
-}
-
-void
-DrawingContext::draw_fillrect (float , float , float , float , 
-		      const CL_Color&amp; )
-{
-}
-
-void
-DrawingContext::draw_rect (float , float , float , float , 
-		  const CL_Color&amp; )
-{
-}
-
-void
-DrawingContext::draw_pixel (float , float , const CL_Color&amp; )
-{
-}
-
-void
-DrawingContext::draw_circle (float , float , float , const CL_Color&amp; )
-{
-}
-
-/** Draws an arc, starting from angle_start to angle_end in
-      counterclockwise direction. Angles are taken in radian */
-void
-DrawingContext::draw_arc (float , float , float , float , float ,
-                          const CL_Color&amp; )
-{
-}
-
-void
-DrawingContext::fill_screen(const CL_Color&amp; color)
-{
   draw(new FillScreenDrawingRequest(color));
 }
 

Modified: trunk/src/display/drawing_context.hpp
===================================================================
--- trunk/src/display/drawing_context.hpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/display/drawing_context.hpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -22,8 +22,8 @@
 
 #include &lt;ClanLib/Core/Math/rect.h&gt;
 #include &lt;ClanLib/Core/Math/matrix4x4.h&gt;
-#include &lt;ClanLib/Display/color.h&gt;
 #include &lt;vector&gt;
+#include &quot;color.hpp&quot;
 #include &quot;drawing_request.hpp&quot;
 
 class CL_Surface;
@@ -56,29 +56,13 @@
   /** Fills the screen with a given color, this is different from
       clear() in that it doesn't remove other DrawingRequest from the
       queue */
-  void fill_screen(const CL_Color&amp; color);
+  void fill_screen(const Color&amp; color);
 
   /*{ */
   void draw(DrawingRequest* request);
   void draw(const CL_Sprite&amp;   sprite,  float x, float y, float z = 0);
   void draw(const CL_Surface&amp;   sprite,  float x, float y, float z = 0);
   void draw(const std::string&amp; text,    float x, float y, float z = 0);
-
-  void draw_line (float x1, float y1, float x2, float y2, 
-		  const CL_Color&amp; color);
-  void draw_fillrect (float x1, float y1, float x2, float y2, 
-		      const CL_Color&amp; color);
-  void draw_rect (float x1, float y1, float x2, float y2, 
-		  const CL_Color&amp; color);
-  void draw_pixel (float x_pos, float y_pos, 
-		   const CL_Color&amp; color);
-  void draw_circle (float x_pos, float y_pos, float radius,
-                    const CL_Color&amp; color);
-
-  /** Draws an arc, starting from angle_start to angle_end in
-      counterclockwise direction. Angles are taken in radian */
-  void draw_arc (float x_pos, float y_pos, float radius, float angle_start, float angle_end,
-                 const CL_Color&amp; color);
   /*} */
   
   /** Translate the drawing context */

Modified: trunk/src/entity.cpp
===================================================================
--- trunk/src/entity.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/entity.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -37,10 +37,9 @@
 }
 
 void
-Entity::set_pos(float x, float y)
+Entity::set_pos(Vector pos)
 {
-  pos.x = x;
-  pos.y = y;
+  this-&gt;pos = pos;
 }
 
 /* EOF */

Modified: trunk/src/entity.hpp
===================================================================
--- trunk/src/entity.hpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/entity.hpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -26,8 +26,8 @@
 #ifndef HEADER_ENTITY_HXX
 #define HEADER_ENTITY_HXX
 
-#include &lt;ClanLib/Core/Math/cl_vector.h&gt;
 #include &lt;ClanLib/Display/sprite.h&gt;
+#include &quot;math/vector.hpp&quot;
 #include &quot;game_object.hpp&quot;
 #include &quot;collision/collision_object.hpp&quot;
 
@@ -39,16 +39,17 @@
   CL_Signal_v0 done; 
 
 protected:
-  CL_Vector pos;
+  Vector pos;
   bool useable;
   
 public:
   Entity();
   virtual ~Entity();
    
-  virtual CL_Vector get_pos() const { return pos; }
+  virtual Vector get_pos() const
+  { return pos; }
 
-  void set_pos(float x, float y);
+  void set_pos(Vector pos);
 
   /** Called once per frame to allow the object to draw itself */
   virtual void draw(SceneContext&amp; gc) = 0;

Modified: trunk/src/flashing_sign.cpp
===================================================================
--- trunk/src/flashing_sign.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/flashing_sign.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -1,7 +1,10 @@
+#include &lt;config.h&gt;
+
 #include &quot;flashing_sign.hpp&quot;
 
 #include &lt;math.h&gt;
-#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
+#include &quot;windstille_getters.hpp&quot;
 #include &quot;timer.hpp&quot;
 #include &quot;globals.hpp&quot;
 #include &quot;sprite2d/manager.hpp&quot;
@@ -12,27 +15,13 @@
   std::string spritename;
   flashspeed = 5;
 
-  lisp::ListIterator iter(lisp);
-  while(iter.next()) {
-    if(iter.item() == &quot;sprite&quot;) {
-      spritename = iter.value().get_string();
-    } else if(iter.item() == &quot;x&quot;) {
-      pos.x = iter.value().get_float();
-    } else if(iter.item() == &quot;y&quot;) {
-      pos.y = iter.value().get_float();
-    } else if(iter.item() == &quot;z&quot;) {
-      pos.z = iter.value().get_float();
-    } else if(iter.item() == &quot;flashspeed&quot;) {
-      flashspeed = iter.value().get_float();
-    } else if(iter.item() == &quot;name&quot;) {
-      name = iter.value().get_string();
-    } else if(iter.item() == &quot;enabled&quot;) {
-      enabled = iter.value().get_bool();
-    } else {
-      std::cerr &lt;&lt; &quot;Skipping unknown attribute '&quot; 
-                &lt;&lt; iter.item() &lt;&lt; &quot;' in FlashingSign\n&quot;;
-    }
-  }
+  lisp::Properties props(lisp);
+  props.get(&quot;sprite&quot;, spritename);
+  props.get(&quot;pos&quot;, pos);
+  props.get(&quot;flashspeed&quot;, flashspeed);
+  props.get(&quot;name&quot;, name);
+  props.get(&quot;enabled&quot;, enabled);
+  props.print_unused_warnings(&quot;flahing-sign&quot;);
 
   if(spritename == &quot;&quot;)
     throw std::runtime_error(&quot;No sprite name specified in FlashingSign&quot;);

Modified: trunk/src/gameconfig.cpp
===================================================================
--- trunk/src/gameconfig.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/gameconfig.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -5,6 +5,7 @@
 #include &quot;lisp/lisp.hpp&quot;
 #include &quot;lisp/parser.hpp&quot;
 #include &quot;lisp/writer.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
 
 Config* config = 0;
 
@@ -26,21 +27,26 @@
 void
 Config::load()
 {
+  using namespace lisp;
+  
   try {
-    std::auto_ptr&lt;lisp::Lisp&gt; root(lisp::Parser::parse(&quot;config&quot;));
-
-    const lisp::Lisp* config_lisp = root-&gt;get_lisp(&quot;windstille-config&quot;);
-    if(!config) {
+    std::auto_ptr&lt;Lisp&gt; root(lisp::Parser::parse(&quot;config&quot;));
+    Properties rootp(root.get());
+    
+    const Lisp* config_lisp;
+    if(rootp.get(&quot;windstille-config&quot;, config_lisp) == false) {
       std::cerr &lt;&lt; &quot;Warning: Config file is not a windstille-config file.\n&quot;;
       return;
     }
 
-    config_lisp-&gt;get(&quot;screen_width&quot;, screen_width);
-    config_lisp-&gt;get(&quot;screen_height&quot;, screen_height);
-    config_lisp-&gt;get(&quot;fullscreen&quot;, use_fullscreen);
-    config_lisp-&gt;get(&quot;show_fps&quot;, show_fps);
-    config_lisp-&gt;get(&quot;sound_enabled&quot;, sound_enabled);
-    config_lisp-&gt;get(&quot;music_enabled&quot;, music_enabled);
+    Properties props(config_lisp);
+    props.get(&quot;screen_width&quot;, screen_width);
+    props.get(&quot;screen_height&quot;, screen_height);
+    props.get(&quot;fullscreen&quot;, use_fullscreen);
+    props.get(&quot;show_fps&quot;, show_fps);
+    props.get(&quot;sound_enabled&quot;, sound_enabled);
+    props.get(&quot;music_enabled&quot;, music_enabled);
+    props.print_unused_warnings(&quot;configfile&quot;);
 
     // TODO read controller config
   } catch(std::exception&amp; e) {

Modified: trunk/src/input/axis_factory.cpp
===================================================================
--- trunk/src/input/axis_factory.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/input/axis_factory.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -16,39 +16,47 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#include &lt;config.h&gt;
 
 #include &lt;ClanLib/Display/joystick.h&gt;
+#include &lt;sstream&gt;
+#include &lt;stdexcept&gt;
 #include &quot;input_axis_input_device.hpp&quot;
 #include &quot;windstille_error.hpp&quot;
 #include &quot;button_factory.hpp&quot;
 #include &quot;button_axis.hpp&quot;
 #include &quot;axis_factory.hpp&quot;
-#include &quot;lisp_util.hpp&quot;
 #include &quot;lisp/lisp.hpp&quot;
-#include &quot;lisp/list_iterator.hpp&quot;
 
 InputAxis* 
 AxisFactory::create(const lisp::Lisp* lisp)
 {
-  lisp::ListIterator iter(lisp);
-  while(iter.next()) {
-    if(iter.item() == &quot;joystick-axis&quot;) {
-      return create_joystick_axis(iter.lisp());
-    } else if(iter.item() == &quot;button-axis&quot;) {
-      return create_button_axis(iter.lisp());
-    } else {
-      std::cerr &lt;&lt; &quot;Skipping unknown tag '&quot; &lt;&lt; iter.item() &lt;&lt; &quot;' in axis.\n&quot;;
-    }
-  }
+  if(lisp-&gt;get_type() != lisp::Lisp::TYPE_LIST)
+    throw std::runtime_error(&quot;expected list in axis argument&quot;);
+  if(lisp-&gt;get_list_size() == 0)
+    throw std::runtime_error(&quot;List needs at least 1 argument in axis&quot;);
+  const lisp::Lisp* namel = lisp-&gt;get_list_elem(0);
+  if(namel-&gt;get_type() != lisp::Lisp::TYPE_SYMBOL)
+    throw std::runtime_error(&quot;axis needs symbol as first argument&quot;);
 
-  return 0;
+  std::string name = namel-&gt;get_string();
+  if(name == &quot;joystick-axis&quot;)
+    return create_joystick_axis(lisp);
+  else if(name == &quot;button-axis&quot;)
+    return create_button_axis(lisp);
+  
+  std::ostringstream msg;
+  msg &lt;&lt; &quot;Unknown axis type '&quot; &lt;&lt; name &lt;&lt; &quot;' found&quot;;
+  throw std::runtime_error(msg.str());
 }
 
 InputAxis*
 AxisFactory::create_joystick_axis(const lisp::Lisp* lisp)
 {
-  int device_num = lisp_get_list_nth(lisp, 0)-&gt;get_int();
-  int axis_num   = lisp_get_list_nth(lisp, 1)-&gt;get_int();
+  if(lisp-&gt;get_list_size() != 3)
+    throw std::runtime_error(&quot;joystick-axis needs 2 arguments&quot;);
+  int device_num = lisp-&gt;get_list_elem(1)-&gt;get_int();
+  int axis_num   = lisp-&gt;get_list_elem(2)-&gt;get_int();
 
   if (device_num &gt;= 0 &amp;&amp; device_num &lt; CL_Joystick::get_device_count())
     return new InputAxisInputDevice(CL_Joystick::get_device(device_num), axis_num);
@@ -59,8 +67,10 @@
 InputAxis*
 AxisFactory::create_button_axis(const lisp::Lisp* lisp)
 {
-  InputButton* left  = ButtonFactory::create(lisp_get_list_nth(lisp, 0));
-  InputButton* right = ButtonFactory::create(lisp_get_list_nth(lisp, 1));
+  if(lisp-&gt;get_list_size() != 3)
+    throw std::runtime_error(&quot;button-axis needs 2 arguments&quot;);
+  InputButton* left  = ButtonFactory::create(lisp-&gt;get_list_elem(1));
+  InputButton* right = ButtonFactory::create(lisp-&gt;get_list_elem(2));
 
   return new ButtonAxis(left, right);
 }

Modified: trunk/src/input/button_factory.cpp
===================================================================
--- trunk/src/input/button_factory.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/input/button_factory.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -23,49 +23,61 @@
 #include &quot;input_button.hpp&quot;
 #include &quot;input_axis.hpp&quot;
 #include &quot;input_button_input_device.hpp&quot;
-#include &quot;lisp/list_iterator.hpp&quot;
-#include &quot;lisp_util.hpp&quot;
 #include &quot;axis_factory.hpp&quot;
 #include &quot;axis_button.hpp&quot;
 #include &quot;multi_button.hpp&quot;
 #include &quot;button_factory.hpp&quot;
+#include &quot;lisp/lisp.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
 
 InputButton* 
 ButtonFactory::create(const lisp::Lisp* lisp)
 {
-  lisp::ListIterator iter(lisp);
-  while(iter.next()) {
-    if(iter.item() == &quot;joystick-button&quot;) {
-      return create_joystick_button(iter.lisp());
-    } else if(iter.item() == &quot;keyboard-button&quot;) {
-      return create_keyboard_button(iter.lisp());
-    } else if(iter.item() == &quot;axis-button&quot;) {
-      return create_axis_button(iter.lisp());
-    } else if(iter.item() == &quot;multi-button&quot;) {
-      return create_multi_button(iter.lisp());
-    } else {
-      std::cerr &lt;&lt; &quot;Skipping unknown tag '&quot; &lt;&lt; iter.item() 
-        &lt;&lt; &quot;' in controller file\n&quot;;
-    }
+  if(lisp-&gt;get_type() != lisp::Lisp::TYPE_LIST)
+    throw std::runtime_error(&quot;expected list in axis argument&quot;);
+  if(lisp-&gt;get_list_size() == 0)
+    throw std::runtime_error(&quot;List needs at least 1 argument in axis&quot;);
+  const lisp::Lisp* namel = lisp-&gt;get_list_elem(0);
+  if(namel-&gt;get_type() != lisp::Lisp::TYPE_SYMBOL)
+    throw std::runtime_error(&quot;axis needs symbol as first argument&quot;);
+ 
+  std::string name = namel-&gt;get_symbol();
+
+  if(name == &quot;joystick_button&quot;) {
+    return create_joystick_button(lisp);
+  } else if(name == &quot;keyboard-button&quot;) {
+    return create_keyboard_button(lisp);
+  } else if(name == &quot;axis-button&quot;) {
+    return create_axis_button(lisp);
+  } else if(name == &quot;multi-button&quot;) {
+    return create_multi_button(lisp);
   }
-      
-  return 0;
+  
+  std::ostringstream msg;
+  msg &lt;&lt; &quot;Unknown button type '&quot; &lt;&lt; name &lt;&lt; &quot;' found&quot;;
+  throw std::runtime_error(msg.str());
 }
 
 InputButton*
 ButtonFactory::create_axis_button(const lisp::Lisp* lisp)
 {
-  InputAxis* axis = AxisFactory::create(lisp_get_list_nth(lisp, 0));
-  bool top = lisp_get_list_nth(lisp, 1)-&gt;get_bool();
+  if(lisp-&gt;get_list_size() != 3)
+    throw std::runtime_error(&quot;axis_button needs exactly 2 arguments&quot;);
   
+  InputAxis* axis = AxisFactory::create(lisp-&gt;get_list_elem(1));
+  bool top = lisp-&gt;get_list_elem(2)-&gt;get_bool();
+  
   return new AxisButton(axis, top);
 }
 
 InputButton*
 ButtonFactory::create_joystick_button(const lisp::Lisp* lisp)
 {
-  int device_num = lisp_get_list_nth(lisp, 0)-&gt;get_int();
-  int button_num = lisp_get_list_nth(lisp, 1)-&gt;get_int();
+  if(lisp-&gt;get_list_size() != 3)
+    throw std::runtime_error(&quot;joystick_button needs exactly 2 arguments&quot;);
+
+  int device_num = lisp-&gt;get_list_elem(1)-&gt;get_int();
+  int button_num = lisp-&gt;get_list_elem(2)-&gt;get_int();
   
   if (device_num &gt;= 0 &amp;&amp; device_num &lt; CL_Joystick::get_device_count())
     return new InputButtonInputDevice(CL_Joystick::get_device(device_num), button_num);
@@ -76,7 +88,9 @@
 InputButton*
 ButtonFactory::create_keyboard_button(const lisp::Lisp* lisp)
 {
-  std::string key_str = lisp-&gt;get_car()-&gt;get_string();
+  if(lisp-&gt;get_list_size() != 2)
+    throw std::runtime_error(&quot;keyboard_button needs exactly 1 argument&quot;);
+  std::string key_str = lisp-&gt;get_list_elem(1)-&gt;get_string();
   int key_num         = CL_Keyboard::get_device().string_to_keyid(key_str);
 
   // FIXME: No error checking
@@ -88,8 +102,10 @@
 {
   MultiButton* button = new MultiButton();
  
-  for( ; lisp != 0; lisp = lisp-&gt;get_cdr()) {
-    button-&gt;add(create(lisp-&gt;get_car()));
+  lisp::Properties props(lisp);
+  lisp::PropertyIterator&lt;const lisp::Lisp*&gt; iter = props.get_iter();
+  while(iter.next()) {
+    button-&gt;add(create(*iter));
   }
   
   return button;

Modified: trunk/src/input/input_manager.cpp
===================================================================
--- trunk/src/input/input_manager.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/input/input_manager.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -25,6 +25,8 @@
 #include &lt;ClanLib/Display/joystick.h&gt;
 
 #include &quot;lisp/parser.hpp&quot;
+#include &quot;lisp/lisp.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
 #include &quot;windstille_error.hpp&quot;
 #include &quot;input_manager_custom.hpp&quot;
 #include &quot;input_manager_player.hpp&quot;
@@ -45,9 +47,10 @@
 InputManager::init(const std::string&amp; filename)
 {
   std::auto_ptr&lt;lisp::Lisp&gt; root (lisp::Parser::parse(filename));
+  lisp::Properties rootp(root.get());
 
-  const lisp::Lisp* controller = root-&gt;get_lisp(&quot;windstille-controller&quot;);
-  if(controller == 0) {
+  const lisp::Lisp* controller;
+  if(rootp.get(&quot;windstille-controller&quot;, controller) == false) {
     std::ostringstream msg;
     msg &lt;&lt; &quot;'&quot; &lt;&lt; filename &lt;&lt; &quot;' is not a windstille-controller file&quot;;
     throw std::runtime_error(msg.str());

Modified: trunk/src/input/input_manager_custom.cpp
===================================================================
--- trunk/src/input/input_manager_custom.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/input/input_manager_custom.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -23,7 +23,8 @@
 #include &lt;ClanLib/Display/display_iostream.h&gt;
 #include &lt;ClanLib/Display/keys.h&gt;
 
-#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;lisp/lisp.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
 #include &quot;controller_def.hpp&quot;
 #include &quot;input_button_input_device.hpp&quot;
 #include &quot;input_axis_input_device.hpp&quot;
@@ -84,14 +85,16 @@
   axes.resize(ControllerDef::get_axis_count());
   keyboards.resize(ControllerDef::get_keyboard_count());
 
-  lisp::ListIterator iter(lisp);
+  lisp::Properties props(lisp);
+  lisp::PropertyIterator&lt;const lisp::Lisp*&gt; iter = props.get_iter();
   while(iter.next()) {
     std::string name = iter.item();
+    const lisp::Lisp* lisp = (*iter)-&gt;get_list_elem(1);
 
     int id = ControllerDef::button_name2id(name);
     if (id != -1)
       {
-        buttons[id] = ButtonFactory::create(iter.lisp());
+        buttons[id] = ButtonFactory::create(lisp);
       }
     else if (name == &quot;keyboard&quot;)
       {
@@ -102,7 +105,7 @@
         id = ControllerDef::axis_name2id(name);
         if (id != -1)
           {
-            axes[id] = AxisFactory::create(iter.lisp());
+            axes[id] = AxisFactory::create(lisp);
           }
         else
           {

Modified: trunk/src/lisp/Jamfile
===================================================================
--- trunk/src/lisp/Jamfile	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/lisp/Jamfile	2005-07-24 22:16:51 UTC (rev 738)
@@ -5,12 +5,14 @@
   lexer.hpp
   lisp.cpp
   lisp.hpp
-  list_iterator.cpp
-  list_iterator.hpp
   parser.cpp
   parser.hpp
   writer.cpp
   writer.hpp
+  properties.cpp
+  properties.hpp
+  getters.hpp
+  getters.cpp
 ;
 
 TRANSLATABLE_SOURCES += [ SearchSource $(sources) ] ;

Added: trunk/src/lisp/getters.cpp
===================================================================
--- trunk/src/lisp/getters.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/lisp/getters.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -0,0 +1,42 @@
+#include &lt;config.h&gt;
+#include &quot;getters.hpp&quot;
+
+namespace lisp
+{
+
+bool get(const Lisp* lisp, bool&amp; val)
+{
+  if(lisp-&gt;get_type() != Lisp::TYPE_BOOL)
+    return false;
+  val = lisp-&gt;get_bool();
+  return true;
+}
+
+bool get(const Lisp* lisp, float&amp; val)
+{
+  if(lisp-&gt;get_type() == Lisp::TYPE_INT)
+    val = lisp-&gt;get_int();
+  else if(lisp-&gt;get_type() == Lisp::TYPE_FLOAT)
+    val = lisp-&gt;get_float();
+  else
+    return false;
+  return true;
+}
+
+bool get(const Lisp* lisp, int&amp; val)
+{
+  if(lisp-&gt;get_type() != Lisp::TYPE_INT)
+    return false;
+  val = lisp-&gt;get_int();
+  return true;
+}
+
+bool get(const Lisp* lisp, std::string&amp; val)
+{
+  if(lisp-&gt;get_type() != Lisp::TYPE_STRING)
+    return false;
+  val = lisp-&gt;get_string();
+  return true;
+}
+
+}

Added: trunk/src/lisp/getters.hpp
===================================================================
--- trunk/src/lisp/getters.hpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/lisp/getters.hpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -0,0 +1,57 @@
+/** This header defines functions that assign the value of Lisp objects to
+ * normal C++ datatypes.
+ *
+ * The get function is overloaded for a set of default datatypes. You can add
+ * further overloads in your own code. The get functions return true if the
+ * value could be converted and false otherwise.
+ *
+ * The property_get function expect a list whose values 1-n are transformed to a
+ * C++ object. This is typically used from the code in the Properties class. You
+ * can also write custom overloads in your code.
+ */
+#ifndef __GETTERS_HPP__
+#define __GETTERS_HPP__
+
+#include &quot;lisp.hpp&quot;
+
+namespace lisp
+{
+
+bool get(const Lisp* lisp, bool&amp; val);
+bool get(const Lisp* lisp, float&amp; val);
+bool get(const Lisp* lisp, int&amp; val);
+bool get(const Lisp* lisp, std::string&amp; val);
+bool get(const Lisp* lisp, const Lisp*&amp; val);
+
+template&lt;class T&gt;
+static inline bool property_get(const Lisp* lisp, T&amp; val)
+{
+  const Lisp* el = lisp-&gt;get_list_elem(1);
+  return get(el, val);
+}
+
+static inline bool property_get(const Lisp* lisp, const Lisp*&amp; val)
+{
+  val = lisp;
+  return true;
+}
+
+template&lt;class T&gt;
+static inline bool property_get(const Lisp* lisp, std::vector&lt;T&gt;&amp; list)
+{
+  list.clear();
+  for(size_t n = 1; n &lt; lisp-&gt;get_list_size(); ++n) {
+    T val;
+    if(get(lisp-&gt;get_list_elem(n), val) == false) {
+      list.clear();
+      return false;
+    }
+    list.push_back(val);
+  }
+  return true;
+}
+
+}
+
+#endif
+

Modified: trunk/src/lisp/lexer.cpp
===================================================================
--- trunk/src/lisp/lexer.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/lisp/lexer.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -166,7 +166,7 @@
         }
 
       default:
-        if(isdigit(*c) || *c == '-') {
+        if(isdigit(*c) || *c == '-' || *c == '.') {
           bool have_nondigits = false;
           bool have_digits = false;
           int have_floating_point = 0;

Modified: trunk/src/lisp/lisp.cpp
===================================================================
--- trunk/src/lisp/lisp.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/lisp/lisp.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -24,11 +24,24 @@
 namespace lisp
 {
     
-Lisp::Lisp(LispType newtype)
-  : type(newtype)
+Lisp::Lisp(int val)
+  : type(TYPE_INT)
 {
+  v.int_ = val;
 }
 
+Lisp::Lisp(float val)
+  : type(TYPE_FLOAT)
+{
+  v.float_ = val;
+}
+
+Lisp::Lisp(bool val)
+  : type(TYPE_BOOL)
+{
+  v.bool_ = val;
+}
+
 Lisp::Lisp(LispType newtype, const std::string&amp; str)
   : type(newtype)
 {
@@ -37,35 +50,25 @@
   memcpy(v.string, str.c_str(), str.size()+1);
 }
 
-Lisp::~Lisp()
+Lisp::Lisp(const std::vector&lt;Lisp*&gt;&amp; list_elements)
+  : type(TYPE_LIST)
 {
-  if(type == TYPE_SYMBOL || type == TYPE_STRING)
-    delete[] v.string;
-  if(type == TYPE_CONS) {
-    delete v.cons.cdr;
-    delete v.cons.car;
+  v.list.size = list_elements.size();
+  v.list.entries = new Lisp* [v.list.size];
+  for(size_t i = 0; i &lt; v.list.size; ++i) {
+    v.list.entries[i] = list_elements[i];
   }
 }
 
-Lisp*
-Lisp::get_lisp(const char* name) const
+Lisp::~Lisp()
 {
-  for(const Lisp* p = this; p != 0; p = p-&gt;get_cdr()) {
-    Lisp* child = p-&gt;get_car();
-    if(!child || child-&gt;get_type() != TYPE_CONS)
-      continue;
-    Lisp* childname = child-&gt;get_car();
-    if(!childname)
-      continue;
-    std::string childName;
-    if(!childname-&gt;get(childName))
-      continue;
-    if(childName == name) {
-      return child-&gt;get_cdr();
-    }
+  if(type == TYPE_SYMBOL || type == TYPE_STRING) {
+    delete[] v.string;
+  } else if(type == TYPE_LIST) {
+    for(size_t i = 0; i &lt; v.list.size; ++i)
+      delete v.list.entries[i];
+    delete[] v.list.entries;
   }
-
-  return 0;
 }
 
 void
@@ -73,34 +76,35 @@
 {
   for(int i = 0; i &lt; indent; ++i)
     out &lt;&lt; ' ';
-  
-  if(type == TYPE_CONS) {
-    out &lt;&lt; &quot;(\n&quot;;
-    const Lisp* lisp = this;
-    while(lisp) {
-      if(lisp-&gt;v.cons.car)
-        lisp-&gt;v.cons.car-&gt;print(out, indent + 1);
-      lisp = lisp-&gt;v.cons.cdr;
-    }
-    for(int i = 0; i &lt; indent; ++i)
-      out &lt;&lt; ' ';
-    out &lt;&lt; ')';
+ 
+  switch(type) {
+    case TYPE_LIST:
+      out &lt;&lt; &quot;(\n&quot;;
+      for(size_t i = 0; i &lt; v.list.size; ++i)
+        v.list.entries[i]-&gt;print(out, indent+2);
+      for(int i = 0; i &lt; indent; ++i)
+        out &lt;&lt; ' ';                      
+      out &lt;&lt; &quot;)&quot;;
+      break;
+    case TYPE_STRING:
+      out &lt;&lt; '\'' &lt;&lt; v.string &lt;&lt; '\'';
+      break;
+    case TYPE_INT:
+      out &lt;&lt; v.int_;
+      break;
+    case TYPE_FLOAT:
+      out &lt;&lt; v.float_;
+      break;
+    case TYPE_SYMBOL:
+      out &lt;&lt; v.string;
+      break;
+    case TYPE_BOOL:
+      out &lt;&lt; (v.bool_ ? &quot;true&quot; : &quot;false&quot;);
+      break;
+    default:
+      out &lt;&lt; &quot;UNKNOWN?!?&quot;;
+      break;
   }
-  if(type == TYPE_STRING) {
-    out &lt;&lt; '\'' &lt;&lt; v.string &lt;&lt; '\'';
-  }
-  if(type == TYPE_INTEGER) {
-    out &lt;&lt; v.integer;
-  }
-  if(type == TYPE_REAL) {
-    out &lt;&lt; v.real;
-  }
-  if(type == TYPE_SYMBOL) {
-    out &lt;&lt; v.string;
-  }
-  if(type == TYPE_BOOLEAN) {
-    out &lt;&lt; (v.boolean ? &quot;true&quot; : &quot;false&quot;);
-  }
   out &lt;&lt; '\n';
 }
 

Modified: trunk/src/lisp/lisp.hpp
===================================================================
--- trunk/src/lisp/lisp.hpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/lisp/lisp.hpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -1,6 +1,5 @@
 //  $Id: lisp.h 2419 2005-05-06 19:08:24Z matzebraun $
 //
-//  TuxKart - a fun racing game with go-kart
 //  Copyright (C) 2004 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
 //  code in this file based on lispreader from Mark Probst
 //
@@ -17,8 +16,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-#ifndef __LISPREADER_HPP__
-#define __LISPREADER_HPP__
+#ifndef __LISP_HPP__
+#define __LISP_HPP__
 
 #include &lt;string&gt;
 #include &lt;vector&gt;
@@ -33,203 +32,84 @@
 {
 public:
   enum LispType {
-    TYPE_CONS,
+    TYPE_LIST,
     TYPE_SYMBOL,
-    TYPE_INTEGER,
+    TYPE_INT,
     TYPE_STRING,
-    TYPE_REAL,
-    TYPE_BOOLEAN
+    TYPE_FLOAT,
+    TYPE_BOOL
   };
 
-  Lisp(LispType newtype);
-  Lisp(LispType newtype, const std::string&amp; value);  
+  /// construct a new Lisp object symbol or string object
+  Lisp(LispType newtype, const std::string&amp; value);
+  Lisp(const std::vector&lt;Lisp*&gt;&amp; list_elements);
+  Lisp(int val);
+  Lisp(float val);
+  Lisp(bool val);
   ~Lisp();                                             
 
   LispType get_type() const
   { return type; } 
 
-  Lisp* get_car() const
-  { return v.cons.car; }
-  Lisp* get_cdr() const
-  { return v.cons.cdr; }
-
-  std::string get_string() const
+  size_t get_list_size() const
   {
-    std::string result;
-    if(!get(result)) {
-      std::ostringstream msg;
-      msg &lt;&lt; &quot;Expected string, got &quot;;
-      print(msg);
-      throw std::runtime_error(msg.str());
-    }
-    return result;
+    return v.list.size;
   }
-
-  int get_int() const
+  Lisp* get_list_elem(size_t i) const
   {
-    int result;
-    if(!get(result)) {
-      std::ostringstream msg;
-      msg &lt;&lt; &quot;Expected integer, got &quot;;
-      print(msg);
-      throw std::runtime_error(msg.str());
-    }
-    return result;
+    assert(i &lt; v.list.size);
+    return v.list.entries[i];
   }
 
-  float get_float() const
+  const char* get_string() const
   {
-    float result;
-    if(!get(result)) {
-      std::ostringstream msg;
-      msg &lt;&lt; &quot;Expected float, got &quot;;
-      print(msg);
-      throw std::runtime_error(msg.str());
-    }
-    return result;
+    if(type != TYPE_STRING)
+      throw std::runtime_error(&quot;Lisp is not a string&quot;);
+    return v.string;
   }
 
-  bool get_bool() const
+  const char* get_symbol() const
   {
-    bool result;
-    if(!get(result)) {
-      std::ostringstream msg;
-      msg &lt;&lt; &quot;Expected bool, got &quot;;
-      print(msg);
-      throw std::runtime_error(msg.str());
-    }
-    return result;
+    if(type != TYPE_SYMBOL)
+      throw std::runtime_error(&quot;Lisp is not a symbol&quot;);
+    return v.string;
   }
 
-  template&lt;class T&gt;
-  void get_vector(std::vector&lt;T&gt;&amp; vec) const
+  int get_int() const
   {
-    vec.clear();
- 
-    for(const lisp::Lisp* child = this ; child != 0; child = child-&gt;get_cdr()) {
-      if(type != TYPE_CONS)
-        throw std::runtime_error(&quot;get_vector called on non-list&quot;);
-      
-      T val;
-      if(!child-&gt;get_car())                           
-        continue;
-      if(child-&gt;get_car()-&gt;get(val)) {
-        vec.push_back(val);
-      }
-    }
+    if(type != TYPE_INT)
+      throw std::runtime_error(&quot;Lisp is not an int&quot;);
+    return v.int_;
   }
 
-  /** conveniance functions which traverse the list until a child with a
-   * specified name is found. The value part is then interpreted in a specific
-   * way. The functions return true, if a child was found and could be
-   * interpreted correctly, otherwise false is returned and the variable value
-   * is not changed.
-   * (Please note that searching the lisp structure is O(n) so these functions
-   *  are no good idea for performance critical areas)
-   */
-  template&lt;class T&gt;
-  bool get(const char* name, T&amp; val) const
+  float get_float() const
   {
-    const Lisp* lisp = get_lisp(name);
-    if(!lisp)
-      return false;
-
-    if(lisp-&gt;get_type() != TYPE_CONS)
-      return false;
-    lisp = lisp-&gt;get_car();
-    if(!lisp)
-      return false;
-    return lisp-&gt;get(val);
+    if(type != TYPE_FLOAT)
+      throw std::runtime_error(&quot;Lisp is not a float&quot;);
+    return v.float_;
   }
 
-  template&lt;class T&gt;
-  bool get_vector(const char* name, std::vector&lt;T&gt;&amp; vec) const
+  bool get_bool() const
   {
-    vec.clear();
-    
-    const Lisp* child = get_lisp(name);
-    if(!child)
-      return false;
-    
-    for( ; child != 0; child = child-&gt;get_cdr()) {
-      T val;
-      if(!child-&gt;get_car())
-        continue;
-      if(child-&gt;get_car()-&gt;get(val)) {
-        vec.push_back(val);
-      }
-    }
-    
-    return true;
+    if(type != TYPE_BOOL)
+      throw std::runtime_error(&quot;Lisp is not a bool&quot;);
+    return v.bool_;
   }
-  
-  Lisp* get_lisp(const char* name) const;
-  Lisp* get_lisp(const std::string&amp; name) const
-  { return get_lisp(name.c_str()); }
 
-  // for debugging/error messages
-  void print(std::ostream&amp; out, int indent = 0) const;
+  void print(std::ostream&amp; out = std::cout, int indent = 0) const;
 
+private:
   union
   {
-    struct
-    {
-      Lisp* car;
-      Lisp* cdr;
-    } cons;
-
+    struct {
+      Lisp** entries;
+      size_t size;
+    } list;
     char* string;
-    int integer;
-    bool boolean;
-    float real;
+    int int_;
+    bool bool_;
+    float float_;
   } v;
-
-private:
-  bool get(std::string&amp; val) const
-  { 
-    if(type != TYPE_STRING &amp;&amp; type != TYPE_SYMBOL)
-      return false;
-    val = v.string;
-    return true;
-  }
-  
-  bool get(unsigned int&amp; val) const
-  {
-    if(type != TYPE_INTEGER)
-      return false;
-    val = v.integer;
-    return true;
-  }
-  
-  bool get(int&amp; val) const
-  {
-    if(type != TYPE_INTEGER)
-      return false;
-    val = v.integer;
-    return true;
-  }
-  
-  bool get(float&amp; val) const
-  {
-    if(type != TYPE_REAL) {
-      if(type == TYPE_INTEGER) {
-        val = v.integer;
-        return true;
-      }
-      return false;
-    }
-    val = v.real;
-    return true;
-  }
-  
-  bool get(bool&amp; val) const
-  {
-    if(type != TYPE_BOOLEAN)
-      return false;
-    val = v.boolean;
-    return true;
-  }
- 
   LispType type;
 };
 

Deleted: trunk/src/lisp/list_iterator.cpp
===================================================================
--- trunk/src/lisp/list_iterator.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/lisp/list_iterator.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -1,55 +0,0 @@
-//  $Id: list_iterator.cpp 2575 2005-06-07 15:59:27Z matzebraun $
-// 
-//  SuperTux
-//  Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-//  02111-1307, USA.
-
-#include &lt;config.h&gt;
-
-#include &quot;list_iterator.hpp&quot;
-#include &lt;stdexcept&gt;
-
-namespace lisp
-{
-
-ListIterator::ListIterator(const lisp::Lisp* newlisp)
-  : current_lisp(0), cur(newlisp)
-{
-}
-
-bool
-ListIterator::next()
-{
-  if(cur == 0)
-    return false;
-
-  const lisp::Lisp* child = cur-&gt;get_car();
-  if(!child)
-    throw std::runtime_error(&quot;child is 0 in list entry&quot;);
-  if(child-&gt;get_type() != lisp::Lisp::TYPE_CONS)
-    throw std::runtime_error(&quot;Expected CONS&quot;);
-  const lisp::Lisp* name = child-&gt;get_car();
-  if(!name || name-&gt;get_type() != lisp::Lisp::TYPE_SYMBOL)
-    throw std::runtime_error(&quot;Expected symbol&quot;);
-  current_item = name-&gt;get_string();
-  current_lisp = child-&gt;get_cdr();
-
-  cur = cur-&gt;get_cdr();
-  return true;
-}
-
-}

Deleted: trunk/src/lisp/list_iterator.hpp
===================================================================
--- trunk/src/lisp/list_iterator.hpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/lisp/list_iterator.hpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -1,55 +0,0 @@
-//  $Id: list_iterator.h 2379 2005-05-01 19:02:16Z matzebraun $
-// 
-//  SuperTux
-//  Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-//  02111-1307, USA.
-
-#ifndef __LISP_ITERATOR_H__
-#define __LISP_ITERATOR_H__
-
-#include &quot;lisp/lisp.hpp&quot;
-
-namespace lisp
-{
-
-/**
- * Small and a bit hacky helper class that helps parsing lisp lists where all
- * entries are lists again themselves
- */
-class ListIterator
-{
-public:
-  ListIterator(const lisp::Lisp* cur);
-  
-  const std::string&amp; item() const
-  { return current_item; }
-  lisp::Lisp* lisp() const
-  { return current_lisp; }
-  lisp::Lisp&amp; value() const
-  { return *(current_lisp-&gt;get_car()); }
-  bool next();
-
-private:
-  std::string current_item;
-  lisp::Lisp* current_lisp;
-  const lisp::Lisp* cur;
-};
-
-}
-
-#endif
-

Modified: trunk/src/lisp/parser.cpp
===================================================================
--- trunk/src/lisp/parser.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/lisp/parser.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -20,10 +20,10 @@
 #include &lt;config.h&gt;
 
 #include &lt;sstream&gt;
-#include &lt;stdexcept&gt;
-#include &lt;fstream&gt;
 #include &lt;cassert&gt;
 #include &lt;iostream&gt;
+#include &lt;string&gt;
+#include &lt;exception&gt;
 
 #include &quot;tinygettext/tinygettext.hpp&quot;
 #include &quot;physfs/physfs_stream.hpp&quot;
@@ -33,6 +33,28 @@
 namespace lisp
 {
 
+class ParseError : public std::exception
+{
+public:
+  ParseError(const Parser* parser, const std::string&amp; message) throw()
+  {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Parse error in '&quot; &lt;&lt; parser-&gt;filename &lt;&lt; &quot;' line &quot;
+      &lt;&lt; parser-&gt;lexer-&gt;getLineNumber() &lt;&lt; &quot;: &quot; &lt;&lt; message;
+    string = msg.str();
+  }
+  ~ParseError() throw()
+  {}
+
+  const char* what() const throw()
+  {
+    return string.c_str();
+  }
+
+private:
+  std::string string;
+};
+
 Parser::Parser()
   : lexer(0), dictionary_manager(0), dictionary(0)
 {
@@ -65,127 +87,107 @@
     throw std::runtime_error(msg.str());
   }
 
-  return parse(in, dirname(filename));
+  return parse(in, filename);
 }
 
 Lisp*
-Parser::parse(std::istream&amp; stream, const std::string&amp; basedir)
+Parser::parse(std::istream&amp; stream, const std::string&amp; filename)
 {
   std::auto_ptr&lt;Parser&gt; parser (new Parser());
-  
-  parser-&gt;dictionary_manager-&gt;add_directory(basedir);   
+
+  parser-&gt;filename = filename;
+  parser-&gt;dictionary_manager-&gt;add_directory(dirname(filename));
   parser-&gt;dictionary = &amp; (parser-&gt;dictionary_manager-&gt;get_dictionary());
   parser-&gt;lexer = new Lexer(stream);
 
   parser-&gt;token = parser-&gt;lexer-&gt;getNextToken();
-  Lisp* result = new Lisp(Lisp::TYPE_CONS);
-  result-&gt;v.cons.car = parser-&gt;read();
-  result-&gt;v.cons.cdr = 0; 
-
-  return result;    
+  std::auto_ptr&lt;Lisp&gt; result (parser-&gt;parse());
+  if(parser-&gt;token != Lexer::TOKEN_EOF) {
+    if(parser-&gt;token == Lexer::TOKEN_CLOSE_PAREN)
+      throw ParseError(parser.get(), &quot;too many ')'&quot;);
+    else
+      throw ParseError(parser.get(), &quot;extra tokens at end of file&quot;);
+  }
+    
+  return result.release();
 }
 
 Lisp*
-Parser::read()
+Parser::parse()
 {
-  Lisp* result;
-  switch(token) {
-    case Lexer::TOKEN_EOF: {
-      std::stringstream msg;
-      msg &lt;&lt; &quot;Parse Error at line &quot; &lt;&lt; lexer-&gt;getLineNumber() &lt;&lt; &quot;: &quot;
-        &lt;&lt; &quot;Unexpected EOF.&quot;;
-      throw std::runtime_error(msg.str());
-    }
-    case Lexer::TOKEN_CLOSE_PAREN: {
-      std::stringstream msg;
-      msg &lt;&lt; &quot;Parse Error at line &quot; &lt;&lt; lexer-&gt;getLineNumber() &lt;&lt; &quot;: &quot;
-        &lt;&lt; &quot;Unexpected ')'.&quot;;
-      throw std::runtime_error(msg.str());
-    }
-    case Lexer::TOKEN_OPEN_PAREN: {
-      result = new Lisp(Lisp::TYPE_CONS);
-      
-      token = lexer-&gt;getNextToken();
-      if(token == Lexer::TOKEN_CLOSE_PAREN) {
-        result-&gt;v.cons.car = 0;
-        result-&gt;v.cons.cdr = 0;
-        break;
-      }
-
-      if(token == Lexer::TOKEN_SYMBOL &amp;&amp;
-          strcmp(lexer-&gt;getString(), &quot;_&quot;) == 0) {
-        // evaluate translation function (_ str) in place here
-        token = lexer-&gt;getNextToken();
-        if(token != Lexer::TOKEN_STRING)
-          throw std::runtime_error(&quot;Expected string after '(_'&quot;);
+  std::vector&lt;Lisp*&gt; entries;
+  try {
+    while(token != Lexer::TOKEN_CLOSE_PAREN &amp;&amp; token != Lexer::TOKEN_EOF) {
+      switch(token) {
+        case Lexer::TOKEN_OPEN_PAREN:
+          token = lexer-&gt;getNextToken();
         
-        result = new Lisp(Lisp::TYPE_STRING);
-        if(dictionary) {
-          std::string translation = dictionary-&gt;translate(lexer-&gt;getString());
-          result-&gt;v.string = new char[translation.size()+1];
-          memcpy(result-&gt;v.string, translation.c_str(), translation.size()+1);
-        } else {
-          size_t len = strlen(lexer-&gt;getString()) + 1;                                
-          result-&gt;v.string = new char[len];
-          memcpy(result-&gt;v.string, lexer-&gt;getString(), len);
+          // Handle (_ &quot;blup&quot;) strings that need to be translated
+          if(token == Lexer::TOKEN_SYMBOL
+              &amp;&amp; strcmp(lexer-&gt;getString(), &quot;_&quot;) == 0) {
+            token = lexer-&gt;getNextToken();
+            if(token != Lexer::TOKEN_STRING)
+              throw ParseError(this, &quot;Expected string after '(_' sequence&quot;);
+            if(dictionary) {
+              std::string translation = dictionary-&gt;translate(lexer-&gt;getString());
+              entries.push_back(new Lisp(Lisp::TYPE_STRING, translation));
+            } else {
+              entries.push_back(new Lisp(Lisp::TYPE_STRING, lexer-&gt;getString()));
+            }
+            
+            token = lexer-&gt;getNextToken();
+            if(token != Lexer::TOKEN_CLOSE_PAREN)
+              throw ParseError(this, &quot;Expected ')' after '(_ &quot;&quot;' sequence&quot;);
+            break;
+          }
+        
+          entries.push_back(parse());
+          if(token != Lexer::TOKEN_CLOSE_PAREN) {
+            if(token == Lexer::TOKEN_EOF)
+              throw ParseError(this, &quot;Expected ')' token, got EOF&quot;);
+            else
+              throw ParseError(this, &quot;Expected ')' token&quot;);
+          }
+          break;
+        case Lexer::TOKEN_SYMBOL:
+          entries.push_back(new Lisp(Lisp::TYPE_SYMBOL, lexer-&gt;getString()));
+          break;
+        case Lexer::TOKEN_STRING:
+          entries.push_back(new Lisp(Lisp::TYPE_STRING, lexer-&gt;getString()));
+          break;
+        case Lexer::TOKEN_INTEGER: {
+          int val;
+          sscanf(lexer-&gt;getString(), &quot;%d&quot;, &amp;val);
+          entries.push_back(new Lisp(val));
+          break;
         }
-        token = lexer-&gt;getNextToken();
-        if(token != Lexer::TOKEN_CLOSE_PAREN)
-          throw std::runtime_error(&quot;Expected ')' after '(_ string'&quot;);
-        break;
-      }
-
-      Lisp* cur = result;
-      do {
-        cur-&gt;v.cons.car = read();
-        if(token == Lexer::TOKEN_CLOSE_PAREN) {
-          cur-&gt;v.cons.cdr = 0;
+        case Lexer::TOKEN_REAL: {
+          float val;
+          sscanf(lexer-&gt;getString(), &quot;%f&quot;, &amp;val);
+          entries.push_back(new Lisp(val));
           break;
         }
-        cur-&gt;v.cons.cdr = new Lisp(Lisp::TYPE_CONS);
-        cur = cur-&gt;v.cons.cdr;
-      } while(1);
+        case Lexer::TOKEN_TRUE:
+          entries.push_back(new Lisp(true));
+          break;
+        case Lexer::TOKEN_FALSE:
+          entries.push_back(new Lisp(false));
+          break;
+        default:
+          // this should never happen
+          assert(false);
+      }
 
-      break;
+      token = lexer-&gt;getNextToken();
     }
-    case Lexer::TOKEN_SYMBOL: {
-      result = new Lisp(Lisp::TYPE_SYMBOL);
-      size_t len = strlen(lexer-&gt;getString()) + 1;
-      result-&gt;v.string = new char[len];
-      memcpy(result-&gt;v.string, lexer-&gt;getString(), len);
-      break;
-    }
-    case Lexer::TOKEN_STRING: {
-      result = new Lisp(Lisp::TYPE_STRING);
-      size_t len = strlen(lexer-&gt;getString()) + 1;
-      result-&gt;v.string = new char[len];
-      memcpy(result-&gt;v.string, lexer-&gt;getString(), len);
-      break;
-    }
-    case Lexer::TOKEN_INTEGER:
-      result = new Lisp(Lisp::TYPE_INTEGER);
-      sscanf(lexer-&gt;getString(), &quot;%d&quot;, &amp;result-&gt;v.integer);
-      break;
-    case Lexer::TOKEN_REAL:
-      result = new Lisp(Lisp::TYPE_REAL);
-      sscanf(lexer-&gt;getString(), &quot;%f&quot;, &amp;result-&gt;v.real);
-      break;
-    case Lexer::TOKEN_TRUE:
-      result = new Lisp(Lisp::TYPE_BOOLEAN);
-      result-&gt;v.boolean = true;
-      break;
-    case Lexer::TOKEN_FALSE:
-      result = new Lisp(Lisp::TYPE_BOOLEAN);
-      result-&gt;v.boolean = false;
-      break;
-
-    default:
-      // this should never happen
-      assert(false);
+  } catch(...) {
+    for(std::vector&lt;Lisp*&gt;::iterator i = entries.begin();
+        i != entries.end(); ++i)
+      delete *i;
+    throw;
   }
-
-  token = lexer-&gt;getNextToken();
-  return result;
+  
+  return new Lisp(entries);
 }
 
 } // end of namespace lisp

Modified: trunk/src/lisp/parser.hpp
===================================================================
--- trunk/src/lisp/parser.hpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/lisp/parser.hpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -2,7 +2,6 @@
 //
 //  TuxKart - a fun racing game with go-kart
 //  Copyright (C) 2004 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
-//  code in this file based on lispreader from Mark Probst
 //
 //  This program is free software; you can redistribute it and/or
 //  modify it under the terms of the GNU General Public License
@@ -38,13 +37,16 @@
 public:
   ~Parser();
   static Lisp* parse(const std::string&amp; filename);
-  static Lisp* parse(std::istream&amp; stream, const std::string&amp; basedir = &quot;&quot;);
+  static Lisp* parse(std::istream&amp; stream, const std::string&amp; filename = &quot;&quot;);
 
 private:
+  friend class ParseError;
+
   Parser();
   
-  Lisp* read();
-    
+  Lisp* parse();
+  
+  std::string filename;
   Lexer* lexer;
   TinyGetText::DictionaryManager* dictionary_manager;
   TinyGetText::Dictionary* dictionary;

Added: trunk/src/lisp/properties.cpp
===================================================================
--- trunk/src/lisp/properties.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/lisp/properties.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -0,0 +1,49 @@
+#include &lt;config.h&gt;
+
+#include &quot;lisp.hpp&quot;
+#include &quot;properties.hpp&quot;
+
+namespace lisp
+{
+
+Properties::Properties(const Lisp* lisp)
+{
+  if(lisp-&gt;get_type() != Lisp::TYPE_LIST)
+    throw std::runtime_error(&quot;Lisp is not a list&quot;);
+
+  for(size_t i = 0; i &lt; lisp-&gt;get_list_size(); ++i) {
+    const Lisp* child = lisp-&gt;get_list_elem(i);
+    if(i == 0 &amp;&amp; child-&gt;get_type() == Lisp::TYPE_SYMBOL)
+      continue;
+    if(child-&gt;get_type() != Lisp::TYPE_LIST)
+      throw std::runtime_error(&quot;child of properties lisp is not a list&quot;);
+    if(child-&gt;get_list_size() &lt;= 1)
+      throw std::runtime_error(
+          &quot;child of properties lisp needs at least 2 elements&quot;);
+    
+    const Lisp* name = child-&gt;get_list_elem(0);
+    if(name-&gt;get_type() != Lisp::TYPE_SYMBOL)
+      throw std::runtime_error(&quot;property has no string as name&quot;);
+    properties.insert(std::make_pair(
+          std::string(name-&gt;get_symbol()), ListEntry(child)));
+  }
+}
+
+Properties::~Properties()
+{
+}
+
+void
+Properties::print_unused_warnings(const std::string&amp; context) const
+{
+  for(PropertyMap::const_iterator i = properties.begin();
+      i != properties.end(); ++i) {
+    if(i-&gt;second.used)
+      continue;
+
+    std::cout &lt;&lt; &quot;Warning: property '&quot; &lt;&lt; i-&gt;first &lt;&lt; &quot;' not used (in &quot;
+      &lt;&lt; context &lt;&lt; &quot;)\n&quot;;
+  }
+}
+
+}

Added: trunk/src/lisp/properties.hpp
===================================================================
--- trunk/src/lisp/properties.hpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/lisp/properties.hpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -0,0 +1,73 @@
+#ifndef __PROPERTIES_HPP__
+#define __PROPERTIES_HPP__
+
+#include &lt;vector&gt;
+#include &quot;getters.hpp&quot;
+#include &quot;property_iterator.hpp&quot;
+
+namespace lisp
+{
+
+class Properties
+{
+public:
+  Properties(const lisp::Lisp* lisp);
+  ~Properties();
+
+  /**
+   * fetches the value of a property. returns true if the property was defined
+   * and could be converted into the target type, false otherwise.
+   * You have to define get() or property_get() functions to support new
+   * datatypes. See getters.hpp for details
+   */
+  template&lt;class T&gt;
+  bool get(const std::string&amp; name, T&amp; val)
+  {
+    PropertyMap::iterator i = properties.find(name);
+    if(i == properties.end())
+      return false;
+    if(property_get(i-&gt;second.lisp, val) == false)
+      return false;
+    i-&gt;second.used = true;
+    return true;
+  }
+
+  /**
+   * returns an iterator over all properties with a certain name
+   */
+  template&lt;class T&gt;
+  bool get_iter(const std::string&amp; name, PropertyIterator&lt;T&gt;&amp; iter)
+  {
+    PropertyMap::iterator beg = properties.lower_bound(name);
+    if(beg == properties.end() || beg-&gt;first != name) {
+      iter = PropertyIterator&lt;T&gt;(properties.end(), properties.end());
+      return false;
+    }
+    PropertyMap::iterator end = properties.upper_bound(name);
+        
+    iter = PropertyIterator&lt;T&gt;(beg, end);
+    return true;
+  }
+
+  /**
+   * returns an iterator over all properties
+   */
+  PropertyIterator&lt;const Lisp*&gt; get_iter()
+  {
+    return PropertyIterator&lt;const Lisp*&gt;(properties.begin(), properties.end());
+  }
+
+  /**
+   * Prints a warning for properties that have not been accessed. This typically
+   * indicates typos that the user should know about
+   */
+  void print_unused_warnings(const std::string&amp; context) const;
+
+private:
+  PropertyMap properties;
+};
+
+}
+
+#endif
+

Added: trunk/src/lisp/property_iterator.hpp
===================================================================
--- trunk/src/lisp/property_iterator.hpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/lisp/property_iterator.hpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -0,0 +1,74 @@
+#ifndef __PROPERTY_ITERATOR_HPP__
+#define __PROPERTY_ITERATOR_HPP__
+
+#include &lt;map&gt;
+#include &lt;string&gt;
+
+namespace lisp
+{
+
+struct ListEntry {
+  ListEntry(const lisp::Lisp* lisp)
+    : lisp(lisp), used(false)
+  {}
+  
+  const Lisp* lisp;
+  bool used;
+};
+typedef std::multimap&lt;std::string, ListEntry&gt; PropertyMap;
+
+template&lt;class T&gt;
+class PropertyIterator
+{
+public:
+  PropertyIterator()
+  {
+    end = i;
+  }
+
+  T* operator -&gt;() const
+  {
+    return &currentval;
+  }
+  T operator*() const
+  {
+    return currentval;
+  }
+  bool next() {
+    bool res;
+    do {
+      if(i == end)
+        return false;
+      res = property_get(i-&gt;second.lisp, currentval);
+      if(res) {
+        i-&gt;second.used = true;
+        current_item = i-&gt;first;
+      }
+      ++i;
+      if(res)
+        return true;
+    } while(true);
+  }
+  
+  const std::string&amp; item() const
+  {
+    return current_item;
+  }
+  
+private:
+  friend class Properties;
+
+  PropertyIterator(PropertyMap::iterator begin, PropertyMap::iterator end)
+    : i(begin), end(end)
+  {
+  }
+    
+  PropertyMap::iterator i;
+  PropertyMap::iterator end;
+  std::string current_item;
+  T currentval;
+};
+
+}
+
+#endif

Deleted: trunk/src/lisp_util.hpp
===================================================================
--- trunk/src/lisp_util.hpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/lisp_util.hpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -1,22 +0,0 @@
-#ifndef __LISP_UTIL_HPP__
-#define __LISP_UTIL_HPP__
-
-#include &quot;lisp/lisp.hpp&quot;
-
-static inline const lisp::Lisp* lisp_get_list_nth(const lisp::Lisp* lisp, int nth)
-{
-  for(int i = 0; i &lt; nth; ++i) {
-    if(lisp-&gt;get_type() != lisp::Lisp::TYPE_CONS)
-      throw std::runtime_error(&quot;Invalid data when reading lisp list&quot;);
-    if(lisp-&gt;get_cdr() == 0)
-      throw std::runtime_error(&quot;lisp list too short&quot;);
-    lisp = lisp-&gt;get_cdr();
-  }
-  if(lisp-&gt;get_type() != lisp::Lisp::TYPE_CONS)
-    throw std::runtime_error(&quot;Invalid data when reading lisp list&quot;);
-
-  return lisp-&gt;get_car();
-}
-
-#endif
-

Modified: trunk/src/player.cpp
===================================================================
--- trunk/src/player.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/player.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -45,7 +45,7 @@
   pos.y = 200;
   pos.z = 100;
   name = &quot;player&quot;;
-  sprite = sprite3d_manager-&gt;create(&quot;3dsprites/heroken.wsprite&quot;);
+  sprite = sprite3d_manager-&gt;create(&quot;3dsprites/hero.wsprite&quot;);
   grenade = sprite3d_manager-&gt;create(&quot;3dsprites/grenade.wsprite&quot;);
   light.set_blend_func(blend_src_alpha, blend_one);
 
@@ -163,7 +163,7 @@
 
   pos += velocity * elapsed_time;
   sprite-&gt;update(elapsed_time);
-  //grenade-&gt;update(elapsed_time);
+  grenade-&gt;update(elapsed_time);
 
   // FIXME: actually movement should be done through CollisionObject
   //        and this-&gt;pos should be set by getting value from the current CollisionObject

Modified: trunk/src/scripting/serialize.cpp
===================================================================
--- trunk/src/scripting/serialize.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/scripting/serialize.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -4,32 +4,33 @@
 #include &lt;assert.h&gt;
 #include &quot;lisp/lisp.hpp&quot;
 #include &quot;lisp/parser.hpp&quot;
-#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
 #include &quot;lisp/writer.hpp&quot;
 
 void load_squirrel_table(HSQUIRRELVM v, int table_idx, const lisp::Lisp* lisp)
 {
   using namespace lisp;
   
-  ListIterator iter(lisp);
+  Properties props(lisp);
+  PropertyIterator&lt;const Lisp*&gt; iter = props.get_iter();
   while(iter.next()) {
     sq_pushstring(v, iter.item().c_str(), iter.item().size());
-    switch(iter.value().get_type()) {
-      case Lisp::TYPE_CONS:
+    switch((*iter)-&gt;get_type()) {
+      case Lisp::TYPE_LIST:
         sq_newtable(v);
-        load_squirrel_table(v, sq_gettop(v), iter.lisp());
+        load_squirrel_table(v, sq_gettop(v), *iter);
         break;
-      case Lisp::TYPE_INTEGER:
-        sq_pushinteger(v, iter.value().get_int());
+      case Lisp::TYPE_INT:
+        sq_pushinteger(v, (*iter)-&gt;get_int());
         break;
-      case Lisp::TYPE_REAL:
-        sq_pushfloat(v, iter.value().get_float());
+      case Lisp::TYPE_FLOAT:
+        sq_pushfloat(v, (*iter)-&gt;get_float());
         break;
       case Lisp::TYPE_STRING:
-        sq_pushstring(v, iter.value().get_string().c_str(), -1);
+        sq_pushstring(v, (*iter)-&gt;get_string(), -1);
         break;
-      case Lisp::TYPE_BOOLEAN:
-        sq_pushbool(v, iter.value().get_bool());
+      case Lisp::TYPE_BOOL:
+        sq_pushbool(v, (*iter)-&gt;get_bool());
         break;
       case Lisp::TYPE_SYMBOL:
         std::cerr &lt;&lt; &quot;Unexpected symbol in lisp file...&quot;;
@@ -52,9 +53,11 @@
   using namespace lisp;
   std::auto_ptr&lt;Lisp&gt; root (Parser::parse(file));
 
-  const lisp::Lisp* table = root-&gt;get_lisp(&quot;squirrel-state&quot;);
-  if(!table)
+  Properties rootp(root.get());
+  const lisp::Lisp* table;
+  if(rootp.get(&quot;squirrel-state&quot;, table) == false)
     throw std::runtime_error(&quot;Not a squirrel-state file&quot;);
+
   load_squirrel_table(v, table_idx, table);
 }
 

Modified: trunk/src/scripting/spawn_object.cpp
===================================================================
--- trunk/src/scripting/spawn_object.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/scripting/spawn_object.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -11,7 +11,8 @@
 
 using namespace lisp;
 
-lisp::Lisp* table_to_lisp(HSQUIRRELVM v, int table_idx)
+lisp::Lisp* table_to_lisp(HSQUIRRELVM v, int table_idx,
+                          std::vector&lt;lisp::Lisp*&gt;&amp; entries)
 {
   using namespace lisp;
   Lisp* lisp = 0;
@@ -21,17 +22,8 @@
     table_idx--;
 
   // iterate table
-  Lisp* cur = 0;
   sq_pushnull(v);
   while(SQ_SUCCEEDED(sq_next(v, table_idx))) {
-    if(cur == 0) {
-      lisp = new Lisp(Lisp::TYPE_CONS);
-      cur = lisp;
-    } else {
-      cur-&gt;v.cons.cdr = new Lisp(Lisp::TYPE_CONS);
-      cur = cur-&gt;v.cons.cdr;
-    }
-    
     // key is -2, value -1 now
     if(sq_gettype(v, -2) != OT_STRING) {
       std::cerr &lt;&lt; &quot;Table contains a non string key\n&quot;;
@@ -40,16 +32,23 @@
     const char* key;
     sq_getstring(v, -2, &amp;key);
 
+    std::vector&lt;Lisp*&gt; childs;
+    childs.push_back(new Lisp(Lisp::TYPE_SYMBOL, key));
+
     Lisp* val = 0;
     switch(sq_gettype(v, -1)) {
-      case OT_INTEGER:
-        val = new Lisp(Lisp::TYPE_INTEGER);
-        sq_getinteger(v, -1, &amp;val-&gt;v.integer);
+      case OT_INTEGER: {
+        int val;
+        sq_getinteger(v, -1, &amp;val);
+        childs.push_back(new Lisp(val));
         break;
-      case OT_FLOAT:
-        val = new Lisp(Lisp::TYPE_REAL);
-        sq_getfloat(v, -1, &amp;val-&gt;v.real);
+      }
+      case OT_FLOAT: {
+        float val;
+        sq_getfloat(v, -1, &amp;val);
+        childs.push_back(new Lisp(val));
         break;
+      }
       case OT_STRING: {
         const char* str;
         sq_getstring(v, -1, &amp;str);
@@ -59,38 +58,25 @@
       case OT_BOOL: {
         SQBool boolean;
         sq_getbool(v, -1, &amp;boolean);
-        val = new Lisp(Lisp::TYPE_BOOLEAN);
-        val-&gt;v.boolean = boolean;
+        val = new Lisp((bool) boolean);
+        break;
       }
-      case OT_TABLE:
-        val = table_to_lisp(v, -1);
+      case OT_TABLE: {
+        table_to_lisp(v, -1, childs);
         break;
+      }
       case OT_ARRAY:
         // TODO...
       default:
         std::cerr &lt;&lt; &quot;Unsupported value type in table\n&quot;;
         break;
     }
-    if(val == 0)
-      continue;
 
-    Lisp* node = new Lisp(Lisp::TYPE_CONS);
-    cur-&gt;v.cons.car = node;
-
-    node-&gt;v.cons.car = new Lisp(Lisp::TYPE_SYMBOL, key);
-    if(val-&gt;get_type() == Lisp::TYPE_CONS) {
-      node-&gt;v.cons.cdr = val;
-    } else {
-      node-&gt;v.cons.cdr = new Lisp(Lisp::TYPE_CONS);
-      node-&gt;v.cons.cdr-&gt;v.cons.car = val;
-      node-&gt;v.cons.cdr-&gt;v.cons.cdr = 0;
-    }
-    
     // pop table key and value
     sq_pop(v, 2);
+
+    entries.push_back(new Lisp(childs));
   }
-  if(cur != 0)
-    cur-&gt;v.cons.cdr = 0;
   // pop iterator
   sq_pop(v, 1);
 
@@ -99,20 +85,17 @@
 
 int spawn_object(HSQUIRRELVM v)
 {
+  using namespace lisp;
+  
   const char* objname;
   sq_getstring(v, 2, &amp;objname);
 
-  // FIXME: who delete's the lisp?
-  lisp::Lisp* lisp = table_to_lisp(v, 3);
-  if(lisp == 0) {
-    // FIXME: this should never get called, instead Lisp should handle
-    // the empty list (nil) properly, instead of just using NULL
-    // pointer
-    std::cerr &lt;&lt; &quot;Invalid or empty table specified for spawn_object\n&quot;;
-    return 0;
-  }
+  std::vector&lt;lisp::Lisp*&gt; entries;
+  entries.push_back(new Lisp(Lisp::TYPE_SYMBOL, objname));
+  table_to_lisp(v, 3, entries);
+  std::auto_ptr&lt;Lisp&gt; lisp (new Lisp(entries));
   try {
-    Sector::current()-&gt;add_object(objname, lisp);
+    Sector::current()-&gt;add_object(objname, lisp.get());
   } catch(std::exception&amp; e) {
     std::cerr &lt;&lt; &quot;Error parsing object in spawn_object: &quot; &lt;&lt; e.what()
       &lt;&lt; &quot;\n&quot;;

Modified: trunk/src/sector.cpp
===================================================================
--- trunk/src/sector.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/sector.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -20,8 +20,9 @@
 #include &lt;iostream&gt;
 #include &lt;sstream&gt;
 #include &lt;stdexcept&gt;
-#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
 #include &quot;lisp/parser.hpp&quot;
+#include &quot;windstille_getters.hpp&quot;
 #include &quot;globals.hpp&quot;
 #include &quot;display/scene_context.hpp&quot;
 #include &quot;tile_map.hpp&quot;
@@ -52,15 +53,12 @@
 
   current_ = this;
   interactive_tilemap = 0;
-  ambient_light = CL_Color(0, 0, 0);
   parse_file(filename);
   if (!interactive_tilemap)
-    std::cout &lt;&lt; &quot;Error: Sector: No interactive-tilemap available&quot; &lt;&lt; std::endl;
-  else
-    {
-      // add interactive to collision engine
-      collision_engine-&gt;add (new CollisionObject (interactive_tilemap));
-    }
+    throw std::runtime_error(&quot;No interactive-tilemap available&quot;);
+
+  // add interactive to collision engine
+  collision_engine-&gt;add (new CollisionObject (interactive_tilemap));
 }
 
 Sector::~Sector()
@@ -79,55 +77,57 @@
 void
 Sector::parse_file(const std::string&amp; filename)
 {
-  std::auto_ptr&lt;lisp::Lisp&gt; root(lisp::Parser::parse(filename));
+  using namespace lisp;
+  
+  std::auto_ptr&lt;Lisp&gt; root(Parser::parse(filename));
+  Properties rootp(root.get());
 
-  const lisp::Lisp* sector = root-&gt;get_lisp(&quot;windstille-sector&quot;);
-  if(!sector) {
+  const Lisp* sector;
+  if(!rootp.get(&quot;windstille-sector&quot;, sector)) {
     std::ostringstream msg;
     msg &lt;&lt; &quot;'&quot; &lt;&lt; filename &lt;&lt; &quot;' is not a windstille-sector file&quot;;
     throw std::runtime_error(msg.str());
   }
+  rootp.print_unused_warnings(&quot;sector&quot;);
+  
+  Properties props(sector);
 
-  std::vector&lt;int&gt; ambient_colors;
+  int version = 1;
+  if(!props.get(&quot;version&quot;, version))
+    std::cerr &lt;&lt; &quot;Warning no version specified in levelformat.\n&quot;;
+  if(version &gt; 1)
+    std::cerr &lt;&lt; &quot;Warning: format version is newer than game.\n&quot;;
+  props.get(&quot;name&quot;, name);
+  props.get(&quot;music&quot;, music);
+  props.get(&quot;init-script&quot;, init_script);
+  props.get(&quot;ambient-color&quot;, ambient_light);
   
-  lisp::ListIterator iter(sector);
+  PropertyIterator&lt;const Lisp*&gt; iter;
+  props.get_iter(&quot;spawnpoint&quot;, iter);
   while(iter.next()) {
-    if(iter.item() == &quot;version&quot;) {
-      if(iter.value().get_int() &gt; 2) {
-        std::cerr &lt;&lt; &quot;Warning: Levelformat is newer than game.\n&quot;;
-      }
-    } else if(iter.item() == &quot;name&quot;) {
-      name = iter.value().get_string();
-    } else if(iter.item() == &quot;music&quot;) {
-      music = iter.value().get_string();
-    } else if(iter.item() == &quot;init-script&quot;) {
-      init_script = iter.value().get_string();
-    } else if(iter.item() == &quot;ambient-color&quot;) {
-      iter.lisp()-&gt;get_vector(ambient_colors);
-      if(ambient_colors.size() != 3)
-        throw std::runtime_error(
-            &quot;ambient-color contains has to contain exactly 3 values&quot;);
-      ambient_light 
-        = CL_Color(ambient_colors[0], ambient_colors[1], ambient_colors[2]);
-    } else if(iter.item() == &quot;spawnpoint&quot;) {
-      spawn_points.push_back(new SpawnPoint(iter.lisp()));
-    } else if(iter.item() == &quot;objects&quot;) {
-      lisp::ListIterator oiter(iter.lisp());
-      while(oiter.next()) {
-        add_object(oiter.item(), oiter.lisp());
-      }
-    } else {
-      std::cerr &lt;&lt; &quot;Skipping unknown tag '&quot; &lt;&lt; iter.item() &lt;&lt; &quot;' in sector\n&quot;;
-    }
+    spawn_points.push_back(new SpawnPoint(*iter));
   }
+
+  const Lisp* objects;
+  if(props.get(&quot;objects&quot;, objects) == false)
+    throw std::runtime_error(&quot;No objects specified&quot;);
+  Properties pobjects(objects);
+  iter = pobjects.get_iter();
+  while(iter.next()) {
+    add_object(iter.item(), *iter);
+  }
+
+  props.print_unused_warnings(&quot;sector&quot;);
 }
 
 void
 Sector::add_object(const std::string&amp; name, const lisp::Lisp* lisp)
 {
+  printf(&quot;ParseObject: '%s'.\n&quot;, name.c_str());
   if(name == &quot;tilemap&quot;) {
     TileMap* tilemap = new TileMap(lisp);
     add(tilemap);
+    printf(&quot;Name: %s.\n&quot;, tilemap-&gt;get_name().c_str());
     if (tilemap-&gt;get_name() == &quot;interactive&quot;)
       interactive_tilemap = tilemap;
   } else if(name == &quot;background&quot;) {
@@ -178,7 +178,7 @@
     }
   }
 
-  CL_Pointf spawnpos(320, 200);
+  Vector spawnpos(320, 200, 0);
   if(result == 0) {
     if(spawnpoint != &quot;default&quot;) {
       std::cerr &lt;&lt; &quot;SpawnPoint '&quot; &lt;&lt; spawnpoint &lt;&lt; &quot;' not found.\n&quot;;
@@ -193,7 +193,7 @@
     player = new Player();
     add(player);
   }
-  player-&gt;set_pos(spawnpos.x, spawnpos.y);
+  player-&gt;set_pos(spawnpos);
 }
 
 void

Modified: trunk/src/sector.hpp
===================================================================
--- trunk/src/sector.hpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/sector.hpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -22,8 +22,8 @@
 
 #include &lt;string&gt;
 #include &lt;vector&gt;
-#include &lt;ClanLib/Display/color.h&gt;
 #include &quot;lisp/lisp.hpp&quot;
+#include &quot;color.hpp&quot;
 
 class GameObject;
 class TileMap;
@@ -51,7 +51,7 @@
   typedef std::vector&lt;SpawnPoint*&gt; SpawnPoints;
   SpawnPoints spawn_points;
 
-  CL_Color ambient_light;
+  Color ambient_light;
 
   /** The TileMap with which the player interacts */
   TileMap* interactive_tilemap;

Modified: trunk/src/spawnpoint.cpp
===================================================================
--- trunk/src/spawnpoint.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/spawnpoint.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -2,24 +2,18 @@
 
 #include &lt;iostream&gt;
 #include &lt;stdexcept&gt;
-#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
+#include &quot;windstille_getters.hpp&quot;
 
 SpawnPoint::SpawnPoint(const lisp::Lisp* lisp)
 {
-  lisp::ListIterator iter(lisp);
-  while(iter.next()) {
-    if(iter.item() == &quot;name&quot;)
-      name = iter.value().get_string();
-    else if(iter.item() == &quot;x&quot;)
-      pos.x = iter.value().get_float();
-    else if(iter.item() == &quot;y&quot;)
-      pos.y = iter.value().get_float();
-    else {
-      std::cerr &lt;&lt; &quot;Skipping unknown tag '&quot; &lt;&lt; iter.item() 
-                &lt;&lt; &quot;' in SpawnPoint.\n&quot;;
-    }
-  }
+  using namespace lisp;
 
+  Properties props(lisp);
+  props.get(&quot;name&quot;, name);
+  props.get(&quot;pos&quot;, pos);
+  props.print_unused_warnings(&quot;spawnpoint&quot;);
+
   if(name == &quot;&quot;)
     throw std::runtime_error(&quot;No name specified for spawnpoint&quot;);
 }

Modified: trunk/src/spawnpoint.hpp
===================================================================
--- trunk/src/spawnpoint.hpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/spawnpoint.hpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -2,7 +2,7 @@
 #define __SPAWN_POINT_HPP__
 
 #include &lt;string&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &quot;math/vector.hpp&quot;
 #include &quot;lisp/lisp.hpp&quot;
 
 class SpawnPoint
@@ -11,7 +11,7 @@
   SpawnPoint(const lisp::Lisp* lisp);
 
   std::string name;
-  CL_Pointf pos;
+  Vector pos;
 };
 
 #endif

Modified: trunk/src/spider_mine.cpp
===================================================================
--- trunk/src/spider_mine.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/spider_mine.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -14,6 +14,7 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#include &lt;config.h&gt;
 
 #include &quot;spider_mine.hpp&quot;
 #include &quot;sector.hpp&quot;
@@ -25,7 +26,8 @@
 #include &quot;console.hpp&quot;
 #include &quot;sprite3d/manager.hpp&quot;
 #include &quot;util.hpp&quot;
-#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
+#include &quot;windstille_getters.hpp&quot;
 #include &quot;player.hpp&quot;
 #include &quot;tile_map.hpp&quot;
 
@@ -39,21 +41,14 @@
     explode(&quot;explo&quot;, resources),
     explode_light(&quot;explolight&quot;, resources)
 {
+  using namespace lisp;
   pos.z = 100;
-  lisp::ListIterator iter(lisp);
-  while(iter.next()) {
-    if(iter.item() == &quot;name&quot;) {
-      name = iter.value().get_string();
-    } else if(iter.item() == &quot;x&quot;) {
-      pos.x = iter.value().get_float();
-    } else if(iter.item() == &quot;y&quot;) {
-      pos.y = iter.value().get_float();
-    } else {
-      std::cerr &lt;&lt; &quot;Skipping unknown attribute '&quot; 
-                &lt;&lt; iter.item() &lt;&lt; &quot;' in SpiderMine\n&quot;;
-    }
-  }
 
+  Properties props(lisp);
+  props.get(&quot;name&quot;, name);
+  props.get(&quot;pos&quot;, pos);
+  props.print_unused_warnings(&quot;spidermine&quot;);
+
   spider_mine.set_scale(.5, .5);
   initial_position = pos;
   walk_speed = 160;

Modified: trunk/src/sprite2d/data.cpp
===================================================================
--- trunk/src/sprite2d/data.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/sprite2d/data.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -7,9 +7,10 @@
 #include &lt;sstream&gt;
 #include &lt;stdexcept&gt;
 #include &quot;util.hpp&quot;
-#include &quot;lisp/list_iterator.hpp&quot;
 #include &quot;lisp/lisp.hpp&quot;
 #include &quot;lisp/parser.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
+#include &quot;windstille_getters.hpp&quot;
 #include &quot;glutil/texture.hpp&quot;
 #include &quot;glutil/texture_manager.hpp&quot;
 
@@ -19,8 +20,9 @@
 Data::Data(const std::string&amp; filename)
 {
   std::auto_ptr&lt;lisp::Lisp&gt; root (lisp::Parser::parse(filename));
-  const lisp::Lisp* sprite = root-&gt;get_lisp(&quot;sprite&quot;);
-  if(sprite == 0) {
+  lisp::Properties rootp(root.get());
+  const lisp::Lisp* sprite;
+  if(rootp.get(&quot;sprite&quot;, sprite) == false) {
     std::ostringstream msg;
     msg &lt;&lt; &quot;File '&quot; &lt;&lt; filename &lt;&lt; &quot;' is not a windstille sprite&quot;;
     throw std::runtime_error(msg.str());
@@ -39,14 +41,13 @@
 void
 Data::parse(const std::string&amp; dir, const lisp::Lisp* lisp)
 {
-  lisp::ListIterator iter(lisp);
+  lisp::Properties props(lisp);
+  lisp::PropertyIterator&lt;const lisp::Lisp*&gt; iter;
+  props.get_iter(&quot;action&quot;, iter);
   while(iter.next()) {
-    if(iter.item() == &quot;action&quot;) {
-      actions.push_back(parse_action(dir, iter.lisp()));
-    } else {
-      std::cerr &lt;&lt; &quot;Skipping unknown tag '&quot; &lt;&lt; iter.item() &lt;&lt; &quot;' in sprite.\n&quot;;
-    }
+    actions.push_back(parse_action(dir, *iter));
   }
+  props.print_unused_warnings(&quot;sprite&quot;);
 
   if(actions.size() == 0)
     throw std::runtime_error(&quot;Sprite contains no actions&quot;);
@@ -58,27 +59,20 @@
   std::auto_ptr&lt;Action&gt; action (new Action);
   action-&gt;speed = 1.0;
   action-&gt;offset = Vector(0, 0, 0);
+ 
+  lisp::Properties props(lisp);
+  props.get(&quot;name&quot;, action-&gt;name);
+  props.get(&quot;speed&quot;, action-&gt;speed);
+  props.get(&quot;offset&quot;, action-&gt;offset);
   
-  lisp::ListIterator iter(lisp);
-  while(iter.next()) {
-    if(iter.item() == &quot;name&quot;) {
-      action-&gt;name = iter.value().get_string();
-    } else if(iter.item() == &quot;speed&quot;) {
-      action-&gt;speed = iter.value().get_float();
-    } else if(iter.item() == &quot;x-offset&quot;) {
-      action-&gt;offset.x = iter.value().get_float();
-    } else if(iter.item() == &quot;y-offset&quot;) {
-      action-&gt;offset.y = iter.value().get_float();
-    } else if(iter.item() == &quot;z-offset&quot;) {
-      // do we use that for anything anyway?
-      action-&gt;offset.z = iter.value().get_float();
-    } else if(iter.item() == &quot;images&quot;) {
-      parse_images(action.get(), dir, iter.lisp());
-    } else if(iter.item() == &quot;image-grid&quot;) {
-      parse_image_grid(action.get(), dir, iter.lisp());
-    }
+  const lisp::Lisp* ilisp;
+  if(props.get(&quot;images&quot;, ilisp)) {
+    parse_images(action.get(), dir, ilisp);
+  } else if(props.get(&quot;image-grid&quot;, ilisp)) {
+    parse_image_grid(action.get(), dir, ilisp);
   }
-
+  props.print_unused_warnings(&quot;sprite action&quot;);
+  
   if(action-&gt;name == &quot;&quot;)
     throw std::runtime_error(&quot;No Name defined for action&quot;);
   if(action-&gt;images.size() == 0) {
@@ -86,7 +80,6 @@
     msg &lt;&lt; &quot;Action '&quot; &lt;&lt; action-&gt;name &lt;&lt; &quot;' contains no images&quot;;
     throw std::runtime_error(msg.str());
   }
-
   return action.release();
 }
 
@@ -94,9 +87,8 @@
 Data::parse_images(Action* action, const std::string&amp; dir,
                    const lisp::Lisp* lisp)
 {
-  while(lisp &amp;&amp; lisp-&gt;get_type() == lisp::Lisp::TYPE_CONS) {
-    const lisp::Lisp* cur = lisp-&gt;get_car();
-    std::string file = cur-&gt;get_string();
+  for(size_t n = 1; n &lt; lisp-&gt;get_list_size(); ++n) {
+    std::string file = lisp-&gt;get_list_elem(n)-&gt;get_string();
     const Texture* texture = texture_manager-&gt;get(dir + &quot;/&quot; + file);
     
     ActionImage image;
@@ -113,8 +105,6 @@
     uvs[6] = 0;
     uvs[7] = texture-&gt;get_max_v();
     action-&gt;images.push_back(image);
-
-    lisp = lisp-&gt;get_cdr();
   }
 }
 
@@ -125,21 +115,15 @@
   std::string filename;
   int x_size = -1;
   int y_size = -1;
-  
-  lisp::ListIterator iter(lisp);
-  while(iter.next()) {
-    if(iter.item() == &quot;file&quot;) {
-      filename = iter.value().get_string();
-    } else if(iter.item() == &quot;x-size&quot;) {
-      x_size = iter.value().get_int();
-    } else if(iter.item() == &quot;y-size&quot;) {
-      y_size = iter.value().get_int();
-    } else {
-      std::cerr &lt;&lt; &quot;Skipping unknown element '&quot; &lt;&lt; iter.item() 
-                &lt;&lt; &quot;' in image-grid declaration.\n&quot;;
-    }
-  }
+ 
+  lisp::Properties props(lisp);
 
+  props.get(&quot;file&quot;, filename);
+  props.get(&quot;x-size&quot;, x_size);
+  props.get(&quot;y-size&quot;, y_size);
+
+  props.print_unused_warnings(&quot;action image-grid&quot;);
+
   if(filename == &quot;&quot; || x_size &lt;= 0 || y_size &lt;= 0)
     throw std::runtime_error(&quot;Invalid or too few data in image-grid&quot;);
 

Modified: trunk/src/sprite3d/sprite.cpp
===================================================================
--- trunk/src/sprite3d/sprite.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/sprite3d/sprite.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -28,7 +28,6 @@
 #include &lt;physfs.h&gt;
 #include &quot;display/drawing_request.hpp&quot;
 #include &quot;display/scene_context.hpp&quot;
-#include &quot;lisp_util.hpp&quot;
 #include &quot;globals.hpp&quot;
 #include &quot;util.hpp&quot;
 #include &quot;timer.hpp&quot;
@@ -101,9 +100,9 @@
   abort_at_frame.speed = frame-&gt;speed;
   abort_at_frame.rot = frame-&gt;rot;
   if(frame-&gt;speed &gt;= 0) {
-      abort_at_frame.frame = frame-&gt;action-&gt;frame_count - 1;
+    abort_at_frame.frame = frame-&gt;action-&gt;frame_count - 1;
   } else {
-      abort_at_frame.frame = 0;
+    abort_at_frame.frame = 0;
   }
 }
 
@@ -240,7 +239,6 @@
   m.matrix[3] += pos[0];
   m.matrix[7] += pos[1];
   m.matrix[11] += pos[2];
-  printf(&quot;Pos: %f %f %f\n&quot;, pos[0], pos[1], pos[2]);
 
   return m;
 }

Modified: trunk/src/test_object.cpp
===================================================================
--- trunk/src/test_object.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/test_object.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -1,29 +1,21 @@
+#include &lt;config.h&gt;
+
 #include &quot;test_object.hpp&quot;
 #include &quot;sprite3d/manager.hpp&quot;
-#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
+#include &quot;windstille_getters.hpp&quot;
 
 TestObject::TestObject(const lisp::Lisp* lisp)
 {
+  using namespace lisp;
   pos = Vector(0, 0, 100);
   std::string spritename;
 
-  lisp::ListIterator iter(lisp);
-  while(iter.next()) {
-    if(iter.item() == &quot;sprite&quot;) {
-      spritename = iter.value().get_string();
-    } else if(iter.item() == &quot;x&quot;) {
-      pos.x = iter.value().get_float();
-    } else if(iter.item() == &quot;y&quot;) {
-      pos.y = iter.value().get_float();
-    } else if(iter.item() == &quot;z&quot;) {
-      pos.z = iter.value().get_float();
-    } else if(iter.item() == &quot;name&quot;) {
-      name = iter.value().get_string();
-    } else {
-      std::cerr &lt;&lt; &quot;Skipping unknown attribute '&quot; 
-                &lt;&lt; iter.item() &lt;&lt; &quot;' in Box\n&quot;;
-    }
-  }
+  Properties props(lisp);
+  props.get(&quot;sprite&quot;, spritename);
+  props.get(&quot;pos&quot;, pos);
+  props.get(&quot;name&quot;, name);
+  props.print_unused_warnings(&quot;testobject&quot;);
 
   if(spritename == &quot;&quot;)
     throw std::runtime_error(&quot;No sprite name specified in Box&quot;);

Modified: trunk/src/tile_factory.cpp
===================================================================
--- trunk/src/tile_factory.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/tile_factory.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -16,6 +16,7 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#include &lt;config.h&gt;
 
 #include &lt;string&gt;
 #include &lt;sstream&gt;
@@ -35,7 +36,7 @@
 #include &quot;tile_factory.hpp&quot;
 #include &quot;lisp/lisp.hpp&quot;
 #include &quot;lisp/parser.hpp&quot;
-#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
 
 extern CL_ResourceManager* resources;
 
@@ -45,27 +46,29 @@
 
 TileFactory::TileFactory (const std::string&amp; filename)
 {
-  std::auto_ptr&lt;lisp::Lisp&gt; root (lisp::Parser::parse(filename));
+  using namespace lisp;
 
   packers.push_back(new TilePacker(1024, 1024));
   packers.push_back(new TilePacker(1024, 1024));
   color_packer     = 0;
 
-  const lisp::Lisp* tiles_lisp = root-&gt;get_lisp(&quot;windstille-tiles&quot;);
-  if(!tiles_lisp) {
+  std::auto_ptr&lt;Lisp&gt; root (Parser::parse(filename));
+  Properties rootp(root.get());
+  
+  const lisp::Lisp* tiles_lisp;
+  if(rootp.get(&quot;windstille-tiles&quot;, tiles_lisp) == false) {
     std::ostringstream msg;
     msg &lt;&lt; &quot;'&quot; &lt;&lt; filename &lt;&lt; &quot;' is not a windstille tiles file&quot;;
     throw std::runtime_error(msg.str());
   }
-
-  lisp::ListIterator iter(tiles_lisp);
+  
+  Properties props(tiles_lisp);
+  PropertyIterator&lt;const lisp::Lisp*&gt; iter;
+  props.get_iter(&quot;tiles&quot;, iter);
   while(iter.next()) {
-    if(iter.item() == &quot;tiles&quot;) {
-      parse_tiles(iter.lisp());
-    } else {
-      std::cout &lt;&lt; &quot;Unknown tag in tiles file: &quot; &lt;&lt; iter.item() &lt;&lt; &quot;\n&quot;;
-    }
+    parse_tiles(*iter);
   }
+  props.print_unused_warnings(&quot;windstille-tiles&quot;);
 }
 
 TileFactory::~TileFactory()
@@ -80,26 +83,20 @@
 void
 TileFactory::parse_tiles(const lisp::Lisp* data)
 {
+  using namespace lisp;
   assert(data);
 
   std::string filename;
   std::string highlight_filename;
   std::vector&lt;int&gt; colmap;
   std::vector&lt;int&gt; ids;
-  
-  lisp::ListIterator iter(data);
-  while(iter.next()) {
-    if(iter.item() == &quot;ids&quot;) {
-      iter.lisp()-&gt;get_vector(ids);
-    } else if(iter.item() == &quot;image&quot;) {
-      filename = iter.value().get_string();
-    } else if(iter.item() == &quot;colmap&quot;) {
-      iter.lisp()-&gt;get_vector(colmap);
-    } else {
-      std::cerr &lt;&lt; &quot;Unknown tag '&quot; &lt;&lt; iter.item() &lt;&lt; &quot;' found in tiles\n&quot;;
-    }
-  }
 
+  Properties props(data);
+  props.get(&quot;ids&quot;, ids);
+  props.get(&quot;image&quot;, filename);
+  props.get(&quot;colmap&quot;, colmap);
+  props.print_unused_warnings(&quot;tiles&quot;);
+
   if(filename == &quot;&quot;)
     throw std::runtime_error(&quot;Missing color-image&quot;);
   

Modified: trunk/src/tile_map.cpp
===================================================================
--- trunk/src/tile_map.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/tile_map.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -20,53 +20,50 @@
 #include &lt;ClanLib/gl.h&gt;
 #include &lt;ClanLib/display.h&gt;
 #include &lt;sstream&gt;
-#include &quot;lisp/list_iterator.hpp&quot;
 #include &quot;tile_map.hpp&quot;
 #include &quot;tile.hpp&quot;
 #include &quot;tile_factory.hpp&quot;
 #include &quot;globals.hpp&quot;
 #include &quot;view.hpp&quot;
 #include &quot;display/vertex_array_drawing_request.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
 
 extern CL_ResourceManager* resources;
 
 TileMap::TileMap(const lisp::Lisp* lisp)
 {
+  using namespace lisp;
   int width = -1;
   int height = -1;
   z_pos = 0;
   total_time = 0;
   
-  lisp::ListIterator iter(lisp);
-  while(iter.next()) {
-    if(iter.item() == &quot;name&quot;) {
-      name = iter.value().get_string();
-    } else if(iter.item() == &quot;z-pos&quot;) {
-      z_pos = iter.value().get_float();
-    } else if(iter.item() == &quot;width&quot;) {
-      width = iter.value().get_int();
-    } else if(iter.item() == &quot;height&quot;) {
-      height = iter.value().get_int();
-    } else if(iter.item() == &quot;data&quot;) {
-      if(width &lt;= 0 || height &lt;= 0) {
-        throw std::runtime_error(
-            &quot;Invalid width or height defined or &quot;
-            &quot;data defined before width and height&quot;);
-      }
-      Field&lt;int&gt; tmpfield(width, height);
-      iter.lisp()-&gt;get_vector(tmpfield.get_vector());
-    
-      field = Field&lt;Tile*&gt;(width, height);
-
-      for (int y = 0; y &lt; field.get_height (); ++y) 
-        {
-          for (int x = 0; x &lt; field.get_width (); ++x)
-            {
-              field(x, y) = TileFactory::current()-&gt;create(tmpfield(x, y));
-            }
-        }
-    } else {
-      std::cout &lt;&lt; &quot;Skipping unknown Tag '&quot; &lt;&lt; iter.item() &lt;&lt; &quot;' in tilemap\n&quot;;
+  Properties props(lisp);
+  props.get(&quot;name&quot;, name);
+  props.get(&quot;z-pos&quot;, z_pos);
+  props.get(&quot;width&quot;, width);
+  props.get(&quot;height&quot;, height);
+  if(width &lt;= 0 || height &lt;= 0) {
+    throw std::runtime_error(
+        &quot;Invalid width or height defined or &quot;
+        &quot;data defined before width and height&quot;);  
+  }
+  Field&lt;int&gt; tmpfield(width, height);
+  props.get(&quot;data&quot;, tmpfield.get_vector());
+  props.print_unused_warnings(&quot;tilemap&quot;);
+  
+  if(width &lt;= 0 || height &lt;= 0) {
+    throw std::runtime_error(
+        &quot;Invalid width or height defined or &quot;
+        &quot;data defined before width and height&quot;);
+  }
+  
+  field = Field&lt;Tile*&gt;(width, height);
+  for (int y = 0; y &lt; field.get_height (); ++y) 
+  {
+    for (int x = 0; x &lt; field.get_width (); ++x)
+    {
+      field(x, y) = TileFactory::current()-&gt;create(tmpfield(x, y));
     }
   }
 

Modified: trunk/src/trigger.cpp
===================================================================
--- trunk/src/trigger.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/trigger.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -23,35 +23,25 @@
 #include &quot;player.hpp&quot;
 #include &quot;script_manager.hpp&quot;
 #include &quot;lisp/lisp.hpp&quot;
-#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
 
 Trigger::Trigger(const lisp::Lisp* lisp)
   : triggered(false), one_time_trigger(false)
 {
+  using namespace lisp;
   float x = -1;
   float y = -1;
   float width = -1;
   float height = -1;
   
-  lisp::ListIterator iter(lisp);
-  while(iter.next()) {
-    if(iter.item() == &quot;x&quot;) {
-      x = iter.value().get_float();
-    } else if(iter.item() == &quot;y&quot;) {
-      y = iter.value().get_float();
-    } else if(iter.item() == &quot;width&quot;) {
-      width = iter.value().get_float();
-    } else if(iter.item() == &quot;height&quot;) {
-      height = iter.value().get_float();
-    } else if(iter.item() == &quot;script&quot;) {
-      script = iter.value().get_string();
-    } else if(iter.item() == &quot;one_time_trigger&quot;) {
-      one_time_trigger = iter.value().get_bool();
-    } else {
-      std::cerr &lt;&lt; &quot;Skipping unknown tag '&quot;
-                &lt;&lt; iter.item() &lt;&lt; &quot;' in Trigger object.\n&quot;;
-    }
-  }
+  Properties props(lisp);
+  props.get(&quot;x&quot;, x);
+  props.get(&quot;y&quot;, y);
+  props.get(&quot;width&quot;, width);
+  props.get(&quot;height&quot;, height);
+  props.get(&quot;script&quot;, script);
+  props.get(&quot;one_time_trigger&quot;, one_time_trigger);
+  props.print_unused_warnings(&quot;trigger&quot;);
 
   if(x &lt; 0 || y &lt; 0 || width &lt; 0 || height &lt; 0)
     throw std::runtime_error(&quot;Invalid or missing area in Trigger object&quot;);

Modified: trunk/src/useable_object.cpp
===================================================================
--- trunk/src/useable_object.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/useable_object.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -16,30 +16,25 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#include &lt;config.h&gt;
 
 #include &quot;globals.hpp&quot;
 #include &quot;useable_object.hpp&quot;
-#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
+#include &quot;windstille_getters.hpp&quot;
 
 UseableObject::UseableObject(const lisp::Lisp* lisp)
   : highlight(&quot;vrdoor/highlight&quot;, resources),
     color(&quot;vrdoor/color&quot;, resources)
 {
+  using namespace lisp;
   set_useable(true);
   pos.z = 0;
-  lisp::ListIterator iter(lisp);
-  while(iter.next()) {
-    if(iter.item() == &quot;x&quot;) {
-      pos.x = iter.value().get_float();
-    } else if(iter.item() == &quot;y&quot;) {
-      pos.y = iter.value().get_float();
-    } else if(iter.item() == &quot;script&quot;) {
-      use_script = iter.value().get_string();
-    } else {
-      std::cerr &lt;&lt; &quot;Skipping unknown attribute '&quot; 
-                &lt;&lt; iter.item() &lt;&lt; &quot;' in UseableObject\n&quot;;
-    }
-  }
+
+  Properties props(lisp);
+  props.get(&quot;pos&quot;, pos);
+  props.get(&quot;script&quot;, use_script);
+  props.print_unused_warnings(&quot;usableobject&quot;);
 }
 
 void

Added: trunk/src/windstille_getters.cpp
===================================================================
--- trunk/src/windstille_getters.cpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/windstille_getters.cpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -0,0 +1,43 @@
+#include &lt;config.h&gt;
+
+#include &quot;lisp/lisp.hpp&quot;
+#include &quot;lisp/getters.hpp&quot;
+#include &quot;windstille_getters.hpp&quot;
+#include &quot;math/vector.hpp&quot;
+#include &quot;color.hpp&quot;
+
+namespace lisp
+{
+
+bool property_get(const lisp::Lisp* lisp, Color&amp; color)
+{
+  std::vector&lt;float&gt; col;
+  if(property_get(lisp, col) == false)
+    return false;
+  if(col.size() == 3)
+    color = Color(col[0], col[1], col[2]);
+  else if(col.size() == 4)
+    color = Color(col[0], col[1], col[2], col[3]);
+  else
+    return false;
+  
+  return true;
+}
+
+bool property_get(const lisp::Lisp* lisp, Vector&amp; vec)
+{
+  size_t size = lisp-&gt;get_list_size();
+  if(size != 4 &amp;&amp; size != 3)
+    return false;
+  if(get(lisp-&gt;get_list_elem(1), vec.x) == false)
+    return false;
+  if(get(lisp-&gt;get_list_elem(2), vec.y) == false)
+    return false;
+  if(size == 4) {
+    if(get(lisp-&gt;get_list_elem(3), vec.z) == false)
+      return false;
+  }
+  return true;
+}
+
+}

Added: trunk/src/windstille_getters.hpp
===================================================================
--- trunk/src/windstille_getters.hpp	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/src/windstille_getters.hpp	2005-07-24 22:16:51 UTC (rev 738)
@@ -0,0 +1,17 @@
+#ifndef __WINDSTILLE_GETTERS_HPP__
+#define __WINDSTILLE_GETTERS_HPP__
+
+#include &quot;math/vector.hpp&quot;
+
+class Color;
+
+namespace lisp
+{
+
+bool property_get(const lisp::Lisp* lisp, Color&amp; col);
+bool property_get(const lisp::Lisp* lisp, Vector&amp; vec);
+
+}
+
+#endif
+

Modified: trunk/tools/windstille_export.py
===================================================================
--- trunk/tools/windstille_export.py	2005-07-24 21:53:20 UTC (rev 737)
+++ trunk/tools/windstille_export.py	2005-07-24 22:16:51 UTC (rev 738)
@@ -32,8 +32,7 @@
 #
 # See windstille/docs/models.txt for more details
 
-import struct, shlex
-import os.path
+import struct, shlex, os.path, math
 import Blender
 from Blender import NMesh
 from Blender import Window
@@ -47,6 +46,25 @@
 # DO NOT change this
 FORMAT_VERSION = 2
 
+def matrix2quaternion(m):
+  s = math.sqrt(abs(m[0][0] + m[1][1] + m[2][2] + m[3][3]))
+  if s == 0.0:
+    x = abs(m[2][1] - m[1][2])
+    y = abs(m[0][2] - m[2][0])
+    z = abs(m[1][0] - m[0][1])
+    if   (x &gt;= y) and (x &gt;= z): return 1.0, 0.0, 0.0, 0.0
+    elif (y &gt;= x) and (y &gt;= z): return 0.0, 1.0, 0.0, 0.0
+    else:                       return 0.0, 0.0, 1.0, 0.0
+  return quaternion_normalize([
+    -(m[2][1] - m[1][2]) / (2.0 * s),     -(m[0][2] - m[2][0]) / (2.0 * s),
+    -(m[1][0] - m[0][1]) / (2.0 * s),
+    0.5 * s,
+    ])
+
+def quaternion_normalize(q):
+  l = math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3])
+  return q[0] / l, q[1] / l, q[2] / l, q[3] / l
+
 # config entry (first_frame, last_frame, speed, samplerate, markers[])
 #  a marker is (name, frame)
 def parse_actionconfig(text):
@@ -386,10 +404,11 @@
 
       # bone positions
       for bone in bones:
-        loc = bone.getLoc()
+        bonemat = bone.getRestMatrix('worldspace')
+        loc = (m[3][0], m[3][1], m[3][2])
         file.write(struct.pack(&quot;=fff&quot;, loc[0], loc[1], loc[2]))
-        quat = bone.getQuat()
-        file.write(struct.pack(&quot;=ffff&quot;, quat.w, quat.x, quat.y, quat.z))
+        quat = matrix2quaternion(bonemat)
+        file.write(struct.pack(&quot;=ffff&quot;, quat[0], quat[1], quat[2], quat[3]))
       
 def fs_callback(filename):
   export(filename)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000390.html">[Windstille-commit] r737 - trunk/src
</A></li>
	<LI>Next message: <A HREF="000392.html">[Windstille-commit] r739 - trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#391">[ date ]</a>
              <a href="thread.html#391">[ thread ]</a>
              <a href="subject.html#391">[ subject ]</a>
              <a href="author.html#391">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/windstille-commit">More information about the Windstille-commit
mailing list</a><br>
</body></html>
