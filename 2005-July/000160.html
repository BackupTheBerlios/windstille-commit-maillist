<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Windstille-commit] r504 - in trunk: data data/images data/levels data/sounds data/sounds/speech src src/scripting
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/windstille-commit/2005-July/index.html" >
   <LINK REL="made" HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r504%20-%20in%20trunk%3A%20data%20data/images%20data/levels%20data/sounds%20data/sounds/speech%20src%20src/scripting&In-Reply-To=%3C200507021429.j62ETAKh009103%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000668.html">
   <LINK REL="Next"  HREF="000161.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Windstille-commit] r504 - in trunk: data data/images data/levels data/sounds data/sounds/speech src src/scripting</H1>
    <B>Matthias Braun at BerliOS</B> 
    <A HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r504%20-%20in%20trunk%3A%20data%20data/images%20data/levels%20data/sounds%20data/sounds/speech%20src%20src/scripting&In-Reply-To=%3C200507021429.j62ETAKh009103%40sheep.berlios.de%3E"
       TITLE="[Windstille-commit] r504 - in trunk: data data/images data/levels data/sounds data/sounds/speech src src/scripting">matzebraun at berlios.de
       </A><BR>
    <I>Sat Jul  2 16:29:10 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000668.html">[Windstille-commit] r503 - in trunk: . data data/levels src src/display src/input src/scripting
</A></li>
        <LI>Next message: <A HREF="000161.html">[Windstille-commit] r505 - trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#160">[ date ]</a>
              <a href="thread.html#160">[ thread ]</a>
              <a href="subject.html#160">[ subject ]</a>
              <a href="author.html#160">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: matzebraun
Date: 2005-07-02 16:29:09 +0200 (Sat, 02 Jul 2005)
New Revision: 504

Added:
   trunk/data/images/arrow.png
   trunk/data/sounds/
   trunk/data/sounds/speech/
   trunk/data/sounds/speech/vr_intro.ogg
   trunk/src/flashing_sign.cpp
   trunk/src/flashing_sign.hpp
   trunk/src/ref.hpp
   trunk/src/refcounter.hpp
   trunk/src/scripting/game_objects.cpp
   trunk/src/scripting/game_objects.hpp
   trunk/src/spawnpoint.cpp
   trunk/src/spawnpoint.hpp
Modified:
   trunk/data/levels/newformat2.wst
   trunk/data/windstille.xml
   trunk/src/Jamfile
   trunk/src/dialog_manager.cpp
   trunk/src/game_object.cpp
   trunk/src/game_object.hpp
   trunk/src/game_session.cpp
   trunk/src/script_manager.cpp
   trunk/src/script_manager.hpp
   trunk/src/scripting/interface.cpp
   trunk/src/scripting/interface.hpp
   trunk/src/scripting/wrapper.cpp
   trunk/src/scripting/wrapper.hpp
   trunk/src/scripting/wrapper.interface.hpp
   trunk/src/scripting/wrapper_util.cpp
   trunk/src/scripting/wrapper_util.hpp
   trunk/src/sector.cpp
   trunk/src/sector.hpp
   trunk/src/tile_map.hpp
Log:
- Added spawnpoints
- Suspended scripts can now wait for an event from an event bitset
- Added FlashingSign object
- GameObject now hsa a name field
- GameObjects with names are exposed to the scripting layer now
- Added a red arrow and some speech for testing (&quot;programmer art&quot;)



Added: trunk/data/images/arrow.png
===================================================================
(Binary files differ)


Property changes on: trunk/data/images/arrow.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/data/levels/newformat2.wst
===================================================================
--- trunk/data/levels/newformat2.wst	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/data/levels/newformat2.wst	2005-07-02 14:29:09 UTC (rev 504)
@@ -5,6 +5,8 @@
   (music  &quot;music/techdemo.ogg&quot;)
   (ambient-color 170 170 170)
   (init-script &quot;
+wait(1.5);
+play_sound(\&quot;sounds/speech/vr_intro.ogg\&quot;);
 set_dialog(TOP + RIGHT, \&quot;human/portrait\&quot;,
 \&quot;Welcome to the VR training programm. Here you \&quot; +
 \&quot;will learn the basic manovering abilities of your \&quot; +
@@ -12,7 +14,14 @@
 \&quot;We will start with climbing. See the block infront \&quot; +
 \&quot;of you? Press [Right] and [Jump] to hang on the ledge.\&quot;);
 show_dialog(0);
+wait_for_dialog();
+Block0Sign.enable();
 &quot;)
+  (spawnpoint
+    (name &quot;default&quot;)
+    (x 300)
+    (y 650)
+  )
   (objects
     (trigger
       (x 768)
@@ -29,6 +38,14 @@
 print(\&quot;3\&quot;);
 &quot;)
     )
+    (flashing-sign
+      (name &quot;Block0Sign&quot;)
+      (x 550)
+      (y 370)
+      (flashspeed 0.7)
+      (sprite &quot;arrows/red&quot;)
+      (enabled #f)
+    )
   (tilemap (name &quot;background&quot;) (width 100) (height 30)
     (data
       37 38 39 40 41 42 37 38 39 40 41 42 37 38 39 40 41 42 37 38 39 40 41 42 37 38 39 40 41 42 37 38 39 40 41 42 37 38 39 40 41 42 37 38 39 40 41 42 37 38 39 40 41 42 37 38 39 40 41 42 37 38 39 40 41 42 37 38 39 40 41 42 37 38 39 40 41 42 37 38 39 40 41 42 37 38 39 40 41 42 37 38 39 40 41 42 37 38 39 40 

Added: trunk/data/sounds/speech/vr_intro.ogg
===================================================================
(Binary files differ)


Property changes on: trunk/data/sounds/speech/vr_intro.ogg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/data/windstille.xml
===================================================================
--- trunk/data/windstille.xml	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/data/windstille.xml	2005-07-02 14:29:09 UTC (rev 504)
@@ -16,6 +16,12 @@
     &lt;/sprite&gt;
   &lt;/section&gt;
 
+  &lt;section name=&quot;arrows&quot;&gt;
+    &lt;sprite name=&quot;red&quot;&gt;
+      &lt;image file=&quot;images/arrow.png&quot;/&gt;
+    &lt;/sprite&gt;
+  &lt;/section&gt;
+
   &lt;sprite name=&quot;controldialog&quot;&gt;
     &lt;image file=&quot;images/controldialog.png&quot; /&gt;
   &lt;/sprite&gt;

Modified: trunk/src/Jamfile
===================================================================
--- trunk/src/Jamfile	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/Jamfile	2005-07-02 14:29:09 UTC (rev 504)
@@ -40,6 +40,8 @@
         entity.cpp
         entity.hpp
         field.hpp
+        flashing_sign.hpp
+        flashing_sign.cpp
         fonts.cpp
         fonts.hpp
         gameconfig.hpp
@@ -69,6 +71,8 @@
         script_manager.cpp
         sector.cpp
         sector.hpp
+        spawnpoint.cpp
+        spawnpoint.hpp
         sprite3d.cpp
         sprite3d.hpp
         tile.cpp

Modified: trunk/src/dialog_manager.cpp
===================================================================
--- trunk/src/dialog_manager.cpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/dialog_manager.cpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -162,6 +162,7 @@
           if ((*i).button.name == FIRE_BUTTON &amp;&amp; (*i).button.down == true)
             {
               GameSession::current()-&gt;set_game_state();
+              script_manager-&gt;fire_wakeup_event(ScriptManager::DIALOG_CLOSED);
               if (dialogs[current_dialog].answers.size() &gt; 0) {
                 script_manager-&gt;run_script(
                   dialogs[current_dialog].answers[current_choice].second);

Added: trunk/src/flashing_sign.cpp
===================================================================
--- trunk/src/flashing_sign.cpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/flashing_sign.cpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -0,0 +1,80 @@
+#include &quot;flashing_sign.hpp&quot;
+
+#include &lt;math.h&gt;
+#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;timer.hpp&quot;
+#include &quot;globals.hpp&quot;
+
+FlashingSign::FlashingSign(const lisp::Lisp* lisp)
+  : sprite(&quot;arrows/red&quot;, resources), pos(0, 0), enabled(false)
+{
+  std::string spritename;
+  flashspeed = 5;
+
+  lisp::ListIterator iter(lisp);
+  while(iter.next()) {
+    if(iter.item() == &quot;sprite&quot;) {
+      spritename = iter.value().get_string();
+    } else if(iter.item() == &quot;x&quot;) {
+      pos.x = iter.value().get_float();
+    } else if(iter.item() == &quot;y&quot;) {
+      pos.y = iter.value().get_float();
+    } else if(iter.item() == &quot;flashspeed&quot;) {
+      flashspeed = iter.value().get_float();
+    } else if(iter.item() == &quot;name&quot;) {
+      name = iter.value().get_string();
+    } else if(iter.item() == &quot;enabled&quot;) {
+      enabled = iter.value().get_bool();
+    } else {
+      std::cerr &lt;&lt; &quot;Skipping unknown attribute '&quot; 
+                &lt;&lt; iter.item() &lt;&lt; &quot;' in FlashingSign\n&quot;;
+    }
+  }
+
+  if(spritename == &quot;&quot;)
+    throw std::runtime_error(&quot;No sprite name specified in FlashingSign&quot;);
+  sprite = CL_Sprite(spritename, resources);
+  flashdelta = game_time;
+}
+
+FlashingSign::~FlashingSign()
+{
+}
+
+void
+FlashingSign::draw(SceneContext&amp; sc)
+{
+  if(!enabled)
+    return;
+  
+  float time = game_time - flashdelta;
+  
+  if(static_cast&lt;int&gt;(time/flashspeed) % 2 == 0) {
+    float alpha = fmodf(time, flashspeed) / flashspeed;
+    // fade on
+    sprite.set_alpha(alpha);
+  } else {
+    float alpha = 1.0 - (fmodf(time, flashspeed) / flashspeed);
+    // fade off
+    sprite.set_alpha(alpha);
+  }
+  sc.color().draw(sprite, pos.x, pos.y, 10);
+}
+
+void
+FlashingSign::update(float )
+{
+}
+
+void
+FlashingSign::enable()
+{
+  enabled = true;
+  flashdelta = game_time;
+}
+
+void
+FlashingSign::disable()
+{
+  enabled = false;
+}

Added: trunk/src/flashing_sign.hpp
===================================================================
--- trunk/src/flashing_sign.hpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/flashing_sign.hpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -0,0 +1,31 @@
+#ifndef __FLASHING_SIGN_HPP__
+#define __FLASHING_SIGN_HPP__
+
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &quot;game_object.hpp&quot;
+#include &quot;lisp/lisp.hpp&quot;
+
+class FlashingSign : public GameObject
+{
+private:
+  CL_Sprite sprite;
+  CL_Pointf pos;
+
+  bool enabled;
+  float flashspeed;
+  float flashdelta;
+
+public:
+  FlashingSign(const lisp::Lisp* lisp);
+  virtual ~FlashingSign();
+
+  virtual void draw(SceneContext&amp; sc);
+  virtual void update(float elapsed_time);
+
+  void enable();
+  void disable();
+};
+
+#endif
+

Modified: trunk/src/game_object.cpp
===================================================================
--- trunk/src/game_object.cpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/game_object.cpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -18,7 +18,9 @@
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 #include &quot;game_object.hpp&quot;
+#include &quot;sector.hpp&quot;
 
 Sector* GameObject::world;
 
+
 /* EOF */

Modified: trunk/src/game_object.hpp
===================================================================
--- trunk/src/game_object.hpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/game_object.hpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -20,28 +20,50 @@
 #ifndef GAME_OBJECT_HXX
 #define GAME_OBJECT_HXX
 
+#include &lt;string&gt;
 #include &quot;display/scene_context.hpp&quot;
+#include &quot;refcounter.hpp&quot;
 
 class Sector;
 
-class GameObject
+class GameObject : public RefCounter
 {
 private:
   static Sector* world;
-  bool remove_;
+  
 protected:
-  void remove () { remove_= true; } 
+  bool removable;
+
+  /**
+   * name of the GameObject. Note: You should not change it anymore once the
+   * object has been added to a Sector
+   */
+  std::string name;
+
 public:
-  bool is_removable () { return remove_; } 
+  GameObject() : removable(false) {}
+  virtual ~GameObject() {}
+
+
+  void remove()
+  {
+    removable = true;
+  }
+  bool is_removable() const
+  {
+    return removable;
+  }
+
+  const std::string&amp; get_name() const
+  {
+    return name;
+  }
+
+  virtual void draw (SceneContext&amp; context) = 0;
+  virtual void update (float elapsed_time) = 0;
+    
   static void set_world (Sector* w) { world = w; }
-  
   Sector* get_world () { return world; }
-
-  GameObject() : remove_ (false) {}
-  virtual ~GameObject() {}
-
-  virtual void draw (SceneContext&amp; sc) =0;
-  virtual void update (float) =0;
 };
 
 #endif

Modified: trunk/src/game_session.cpp
===================================================================
--- trunk/src/game_session.cpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/game_session.cpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -96,14 +96,8 @@
   // Draw HUD
   energiebar-&gt;draw();
 
-  switch (control_state)
-    {
-    case DIALOG:
-      dialog_manager-&gt;draw();      
-      break;
-    default:
-      break;
-    }
+  if(control_state == DIALOG)
+    dialog_manager-&gt;draw(); 
   
   control_dialog.set_alignment(origin_bottom_right);
   control_dialog.draw(800-16, 600-16);
@@ -237,14 +231,11 @@
 
   GameObject::set_world (world);
 
-  player = new Player();
   view   = new View();
   
   energiebar = new Energiebar();
   dialog_manager = new DialogManager();
 
-  world-&gt;add(player);
-
   logo       = CL_Sprite(&quot;logo&quot;, resources);
   logo_black = CL_Sprite(&quot;logo_black&quot;, resources);
 
@@ -301,6 +292,7 @@
   world-&gt;add(new Sprite3D(&quot;3dsprites/3dsprites&quot;));
 
   world-&gt;activate();
+  world-&gt;spawn_player(&quot;default&quot;);
 }
 
 void

Added: trunk/src/ref.hpp
===================================================================
--- trunk/src/ref.hpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/ref.hpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -0,0 +1,49 @@
+#ifndef __REF_HPP__
+#define __REF_HPP__
+
+template&lt;typename T&gt;
+class Ref
+{
+public:
+  Ref(T* object)
+    : object(object)
+  {
+    if(object)
+      object-&gt;ref();
+  }
+  ~Ref()
+  {
+    if(object)
+      object-&gt;unref();
+  }
+
+  void operator= (T* object)
+  {
+    if(object)
+      object-&gt;ref();
+    if(this-&gt;object)
+      this-&gt;object-&gt;unref();
+    this-&gt;object = object;
+  }
+
+  T* operator -&gt;() const
+  {
+    return object;
+  }
+
+  T&amp; operator* () const
+  {
+    return *object;
+  }
+
+  T* get() const
+  {
+    return object;
+  }
+
+private:
+  T* object;
+};
+
+#endif
+

Added: trunk/src/refcounter.hpp
===================================================================
--- trunk/src/refcounter.hpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/refcounter.hpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -0,0 +1,35 @@
+#ifndef __REFCOUNTER_HPP__
+#define __REFCOUNTER_HPP__
+
+#include &lt;assert.h&gt;
+
+class RefCounter
+{
+public:
+  RefCounter()
+    : refcount(0)
+  { }
+  virtual ~RefCounter()
+  {
+    assert(refcount == 0);
+  }
+
+  void ref()
+  {
+    refcount++;
+  }
+  void unref()
+  {
+    refcount--;
+    if(refcount &lt;= 0) {
+      delete this;
+      return;
+    }
+  }
+
+private:
+  int refcount;
+};
+
+#endif
+

Modified: trunk/src/script_manager.cpp
===================================================================
--- trunk/src/script_manager.cpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/script_manager.cpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -54,7 +54,7 @@
   sq_setprintfunc(v, printfunc);
   
   // register windstille API
-  register_windstille_wrapper(v);
+  SquirrelWrapper::register_windstille_wrapper(v);
 }
 
 ScriptManager::~ScriptManager()
@@ -108,40 +108,7 @@
   handle_suspends(vm, vm_obj);
 }
 
-void
-ScriptManager::expose_object(void* object, const std::string&amp; name,
-                                 const std::string&amp; type)
-{
-  // part1 of registration of the instance in the root table
-  sq_pushroottable(v);
-  sq_pushstring(v, name.c_str(), -1);
-
-  // resolve class name
-  sq_pushroottable(v);
-  sq_pushstring(v, type.c_str(), -1);
-  if(sq_get(v, -2) &lt; 0) {
-    std::ostringstream msg;
-    msg &lt;&lt; &quot;Couldn't resolve squirrel type '&quot; &lt;&lt; type &lt;&lt; &quot;'.&quot;;
-    throw std::runtime_error(msg.str());
-  }
-  sq_remove(v, -2); // remove roottable
-  
-  // create an instance and set pointer to c++ object
-  if(sq_createinstance(v, -1) &lt; 0 || sq_setinstanceup(v, -1, object)) {
-    std::ostringstream msg;
-    msg &lt;&lt; &quot;Couldn't setup squirrel instance for object '&quot;
-        &lt;&lt; name &lt;&lt; &quot;' of type '&quot; &lt;&lt; type &lt;&lt; &quot;'.&quot;;
-    throw SquirrelError(v, msg.str());
-  }
-  
-  sq_remove(v, -2); // remove class from stack
-  
-  // part2 of registration of the instance in the root table
-  if(sq_createslot(v, -3) &lt; 0)
-    throw SquirrelError(v, &quot;Couldn't register object in squirrel root table&quot;);    sq_pop(v, 1);
-}
-
-void
+bool
 ScriptManager::handle_suspends(HSQUIRRELVM vm, HSQOBJECT vm_obj)
 {
   if(sq_getvmstate(vm) == SQ_VMSTATE_SUSPENDED) {
@@ -157,10 +124,14 @@
     if(!found) {
       std::cerr &lt;&lt; &quot;Warning: Script suspended but not in wakeup list!\n&quot;;
       sq_release(v, &amp;vm_obj);
-    }  
+      return true;
+    }
   } else {
     sq_release(v, &amp;vm_obj);
+    return true;
   }
+
+  return false;
 }
 
 void
@@ -169,7 +140,8 @@
   for(WaitingVMs::iterator i = waiting_vms.begin(); i != waiting_vms.end(); ) {
     WaitingVM&amp; waiting_vm = *i;
     
-    if(game_time &gt;= waiting_vm.wakeup_time) {
+    if(waiting_vm.wakeup_time &gt; 0 &amp;&amp; game_time &gt;= waiting_vm.wakeup_time) {
+      waiting_vm.waiting_for_events = 0;
       try {
         if(sq_wakeupvm(waiting_vm.vm, false, false) &lt; 0) {
           throw SquirrelError(waiting_vm.vm, &quot;Couldn't resume script&quot;);
@@ -180,10 +152,10 @@
         i = waiting_vms.erase(i);
         continue;
       }
-      handle_suspends(waiting_vm.vm, waiting_vm.vm_obj);
+      bool stopped = handle_suspends(waiting_vm.vm, waiting_vm.vm_obj);
 
       // remove (but check that the script hasn't set a new wakeup_time)
-      if(game_time &gt;= waiting_vm.wakeup_time)
+      if(stopped)
         i = waiting_vms.erase(i);
     } else {
       ++i;
@@ -192,14 +164,19 @@
 }
 
 void
-ScriptManager::set_wakeup_time(HSQUIRRELVM vm, float time)
+ScriptManager::set_wakeup_event(HSQUIRRELVM vm, WakeupEvent event, float time)
 {
   // search if the VM is already in the wakeup list and update it
   for(WaitingVMs::iterator i = waiting_vms.begin();
       i != waiting_vms.end(); ++i) {
     WaitingVM&amp; waiting_vm = *i;
     if(waiting_vm.vm == vm) {
-      waiting_vm.wakeup_time = game_time + time;
+      if(time &lt; 0) {
+        waiting_vm.wakeup_time = -1;
+      } else {
+        waiting_vm.wakeup_time = game_time + time;
+      }
+      waiting_vm.waiting_for_events |= event;
       return;
     }
   }
@@ -207,7 +184,37 @@
   // create a new entry
   WaitingVM waiting_vm;
   waiting_vm.vm = vm;
-  waiting_vm.wakeup_time = game_time + time;
+  if(time &lt; 0) {
+    waiting_vm.wakeup_time = -1;
+  } else {
+    waiting_vm.wakeup_time = game_time + time;
+  }
+  waiting_vm.waiting_for_events = event;
   waiting_vms.push_back(waiting_vm);
 }
 
+void
+ScriptManager::remove_object(const std::string&amp; name)
+{
+  sq_pushroottable(v);
+  sq_pushstring(v, name.c_str(), -1);
+  if(sq_deleteslot(v, -2, SQFalse) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't remove squirrel object '&quot; &lt;&lt; name &lt;&lt; &quot;'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+  sq_pop(v, 1);
+}
+
+void
+ScriptManager::fire_wakeup_event(WakeupEvent event)
+{
+  for(WaitingVMs::iterator i = waiting_vms.begin();
+      i != waiting_vms.end(); ++i) {
+    WaitingVM&amp; vm = *i;
+    if(vm.waiting_for_events &amp; event) {
+      vm.wakeup_time = game_time;
+    }
+  }
+}
+

Modified: trunk/src/script_manager.hpp
===================================================================
--- trunk/src/script_manager.hpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/script_manager.hpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -6,6 +6,8 @@
 #include &lt;squirrel.h&gt;
 #include &lt;iostream&gt;
 #include &quot;timer.hpp&quot;
+#include &quot;scripting/wrapper.hpp&quot;
+#include &quot;scripting/wrapper_util.hpp&quot;
 
 class ScriptManager
 {
@@ -17,28 +19,55 @@
 
   void run_script(const std::string&amp; script, const std::string&amp; sourcename = &quot;&quot;);
   void run_script(std::istream&amp; in, const std::string&amp; sourcename = &quot;&quot;);
-  
-  void expose_object(void* object, const std::string&amp; name,
-                     const std::string&amp; type);
 
+  template&lt;typename T&gt;
+  void expose_object(T* object, const std::string&amp; name, bool free)
+  {
+    // part1 of registration of the instance in the root table
+    sq_pushroottable(v);
+    sq_pushstring(v, name.c_str(), -1);
+
+    sq_pushroottable(v);
+    SquirrelWrapper::create_squirrel_instance(v, object, free);
+    sq_remove(v, -2);
+    
+    // register instance in root table
+    if(sq_createslot(v, -3) &lt; 0) {
+      std::ostringstream msg;
+      msg &lt;&lt; &quot;Couldn't register object '&quot; &lt;&lt; name &lt;&lt; &quot;' in squirrel root table&quot;;
+      throw SquirrelError(v, msg.str());
+    }
+
+    sq_pop(v, 1);
+  }
+  void remove_object(const std::string&amp; name); 
+
   HSQUIRRELVM get_vm()
   {
     return v;
   }
 
-  void set_wakeup_time(HSQUIRRELVM vm, float time);
+  enum WakeupEvent {
+    TIME            = 0x0000,
+    DIALOG_CLOSED   = 0x0001
+  };                  
 
+  void set_wakeup_event(HSQUIRRELVM vm, WakeupEvent event, float timeout = -1);
+  void fire_wakeup_event(WakeupEvent event);
+
 private:
-  void handle_suspends(HSQUIRRELVM vm, HSQOBJECT vm_obj);
+  /// retuns true if the vm has stopped
+  bool handle_suspends(HSQUIRRELVM vm, HSQOBJECT vm_obj);
   
   struct WaitingVM {
     HSQUIRRELVM vm;
     HSQOBJECT vm_obj;
     float wakeup_time;
+    int waiting_for_events;
   };
   typedef std::list&lt;WaitingVM&gt; WaitingVMs;
   WaitingVMs waiting_vms;
-  
+
   HSQUIRRELVM v;
 };
 

Added: trunk/src/scripting/game_objects.cpp
===================================================================
--- trunk/src/scripting/game_objects.cpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/scripting/game_objects.cpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -0,0 +1,25 @@
+#include &quot;game_objects.hpp&quot;
+
+namespace Scripting
+{
+
+const std::string&amp;
+GameObject::get_name() const
+{
+  return object-&gt;get_name();
+}
+
+void
+FlashingSign::enable()
+{
+  obj()-&gt;enable();
+}
+
+void
+FlashingSign::disable()
+{
+  obj()-&gt;disable();
+}
+
+}
+

Added: trunk/src/scripting/game_objects.hpp
===================================================================
--- trunk/src/scripting/game_objects.hpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/scripting/game_objects.hpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -0,0 +1,57 @@
+#ifndef __GAMEOBJECTS_HPP__
+#define __GAMEOBJECTS_HPP__
+
+#ifndef SCRIPTING_API
+#include &quot;game_object.hpp&quot;
+#include &quot;flashing_sign.hpp&quot;
+#include &quot;ref.hpp&quot;
+
+typedef GameObject _GameObject;
+typedef FlashingSign _FlashingSign;
+#endif
+
+namespace Scripting
+{
+
+class GameObject
+{
+#ifndef SCRIPTING_API
+protected:
+  Ref&lt;_GameObject&gt; object;
+  
+public:
+  GameObject(_GameObject* _object)
+    : object(_object)
+  { }
+  virtual ~GameObject()
+  {}
+#endif
+  
+public:
+  const std::string&amp; get_name() const;
+};
+
+class FlashingSign : public GameObject
+{
+#ifndef SCRIPTING_API
+public:
+  FlashingSign(_FlashingSign* _object)
+    : GameObject(_object)
+  { }
+  virtual ~FlashingSign() {}  
+
+  _FlashingSign* obj() const
+  {
+    return reinterpret_cast&lt;_FlashingSign*&gt; (object.get());
+  }
+#endif
+
+public:
+  void enable();
+  void disable();
+};
+
+}
+
+#endif
+

Modified: trunk/src/scripting/interface.cpp
===================================================================
--- trunk/src/scripting/interface.cpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/scripting/interface.cpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -37,8 +37,13 @@
 
 void wait(HSQUIRRELVM vm, float time)
 {
-  script_manager-&gt;set_wakeup_time(vm, time);
+  script_manager-&gt;set_wakeup_event(vm, ScriptManager::TIME, time);
 }
 
+void wait_for_dialog(HSQUIRRELVM vm)
+{
+  script_manager-&gt;set_wakeup_event(vm, ScriptManager::DIALOG_CLOSED, -1);
 }
 
+}
+

Modified: trunk/src/scripting/interface.hpp
===================================================================
--- trunk/src/scripting/interface.hpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/scripting/interface.hpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -33,6 +33,11 @@
  */
 void wait(HSQUIRRELVM vm, float time);
 
+/** @SUSPEND@
+ * Waits till currently opened dialog has closed.
+ */
+void wait_for_dialog(HSQUIRRELVM vm);
+
 }
 
 #endif

Modified: trunk/src/scripting/wrapper.cpp
===================================================================
--- trunk/src/scripting/wrapper.cpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/scripting/wrapper.cpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -12,8 +12,94 @@
 #include &quot;wrapper_util.hpp&quot;
 #include &quot;wrapper.interface.hpp&quot;
 
-using namespace Scripting;
+namespace SquirrelWrapper
+{
 
+static int GameObject_release_hook(SQUserPointer ptr, int )
+{
+  Scripting::GameObject* _this = reinterpret_cast&lt;Scripting::GameObject*&gt; (ptr);
+  delete _this;
+  return 0;
+}
+
+void create_squirrel_instance(HSQUIRRELVM v, Scripting::GameObject* object, bool setup_releasehook)
+{
+  sq_pushstring(v, &quot;GameObject&quot;, -1);
+  if(sq_get(v, -2) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't resolved squirrel type 'GameObject'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  if(sq_createinstance(v, -1) &lt; 0 || sq_setinstanceup(v, -1, object) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't setup squirrel instance for object of type 'GameObject'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+  sq_remove(v, -2);
+
+  if(setup_releasehook) {
+    sq_setreleasehook(v, -1, GameObject_release_hook);
+  }
+}
+static int GameObject_get_name_wrapper(HSQUIRRELVM v)
+{
+  Scripting::GameObject* _this;
+  sq_getinstanceup(v, 1, (SQUserPointer*) &amp;_this, 0);
+  
+  const std::string&amp; return_value = _this-&gt;get_name();
+  
+  sq_pushstring(v, return_value.c_str(), return_value.size());
+  return 1;
+}
+
+static int FlashingSign_release_hook(SQUserPointer ptr, int )
+{
+  Scripting::FlashingSign* _this = reinterpret_cast&lt;Scripting::FlashingSign*&gt; (ptr);
+  delete _this;
+  return 0;
+}
+
+void create_squirrel_instance(HSQUIRRELVM v, Scripting::FlashingSign* object, bool setup_releasehook)
+{
+  sq_pushstring(v, &quot;FlashingSign&quot;, -1);
+  if(sq_get(v, -2) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't resolved squirrel type 'FlashingSign'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  if(sq_createinstance(v, -1) &lt; 0 || sq_setinstanceup(v, -1, object) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't setup squirrel instance for object of type 'FlashingSign'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+  sq_remove(v, -2);
+
+  if(setup_releasehook) {
+    sq_setreleasehook(v, -1, FlashingSign_release_hook);
+  }
+}
+static int FlashingSign_enable_wrapper(HSQUIRRELVM v)
+{
+  Scripting::FlashingSign* _this;
+  sq_getinstanceup(v, 1, (SQUserPointer*) &amp;_this, 0);
+  
+  _this-&gt;enable();
+  
+  return 0;
+}
+
+static int FlashingSign_disable_wrapper(HSQUIRRELVM v)
+{
+  Scripting::FlashingSign* _this;
+  sq_getinstanceup(v, 1, (SQUserPointer*) &amp;_this, 0);
+  
+  _this-&gt;disable();
+  
+  return 0;
+}
+
 static int play_music_wrapper(HSQUIRRELVM v)
 {
   const char* arg0;
@@ -79,35 +165,176 @@
   return sq_suspendvm(v);
 }
 
-WrappedFunction windstille_global_functions[] = {
-  { &quot;play_music&quot;, &amp;play_music_wrapper },
-  { &quot;play_sound&quot;, &amp;play_sound_wrapper },
-  { &quot;set_dialog&quot;, &amp;set_dialog_wrapper },
-  { &quot;show_dialog&quot;, &amp;show_dialog_wrapper },
-  { &quot;hide_dialog&quot;, &amp;hide_dialog_wrapper },
-  { &quot;wait&quot;, &amp;wait_wrapper },
-  { 0, 0 }
-};
+static int wait_for_dialog_wrapper(HSQUIRRELVM v)
+{
+  HSQUIRRELVM arg0 = v;
+  
+  Scripting::wait_for_dialog(arg0);
+  
+  return sq_suspendvm(v);
+}
 
-WrappedConstant&lt;int&gt; windstille_int_constants[] = {
-  { &quot;VCENTER&quot;, 0},
-  { &quot;LEFT&quot;, 1},
-  { &quot;RIGHT&quot;, 2},
-  { &quot;HCENTER&quot;, 0},
-  { &quot;TOP&quot;, 16},
-  { &quot;BOTTOM&quot;, 32},
-  { 0, 0}
-};
+void register_windstille_wrapper(HSQUIRRELVM v)
+{
+  sq_pushroottable(v);
+  sq_pushstring(v, &quot;VCENTER&quot;, -1);
+  sq_pushinteger(v, 0);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register constant'VCENTER'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
 
-WrappedConstant&lt;float&gt; windstille_float_constants[] = {
-  { 0, 0}
-};
+  sq_pushstring(v, &quot;LEFT&quot;, -1);
+  sq_pushinteger(v, 1);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register constant'LEFT'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
 
-WrappedConstant&lt;const char*&gt; windstille_string_constants[] = {
-  { 0, 0}
-};
+  sq_pushstring(v, &quot;RIGHT&quot;, -1);
+  sq_pushinteger(v, 2);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register constant'RIGHT'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
 
-WrappedClass windstille_classes[] = {
-  { 0, 0, 0, 0, 0 }
-};
+  sq_pushstring(v, &quot;HCENTER&quot;, -1);
+  sq_pushinteger(v, 0);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register constant'HCENTER'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
 
+  sq_pushstring(v, &quot;TOP&quot;, -1);
+  sq_pushinteger(v, 16);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register constant'TOP'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  sq_pushstring(v, &quot;BOTTOM&quot;, -1);
+  sq_pushinteger(v, 32);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register constant'BOTTOM'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  sq_pushstring(v, &quot;play_music&quot;, -1);
+  sq_newclosure(v, &amp;play_music_wrapper, 0);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register function'play_music'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  sq_pushstring(v, &quot;play_sound&quot;, -1);
+  sq_newclosure(v, &amp;play_sound_wrapper, 0);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register function'play_sound'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  sq_pushstring(v, &quot;set_dialog&quot;, -1);
+  sq_newclosure(v, &amp;set_dialog_wrapper, 0);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register function'set_dialog'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  sq_pushstring(v, &quot;show_dialog&quot;, -1);
+  sq_newclosure(v, &amp;show_dialog_wrapper, 0);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register function'show_dialog'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  sq_pushstring(v, &quot;hide_dialog&quot;, -1);
+  sq_newclosure(v, &amp;hide_dialog_wrapper, 0);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register function'hide_dialog'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  sq_pushstring(v, &quot;wait&quot;, -1);
+  sq_newclosure(v, &amp;wait_wrapper, 0);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register function'wait'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  sq_pushstring(v, &quot;wait_for_dialog&quot;, -1);
+  sq_newclosure(v, &amp;wait_for_dialog_wrapper, 0);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register function'wait_for_dialog'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  // Register class GameObject
+  sq_pushstring(v, &quot;GameObject&quot;, -1);
+  if(sq_newclass(v, SQFalse) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't create new class 'GameObject'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+  sq_pushstring(v, &quot;get_name&quot;, -1);
+  sq_newclosure(v, &amp;GameObject_get_name_wrapper, 0);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register function'get_name'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register class'GameObject'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  // Register class FlashingSign
+  sq_pushstring(v, &quot;FlashingSign&quot;, -1);
+  sq_pushstring(v, &quot;GameObject&quot;, -1);
+  sq_get(v, -3);
+  if(sq_newclass(v, SQTrue) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't create new class 'FlashingSign'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+  sq_pushstring(v, &quot;enable&quot;, -1);
+  sq_newclosure(v, &amp;FlashingSign_enable_wrapper, 0);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register function'enable'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  sq_pushstring(v, &quot;disable&quot;, -1);
+  sq_newclosure(v, &amp;FlashingSign_disable_wrapper, 0);
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register function'disable'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  if(sq_createslot(v, -3) &lt; 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't register class'FlashingSign'&quot;;
+    throw SquirrelError(v, msg.str());
+  }
+
+  sq_pop(v, 1);
+}
+
+}
+

Modified: trunk/src/scripting/wrapper.hpp
===================================================================
--- trunk/src/scripting/wrapper.hpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/scripting/wrapper.hpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -6,21 +6,17 @@
 #ifndef __windstille_WRAPPER_H__
 #define __windstille_WRAPPER_H__
 
-#include &quot;wrapper_util.hpp&quot;
+#include &lt;squirrel.h&gt;
+#include &quot;wrapper.interface.hpp&quot;
 
-extern WrappedFunction windstille_global_functions[];
-extern WrappedClass windstille_classes[];
-extern WrappedConstant&lt;int&gt; windstille_int_constants[];
-extern WrappedConstant&lt;float&gt; windstille_float_constants[];
-extern WrappedConstant&lt;const char*&gt; windstille_string_constants[];
-
-static inline void register_windstille_wrapper(HSQUIRRELVM v)
+namespace SquirrelWrapper
 {
-    register_functions(v, windstille_global_functions);
-    register_classes(v, windstille_classes);
-    register_constants(v, windstille_int_constants);
-    register_constants(v, windstille_float_constants);
-    register_constants(v, windstille_string_constants);
+
+void register_windstille_wrapper(HSQUIRRELVM v);
+
+void create_squirrel_instance(HSQUIRRELVM v, Scripting::GameObject* object, bool setup_releasehook = false);
+void create_squirrel_instance(HSQUIRRELVM v, Scripting::FlashingSign* object, bool setup_releasehook = false);
+
 }
 
 #endif

Modified: trunk/src/scripting/wrapper.interface.hpp
===================================================================
--- trunk/src/scripting/wrapper.interface.hpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/scripting/wrapper.interface.hpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -1 +1,2 @@
 #include &quot;interface.hpp&quot;
+#include &quot;game_objects.hpp&quot;

Modified: trunk/src/scripting/wrapper_util.cpp
===================================================================
--- trunk/src/scripting/wrapper_util.cpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/scripting/wrapper_util.cpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -4,57 +4,6 @@
 #include &lt;sstream&gt;
 #include &quot;wrapper_util.hpp&quot;
 
-static void register_function(HSQUIRRELVM v, SQFUNCTION func, const char* name)
-{
-    sq_pushstring(v, name, -1);
-    sq_newclosure(v, func, 0); //create a new function
-    if(sq_createslot(v, -3) &lt; 0) {
-        std::stringstream msg;
-        msg &lt;&lt; &quot;Couldn't register function '&quot; &lt;&lt; name &lt;&lt; &quot;'&quot;;
-        throw SquirrelError(v, msg.str());
-    }
-}
-
-static void _register_functions(HSQUIRRELVM v, WrappedFunction* functions)
-{
-    for(WrappedFunction* func = functions; func-&gt;name != 0; ++func) {
-        register_function(v, func-&gt;f, func-&gt;name);
-    }
-}
-
-static void register_class(HSQUIRRELVM v, WrappedClass* wclass)
-{
-    sq_pushstring(v, wclass-&gt;name, -1);
-    sq_newclass(v, false);
-    _register_functions(v, wclass-&gt;functions);
-    _register_constants(v, wclass-&gt;int_consts);
-    _register_constants(v, wclass-&gt;float_consts);
-    _register_constants(v, wclass-&gt;string_consts);
-
-    if(sq_createslot(v, -3) &lt; 0) {
-        std::stringstream msg;
-        msg &lt;&lt; &quot;Couldn't register function '&quot; &lt;&lt; wclass-&gt;name &lt;&lt; &quot;'&quot;;
-        throw SquirrelError(v, msg.str());
-    }
-}
-
-void register_functions(HSQUIRRELVM v, WrappedFunction* functions)
-{
-    sq_pushroottable(v);
-    _register_functions(v, functions);
-    sq_pop(v, 1);
-}
-
-void register_classes(HSQUIRRELVM v, WrappedClass* classes)
-{
-    sq_pushroottable(v);
-    for(WrappedClass* wclass = classes; wclass-&gt;name != 0; ++wclass) {
-        register_class(v, wclass);
-    }
-    sq_pop(v, 1);
-}
-
-
 void print_squirrel_stack(HSQUIRRELVM v)
 {
     printf(&quot;--------------------------------------------------------------\n&quot;);

Modified: trunk/src/scripting/wrapper_util.hpp
===================================================================
--- trunk/src/scripting/wrapper_util.hpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/scripting/wrapper_util.hpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -6,25 +6,6 @@
 #include &lt;sstream&gt;
 #include &lt;string&gt;
 
-struct WrappedFunction {
-    const char* name;
-    SQFUNCTION f;
-};
-
-template&lt;typename T&gt;
-struct WrappedConstant {
-    const char* name;
-    T value;
-};
-
-struct WrappedClass {
-    const char* name;
-    WrappedFunction* functions;
-    WrappedConstant&lt;int&gt;* int_consts;
-    WrappedConstant&lt;float&gt;* float_consts;
-    WrappedConstant&lt;const char*&gt;* string_consts;
-};
-
 class SquirrelError : public std::exception
 {
 public:
@@ -36,46 +17,6 @@
   std::string message;
 };
 
-void register_functions(HSQUIRRELVM v, WrappedFunction* functions);
-void register_classes(HSQUIRRELVM v, WrappedClass* classes);
-
-static inline void push_value(HSQUIRRELVM v, int val)
-{
-    sq_pushinteger(v, val);
-}
-
-static inline void push_value(HSQUIRRELVM v, float val)
-{
-    sq_pushfloat(v, val);
-}
-
-static inline void push_value(HSQUIRRELVM v, const char* str)
-{
-    sq_pushstring(v, str, -1);
-}
-
-template&lt;typename T&gt;
-void _register_constants(HSQUIRRELVM v, WrappedConstant&lt;T&gt;* constants)
-{
-    for(WrappedConstant&lt;T&gt;* c = constants; c-&gt;name != 0; ++c) {
-        sq_pushstring(v, c-&gt;name, -1);
-        push_value(v, c-&gt;value);
-        if(sq_createslot(v, -3) &lt; 0) {
-            std::stringstream msg;
-            msg &lt;&lt; &quot;Couldn't register int constant '&quot; &lt;&lt; c-&gt;name &lt;&lt; &quot;'&quot;;
-            throw SquirrelError(v, msg.str());
-        }
-    }
-}
-
-template&lt;typename T&gt;
-void register_constants(HSQUIRRELVM v, WrappedConstant&lt;T&gt;* constants)
-{
-    sq_pushroottable(v);
-    _register_constants(v, constants);
-    sq_pop(v, 1);
-}
-
 void print_squirrel_stack(HSQUIRRELVM v);
 
 #endif

Modified: trunk/src/sector.cpp
===================================================================
--- trunk/src/sector.cpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/sector.cpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -28,13 +28,16 @@
 #include &quot;game_object.hpp&quot;
 #include &quot;player.hpp&quot;
 #include &quot;trigger.hpp&quot;
+#include &quot;flashing_sign.hpp&quot;
 #include &quot;sector.hpp&quot;
+#include &quot;spawnpoint.hpp&quot;
 #include &quot;sound/sound_manager.hpp&quot;
 #include &quot;script_manager.hpp&quot;
 
 Sector* Sector::current_ = 0;
 
 Sector::Sector(const std::string&amp; filename)
+  : player(0)
 {
   current_ = this;
   interactive_tilemap = 0;
@@ -46,6 +49,13 @@
 
 Sector::~Sector()
 {
+  for(SpawnPoints::iterator i = spawn_points.begin();
+      i != spawn_points.end(); ++i)
+    delete *i;                                         
+  for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
+    (*i)-&gt;unref();
+  for(Objects::iterator i = new_objects.begin(); i != new_objects.end(); ++i)
+    (*i)-&gt;unref();
 }
 
 void
@@ -81,6 +91,8 @@
             &quot;ambient-color contains has to contain exactly 3 values&quot;);
       ambient_light 
         = CL_Color(ambient_colors[0], ambient_colors[1], ambient_colors[2]);
+    } else if(iter.item() == &quot;spawnpoint&quot;) {
+      spawn_points.push_back(new SpawnPoint(iter.lisp()));
     } else if(iter.item() == &quot;objects&quot;) {
       lisp::ListIterator oiter(iter.lisp());
       while(oiter.next()) {
@@ -104,6 +116,8 @@
     // TODO
   } else if(name == &quot;trigger&quot;) {
     add(new Trigger(lisp));
+  } else if(name == &quot;flashing-sign&quot;) {
+    add(new FlashingSign(lisp));
   } else {
     std::cout &lt;&lt; &quot;Skipping unknown Object: &quot; &lt;&lt; name &lt;&lt; &quot;\n&quot;;
   }
@@ -120,6 +134,37 @@
 }
 
 void
+Sector::spawn_player(const std::string&amp; spawnpoint)
+{
+  const SpawnPoint* result = 0;
+  for(SpawnPoints::iterator i = spawn_points.begin();
+      i != spawn_points.end(); ++i) {
+    const SpawnPoint* sp = *i;
+    if(sp-&gt;name == spawnpoint) {
+      result = sp;
+      break;
+    }
+  }
+
+  CL_Pointf spawnpos(320, 200);
+  if(result == 0) {
+    if(spawnpoint != &quot;default&quot;) {
+      std::cerr &lt;&lt; &quot;SpawnPoint '&quot; &lt;&lt; spawnpoint &lt;&lt; &quot;' not found.\n&quot;;
+      spawn_player(&quot;default&quot;);
+      return;
+    }
+  } else {
+    spawnpos = result-&gt;pos;
+  }
+
+  if(!player) {
+    player = new Player();
+    add(player);
+  }
+  player-&gt;set_position(CL_Vector(spawnpos.x, spawnpos.y, 0));
+}
+
+void
 Sector::draw(SceneContext&amp; sc)
 {
   sc.light().fill_screen(ambient_light);
@@ -156,7 +201,10 @@
   for(Objects::iterator i = objects.begin(); i != objects.end(); ) {
     GameObject* object = *i;
     if(object-&gt;is_removable()) {
-      delete object;
+      if(object-&gt;get_name() != &quot;&quot;) {
+        remove_object_from_squirrel(object);
+      }
+      object-&gt;unref();
       i = objects.erase(i);
       continue;
     }
@@ -169,8 +217,32 @@
 Sector::add(GameObject* obj)
 {
   new_objects.push_back(obj);
+  obj-&gt;ref();
+  if(obj-&gt;get_name() != &quot;&quot;) {
+    expose_object_to_squirrel(obj);
+  }
 }
 
+void
+Sector::remove_object_from_squirrel(GameObject* object)
+{
+  script_manager-&gt;remove_object(object-&gt;get_name());
+}
+
+void
+Sector::expose_object_to_squirrel(GameObject* object)
+{
+  FlashingSign* sign = dynamic_cast&lt;FlashingSign*&gt; (object);
+  if(sign) {
+    script_manager-&gt;expose_object(new Scripting::FlashingSign(sign),
+                                  object-&gt;get_name(), true);
+    return;
+  }
+
+  script_manager-&gt;expose_object(new Scripting::GameObject(object),
+                                object-&gt;get_name(), true);
+}
+
 int
 Sector::get_width () const
 {

Modified: trunk/src/sector.hpp
===================================================================
--- trunk/src/sector.hpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/sector.hpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -29,6 +29,7 @@
 class TileMap;
 class Player;
 class SceneContext;
+class SpawnPoint;
 
 /** */
 class Sector
@@ -45,6 +46,9 @@
    */
   Objects new_objects;
 
+  typedef std::vector&lt;SpawnPoint*&gt; SpawnPoints;
+  SpawnPoints spawn_points;
+
   CL_Color ambient_light;
 
   /** The TileMap with which the player interacts */
@@ -59,6 +63,8 @@
 
   void commit_adds();
   void commit_removes();
+  void expose_object_to_squirrel(GameObject* object);
+  void remove_object_from_squirrel(GameObject* object);
 public:
   Sector(const std::string&amp; filename);
   ~Sector();
@@ -72,6 +78,11 @@
    * activates the sector. (Runs init script, changes music)
    */
   void activate();
+  
+  /**
+   * Spawns the player at the specified spawnpoint
+   */
+  void spawn_player(const std::string&amp; spawnpoint);
 
   int get_width () const;
   int get_height () const;

Added: trunk/src/spawnpoint.cpp
===================================================================
--- trunk/src/spawnpoint.cpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/spawnpoint.cpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -0,0 +1,25 @@
+#include &quot;spawnpoint.hpp&quot;
+
+#include &lt;iostream&gt;
+#include &lt;stdexcept&gt;
+#include &quot;lisp/list_iterator.hpp&quot;
+
+SpawnPoint::SpawnPoint(const lisp::Lisp* lisp)
+{
+  lisp::ListIterator iter(lisp);
+  while(iter.next()) {
+    if(iter.item() == &quot;name&quot;)
+      name = iter.value().get_string();
+    else if(iter.item() == &quot;x&quot;)
+      pos.x = iter.value().get_float();
+    else if(iter.item() == &quot;y&quot;)
+      pos.y = iter.value().get_float();
+    else {
+      std::cerr &lt;&lt; &quot;Skipping unknown tag '&quot; &lt;&lt; iter.item() 
+                &lt;&lt; &quot;' in SpawnPoint.\n&quot;;
+    }
+  }
+
+  if(name == &quot;&quot;)
+    throw std::runtime_error(&quot;No name specified for spawnpoint&quot;);
+}

Added: trunk/src/spawnpoint.hpp
===================================================================
--- trunk/src/spawnpoint.hpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/spawnpoint.hpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -0,0 +1,18 @@
+#ifndef __SPAWN_POINT_HPP__
+#define __SPAWN_POINT_HPP__
+
+#include &lt;string&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &quot;lisp/lisp.hpp&quot;
+
+class SpawnPoint
+{
+public:
+  SpawnPoint(const lisp::Lisp* lisp);
+
+  std::string name;
+  CL_Pointf pos;
+};
+
+#endif
+

Modified: trunk/src/tile_map.hpp
===================================================================
--- trunk/src/tile_map.hpp	2005-07-01 22:34:46 UTC (rev 503)
+++ trunk/src/tile_map.hpp	2005-07-02 14:29:09 UTC (rev 504)
@@ -38,7 +38,6 @@
   friend class TileMapDrawingRequest;
   Field&lt;Tile*&gt; field;
   typedef Field&lt;Tile*&gt;::iterator FieldIter;
-  std::string name;
   float z_pos; 
   float total_time;
 public:
@@ -60,8 +59,6 @@
   int get_height () const { return field.get_height (); }
 
   int get_tile_size () const { return TILE_SIZE; }
-
-  std::string get_name() const { return name; }
 };
 
 #endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000668.html">[Windstille-commit] r503 - in trunk: . data data/levels src src/display src/input src/scripting
</A></li>
	<LI>Next message: <A HREF="000161.html">[Windstille-commit] r505 - trunk/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#160">[ date ]</a>
              <a href="thread.html#160">[ thread ]</a>
              <a href="subject.html#160">[ subject ]</a>
              <a href="author.html#160">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/windstille-commit">More information about the Windstille-commit
mailing list</a><br>
</body></html>
