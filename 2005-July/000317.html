<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Windstille-commit] r664 - in trunk: . data/images data/levels src src/display src/glutil src/physfs src/sprite2d src/sprite3d
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/windstille-commit/2005-July/index.html" >
   <LINK REL="made" HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r664%20-%20in%20trunk%3A%20.%20data/images%20data/levels%20src%20src/display%20src/glutil%20src/physfs%20src/sprite2d%20src/sprite3d&In-Reply-To=%3C200507172346.j6HNkXbv001124%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000316.html">
   <LINK REL="Next"  HREF="000318.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Windstille-commit] r664 - in trunk: . data/images data/levels src src/display src/glutil src/physfs src/sprite2d src/sprite3d</H1>
    <B>Matthias Braun at BerliOS</B> 
    <A HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r664%20-%20in%20trunk%3A%20.%20data/images%20data/levels%20src%20src/display%20src/glutil%20src/physfs%20src/sprite2d%20src/sprite3d&In-Reply-To=%3C200507172346.j6HNkXbv001124%40sheep.berlios.de%3E"
       TITLE="[Windstille-commit] r664 - in trunk: . data/images data/levels src src/display src/glutil src/physfs src/sprite2d src/sprite3d">matzebraun at berlios.de
       </A><BR>
    <I>Mon Jul 18 01:46:33 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000316.html">[Windstille-commit] r663 - trunk/src
</A></li>
        <LI>Next message: <A HREF="000318.html">[Windstille-commit] r665 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#317">[ date ]</a>
              <a href="thread.html#317">[ thread ]</a>
              <a href="subject.html#317">[ subject ]</a>
              <a href="author.html#317">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: matzebraun
Date: 2005-07-18 01:46:17 +0200 (Mon, 18 Jul 2005)
New Revision: 664

Added:
   trunk/data/images/arrow.sprite
   trunk/data/images/human.sprite
   trunk/src/glutil/
   trunk/src/glutil/Jamfile
   trunk/src/glutil/texture.cpp
   trunk/src/glutil/texture.hpp
   trunk/src/glutil/texture_manager.cpp
   trunk/src/glutil/texture_manager.hpp
   trunk/src/physfs/physfs_sdl.cpp
   trunk/src/physfs/physfs_sdl.hpp
   trunk/src/sprite2d/
   trunk/src/sprite2d/Jamfile
   trunk/src/sprite2d/data.cpp
   trunk/src/sprite2d/data.hpp
   trunk/src/sprite2d/format
   trunk/src/sprite2d/manager.cpp
   trunk/src/sprite2d/manager.hpp
   trunk/src/sprite2d/sprite.cpp
   trunk/src/sprite2d/sprite.hpp
   trunk/src/sprite3d/data.cpp
   trunk/src/sprite3d/data.hpp
   trunk/src/sprite3d/manager.cpp
   trunk/src/sprite3d/manager.hpp
   trunk/src/sprite3d/sprite.cpp
   trunk/src/sprite3d/sprite.hpp
Removed:
   trunk/src/sprite3d/sprite3d.cpp
   trunk/src/sprite3d/sprite3d.hpp
   trunk/src/sprite3d/sprite3d_data.cpp
   trunk/src/sprite3d/sprite3d_data.hpp
   trunk/src/sprite3d/sprite3d_manager.cpp
   trunk/src/sprite3d/sprite3d_manager.hpp
Modified:
   trunk/Jamrules
   trunk/configure.ac
   trunk/data/levels/newformat2.wst
   trunk/src/Jamfile
   trunk/src/character.cpp
   trunk/src/character.hpp
   trunk/src/display/drawing_request.hpp
   trunk/src/flashing_sign.cpp
   trunk/src/flashing_sign.hpp
   trunk/src/nightvision.cpp
   trunk/src/physfs/Jamfile
   trunk/src/player.cpp
   trunk/src/player.hpp
   trunk/src/spider_mine.cpp
   trunk/src/sprite3d/Jamfile
   trunk/src/test_object.cpp
   trunk/src/test_object.hpp
   trunk/src/windstille_main.cpp
   trunk/src/windstille_main.hpp
Log:
- Add OpenGL TextureManager class to get more independent from ClanLib
   (uses SDL to load images)
- Add Sprite2D class to handle 2d sprites



Modified: trunk/Jamrules
===================================================================
--- trunk/Jamrules	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/Jamrules	2005-07-17 23:46:17 UTC (rev 664)
@@ -52,13 +52,10 @@
 IncludeDir $(top_srcdir)/src/squirrel/include ;
 
 # use CLANLIB, OPENAL and PHYSFS
-CXXFLAGS += $(CLANLIB_CFLAGS) $(OPENAL_CFLAGS) $(PHYSFS_CFLAGS)
-    $(VORBIS_CFLAGS) $(OGG_CFLAGS) $(ICONV_CFLAGS) $(GL_CFLAGS) $(GLU_CFLAGS) ;
-CFLAGS += $(CLANLIB_CFLAGS) $(OPENAL_CFLAGS) $(PHYSFS_CFLAGS)
-    $(VORBISFILE_CFLAGS) $(VORBIS_CFLAGS) $(OGG_CFLAGS) $(ICONV_CFLAGS) 
-    $(GL_CFLAGS) $(GLU_CFLAGS) ;
-LIBS += $(CLANLIB_LIBS) $(OPENAL_LIBS) $(PHYSFS_LIBS) $(VORBISFILE_LIBS)
-    $(VORBIS_LIBS) $(OGG_LIBS) $(ICONV_LIBS) $(GL_LIBS) $(GLU_LIBS) ;
+USE_LIBS = SDL SDLIMAGE CLANLIB OPENAL PHYSFS VORBIS OGG ICONV GL GLU ;
+CXXFLAGS += $($(USE_LIBS)_CFLAGS) ;
+CFLAGS += $($(USE_LIBS)_CFLAGS) ;
+LIBS += $($(USE_LIBS)_LIBS) ;
 
 # for the emacsers out there (compiles all objects in current subdir if jam is
 # invoked in a subdir)

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/configure.ac	2005-07-17 23:46:17 UTC (rev 664)
@@ -101,6 +101,15 @@
 XIPH_PATH_OGG(, [AC_MSG_ERROR([Please install libogg])])
 XIPH_PATH_VORBIS(, [AC_MSG_ERROR([Please install libvorbis])])
 
+AM_PATH_SDL([1.2.5], , AC_MSG_ERROR([Please install libsdl &gt;= 1.2.5]))
+
+NP_FINDLIB([SDLIMAGE], [SDL_image], [SDL_image &gt;= 1.2],
+        NP_LANG_PROGRAM([#include &lt;SDL_image.h&gt;], [IMG_Load(&quot;&quot;);]),
+        [], [-lSDL_image],
+        [],
+        [AC_MSG_ERROR([Please install SDLImage &gt;= 1.2.1])],
+        [$SDL_CFLAGS], [$SDL_LIBS])
+
 NP_FINDLIB([OPENAL], [OpenAL], [OpenAL],
          NP_LANG_PROGRAM([#include &lt;AL/alc.h&gt;],
            [alcOpenDevice(0);]),

Added: trunk/data/images/arrow.sprite
===================================================================
--- trunk/data/images/arrow.sprite	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/data/images/arrow.sprite	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,6 @@
+(sprite
+  (action
+    (name &quot;default&quot;)
+    (images &quot;arrow.png&quot;)
+  )
+)

Added: trunk/data/images/human.sprite
===================================================================
--- trunk/data/images/human.sprite	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/data/images/human.sprite	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,20 @@
+(sprite
+  (action
+    (name &quot;walk&quot;)
+    (speed 15.0)
+    (image-grid
+      (file &quot;hero_walk.png&quot;)
+      (x-size 89)
+      (y-size 128)
+    )
+  )
+  (action
+    (name &quot;turn&quot;)
+    (speed 15.0)
+    (image-grid
+      (file &quot;human_turn.png&quot;)
+      (x-size 98)
+      (y-size 125)
+    )
+  )
+)

Modified: trunk/data/levels/newformat2.wst
===================================================================
--- trunk/data/levels/newformat2.wst	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/data/levels/newformat2.wst	2005-07-17 23:46:17 UTC (rev 664)
@@ -31,7 +31,7 @@
       (x 550)
       (y 370)
       (flashspeed 0.7)
-      (sprite &quot;arrows/red&quot;)
+      (sprite &quot;images/arrow.sprite&quot;)
       (enabled #f)
     )
     (box

Modified: trunk/src/Jamfile
===================================================================
--- trunk/src/Jamfile	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/Jamfile	2005-07-17 23:46:17 UTC (rev 664)
@@ -1,12 +1,14 @@
 SubDir TOP src ;
 
 SubInclude TOP src display ;
+SubInclude TOP src glutil ;
 SubInclude TOP src input ;
 SubInclude TOP src lisp ;
 SubInclude TOP src physfs ;
 SubInclude TOP src squirrel ;
 SubInclude TOP src sound ;
 SubInclude TOP src scripting ;
+SubInclude TOP src sprite2d ;
 SubInclude TOP src sprite3d ;
 SubInclude TOP src tinygettext ;
 SubInclude TOP src collision ;
@@ -111,6 +113,8 @@
 
 Application windstille 
     :   $(display_objects)
+
+        $(glutil_objects)
     
         $(input_objects)
 
@@ -122,6 +126,8 @@
 
         $(sound_objects)
 
+        $(sprite2d_objects)
+
         $(sprite3d_objects)
 
         $(tinygettext_objects)

Modified: trunk/src/character.cpp
===================================================================
--- trunk/src/character.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/character.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -25,7 +25,7 @@
 #include &quot;script_manager.hpp&quot;
 #include &quot;physfs/physfs_stream.hpp&quot;
 #include &quot;console.hpp&quot;
-#include &quot;sprite3d/sprite3d_manager.hpp&quot;
+#include &quot;sprite3d/manager.hpp&quot;
 #include &quot;util.hpp&quot;
 #include &quot;lisp/list_iterator.hpp&quot;
 

Modified: trunk/src/character.hpp
===================================================================
--- trunk/src/character.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/character.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -21,13 +21,13 @@
 #define HEADER_CHARACTER_HPP
 
 #include &quot;entity.hpp&quot;
-#include &quot;sprite3d/sprite3d.hpp&quot;
+#include &quot;sprite3d/sprite.hpp&quot;
 #include &quot;lisp/lisp.hpp&quot;
 
 class Character : public Entity
 {
 private:
-  Sprite3D* sprite;
+  sprite3d::Sprite* sprite;
     
 public:
   Character(const lisp::Lisp* lisp);

Modified: trunk/src/display/drawing_request.hpp
===================================================================
--- trunk/src/display/drawing_request.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/display/drawing_request.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -39,10 +39,6 @@
   
   virtual void draw(CL_GraphicContext* gc) = 0;
   
-  /** Returns true if the request contains an alpha channel and needs
-      to be drawn in order */
-  virtual bool has_alpha() { return true; }
-
   /** Returns the position at which the request should be drawn */
   float get_z_pos() const
   { return pos.z; }

Modified: trunk/src/flashing_sign.cpp
===================================================================
--- trunk/src/flashing_sign.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/flashing_sign.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -4,9 +4,10 @@
 #include &quot;lisp/list_iterator.hpp&quot;
 #include &quot;timer.hpp&quot;
 #include &quot;globals.hpp&quot;
+#include &quot;sprite2d/manager.hpp&quot;
 
 FlashingSign::FlashingSign(const lisp::Lisp* lisp)
-  : sprite(&quot;arrows/red&quot;, resources), pos(0, 0), enabled(false)
+  : pos(0, 0, 10.0), enabled(false)
 {
   std::string spritename;
   flashspeed = 5;
@@ -19,6 +20,8 @@
       pos.x = iter.value().get_float();
     } else if(iter.item() == &quot;y&quot;) {
       pos.y = iter.value().get_float();
+    } else if(iter.item() == &quot;z&quot;) {
+      pos.z = iter.value().get_float();
     } else if(iter.item() == &quot;flashspeed&quot;) {
       flashspeed = iter.value().get_float();
     } else if(iter.item() == &quot;name&quot;) {
@@ -33,12 +36,14 @@
 
   if(spritename == &quot;&quot;)
     throw std::runtime_error(&quot;No sprite name specified in FlashingSign&quot;);
-  sprite = CL_Sprite(spritename, resources);
+  
+  sprite = sprite2d_manager-&gt;create(spritename);
   flashdelta = game_time;
 }
 
 FlashingSign::~FlashingSign()
 {
+  delete sprite;
 }
 
 void
@@ -52,18 +57,19 @@
   if(static_cast&lt;int&gt;(time/flashspeed) % 2 == 0) {
     float alpha = fmodf(time, flashspeed) / flashspeed;
     // fade on
-    sprite.set_alpha(alpha);
+    sprite-&gt;set_alpha(alpha);
   } else {
     float alpha = 1.0 - (fmodf(time, flashspeed) / flashspeed);
     // fade off
-    sprite.set_alpha(alpha);
+    sprite-&gt;set_alpha(alpha);
   }
-  sc.color().draw(sprite, pos.x, pos.y, 10);
+  sprite-&gt;draw(sc, pos);
 }
 
 void
-FlashingSign::update(float )
+FlashingSign::update(float elapsed_time)
 {
+  sprite-&gt;update(elapsed_time);
 }
 
 void

Modified: trunk/src/flashing_sign.hpp
===================================================================
--- trunk/src/flashing_sign.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/flashing_sign.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -1,16 +1,16 @@
 #ifndef __FLASHING_SIGN_HPP__
 #define __FLASHING_SIGN_HPP__
 
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
 #include &quot;game_object.hpp&quot;
 #include &quot;lisp/lisp.hpp&quot;
+#include &quot;math/vector.hpp&quot;
+#include &quot;sprite2d/sprite.hpp&quot;
 
 class FlashingSign : public GameObject
 {
 private:
-  CL_Sprite sprite;
-  CL_Pointf pos;
+  sprite2d::Sprite* sprite;
+  Vector pos;
 
   bool enabled;
   float flashspeed;

Added: trunk/src/glutil/Jamfile
===================================================================
--- trunk/src/glutil/Jamfile	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/glutil/Jamfile	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,12 @@
+SubDir TOP src glutil ;
+
+sources =
+    texture.cpp
+    texture.hpp
+    texture_manager.cpp
+    texture_manager.hpp
+;
+
+TRANSLATABLE_SOURCES += [ SearchSource $(sources) ] ;
+glutil_objects = [ CompileObjects $(sources) ] ;
+

Added: trunk/src/glutil/texture.cpp
===================================================================
--- trunk/src/glutil/texture.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/glutil/texture.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,31 @@
+#include &quot;texture.hpp&quot;
+
+Texture::Texture()
+{
+}
+
+Texture::~Texture()
+{
+  glDeleteTextures(1, &amp;handle);
+}
+
+static int power_of_two(int val) {
+  int result = 1;
+  while(result &lt; val)
+    result *= 2;
+  return result;
+}
+
+float
+Texture::get_max_u() const
+{
+  int newwidth = power_of_two(orig_width);
+  return static_cast&lt;float&gt;(orig_width)/static_cast&lt;float&gt;(newwidth);
+}
+
+float Texture::get_max_v() const
+{
+  int newheight = power_of_two(orig_height);
+  return static_cast&lt;float&gt;(orig_height)/static_cast&lt;float&gt;(newheight);
+}
+

Added: trunk/src/glutil/texture.hpp
===================================================================
--- trunk/src/glutil/texture.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/glutil/texture.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,26 @@
+#ifndef __TEXTURE_HPP__
+#define __TEXTURE_HPP__
+
+#include &lt;GL/gl.h&gt;
+
+class Texture
+{
+public:
+  int orig_width;
+  int orig_height;
+  GLuint handle;
+
+  ~Texture();
+
+  /** returns the u texture-coordinate where the real image ends */
+  float get_max_u() const;
+  /** returns the v texture-coordinate where the real image ends */
+  float get_max_v() const;
+
+private:
+  friend class TextureManager;
+  Texture();
+};
+
+#endif
+

Added: trunk/src/glutil/texture_manager.cpp
===================================================================
--- trunk/src/glutil/texture_manager.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/glutil/texture_manager.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,131 @@
+#include &lt;config.h&gt;
+
+#include &quot;texture_manager.hpp&quot;
+
+#include &lt;iostream&gt;
+#include &lt;sstream&gt;
+#include &lt;stdexcept&gt;
+#include &lt;SDL_image.h&gt;
+#include &lt;ClanLib/Display/Providers/provider_factory.h&gt;
+#include &lt;ClanLib/Display/surface.h&gt;
+#include &lt;ClanLib/Display/pixel_buffer.h&gt;
+#include &lt;ClanLib/Display/pixel_format.h&gt;
+#include &lt;ClanLib/GL/opengl_state.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/display_window.h&gt;
+#include &quot;util.hpp&quot;
+#include &quot;globals.hpp&quot;
+#include &quot;texture.hpp&quot;
+#include &quot;physfs/physfs_sdl.hpp&quot;
+
+TextureManager::TextureManager* texture_manager = 0;
+
+TextureManager::TextureManager()
+{
+}
+
+TextureManager::~TextureManager()
+{
+  for(Textures::iterator i = textures.begin(); i != textures.end(); ++i) {
+    delete i-&gt;second;
+  }
+}
+
+const Texture*
+TextureManager::get(const std::string&amp; filename)
+{
+  Textures::iterator i = textures.find(filename);
+  if(i != textures.end())
+    return i-&gt;second;
+
+  SDL_Surface* image = IMG_Load_RW(get_physfs_SDLRWops(filename), 1);
+  if(!image) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't load image '&quot; &lt;&lt; filename &lt;&lt; &quot;' :&quot; &lt;&lt; SDL_GetError();
+    throw std::runtime_error(msg.str());
+  }
+
+  std::cerr &lt;&lt; filename &lt;&lt; &quot; loaded.\n&quot;;
+  Texture* result;
+  try {
+    result = create(image);
+  } catch(std::exception&amp; e) {
+    SDL_FreeSurface(image);
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't create texture for '&quot; &lt;&lt; filename &lt;&lt; &quot;': &quot; &lt;&lt; e.what();
+    throw std::runtime_error(msg.str());
+  }
+
+  SDL_FreeSurface(image);
+  textures.insert(std::make_pair(filename, result));
+  
+  return result;
+}
+
+static int power_of_two(int val) {
+  int result = 1;
+  while(result &lt; val)
+    result *= 2;
+  return result;
+}
+
+Texture*
+TextureManager::create(SDL_Surface* image)
+{
+  CL_OpenGLState state(CL_Display::get_current_window()-&gt;get_gc());
+  state.set_active();
+  state.setup_2d();
+  
+  int texture_w = power_of_two(image-&gt;w);
+  int texture_h = power_of_two(image-&gt;h);
+
+  GLint maxt;
+  glGetIntegerv(GL_MAX_TEXTURE_SIZE, &amp;maxt);
+  if(texture_w &gt; maxt || texture_h &gt; maxt)
+      throw std::runtime_error(&quot;Texture too big&quot;);
+
+#if SDL_BYTEORDER == SDL_BIG_ENDIAN
+  SDL_Surface* convert = SDL_CreateRGBSurface(SDL_SWSURFACE,
+      texture_w, texture_h, 32,
+      0xff000000, 0x00ff0000, 0x0000ff00, 0x000000ff);
+#else
+  SDL_Surface* convert = SDL_CreateRGBSurface(SDL_SWSURFACE,
+      texture_w, texture_h, 32,
+      0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000);
+#endif
+
+  if(convert == 0)
+    throw std::runtime_error(&quot;Couldn't create texture: out of memory&quot;);
+  SDL_SetAlpha(image, 0, 0);
+  SDL_BlitSurface(image, 0, convert, 0);
+
+  GLuint handle;
+  glGenTextures(1, &amp;handle);
+
+  SDL_PixelFormat* format = convert-&gt;format;
+
+  glBindTexture(GL_TEXTURE_2D, handle);
+  glPixelStorei(GL_UNPACK_ROW_LENGTH, convert-&gt;pitch/format-&gt;BytesPerPixel);
+  glTexImage2D(GL_TEXTURE_2D, 0, format-&gt;BytesPerPixel,
+      convert-&gt;w, convert-&gt;h, 0, GL_RGBA,
+      GL_UNSIGNED_BYTE, convert-&gt;pixels);
+
+  assert_gl(&quot;creating texture&quot;);
+
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_CLAMP);
+
+  assert_gl(&quot;setting texture parameters&quot;);
+
+  SDL_FreeSurface(convert);
+  
+  Texture* result = new Texture();
+  result-&gt;handle = handle;
+  result-&gt;orig_width = image-&gt;w;
+  result-&gt;orig_height = image-&gt;h;
+  return result;
+}
+

Added: trunk/src/glutil/texture_manager.hpp
===================================================================
--- trunk/src/glutil/texture_manager.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/glutil/texture_manager.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,34 @@
+#ifndef __TEXTURE_MANAGER_H__
+#define __TEXTURE_MANAGER_H__
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+#include &lt;SDL.h&gt;
+
+#include &lt;ClanLib/Display/pixel_buffer.h&gt;
+
+class Texture;
+
+class TextureManager
+{
+public:
+  TextureManager();
+  ~TextureManager();
+
+  /** returns a texture containing the image specified with filename
+   * Note: You must NOT delete the returned Texture
+   */
+  const Texture* get(const std::string&amp; filename);
+
+private:
+  Texture* create(SDL_Surface* surface);
+  Texture* create(CL_PixelBuffer* buffer);
+  
+  typedef std::map&lt;std::string, Texture*&gt; Textures;
+  Textures textures;
+};
+
+extern TextureManager* texture_manager;
+
+#endif
+

Modified: trunk/src/nightvision.cpp
===================================================================
--- trunk/src/nightvision.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/nightvision.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -25,6 +25,7 @@
   : nightvision(&quot;nightvision&quot;, resources),
     noise(&quot;noise&quot;, resources)
 {
+  (void) lisp;
   name = &quot;nightvision&quot;;
   noise.set_alignment(origin_center);
 }
@@ -61,7 +62,7 @@
 }
 
 void
-Nightvision::update(float delta)
+Nightvision::update(float )
 {
 }
 

Modified: trunk/src/physfs/Jamfile
===================================================================
--- trunk/src/physfs/Jamfile	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/physfs/Jamfile	2005-07-17 23:46:17 UTC (rev 664)
@@ -3,6 +3,8 @@
 sources = 
     physfs_stream.cpp
     physfs_stream.hpp
+    physfs_sdl.cpp
+    physfs_sdl.hpp
 ;
 
 TRANSLATABLE_SOURCES += [ SearchSource $(sources) ] ;

Added: trunk/src/physfs/physfs_sdl.cpp
===================================================================
--- trunk/src/physfs/physfs_sdl.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/physfs/physfs_sdl.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,93 @@
+/*
+Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#include &lt;config.h&gt;
+
+#include &quot;physfs_sdl.hpp&quot;
+
+#include &lt;physfs.h&gt;
+
+#include &lt;stdexcept&gt;
+#include &lt;sstream&gt;
+#include &lt;iostream&gt;
+
+#include &lt;assert.h&gt;
+
+static int func_seek(struct SDL_RWops* context, int offset, int whence)
+{
+    PHYSFS_file* file = (PHYSFS_file*) context-&gt;hidden.unknown.data1;
+    int res;
+    switch(whence) {
+        case SEEK_SET:
+            res = PHYSFS_seek(file, offset);
+            break;
+        case SEEK_CUR:
+            res = PHYSFS_seek(file, PHYSFS_tell(file) + offset);
+            break;
+        case SEEK_END:
+            res = PHYSFS_seek(file, PHYSFS_fileLength(file) + offset);
+            break;
+        default:
+            res = 0;
+            assert(false);
+            break;
+    }
+    if(res == 0) {
+        std::cerr &lt;&lt; &quot;Error seeking in file: &quot; &lt;&lt; PHYSFS_getLastError() &lt;&lt; &quot;\n&quot;;
+        return -1;
+    }
+
+    return (int) PHYSFS_tell(file);
+}
+
+static int func_read(struct SDL_RWops* context, void* ptr, int size, int maxnum)
+{
+    PHYSFS_file* file = (PHYSFS_file*) context-&gt;hidden.unknown.data1;
+
+    int res = PHYSFS_read(file, ptr, size, maxnum);
+    return res;
+}
+
+static int func_close(struct SDL_RWops* context)
+{
+    PHYSFS_file* file = (PHYSFS_file*) context-&gt;hidden.unknown.data1;
+    
+    PHYSFS_close(file);
+    delete context;
+
+    return 0;
+}
+
+SDL_RWops* get_physfs_SDLRWops(const std::string&amp; filename)
+{
+    PHYSFS_file* file = (PHYSFS_file*) PHYSFS_openRead(filename.c_str());
+    if(!file) {
+        std::stringstream msg;
+        msg &lt;&lt; &quot;Couldn't open '&quot; &lt;&lt; filename &lt;&lt; &quot;': &quot;
+            &lt;&lt; PHYSFS_getLastError();
+        throw std::runtime_error(msg.str());
+    }
+    
+    SDL_RWops* ops = new SDL_RWops();
+    ops-&gt;type = 0;
+    ops-&gt;hidden.unknown.data1 = file;
+    ops-&gt;seek = func_seek;
+    ops-&gt;read = func_read;
+    ops-&gt;write = 0;
+    ops-&gt;close = func_close;
+    return ops;
+}

Added: trunk/src/physfs/physfs_sdl.hpp
===================================================================
--- trunk/src/physfs/physfs_sdl.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/physfs/physfs_sdl.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,27 @@
+/*
+Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#ifndef __PHYSFSSDL_HPP__
+#define __PHYSFSSDL_HPP__
+
+#include &lt;SDL.h&gt;
+#include &lt;string&gt;
+
+SDL_RWops* get_physfs_SDLRWops(const std::string&amp; filename);
+
+#endif
+

Modified: trunk/src/player.cpp
===================================================================
--- trunk/src/player.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/player.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -26,7 +26,7 @@
 #include &quot;player.hpp&quot;
 #include &quot;bomb.hpp&quot;
 #include &quot;globals.hpp&quot;
-#include &quot;sprite3d/sprite3d_manager.hpp&quot;
+#include &quot;sprite3d/manager.hpp&quot;
 
 static const int MAX_ENERGY = 16;
 static const float WALK_SPEED = 128.0;

Modified: trunk/src/player.hpp
===================================================================
--- trunk/src/player.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/player.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -25,7 +25,7 @@
 #include &lt;ClanLib/display.h&gt;
 
 #include &quot;input/controller.hpp&quot;
-#include &quot;sprite3d/sprite3d.hpp&quot;
+#include &quot;sprite3d/sprite.hpp&quot;
 #include &quot;math/vector.hpp&quot;
 #include &quot;globals.hpp&quot;
 #include &quot;entity.hpp&quot;
@@ -40,8 +40,8 @@
   Vector velocity;
  
   CL_Sprite light;
-  Sprite3D* sprite;
-  Sprite3D* grenade;
+  sprite3d::Sprite* sprite;
+  sprite3d::Sprite* grenade;
 
   bool jumping;
   bool bomb_placed;

Modified: trunk/src/spider_mine.cpp
===================================================================
--- trunk/src/spider_mine.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/spider_mine.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -23,7 +23,7 @@
 #include &quot;script_manager.hpp&quot;
 #include &quot;physfs/physfs_stream.hpp&quot;
 #include &quot;console.hpp&quot;
-#include &quot;sprite3d/sprite3d_manager.hpp&quot;
+#include &quot;sprite3d/manager.hpp&quot;
 #include &quot;util.hpp&quot;
 #include &quot;lisp/list_iterator.hpp&quot;
 #include &quot;player.hpp&quot;

Added: trunk/src/sprite2d/Jamfile
===================================================================
--- trunk/src/sprite2d/Jamfile	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite2d/Jamfile	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,14 @@
+SubDir TOP src sprite2d ;
+
+sources =
+    data.cpp
+    data.hpp
+    sprite.cpp
+    sprite.hpp
+    manager.cpp
+    manager.hpp
+;
+
+TRANSLATABLE_SOURCES += [ SearchSource $(sources) ] ;
+sprite2d_objects = [ CompileObjects $(sources) ] ;
+

Added: trunk/src/sprite2d/data.cpp
===================================================================
--- trunk/src/sprite2d/data.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite2d/data.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,180 @@
+#include &lt;config.h&gt;
+
+#include &quot;sprite2d/data.hpp&quot;
+
+#include &lt;iostream&gt;
+#include &lt;memory&gt;
+#include &lt;sstream&gt;
+#include &lt;stdexcept&gt;
+#include &quot;util.hpp&quot;
+#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;lisp/lisp.hpp&quot;
+#include &quot;lisp/parser.hpp&quot;
+#include &quot;glutil/texture.hpp&quot;
+#include &quot;glutil/texture_manager.hpp&quot;
+
+namespace sprite2d
+{
+
+Data::Data(const std::string&amp; filename)
+{
+  std::auto_ptr&lt;lisp::Lisp&gt; root (lisp::Parser::parse(filename));
+  const lisp::Lisp* sprite = root-&gt;get_lisp(&quot;sprite&quot;);
+  if(sprite == 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;File '&quot; &lt;&lt; filename &lt;&lt; &quot;' is not a windstille sprite&quot;;
+    throw std::runtime_error(msg.str());
+  }
+
+  std::string dir = dirname(filename);
+  parse(dir, sprite);
+}
+
+Data::~Data()
+{
+  for(Actions::iterator i = actions.begin(); i != actions.end(); ++i)
+    delete *i;
+}
+
+void
+Data::parse(const std::string&amp; dir, const lisp::Lisp* lisp)
+{
+  lisp::ListIterator iter(lisp);
+  while(iter.next()) {
+    if(iter.item() == &quot;action&quot;) {
+      actions.push_back(parse_action(dir, iter.lisp()));
+    } else {
+      std::cerr &lt;&lt; &quot;Skipping unknown tag '&quot; &lt;&lt; iter.item() &lt;&lt; &quot;' in sprite.\n&quot;;
+    }
+  }
+
+  if(actions.size() == 0)
+    throw std::runtime_error(&quot;Sprite contains no actions&quot;);
+}
+
+Action*
+Data::parse_action(const std::string&amp; dir, const lisp::Lisp* lisp)
+{
+  std::auto_ptr&lt;Action&gt; action (new Action);
+  action-&gt;speed = 1.0;
+  action-&gt;offset = Vector(0, 0, 0);
+  
+  lisp::ListIterator iter(lisp);
+  while(iter.next()) {
+    if(iter.item() == &quot;name&quot;) {
+      action-&gt;name = iter.value().get_string();
+    } else if(iter.item() == &quot;speed&quot;) {
+      action-&gt;speed = iter.value().get_float();
+    } else if(iter.item() == &quot;x-offset&quot;) {
+      action-&gt;offset.x = iter.value().get_float();
+    } else if(iter.item() == &quot;y-offset&quot;) {
+      action-&gt;offset.y = iter.value().get_float();
+    } else if(iter.item() == &quot;z-offset&quot;) {
+      // do we use that for anything anyway?
+      action-&gt;offset.z = iter.value().get_float();
+    } else if(iter.item() == &quot;images&quot;) {
+      parse_images(action.get(), dir, iter.lisp());
+    } else if(iter.item() == &quot;image-grid&quot;) {
+      parse_image_grid(action.get(), dir, iter.lisp());
+    }
+  }
+
+  if(action-&gt;name == &quot;&quot;)
+    throw std::runtime_error(&quot;No Name defined for action&quot;);
+  if(action-&gt;images.size() == 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Action '&quot; &lt;&lt; action-&gt;name &lt;&lt; &quot;' contains no images&quot;;
+    throw std::runtime_error(msg.str());
+  }
+
+  return action.release();
+}
+
+void
+Data::parse_images(Action* action, const std::string&amp; dir,
+                   const lisp::Lisp* lisp)
+{
+  while(lisp &amp;&amp; lisp-&gt;get_type() == lisp::Lisp::TYPE_CONS) {
+    const lisp::Lisp* cur = lisp-&gt;get_car();
+    std::string file = cur-&gt;get_string();
+    const Texture* texture = texture_manager-&gt;get(dir + &quot;/&quot; + file);
+    
+    ActionImage image;
+    image.texture = texture-&gt;handle;
+    image.width = texture-&gt;orig_width;
+    image.height = texture-&gt;orig_height;
+    float* uvs = image.texcoords;
+    uvs[0] = 0;
+    uvs[1] = 0;
+    uvs[2] = texture-&gt;get_max_u();
+    uvs[3] = 0;
+    uvs[4] = texture-&gt;get_max_u();
+    uvs[5] = texture-&gt;get_max_v();
+    uvs[6] = 0;
+    uvs[7] = texture-&gt;get_max_v();
+    action-&gt;images.push_back(image);
+
+    lisp = lisp-&gt;get_cdr();
+  }
+}
+
+void
+Data::parse_image_grid(Action* action, const std::string&amp; dir,
+                       const lisp::Lisp* lisp)
+{
+  std::string filename;
+  int x_size = -1;
+  int y_size = -1;
+  
+  lisp::ListIterator iter(lisp);
+  while(iter.next()) {
+    if(iter.item() == &quot;file&quot;) {
+      filename = iter.value().get_string();
+    } else if(iter.item() == &quot;x-size&quot;) {
+      x_size = iter.value().get_int();
+    } else if(iter.item() == &quot;y-size&quot;) {
+      y_size = iter.value().get_int();
+    } else {
+      std::cerr &lt;&lt; &quot;Skipping unknown element '&quot; &lt;&lt; iter.item() 
+                &lt;&lt; &quot;' in image-grid declaration.\n&quot;;
+    }
+  }
+
+  if(filename == &quot;&quot; || x_size &lt;= 0 || y_size &lt;= 0)
+    throw std::runtime_error(&quot;Invalid or too few data in image-grid&quot;);
+
+  const Texture* texture = texture_manager-&gt;get(dir + &quot;/&quot; + filename);
+
+  if(texture-&gt;orig_width % x_size != 0 || texture-&gt;orig_height % y_size != 0) {
+    std::cerr &lt;&lt; &quot;Warning texture '&quot; &lt;&lt; filename
+              &lt;&lt; &quot;' doesn't match a grid size.\n&quot;;
+  }
+
+  for(int y = 0; y &lt;= texture-&gt;orig_height - y_size; y += y_size) {
+    for(int x = 0; x &lt;= texture-&gt;orig_width - x_size; x += x_size) {
+      ActionImage image;
+      image.texture = texture-&gt;handle;
+      image.width = x_size;
+      image.height = y_size;
+      // TODO: check if (x + x_size - 1) is correct or (x + x_size)
+      float min_u = (texture-&gt;get_max_u() * x) / static_cast&lt;float&gt;(texture-&gt;orig_width);
+      float max_u = (texture-&gt;get_max_u() * (x + x_size)) / static_cast&lt;float&gt;(texture-&gt;orig_width);
+      float min_v = (texture-&gt;get_max_v() * y) / static_cast&lt;float&gt;(texture-&gt;orig_height);
+      float max_v = (texture-&gt;get_max_v() * (y + y_size)) / static_cast&lt;float&gt;(texture-&gt;orig_height);
+      
+      float* uvs = image.texcoords;
+      uvs[0] = min_u;
+      uvs[1] = min_v;
+      uvs[2] = max_u;
+      uvs[3] = min_v;
+      uvs[4] = max_u;
+      uvs[5] = max_v;
+      uvs[6] = min_u;
+      uvs[7] = max_v;
+
+      action-&gt;images.push_back(image);
+    }
+  }
+}
+ 
+}

Added: trunk/src/sprite2d/data.hpp
===================================================================
--- trunk/src/sprite2d/data.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite2d/data.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,54 @@
+#ifndef __SPRITE_DATA_HPP__
+#define __SPRITE_DATA_HPP__
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;GL/gl.h&gt;
+#include &quot;math/vector.hpp&quot;
+#include &quot;lisp/lisp.hpp&quot;
+
+namespace sprite2d
+{
+struct Action;
+struct ActionImage;
+
+class Data
+{
+public:
+  Data(const std::string&amp; filename);
+  virtual ~Data();
+
+  typedef std::vector&lt;Action*&gt; Actions;
+  Actions actions;
+
+private:
+  void parse(const std::string&amp; dir, const lisp::Lisp* lisp);
+  
+  Action* parse_action(const std::string&amp; dir, const lisp::Lisp* lisp);
+  void parse_images(Action* action, const std::string&amp; dir, 
+                    const lisp::Lisp* lisp);
+  void parse_image_grid(Action* action, const std::string&amp; dir,
+                        const lisp::Lisp* lisp); 
+};
+
+struct ActionImage
+{
+  GLuint texture;
+  float width;
+  float height;
+  float texcoords[8];
+};
+
+struct Action
+{
+  std::string name;
+  float speed;
+  Vector offset;
+  typedef std::vector&lt;ActionImage&gt; Images;
+  Images images;
+};
+
+}
+
+#endif
+

Added: trunk/src/sprite2d/format
===================================================================
--- trunk/src/sprite2d/format	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite2d/format	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,16 @@
+(sprite
+    (action
+        (name &quot;walk-right&quot;)
+        (speed 15.0)
+        (x-offset 4)
+        (y-offset 20)
+        (images &quot;...&quot;
+                &quot;...&quot;
+        )
+        (image-grid
+            (file &quot;...&quot;)
+            (x-size 20)
+            (y-size 20)
+        )
+    )
+)

Added: trunk/src/sprite2d/manager.cpp
===================================================================
--- trunk/src/sprite2d/manager.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite2d/manager.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,34 @@
+#include &lt;config.h&gt;
+
+#include &quot;sprite2d/manager.hpp&quot;
+#include &quot;sprite2d/data.hpp&quot;
+#include &quot;sprite2d/sprite.hpp&quot;
+
+sprite2d::Manager* sprite2d_manager = 0;
+
+namespace sprite2d
+{
+
+Manager::Manager()
+{
+}
+
+Manager::~Manager()
+{
+  for(Datas::iterator i = datas.begin(); i != datas.end(); ++i)
+    delete i-&gt;second;
+}
+
+Sprite*
+Manager::create(const std::string&amp; filename)
+{
+  Datas::iterator i = datas.find(filename);
+  if(i != datas.end())
+    return new Sprite(i-&gt;second);
+  
+  Data* data = new Data(filename);
+  datas.insert(std::make_pair(filename, data));
+  return new Sprite(data);
+}
+
+}

Added: trunk/src/sprite2d/manager.hpp
===================================================================
--- trunk/src/sprite2d/manager.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite2d/manager.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,31 @@
+#ifndef __SPRITE2D_MANAGER_HPP__
+#define __SPRITE2D_MANAGER_HPP__
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+
+namespace sprite2d
+{
+
+class Sprite;
+class Data;
+
+class Manager
+{
+public:
+  Manager();
+  ~Manager();
+
+  Sprite* create(const std::string&amp; filename);
+
+private:
+  typedef std::map&lt;std::string, Data*&gt; Datas;
+  Datas datas;
+};
+
+}
+
+extern sprite2d::Manager* sprite2d_manager;
+
+#endif
+

Added: trunk/src/sprite2d/sprite.cpp
===================================================================
--- trunk/src/sprite2d/sprite.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite2d/sprite.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,197 @@
+#include &lt;config.h&gt;
+
+#include &quot;sprite2d/sprite.hpp&quot;
+
+#include &lt;math.h&gt;
+#include &lt;GL/gl.h&gt;
+#include &lt;ClanLib/gl.h&gt;
+#include &lt;ClanLib/display.h&gt;
+#include &quot;display/drawing_request.hpp&quot;
+#include &quot;display/scene_context.hpp&quot;
+#include &quot;sprite2d/data.hpp&quot;
+#include &quot;util.hpp&quot;
+
+namespace sprite2d
+{
+
+Sprite::Sprite(const Data* data)
+  : data(data)
+{
+  current_action = data-&gt;actions[0];
+  vflip = false;
+  frame = 0;
+  speed = 1.0;
+  pingpong = false;
+  reverse = false;
+  alpha = 0.0;
+}
+
+Sprite::~Sprite()
+{
+}
+
+void
+Sprite::update(float elapsed_time)
+{
+  float step = elapsed_time * speed * current_action-&gt;speed;
+  if(reverse)
+    step = -step;
+
+  frame = fmodf(frame + current_action-&gt;images.size() + step,
+      current_action-&gt;images.size());
+}
+
+void
+Sprite::set_action(const std::string&amp; name)
+{
+  for(Data::Actions::const_iterator i = data-&gt;actions.begin();
+      i != data-&gt;actions.end(); ++i) {
+    const Action* action = *i;
+    if(action-&gt;name == name) {
+      current_action = action;
+      pingpong = false;
+      reverse = false;
+      speed = 1.0;
+      frame = 0;
+      vflip = false;
+      alpha = 0.0;
+      return;
+    }
+  }
+
+  std::ostringstream msg;
+  msg &lt;&lt; &quot;No action '&quot; &lt;&lt; name &lt;&lt; &quot;' defined&quot;;
+  throw std::runtime_error(msg.str());
+}
+
+void
+Sprite::set_vflip(bool vflip)
+{
+  this-&gt;vflip = vflip;
+}
+
+bool
+Sprite::get_vflip() const
+{
+  return vflip;
+}
+
+void
+Sprite::set_pingpong(bool pingpong)
+{
+  this-&gt;pingpong = pingpong;
+}
+
+bool
+Sprite::get_pingpong() const
+{
+  return pingpong;
+}
+
+void
+Sprite::set_speed(float speed)
+{
+  this-&gt;speed = speed;
+}
+
+float
+Sprite::get_speed() const
+{
+  return speed;
+}
+
+void
+Sprite::set_alpha(float alpha)
+{
+  this-&gt;alpha = alpha;
+}
+
+float
+Sprite::get_alpha() const
+{
+  return alpha;
+}
+
+class SpriteDrawingRequest : public DrawingRequest
+{
+private:
+  Sprite* sprite;
+  
+public:
+  SpriteDrawingRequest(Sprite* sprite, const Vector&amp; pos,
+      const Matrix&amp; modelview)
+    : DrawingRequest(pos, modelview), sprite(sprite)
+  {
+  }
+
+  void draw(CL_GraphicContext* gc)
+  {
+    sprite-&gt;draw(gc, pos, modelview);
+  }
+};
+
+void
+Sprite::draw(CL_GraphicContext* gc, const Vector&amp; pos, const Matrix&amp; modelview)
+{
+  static const float rectvertices[12] 
+    = { 0, 0, 0,
+        1, 0, 0,
+        1, 1, 0, 
+        0, 1, 0 };
+
+  CL_OpenGLState state(gc);
+  state.set_active();
+  state.setup_2d();
+
+  glPushMatrix();
+  glMultMatrixd(modelview);
+  glTranslatef(pos.x, pos.y, 0);
+  if(vflip)
+    glRotatef(180, 0, 1.0, 0);
+  
+  // TODO: move alot of this state management to DrawingContext class...
+  glDisable(GL_DEPTH_TEST);
+  glEnable(GL_TEXTURE_2D);
+  glEnable(GL_BLEND);
+  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+#if 1
+  glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+  glEnableClientState(GL_VERTEX_ARRAY);
+  glDisableClientState(GL_NORMAL_ARRAY);
+#endif
+  glColor4f(1.0, 1.0, 1.0, alpha);
+
+  const ActionImage&amp; image 
+    = current_action-&gt;images[ static_cast&lt;int&gt; (frame) ];
+  glScalef(image.width, image.height, 1.0);
+
+  glBindTexture(GL_TEXTURE_2D, image.texture);
+
+  // TODO find out which of the 2 is faster
+#if 1
+  glVertexPointer(3, GL_FLOAT, 0, rectvertices);
+  glTexCoordPointer(2, GL_FLOAT, 0, image.texcoords);
+  glDrawArrays(GL_QUADS, 0, 4);
+#else
+  glBegin(GL_QUADS);
+  for(int i = 0; i &lt; 4; ++i) {
+    glVertex3f(rectvertices[i*3], rectvertices[i*3+1], rectvertices[i*3+2]);
+    glTexCoord2d(image.texcoords[i*2], image.texcoords[i*2+1]);
+  }
+  glEnd();
+#endif
+
+  glPopMatrix();
+
+  assert_gl(&quot;drawing 2d sprite&quot;);
+}
+
+void
+Sprite::draw(SceneContext&amp; sc, const Vector&amp; pos)
+{
+  sc.color().draw(
+    new SpriteDrawingRequest(this, pos, sc.color().get_modelview()));
+}
+
+}

Added: trunk/src/sprite2d/sprite.hpp
===================================================================
--- trunk/src/sprite2d/sprite.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite2d/sprite.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,63 @@
+#ifndef __SPRITE2D_SPRITE_HPP__
+#define __SPRITE2D_SPRITE_HPP__
+
+#include &lt;string&gt;
+#include &quot;math/vector.hpp&quot;
+#include &quot;math/matrix.hpp&quot;
+
+class CL_GraphicContext;
+class SceneContext;
+
+namespace sprite2d
+{
+
+class Data;
+struct Action;
+
+class Sprite
+{
+public:
+  ~Sprite();
+
+  void update(float elapsed_time);
+  void draw(SceneContext&amp; sc, const Vector&amp; pos);
+
+  void set_action(const std::string&amp; name);
+  const std::string&amp; get_action() const;
+
+  void set_vflip(bool vflip);
+  bool get_vflip() const;
+
+  void set_pingpong(bool pingpong);
+  bool get_pingpong() const;
+
+  void set_speed(float speed);
+  float get_speed() const;
+
+  void set_alpha(float alpha);
+  float get_alpha() const;
+
+private:
+  friend class SpriteDrawingRequest;
+  friend class Manager;
+  Sprite(const Data* data);
+  Sprite(const Sprite&amp; );
+  Sprite&amp; operator= (const Sprite&amp; );
+
+  void draw(CL_GraphicContext* gc, const Vector&amp; pos, const Matrix&amp; modelview);
+
+  const Data* data;
+  const Action* current_action;
+  float frame;
+  float speed;
+  float alpha;
+
+  bool pingpong;
+  bool reverse;
+  bool vflip;
+};
+
+}
+
+#endif
+

Modified: trunk/src/sprite3d/Jamfile
===================================================================
--- trunk/src/sprite3d/Jamfile	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite3d/Jamfile	2005-07-17 23:46:17 UTC (rev 664)
@@ -1,12 +1,12 @@
 SubDir TOP src sprite3d ;
 
 sources =
-  sprite3d_data.cpp
-  sprite3d_data.hpp
-  sprite3d.cpp
-  sprite3d.hpp
-  sprite3d_manager.cpp
-  sprite3d_manager.hpp
+  data.cpp
+  data.hpp
+  sprite.cpp
+  sprite.hpp
+  manager.cpp
+  manager.hpp
 ;
 
 TRANSLATABLE_SOURCES += [ SearchSource $(sources) ] ;

Added: trunk/src/sprite3d/data.cpp
===================================================================
--- trunk/src/sprite3d/data.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite3d/data.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,269 @@
+#include &lt;config.h&gt;
+
+#include &quot;sprite3d/data.hpp&quot;
+
+#include &lt;physfs.h&gt;
+#include &lt;string.h&gt;
+#include &lt;sstream&gt;
+#include &lt;stdexcept&gt;
+#include &quot;util.hpp&quot;
+#include &quot;globals.hpp&quot;
+#include &quot;glutil/texture_manager.hpp&quot;
+#include &quot;glutil/texture.hpp&quot;
+
+namespace sprite3d
+{
+
+static const int FORMAT_VERSION = 2;
+
+static inline float read_float(PHYSFS_file* file)
+{
+    uint32_t int_result;
+    if(PHYSFS_readULE32(file, &amp;int_result) == 0) {
+        std::ostringstream msg;
+        msg &lt;&lt; &quot;Problem reading float value: &quot; &lt;&lt; PHYSFS_getLastError();
+        throw std::runtime_error(msg.str());
+    }
+
+    // is this platform independent?
+    return * ( reinterpret_cast&lt;float*&gt; (&amp;int_result) );
+}
+
+static inline uint16_t read_uint16_t(PHYSFS_file* file)
+{
+    uint16_t result;
+    if(PHYSFS_readULE16(file, &amp;result) == 0) {
+        std::ostringstream msg;
+        msg &lt;&lt; &quot;Problem reading uint16 value: &quot; &lt;&lt; PHYSFS_getLastError();
+        throw std::runtime_error(msg.str());
+    }
+    return result;
+}
+
+static inline std::string read_string(PHYSFS_file* file, size_t size)
+{
+    char buffer[size+1];
+    if(PHYSFS_read(file, buffer, size, 1) != 1) {
+        std::ostringstream msg;
+        msg &lt;&lt; &quot;Problem reading string value: &quot; &lt;&lt; PHYSFS_getLastError();
+        throw std::runtime_error(msg.str());
+    }
+    buffer[size] = 0;
+
+    return buffer;
+}
+
+Data::Data(const std::string&amp; filename)
+  : mesh_count(0), meshs(0), bone_count(0), bones(0),
+  action_count(0), actions(0)
+{
+  PHYSFS_file* file = PHYSFS_openRead(filename.c_str());
+  if(!file) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Couldn't open '&quot; &lt;&lt; filename &lt;&lt; &quot;': &quot;
+      &lt;&lt; PHYSFS_getLastError();
+    throw std::runtime_error(msg.str());
+  }
+
+  try {
+    std::string magic = read_string(file, 4);
+    if(magic != &quot;W3DS&quot;)
+      throw std::runtime_error(&quot;Not a windstille 3d sprite file&quot;);
+    uint16_t format_version = read_uint16_t(file);
+    if(format_version &gt; FORMAT_VERSION)
+      throw std::runtime_error(&quot;sprite file format too new&quot;);
+    if(format_version &lt; FORMAT_VERSION)
+      throw std::runtime_error(&quot;sprite file format too old&quot;);
+
+    mesh_count = read_uint16_t(file);
+    if(mesh_count == 0)
+      throw std::runtime_error(&quot;Sprite contains no meshs&quot;);
+    bone_count = read_uint16_t(file);
+    action_count = read_uint16_t(file);
+    if(action_count == 0)
+      throw std::runtime_error(&quot;Sprite contains no actions&quot;);
+
+    // read meshs
+    meshs = new Mesh[mesh_count];
+    for(uint16_t i = 0; i &lt; mesh_count; ++i) {
+      Mesh&amp; mesh = meshs[i];
+
+      std::string texturename = read_string(file, 64);
+      texturename = dirname(filename) + basename(texturename);
+      mesh.triangle_count = read_uint16_t(file);
+      mesh.vertex_count = read_uint16_t(file);
+
+      printf(&quot;Reading Mesh Tex %s Tri %u Vs %u.\n&quot;, texturename.c_str(),
+              mesh.triangle_count, mesh.vertex_count);
+
+      const Texture* texture = texture_manager-&gt;get(texturename);
+      mesh.texture = texture-&gt;handle;
+
+      // read triangles
+      mesh.vertex_indices = new uint16_t[mesh.triangle_count * 3];
+      for(uint16_t v = 0; v &lt; mesh.triangle_count * 3; ++v) {
+        mesh.vertex_indices[v] = read_uint16_t(file);
+      }
+      
+      mesh.normals = new float[mesh.triangle_count * 3];
+      for(uint16_t n = 0; n &lt; mesh.triangle_count * 3; ++n) {
+        mesh.normals[n] = read_float(file);
+      }
+
+      mesh.tex_coords = new float[mesh.vertex_count * 2];
+      for(uint16_t v = 0; v &lt; mesh.vertex_count * 2; ++v) {
+        mesh.tex_coords[v] = read_float(file);
+      }
+    }
+
+    // read bones
+    bones = new Bone[bone_count];
+    for(uint16_t b = 0; b &lt; bone_count; ++b) {
+      Bone&amp; bone = bones[b];
+      bone.name = read_string(file, 64);
+    }
+
+    // read actions
+    actions = new Action[action_count];
+    for(uint16_t i = 0; i &lt; action_count; ++i) {
+      Action&amp; action = actions[i];
+
+      action.name = read_string(file, 64);
+      action.speed = read_float(file);
+      action.marker_count = read_uint16_t(file);
+      action.frame_count = read_uint16_t(file);
+
+      printf(&quot;ReadingAction %s Frames %u.\n&quot;, action.name.c_str(), action.frame_count);
+
+      // read markers
+      action.markers = new Marker[action.marker_count];
+      for(uint16_t m = 0; m &lt; action.marker_count; ++m) {
+        Marker&amp; marker = action.markers[m];
+        marker.name = read_string(file, 64);
+        marker.frame = read_uint16_t(file);
+        printf(&quot;Marker '%s' at %u.\n&quot;, marker.name.c_str(), marker.frame);
+      }
+
+      // read frames
+      action.frames = new ActionFrame[action.frame_count];
+      for(uint16_t f = 0; f &lt; action.frame_count; ++f) {
+        ActionFrame&amp; frame = action.frames[f];
+        
+        frame.meshs = new MeshVertices[mesh_count];
+        for(uint16_t m = 0; m &lt; mesh_count; ++m) {
+          MeshVertices&amp; mesh = frame.meshs[m];
+
+          mesh.vertices = new float[meshs[m].vertex_count * 3];
+          for(uint16_t v = 0; v &lt; meshs[m].vertex_count * 3; ++v) {
+            mesh.vertices[v] = read_float(file);
+          }
+        }
+
+        frame.bones = new BonePosition[bone_count];
+        for(uint16_t b = 0; b &lt; bone_count; ++b) {
+          BonePosition&amp; bone = frame.bones[b];
+          for(int i = 0; i &lt; 3; ++i)
+            bone.pos[i] = read_float(file);
+          for(int i = 0; i &lt; 4; ++i)
+            bone.quat[i] = read_float(file);
+        }
+      }
+    }
+  } catch(std::exception&amp; e) {
+    clear();
+    PHYSFS_close(file);
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Problem while reading '&quot; &lt;&lt; filename &lt;&lt; &quot;': &quot; &lt;&lt; e.what();
+    throw std::runtime_error(msg.str());
+  }
+  PHYSFS_close(file);
+}
+
+Data::~Data()
+{
+  clear();
+}
+
+void
+Data::clear()
+{
+  if(meshs != 0) {
+    for(uint16_t m = 0; m &lt; mesh_count; ++m) {
+      Mesh&amp; mesh = meshs[m];
+      delete[] mesh.vertex_indices;
+      delete[] mesh.tex_coords;
+      delete[] mesh.normals;
+    }
+    delete[] meshs;
+    meshs = 0;
+  }
+  
+  delete[] bones;
+  bones = 0;
+
+  if(actions != 0) {
+    for(uint16_t a = 0; a &lt; action_count; ++a) {
+      Action&amp; action = actions[a];
+      delete[] action.markers;      
+      if(action.frames == 0)
+        continue;
+      
+      for(uint16_t f = 0; f &lt; action.frame_count; ++f) {
+        ActionFrame&amp; frame = action.frames[f];
+        if(frame.meshs == 0)
+          continue;
+        for(uint16_t m = 0; m &lt; mesh_count; ++m) {
+          MeshVertices&amp; vertices = frame.meshs[m];
+          delete[] vertices.vertices;
+        }
+        delete[] frame.meshs;
+        delete[] frame.bones;
+      }
+      delete[] action.frames;
+    }
+    delete[] actions;
+  }
+  mesh_count = 0;
+  action_count = 0;
+}
+
+const Action&amp;
+Data::get_action(const std::string&amp; name) const
+{
+  for(uint16_t a = 0; a &lt; action_count; ++a) {
+    if(actions[a].name == name)
+      return actions[a];
+  }
+  std::ostringstream msg;
+  msg &lt;&lt; &quot;No action with name '&quot; &lt;&lt; name &lt;&lt; &quot;' defined&quot;;
+  throw std::runtime_error(msg.str());
+}
+
+const Marker&amp;
+Data::get_marker(const Action* action, const std::string&amp; name) const
+{
+  for(uint16_t m = 0; m &lt; action-&gt;marker_count; ++m) {
+    if(action-&gt;markers[m].name == name)
+      return action-&gt;markers[m];
+  }
+  std::ostringstream msg;
+  msg &lt;&lt; &quot;No marker with name '&quot; &lt;&lt; name &lt;&lt; &quot;' defined in action '&quot;
+      &lt;&lt; action-&gt;name &lt;&lt; &quot;'&quot;;
+  throw std::runtime_error(msg.str());
+}
+
+uint16_t
+Data::get_bone_id(const std::string&amp; name) const
+{
+  for(uint16_t b = 0; b &lt; bone_count; ++b) {
+    if(bones[b].name == name)
+      return b;
+  }
+
+  std::ostringstream msg;
+  msg &lt;&lt; &quot;No bone with name '&quot; &lt;&lt; name &lt;&lt; &quot;' defined&quot;;
+  throw std::runtime_error(msg.str());
+}
+
+}
+

Added: trunk/src/sprite3d/data.hpp
===================================================================
--- trunk/src/sprite3d/data.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite3d/data.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,127 @@
+//  $Id$
+// 
+//  Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#ifndef HEADER_SPRITE3D_DATA_HPP
+#define HEADER_SPRITE3D_DATA_HPP
+
+#include &lt;stdint.h&gt;
+#include &lt;string&gt;
+#include &lt;GL/gl.h&gt;
+
+namespace sprite3d
+{
+
+struct Mesh;
+struct Bone;
+struct MeshVertices;
+struct ActionFrame;
+struct Action;
+struct Marker;
+
+/**
+ * This class holds the data of a .wsprite file.
+ */
+class Data
+{
+public:
+  Data(const std::string&amp; filename);
+  ~Data();
+
+  const Action&amp; get_action(const std::string&amp; name) const;
+  const Marker&amp; get_marker(const Action* action, const std::string&amp; name) const;
+  uint16_t get_bone_id(const std::string&amp; name) const;
+
+  uint16_t mesh_count;
+  Mesh* meshs;
+  uint16_t bone_count;
+  Bone* bones;
+  uint16_t action_count;
+  Action* actions;
+
+private:
+  void clear();
+  
+  Data (const Data&amp;);
+  Data&amp; operator= (const Data&amp;);
+};
+
+struct Mesh
+{
+  Mesh()
+    : vertex_indices(0), tex_coords(0), normals(0)
+  { }
+
+  GLuint texture;
+  uint16_t triangle_count;
+  uint16_t* vertex_indices;
+  float* tex_coords;
+  float* normals;
+  uint16_t vertex_count;
+};
+
+struct Bone
+{
+  std::string name;
+};
+
+struct MeshVertices
+{
+  MeshVertices()
+    : vertices(0)
+  { }
+  float* vertices;
+};
+
+struct BonePosition
+{
+  BonePosition()
+  { }
+  float pos[3]; // x, y, z
+  float quat[4]; // w, x, y, z
+};
+
+struct ActionFrame
+{
+  ActionFrame()
+    : meshs(0), bones(0)
+  { }
+  MeshVertices* meshs;
+  BonePosition* bones;
+};
+
+struct Marker
+{
+  std::string name;
+  uint16_t frame;
+};
+
+struct Action
+{
+  Action()
+    : markers(0), frames(0)
+  { }
+  std::string name;
+  float speed;
+  uint16_t marker_count;
+  Marker* markers;
+  uint16_t frame_count;
+  ActionFrame* frames;
+};
+
+}
+
+#endif

Added: trunk/src/sprite3d/manager.cpp
===================================================================
--- trunk/src/sprite3d/manager.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite3d/manager.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,34 @@
+#include &lt;config.h&gt;
+
+#include &quot;sprite3d/manager.hpp&quot;
+#include &quot;sprite3d/data.hpp&quot;
+#include &quot;sprite3d/sprite.hpp&quot;
+
+sprite3d::Manager* sprite3d_manager = 0;
+
+namespace sprite3d
+{
+
+Manager::Manager()
+{
+}
+
+Manager::~Manager()
+{
+  for(Datas::iterator i = datas.begin(); i != datas.end(); ++i)
+    delete i-&gt;second;
+}
+
+Sprite*
+Manager::create(const std::string&amp; filename)
+{
+  Datas::iterator i = datas.find(filename);
+  if(i != datas.end())
+    return new Sprite(i-&gt;second);
+  
+  Data* data = new Data(filename);
+  datas.insert(std::make_pair(filename, data));
+  return new Sprite(data);
+}
+
+}

Added: trunk/src/sprite3d/manager.hpp
===================================================================
--- trunk/src/sprite3d/manager.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite3d/manager.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,31 @@
+#ifndef __SPRITE3D_MANAGER_HPP__
+#define __SPRITE3D_MANAGER_HPP__
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+
+namespace sprite3d
+{
+
+class Sprite;
+class Data;
+
+class Manager
+{
+public:
+  Manager();
+  ~Manager();
+
+  Sprite* create(const std::string&amp; filename);
+
+private:
+  typedef std::map&lt;std::string, Data*&gt; Datas;
+  Datas datas;
+};
+
+}
+
+extern sprite3d::Manager* sprite3d_manager;
+
+#endif
+

Added: trunk/src/sprite3d/sprite.cpp
===================================================================
--- trunk/src/sprite3d/sprite.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite3d/sprite.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,404 @@
+//  $Id$
+//
+//  Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#include &lt;config.h&gt;
+
+#include &quot;sprite3d/sprite.hpp&quot;
+
+#include &lt;vector&gt;
+#include &lt;stdint.h&gt;
+#include &lt;sstream&gt;
+#include &lt;stdexcept&gt;
+#include &lt;ClanLib/gl.h&gt;
+#include &lt;ClanLib/display.h&gt;
+#include &lt;physfs.h&gt;
+#include &quot;display/drawing_request.hpp&quot;
+#include &quot;display/scene_context.hpp&quot;
+#include &quot;lisp_util.hpp&quot;
+#include &quot;globals.hpp&quot;
+#include &quot;util.hpp&quot;
+#include &quot;timer.hpp&quot;
+#include &quot;sprite3d/data.hpp&quot;
+
+namespace sprite3d
+{
+
+Sprite::Sprite(const Data* data)
+  : data(data), actions_switched(false)
+{
+  frame1.action = &amp;data-&gt;actions[0];
+  frame1.frame = 0;
+  frame1.rot = false;
+  frame1.speed = 1.0;
+  frame2 = frame1;
+  abort_at_frame.action = 0;
+  next_frame.action = 0;
+  next_action.action = 0;
+
+  bone_positions = new BonePosition[data-&gt;bone_count];
+}
+
+Sprite::~Sprite()
+{
+  delete[] bone_positions;
+}
+
+void
+Sprite::set_action(const std::string&amp; actionname, float speed)
+{
+  next_frame.action = &amp; data-&gt;get_action(actionname);
+  // set to last action so that next set_next_frame call will result in frame 0
+  if(speed &gt;= 0) {
+    next_frame.frame = 0;
+  } else {
+    next_frame.frame = next_frame.action-&gt;frame_count - 1;
+  }
+  next_frame.speed = speed;
+  next_frame.rot = frame2.rot;
+
+  next_action.action = 0;
+  actions_switched = false;
+}
+
+const std::string&amp;
+Sprite::get_action() const
+{
+  if(next_frame.action != 0)
+    return next_frame.action-&gt;name;
+  
+  return frame2.action-&gt;name;
+}
+
+void
+Sprite::set_next_action(const std::string&amp; name, float speed)
+{
+  next_action.action = &amp; data-&gt;get_action(name);
+  if(speed &gt;= 0) {
+    next_action.frame = 0;
+  } else {
+    next_action.frame = next_action.action-&gt;frame_count - 1;
+  }
+  next_action.speed = speed;
+  next_action.rot = frame2.rot;
+  actions_switched = false;
+
+  const Frame* frame = next_frame.action != 0 ? &amp;next_frame : &amp;frame2;
+  abort_at_frame.action = frame-&gt;action;
+  abort_at_frame.speed = frame-&gt;speed;
+  abort_at_frame.rot = frame-&gt;rot;
+  if(frame-&gt;speed &gt;= 0) {
+      abort_at_frame.frame = frame-&gt;action-&gt;frame_count - 1;
+  } else {
+      abort_at_frame.frame = 0;
+  }
+}
+
+void
+Sprite::set_next_rot(bool rot)
+{
+  next_action.rot = rot;
+}
+
+void
+Sprite::abort_at_marker(const std::string&amp; name)
+{
+  const Marker&amp; marker = data-&gt;get_marker(frame1.action, name);
+  abort_at_frame = frame1;
+  abort_at_frame.frame = marker.frame;
+}
+
+bool
+Sprite::before_marker(const std::string&amp; name) const
+{
+  const Marker&amp; marker = data-&gt;get_marker(frame1.action, name);  
+  return frame1.frame &lt; marker.frame;
+}
+
+bool
+Sprite::switched_actions()
+{
+  if(actions_switched) {
+    actions_switched = false;
+    return true;
+  }
+
+  return false;
+}
+
+void
+Sprite::set_speed(float speed)
+{
+  if(speed &lt; 0 &amp;&amp; frame1.speed &gt;= 0
+      || speed &gt;= 0 &amp;&amp; frame1.speed &lt; 0) {
+    blend_time = 1.0 - blend_time;
+    std::swap(frame1, frame2);
+  }
+  frame1.speed = speed;
+  frame2.speed = speed;
+}
+
+float
+Sprite::get_speed() const
+{
+  return frame1.speed;
+}
+
+void
+Sprite::set_rot(bool rot)
+{
+  next_frame.rot = rot;
+}
+
+bool
+Sprite::get_rot() const
+{
+  if(next_frame.action != 0)
+    return next_frame.rot;
+  
+  return frame1.rot;
+}
+
+BoneID
+Sprite::get_bone_id(const std::string&amp; name) const
+{
+  return data-&gt;get_bone_id(name); 
+}
+
+static inline void set_matrix_from_quat(Matrix&amp; m, float w,
+    float x, float y, float z)
+{
+  //row1
+  m.matrix[0] = 1.0f - 2*y*y - 2*z*z;
+  m.matrix[4] = 2*x*y - 2*w*z;
+  m.matrix[8] = 2*x*z + 2*w*y;
+  m.matrix[12] = 0.0f;
+
+  //row2
+  m.matrix[1] = 2*x*y + 2*w*z;
+  m.matrix[5] = 1.0f - 2*x*x - 2*z*z;
+  m.matrix[9] = 2*y*z - 2*w*x;
+  m.matrix[13] = 0.0f;
+
+  //row3
+  m.matrix[2] = 2*x*z - 2*w*y;
+  m.matrix[6] = 2*y*z + 2*w*x;
+  m.matrix[10] = 1.0f - 2*x*x - 2*y*y;
+  m.matrix[14] = 0.0f;
+
+  //row4
+  m.matrix[3] = 0.0f;
+  m.matrix[7] = 0.0f;
+  m.matrix[11] = 0.0f;
+  m.matrix[15] = 1.0f;
+}
+
+Matrix
+Sprite::get_bone_matrix(BoneID id) const
+{
+  float t_1 = 1.0 - blend_time;
+  const BonePosition&amp; bone1 = frame1.action-&gt;frames[frame1.frame].bones[id];
+  const BonePosition&amp; bone2 = frame2.action-&gt;frames[frame2.frame].bones[id];
+
+  float pos[3];
+  float quat[4];
+  if(frame1.rot) {
+    pos[0] = -bone1.pos[0] * t_1;
+    pos[1] = bone1.pos[1] * t_1;
+    pos[2] = -bone1.pos[2] * t_1;   
+  } else {
+    for(int i = 0; i &lt; 3; ++i)
+      pos[i] = bone1.pos[i] * t_1;
+    for(int i = 0; i &lt; 4; ++i)
+      quat[i] = bone1.quat[i] * t_1;
+  }
+  if(frame2.rot) {
+    pos[0] += -bone2.pos[0] * blend_time;
+    pos[1] += bone2.pos[1] * blend_time;
+    pos[2] += -bone2.pos[2] * blend_time;
+  } else {
+    for(int i = 0; i &lt; 3; ++i)
+      pos[i] += bone2.pos[i] * blend_time;
+    for(int i = 0; i &lt; 4; ++i)
+      quat[i] += bone2.quat[i] * blend_time;
+  }
+
+  Matrix m(true);
+  m.matrix[3] += pos[0];
+  m.matrix[7] += pos[1];
+  m.matrix[11] += pos[2];
+  printf(&quot;Pos: %f %f %f\n&quot;, pos[0], pos[1], pos[2]);
+
+  return m;
+}
+
+class SpriteDrawingRequest : public DrawingRequest
+{
+private:
+  Sprite* sprite;
+
+public:
+  SpriteDrawingRequest(Sprite* sprite, const Vector&amp; pos,
+                         const Matrix&amp; modelview)
+      : DrawingRequest(pos, modelview), sprite(sprite)
+  {
+  }
+
+  void draw(CL_GraphicContext* gc)
+  {
+    sprite-&gt;draw(gc, pos, modelview);
+  }
+};
+
+void
+Sprite::set_next_frame()
+{
+  if(frame2.action != frame1.action &amp;&amp; abort_at_frame.action == 0) {
+    actions_switched = true;
+  }
+  
+  frame1 = frame2;
+  if(next_frame.action != 0) {
+    frame2 = next_frame;
+    next_frame.action = 0;
+    return;
+  }
+  if(frame2 == abort_at_frame &amp;&amp; next_action.action != 0) {
+    frame2 = next_action;
+    abort_at_frame.action = 0;
+    next_action.action = 0;
+    return;
+  }
+
+  frame2.action = frame1.action;
+  if(frame1.speed &lt; 0) {
+    frame2.frame = (frame1.frame + frame1.action-&gt;frame_count - 1)
+      % frame2.action-&gt;frame_count;
+  } else {
+    frame2.frame = (frame1.frame + 1) % frame1.action-&gt;frame_count;
+  }
+  frame2.speed = frame1.speed;
+  frame2.rot = frame1.rot;
+}
+
+void
+Sprite::update(float elapsed_time)
+{
+  float time_delta = elapsed_time * frame1.action-&gt;speed * frame1.speed;
+  if(frame1.speed &lt; 0)
+    time_delta = -time_delta;
+
+  while(blend_time + time_delta &gt;= 1.0) {
+    elapsed_time -= (1.0 - blend_time) / (frame1.action-&gt;speed * frame1.speed);
+    set_next_frame();
+
+    time_delta = elapsed_time * frame1.action-&gt;speed * frame1.speed;
+    blend_time = 0.0;
+  }
+  blend_time += time_delta;
+}
+
+void
+Sprite::draw(SceneContext&amp; sc, const Vector&amp; pos)
+{
+  sc.color().draw(
+    new SpriteDrawingRequest(this, pos, sc.color().get_modelview()));
+}
+
+void
+Sprite::draw(SceneContext&amp; sc, const Matrix&amp; matrix)
+{
+  Matrix mmatrix 
+    = matrix.multiply(sc.color().get_modelview());
+  sc.color().draw(
+    new SpriteDrawingRequest(this, Vector(0, 0, 0), mmatrix));
+}
+
+void
+Sprite::draw(CL_GraphicContext* gc, const Vector&amp; pos,
+               const Matrix&amp; modelview)
+{
+  CL_OpenGLState state(gc);
+  state.set_active();
+  state.setup_2d();
+
+  glPushMatrix();
+  glMultMatrixd(modelview);
+  glTranslatef(pos.x, pos.y, 0);
+  if(frame1.rot) {
+    glRotatef(180, 0, 1.0, 0);
+  }                           
+
+  glClear(GL_DEPTH_BUFFER_BIT);
+  glEnable(GL_DEPTH_TEST);
+  glEnable(GL_TEXTURE_2D);
+
+  glEnableClientState(GL_VERTEX_ARRAY);
+  glEnableClientState(GL_TEXTURE_COORD_ARRAY);  
+
+  assert_gl(&quot;gl init before sprite&quot;);
+
+  const ActionFrame&amp; aframe1 = frame1.action-&gt;frames[frame1.frame];
+  const ActionFrame&amp; aframe2 = frame2.action-&gt;frames[frame2.frame];
+  
+  float t_1 = 1.0 - blend_time;
+  for(uint16_t m = 0; m &lt; data-&gt;mesh_count; ++m) {
+    const Mesh&amp; mesh = data-&gt;meshs[m];
+    const MeshVertices&amp; vertices1 = aframe1.meshs[m];
+    const MeshVertices&amp; vertices2 = aframe2.meshs[m];
+
+    // set texture
+    glBindTexture(GL_TEXTURE_2D, mesh.texture);
+    
+    // blend between frame1 + frame2
+    float* verts = new float[mesh.vertex_count * 3];
+    if(frame1.rot == frame2.rot) {
+      for(uint16_t v = 0; v &lt; mesh.vertex_count*3; ++v) {
+        verts[v] 
+          = vertices1.vertices[v] * t_1 + vertices2.vertices[v] * blend_time;
+      }
+    } else {
+      // need to manually rotate 180 degree here because frames have different
+      // rot values (=&gt; x=-x, y=y, z=-z)
+      for(uint16_t v = 0; v &lt; mesh.vertex_count; ++v) {
+        verts[v*3] 
+          = vertices1.vertices[v*3] * t_1 
+              - vertices2.vertices[v*3] * blend_time;
+        verts[v*3+1]
+          = vertices1.vertices[v*3+1] * t_1 
+              + vertices2.vertices[v*3+1] * blend_time;
+        verts[v*3+2]
+          = vertices1.vertices[v*3+2] * t_1
+              - vertices2.vertices[v*3+2] * blend_time;
+      }
+    }
+   
+    // draw mesh
+    glVertexPointer(3, GL_FLOAT, 0, verts);
+    glNormalPointer(GL_FLOAT, 0, mesh.normals);
+    glTexCoordPointer(2, GL_FLOAT, 0, mesh.tex_coords);
+    glDrawElements(GL_TRIANGLES, mesh.triangle_count * 3, GL_UNSIGNED_SHORT,
+        mesh.vertex_indices);
+    delete[] verts;
+  }
+
+  assert_gl(&quot;rendering 3d sprite&quot;);      
+
+  glPopMatrix();
+}
+
+}
+

Added: trunk/src/sprite3d/sprite.hpp
===================================================================
--- trunk/src/sprite3d/sprite.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite3d/sprite.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -0,0 +1,145 @@
+//  $Id$
+// 
+//  Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#ifndef HEADER_SPRITE3D_HPP
+#define HEADER_SPRITE3D_HPP
+
+#include &lt;string&gt;
+#include &lt;stdint.h&gt;
+#include &quot;game_object.hpp&quot;
+#include &quot;display/scene_context.hpp&quot;
+#include &quot;math/vector.hpp&quot;
+#include &quot;math/matrix.hpp&quot;
+
+class SceneContext;
+
+namespace sprite3d
+{
+
+class Data;
+struct Action;
+struct ActionFrame;
+struct BonePosition;
+
+typedef uint16_t BoneID;
+
+/**
+ * This class is a 3d sprite. It's a set of textured meshs with different
+ * animations (called actions) that are keyframe animated.
+ */
+class Sprite
+{
+public:
+  ~Sprite();
+
+  /**
+   * You should call this every frame
+   */
+  void update(float elapsed_time);
+  void draw(SceneContext&amp; sc, const Vector&amp; pos);
+  void draw(SceneContext&amp; sc, const Matrix&amp; matrix);
+  
+  /**
+   * Changes action (after the currently shown animation frame)
+   */
+  void set_action(const std::string&amp; name, float speed = 1.0);
+  
+  /**
+   * Return the name of the currently active action
+   */
+  const std::string&amp; get_action() const;
+
+  /**
+   * Set the next action and vflip value to be played after the current action
+   * has finished (or reached the point to be defined by abort_at_marker)
+   */
+  void set_next_action(const std::string&amp; name, float speed = 1.0);
+  void set_next_rot(bool rot);
+
+  /**
+   * Abort current action after a certain marker has been reached.
+   * (This only works if set_next_action has been used before)
+   */
+  void abort_at_marker(const std::string&amp; marker);
+
+  /**
+   * returns true if the current frame of the action is before a certain marker
+   */
+  bool before_marker(const std::string&amp; marker) const;
+
+  /**
+   * returns true exactly once after actions have been switched after a
+   * set_next_action call (another call to set_next_action resets this flag)
+   */
+  bool switched_actions();
+
+  /**
+   * The speed of the action is multiplied with this factor
+   */
+  void set_speed(float speed);
+  float get_speed() const;
+
+  /**
+   * Rotate (or not rotate) the model 180 degree
+   */
+  void set_rot(bool rot = true);
+  bool get_rot() const;
+
+  BoneID get_bone_id(const std::string&amp; name) const;
+  Matrix get_bone_matrix(BoneID id) const;
+
+private:
+  friend class SpriteDrawingRequest;
+  friend class Manager;
+  Sprite(const Data* data);
+  
+  Sprite (const Sprite&amp;);
+  Sprite&amp; operator= (const Sprite&amp;);
+
+  struct Frame {
+    const Action* action;
+    int frame;
+    float speed;
+    bool rot;
+
+    bool operator==(const Frame&amp; o) const
+    {
+      return action == o.action &amp;&amp; frame == o.frame &amp;&amp; speed == o.speed
+        &amp;&amp; rot == o.rot;
+    }
+  };
+
+  void set_next_frame();
+  void draw(CL_GraphicContext* gc, const Vector&amp; pos, const Matrix&amp; modelview);
+
+  const Data* data;
+  bool actions_switched;
+
+  BonePosition* bone_positions;
+
+  Frame frame1;
+  Frame frame2;
+  float blend_time;
+ 
+  Frame next_frame;
+  Frame next_action;
+  Frame abort_at_frame;
+};
+
+}
+
+#endif

Deleted: trunk/src/sprite3d/sprite3d.cpp
===================================================================
--- trunk/src/sprite3d/sprite3d.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite3d/sprite3d.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -1,398 +0,0 @@
-//  $Id$
-//
-//  Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-#include &quot;sprite3d.hpp&quot;
-
-#include &lt;vector&gt;
-#include &lt;stdint.h&gt;
-#include &lt;sstream&gt;
-#include &lt;stdexcept&gt;
-#include &lt;ClanLib/gl.h&gt;
-#include &lt;ClanLib/display.h&gt;
-#include &lt;physfs.h&gt;
-#include &quot;display/drawing_request.hpp&quot;
-#include &quot;display/scene_context.hpp&quot;
-#include &quot;sprite3d_data.hpp&quot;
-#include &quot;lisp_util.hpp&quot;
-#include &quot;globals.hpp&quot;
-#include &quot;util.hpp&quot;
-#include &quot;timer.hpp&quot;
-
-Sprite3D::Sprite3D(const Sprite3DData* data)
-  : data(data), actions_switched(false)
-{
-  frame1.action = &amp;data-&gt;actions[0];
-  frame1.frame = 0;
-  frame1.rot = false;
-  frame1.speed = 1.0;
-  frame2 = frame1;
-  abort_at_frame.action = 0;
-  next_frame.action = 0;
-  next_action.action = 0;
-
-  bone_positions = new BonePosition[data-&gt;bone_count];
-}
-
-Sprite3D::~Sprite3D()
-{
-  delete[] bone_positions;
-}
-
-void
-Sprite3D::set_action(const std::string&amp; actionname, float speed)
-{
-  next_frame.action = &amp; data-&gt;get_action(actionname);
-  // set to last action so that next set_next_frame call will result in frame 0
-  if(speed &gt;= 0) {
-    next_frame.frame = 0;
-  } else {
-    next_frame.frame = next_frame.action-&gt;frame_count - 1;
-  }
-  next_frame.speed = speed;
-  next_frame.rot = frame2.rot;
-
-  next_action.action = 0;
-  actions_switched = false;
-}
-
-const std::string&amp;
-Sprite3D::get_action() const
-{
-  if(next_frame.action != 0)
-    return next_frame.action-&gt;name;
-  
-  return frame2.action-&gt;name;
-}
-
-void
-Sprite3D::set_next_action(const std::string&amp; name, float speed)
-{
-  next_action.action = &amp; data-&gt;get_action(name);
-  if(speed &gt;= 0) {
-    next_action.frame = 0;
-  } else {
-    next_action.frame = next_action.action-&gt;frame_count - 1;
-  }
-  next_action.speed = speed;
-  next_action.rot = frame2.rot;
-  actions_switched = false;
-
-  const Frame* frame = next_frame.action != 0 ? &amp;next_frame : &amp;frame2;
-  abort_at_frame.action = frame-&gt;action;
-  abort_at_frame.speed = frame-&gt;speed;
-  abort_at_frame.rot = frame-&gt;rot;
-  if(frame-&gt;speed &gt;= 0) {
-      abort_at_frame.frame = frame-&gt;action-&gt;frame_count - 1;
-  } else {
-      abort_at_frame.frame = 0;
-  }
-}
-
-void
-Sprite3D::set_next_rot(bool rot)
-{
-  next_action.rot = rot;
-}
-
-void
-Sprite3D::abort_at_marker(const std::string&amp; name)
-{
-  const Marker&amp; marker = data-&gt;get_marker(frame1.action, name);
-  abort_at_frame = frame1;
-  abort_at_frame.frame = marker.frame;
-}
-
-bool
-Sprite3D::before_marker(const std::string&amp; name) const
-{
-  const Marker&amp; marker = data-&gt;get_marker(frame1.action, name);  
-  return frame1.frame &lt; marker.frame;
-}
-
-bool
-Sprite3D::switched_actions()
-{
-  if(actions_switched) {
-    actions_switched = false;
-    return true;
-  }
-
-  return false;
-}
-
-void
-Sprite3D::set_speed(float speed)
-{
-  if(speed &lt; 0 &amp;&amp; frame1.speed &gt;= 0
-      || speed &gt;= 0 &amp;&amp; frame1.speed &lt; 0) {
-    blend_time = 1.0 - blend_time;
-    std::swap(frame1, frame2);
-  }
-  frame1.speed = speed;
-  frame2.speed = speed;
-}
-
-float
-Sprite3D::get_speed() const
-{
-  return frame1.speed;
-}
-
-void
-Sprite3D::set_rot(bool rot)
-{
-  next_frame.rot = rot;
-}
-
-bool
-Sprite3D::get_rot() const
-{
-  if(next_frame.action != 0)
-    return next_frame.rot;
-  
-  return frame1.rot;
-}
-
-BoneID
-Sprite3D::get_bone_id(const std::string&amp; name) const
-{
-  return data-&gt;get_bone_id(name); 
-}
-
-static inline void set_matrix_from_quat(Matrix&amp; m, float w,
-    float x, float y, float z)
-{
-  //row1
-  m.matrix[0] = 1.0f - 2*y*y - 2*z*z;
-  m.matrix[4] = 2*x*y - 2*w*z;
-  m.matrix[8] = 2*x*z + 2*w*y;
-  m.matrix[12] = 0.0f;
-
-  //row2
-  m.matrix[1] = 2*x*y + 2*w*z;
-  m.matrix[5] = 1.0f - 2*x*x - 2*z*z;
-  m.matrix[9] = 2*y*z - 2*w*x;
-  m.matrix[13] = 0.0f;
-
-  //row3
-  m.matrix[2] = 2*x*z - 2*w*y;
-  m.matrix[6] = 2*y*z + 2*w*x;
-  m.matrix[10] = 1.0f - 2*x*x - 2*y*y;
-  m.matrix[14] = 0.0f;
-
-  //row4
-  m.matrix[3] = 0.0f;
-  m.matrix[7] = 0.0f;
-  m.matrix[11] = 0.0f;
-  m.matrix[15] = 1.0f;
-}
-
-Matrix
-Sprite3D::get_bone_matrix(BoneID id) const
-{
-  float t_1 = 1.0 - blend_time;
-  const BonePosition&amp; bone1 = frame1.action-&gt;frames[frame1.frame].bones[id];
-  const BonePosition&amp; bone2 = frame2.action-&gt;frames[frame2.frame].bones[id];
-
-  float pos[3];
-  float quat[4];
-  if(frame1.rot) {
-    pos[0] = -bone1.pos[0] * t_1;
-    pos[1] = bone1.pos[1] * t_1;
-    pos[2] = -bone1.pos[2] * t_1;   
-  } else {
-    for(int i = 0; i &lt; 3; ++i)
-      pos[i] = bone1.pos[i] * t_1;
-    for(int i = 0; i &lt; 4; ++i)
-      quat[i] = bone1.quat[i] * t_1;
-  }
-  if(frame2.rot) {
-    pos[0] += -bone2.pos[0] * blend_time;
-    pos[1] += bone2.pos[1] * blend_time;
-    pos[2] += -bone2.pos[2] * blend_time;
-  } else {
-    for(int i = 0; i &lt; 3; ++i)
-      pos[i] += bone2.pos[i] * blend_time;
-    for(int i = 0; i &lt; 4; ++i)
-      quat[i] += bone2.quat[i] * blend_time;
-  }
-
-  Matrix m(true);
-  m.matrix[3] += pos[0];
-  m.matrix[7] += pos[1];
-  m.matrix[11] += pos[2];
-  printf(&quot;Pos: %f %f %f\n&quot;, pos[0], pos[1], pos[2]);
-
-  return m;
-}
-
-class Sprite3DDrawingRequest : public DrawingRequest
-{
-private:
-  Sprite3D* sprite;
-
-public:
-  Sprite3DDrawingRequest(Sprite3D* sprite, const Vector&amp; pos,
-                         const Matrix&amp; modelview)
-      : DrawingRequest(pos, modelview), sprite(sprite)
-  {
-  }
-
-  void draw(CL_GraphicContext* gc)
-  {
-    sprite-&gt;draw(gc, pos, modelview);
-  }
-};
-
-void
-Sprite3D::set_next_frame()
-{
-  if(frame2.action != frame1.action &amp;&amp; abort_at_frame.action == 0) {
-    actions_switched = true;
-  }
-  
-  frame1 = frame2;
-  if(next_frame.action != 0) {
-    frame2 = next_frame;
-    next_frame.action = 0;
-    return;
-  }
-  if(frame2 == abort_at_frame &amp;&amp; next_action.action != 0) {
-    frame2 = next_action;
-    abort_at_frame.action = 0;
-    next_action.action = 0;
-    return;
-  }
-
-  frame2.action = frame1.action;
-  if(frame1.speed &lt; 0) {
-    frame2.frame = (frame1.frame + frame1.action-&gt;frame_count - 1)
-      % frame2.action-&gt;frame_count;
-  } else {
-    frame2.frame = (frame1.frame + 1) % frame1.action-&gt;frame_count;
-  }
-  frame2.speed = frame1.speed;
-  frame2.rot = frame1.rot;
-}
-
-void
-Sprite3D::update(float elapsed_time)
-{
-  float time_delta = elapsed_time * frame1.action-&gt;speed * frame1.speed;
-  if(frame1.speed &lt; 0)
-    time_delta = -time_delta;
-
-  while(blend_time + time_delta &gt;= 1.0) {
-    elapsed_time -= (1.0 - blend_time) / (frame1.action-&gt;speed * frame1.speed);
-    set_next_frame();
-
-    time_delta = elapsed_time * frame1.action-&gt;speed * frame1.speed;
-    blend_time = 0.0;
-  }
-  blend_time += time_delta;
-}
-
-void
-Sprite3D::draw(SceneContext&amp; sc, const Vector&amp; pos)
-{
-  sc.color().draw(
-    new Sprite3DDrawingRequest(this, pos, sc.color().get_modelview()));
-}
-
-void
-Sprite3D::draw(SceneContext&amp; sc, const Matrix&amp; matrix)
-{
-  Matrix mmatrix 
-    = matrix.multiply(sc.color().get_modelview());
-  sc.color().draw(
-    new Sprite3DDrawingRequest(this, Vector(0, 0, 0), mmatrix));
-}
-
-void
-Sprite3D::draw(CL_GraphicContext* gc, const Vector&amp; pos,
-               const Matrix&amp; modelview)
-{
-  CL_OpenGLState state(gc);
-  state.set_active();
-  state.setup_2d();
-
-  glPushMatrix();
-  glMultMatrixd(modelview);
-  glTranslatef(pos.x, pos.y, 0);
-  if(frame1.rot) {
-    glRotatef(180, 0, 1.0, 0);
-  }                           
-
-  glClear(GL_DEPTH_BUFFER_BIT);
-  glEnable(GL_DEPTH_TEST);
-  glEnable(GL_TEXTURE_2D);
-
-  glEnableClientState(GL_VERTEX_ARRAY);
-  glEnableClientState(GL_TEXTURE_COORD_ARRAY);  
-
-  assert_gl(&quot;gl init before sprite&quot;);
-
-  const ActionFrame&amp; aframe1 = frame1.action-&gt;frames[frame1.frame];
-  const ActionFrame&amp; aframe2 = frame2.action-&gt;frames[frame2.frame];
-  
-  float t_1 = 1.0 - blend_time;
-  for(uint16_t m = 0; m &lt; data-&gt;mesh_count; ++m) {
-    const Mesh&amp; mesh = data-&gt;meshs[m];
-    const MeshVertices&amp; vertices1 = aframe1.meshs[m];
-    const MeshVertices&amp; vertices2 = aframe2.meshs[m];
-    
-    // blend between frame1 + frame2
-    float* verts = new float[mesh.vertex_count * 3];
-    if(frame1.rot == frame2.rot) {
-      for(uint16_t v = 0; v &lt; mesh.vertex_count*3; ++v) {
-        verts[v] 
-          = vertices1.vertices[v] * t_1 + vertices2.vertices[v] * blend_time;
-      }
-    } else {
-      // need to manually rotate 180 degree here because frames have different
-      // rot values (=&gt; x=-x, y=y, z=-z)
-      for(uint16_t v = 0; v &lt; mesh.vertex_count; ++v) {
-        verts[v*3] 
-          = vertices1.vertices[v*3] * t_1 
-              - vertices2.vertices[v*3] * blend_time;
-        verts[v*3+1]
-          = vertices1.vertices[v*3+1] * t_1 
-              + vertices2.vertices[v*3+1] * blend_time;
-        verts[v*3+2]
-          = vertices1.vertices[v*3+2] * t_1
-              - vertices2.vertices[v*3+2] * blend_time;
-      }
-    }
-   
-    // draw mesh
-    CL_OpenGLSurface&amp; texture = const_cast&lt;CL_OpenGLSurface&amp;&gt; (mesh.texture);
-    texture.bind();
-
-    glVertexPointer(3, GL_FLOAT, 0, verts);
-    glNormalPointer(GL_FLOAT, 0, mesh.normals);
-    glTexCoordPointer(2, GL_FLOAT, 0, mesh.tex_coords);
-    glDrawElements(GL_TRIANGLES, mesh.triangle_count * 3, GL_UNSIGNED_SHORT,
-        mesh.vertex_indices);
-    
-    delete[] verts;
-  }
-
-  assert_gl(&quot;rendering 3d sprite&quot;);      
-
-  glPopMatrix();
-}
-

Deleted: trunk/src/sprite3d/sprite3d.hpp
===================================================================
--- trunk/src/sprite3d/sprite3d.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite3d/sprite3d.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -1,139 +0,0 @@
-//  $Id$
-// 
-//  Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-#ifndef HEADER_SPRITE3D_HPP
-#define HEADER_SPRITE3D_HPP
-
-#include &lt;string&gt;
-#include &lt;stdint.h&gt;
-#include &quot;game_object.hpp&quot;
-#include &quot;display/scene_context.hpp&quot;
-#include &quot;math/vector.hpp&quot;
-#include &quot;math/matrix.hpp&quot;
-
-class SceneContext;
-class Sprite3DData;
-struct Action;
-struct ActionFrame;
-struct BonePosition;
-
-typedef uint16_t BoneID;
-
-/**
- * This class is a 3d sprite. It's a set of textured meshs with different
- * animations (called actions) that are keyframe animated.
- */
-class Sprite3D
-{
-public:
-  ~Sprite3D();
-
-  /**
-   * You should call this every frame
-   */
-  void update(float elapsed_time);
-  void draw(SceneContext&amp; sc, const Vector&amp; pos);
-  void draw(SceneContext&amp; sc, const Matrix&amp; matrix);
-  
-  /**
-   * Changes action (after the currently shown animation frame)
-   */
-  void set_action(const std::string&amp; name, float speed = 1.0);
-  
-  /**
-   * Return the name of the currently active action
-   */
-  const std::string&amp; get_action() const;
-
-  /**
-   * Set the next action and vflip value to be played after the current action
-   * has finished (or reached the point to be defined by abort_at_marker)
-   */
-  void set_next_action(const std::string&amp; name, float speed = 1.0);
-  void set_next_rot(bool rot);
-
-  /**
-   * Abort current action after a certain marker has been reached.
-   * (This only works if set_next_action has been used before)
-   */
-  void abort_at_marker(const std::string&amp; marker);
-
-  /**
-   * returns true if the current frame of the action is before a certain marker
-   */
-  bool before_marker(const std::string&amp; marker) const;
-
-  /**
-   * returns true exactly once after actions have been switched after a
-   * set_next_action call (another call to set_next_action resets this flag)
-   */
-  bool switched_actions();
-
-  /**
-   * The speed of the action is multiplied with this factor
-   */
-  void set_speed(float speed);
-  float get_speed() const;
-
-  /**
-   * Rotate (or not rotate) the model 180 degree
-   */
-  void set_rot(bool rot = true);
-  bool get_rot() const;
-
-  BoneID get_bone_id(const std::string&amp; name) const;
-  Matrix get_bone_matrix(BoneID id) const;
-
-private:
-  friend class Sprite3DDrawingRequest;
-  friend class Sprite3DManager;
-  Sprite3D(const Sprite3DData* data);
-  
-  Sprite3D (const Sprite3D&amp;);
-  Sprite3D&amp; operator= (const Sprite3D&amp;);
-
-  struct Frame {
-    const Action* action;
-    int frame;
-    float speed;
-    bool rot;
-
-    bool operator==(const Frame&amp; o) const
-    {
-      return action == o.action &amp;&amp; frame == o.frame &amp;&amp; speed == o.speed
-        &amp;&amp; rot == o.rot;
-    }
-  };
-
-  void set_next_frame();
-  void draw(CL_GraphicContext* gc, const Vector&amp; pos, const Matrix&amp; modelview);
-
-  const Sprite3DData* data;
-  bool actions_switched;
-
-  BonePosition* bone_positions;
-
-  Frame frame1;
-  Frame frame2;
-  float blend_time;
- 
-  Frame next_frame;
-  Frame next_action;
-  Frame abort_at_frame;
-};
-
-#endif

Deleted: trunk/src/sprite3d/sprite3d_data.cpp
===================================================================
--- trunk/src/sprite3d/sprite3d_data.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite3d/sprite3d_data.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -1,259 +0,0 @@
-#include &quot;sprite3d_data.hpp&quot;
-
-#include &lt;physfs.h&gt;
-#include &lt;string.h&gt;
-#include &lt;sstream&gt;
-#include &lt;stdexcept&gt;
-#include &quot;util.hpp&quot;
-#include &quot;globals.hpp&quot;
-
-static const int FORMAT_VERSION = 2;
-
-static inline float read_float(PHYSFS_file* file)
-{
-    uint32_t int_result;
-    if(PHYSFS_readULE32(file, &amp;int_result) == 0) {
-        std::ostringstream msg;
-        msg &lt;&lt; &quot;Problem reading float value: &quot; &lt;&lt; PHYSFS_getLastError();
-        throw std::runtime_error(msg.str());
-    }
-
-    // is this platform independent?
-    return * ( reinterpret_cast&lt;float*&gt; (&amp;int_result) );
-}
-
-static inline uint16_t read_uint16_t(PHYSFS_file* file)
-{
-    uint16_t result;
-    if(PHYSFS_readULE16(file, &amp;result) == 0) {
-        std::ostringstream msg;
-        msg &lt;&lt; &quot;Problem reading uint16 value: &quot; &lt;&lt; PHYSFS_getLastError();
-        throw std::runtime_error(msg.str());
-    }
-    return result;
-}
-
-static inline std::string read_string(PHYSFS_file* file, size_t size)
-{
-    char buffer[size+1];
-    if(PHYSFS_read(file, buffer, size, 1) != 1) {
-        std::ostringstream msg;
-        msg &lt;&lt; &quot;Problem reading string value: &quot; &lt;&lt; PHYSFS_getLastError();
-        throw std::runtime_error(msg.str());
-    }
-    buffer[size] = 0;
-
-    return buffer;
-}
-
-Sprite3DData::Sprite3DData(const std::string&amp; filename)
-  : mesh_count(0), meshs(0), bone_count(0), bones(0),
-  action_count(0), actions(0)
-{
-  PHYSFS_file* file = PHYSFS_openRead(filename.c_str());
-  if(!file) {
-    std::ostringstream msg;
-    msg &lt;&lt; &quot;Couldn't open '&quot; &lt;&lt; filename &lt;&lt; &quot;': &quot;
-      &lt;&lt; PHYSFS_getLastError();
-    throw std::runtime_error(msg.str());
-  }
-
-  try {
-    std::string magic = read_string(file, 4);
-    if(magic != &quot;W3DS&quot;)
-      throw std::runtime_error(&quot;Not a windstille 3d sprite file&quot;);
-    uint16_t format_version = read_uint16_t(file);
-    if(format_version &gt; FORMAT_VERSION)
-      throw std::runtime_error(&quot;sprite file format too new&quot;);
-    if(format_version &lt; FORMAT_VERSION)
-      throw std::runtime_error(&quot;sprite file format too old&quot;);
-
-    mesh_count = read_uint16_t(file);
-    if(mesh_count == 0)
-      throw std::runtime_error(&quot;Sprite contains no meshs&quot;);
-    bone_count = read_uint16_t(file);
-    action_count = read_uint16_t(file);
-    if(action_count == 0)
-      throw std::runtime_error(&quot;Sprite contains no actions&quot;);
-
-    // read meshs
-    meshs = new Mesh[mesh_count];
-    for(uint16_t i = 0; i &lt; mesh_count; ++i) {
-      Mesh&amp; mesh = meshs[i];
-
-      std::string texturename = read_string(file, 64);
-      texturename = dirname(filename) + basename(texturename);
-      mesh.triangle_count = read_uint16_t(file);
-      mesh.vertex_count = read_uint16_t(file);
-
-      printf(&quot;Reading Mesh Tex %s Tri %u Vs %u.\n&quot;, texturename.c_str(),
-              mesh.triangle_count, mesh.vertex_count);
-
-      mesh.texture = CL_OpenGLSurface(datadir + texturename);
-
-      // read triangles
-      mesh.vertex_indices = new uint16_t[mesh.triangle_count * 3];
-      for(uint16_t v = 0; v &lt; mesh.triangle_count * 3; ++v) {
-        mesh.vertex_indices[v] = read_uint16_t(file);
-      }
-      
-      mesh.normals = new float[mesh.triangle_count * 3];
-      for(uint16_t n = 0; n &lt; mesh.triangle_count * 3; ++n) {
-        mesh.normals[n] = read_float(file);
-      }
-
-      mesh.tex_coords = new float[mesh.vertex_count * 2];
-      for(uint16_t v = 0; v &lt; mesh.vertex_count * 2; ++v) {
-        mesh.tex_coords[v] = read_float(file);
-      }
-    }
-
-    // read bones
-    bones = new Bone[bone_count];
-    for(uint16_t b = 0; b &lt; bone_count; ++b) {
-      Bone&amp; bone = bones[b];
-      bone.name = read_string(file, 64);
-    }
-
-    // read actions
-    actions = new Action[action_count];
-    for(uint16_t i = 0; i &lt; action_count; ++i) {
-      Action&amp; action = actions[i];
-
-      action.name = read_string(file, 64);
-      action.speed = read_float(file);
-      action.marker_count = read_uint16_t(file);
-      action.frame_count = read_uint16_t(file);
-
-      printf(&quot;ReadingAction %s Frames %u.\n&quot;, action.name.c_str(), action.frame_count);
-
-      // read markers
-      action.markers = new Marker[action.marker_count];
-      for(uint16_t m = 0; m &lt; action.marker_count; ++m) {
-        Marker&amp; marker = action.markers[m];
-        marker.name = read_string(file, 64);
-        marker.frame = read_uint16_t(file);
-        printf(&quot;Marker '%s' at %u.\n&quot;, marker.name.c_str(), marker.frame);
-      }
-
-      // read frames
-      action.frames = new ActionFrame[action.frame_count];
-      for(uint16_t f = 0; f &lt; action.frame_count; ++f) {
-        ActionFrame&amp; frame = action.frames[f];
-        
-        frame.meshs = new MeshVertices[mesh_count];
-        for(uint16_t m = 0; m &lt; mesh_count; ++m) {
-          MeshVertices&amp; mesh = frame.meshs[m];
-
-          mesh.vertices = new float[meshs[m].vertex_count * 3];
-          for(uint16_t v = 0; v &lt; meshs[m].vertex_count * 3; ++v) {
-            mesh.vertices[v] = read_float(file);
-          }
-        }
-
-        frame.bones = new BonePosition[bone_count];
-        for(uint16_t b = 0; b &lt; bone_count; ++b) {
-          BonePosition&amp; bone = frame.bones[b];
-          for(int i = 0; i &lt; 3; ++i)
-            bone.pos[i] = read_float(file);
-          for(int i = 0; i &lt; 4; ++i)
-            bone.quat[i] = read_float(file);
-        }
-      }
-    }
-  } catch(std::exception&amp; e) {
-    clear();
-    PHYSFS_close(file);
-    std::ostringstream msg;
-    msg &lt;&lt; &quot;Problem while reading '&quot; &lt;&lt; filename &lt;&lt; &quot;': &quot; &lt;&lt; e.what();
-    throw std::runtime_error(msg.str());
-  }
-  PHYSFS_close(file);
-}
-
-Sprite3DData::~Sprite3DData()
-{
-  clear();
-}
-
-void
-Sprite3DData::clear()
-{
-  if(meshs != 0) {
-    for(uint16_t m = 0; m &lt; mesh_count; ++m) {
-      Mesh&amp; mesh = meshs[m];
-      delete[] mesh.vertex_indices;
-      delete[] mesh.tex_coords;
-      delete[] mesh.normals;
-    }
-    delete[] meshs;
-    meshs = 0;
-  }
-  
-  delete[] bones;
-  bones = 0;
-
-  if(actions != 0) {
-    for(uint16_t a = 0; a &lt; action_count; ++a) {
-      Action&amp; action = actions[a];
-      delete[] action.markers;      
-      if(action.frames == 0)
-        continue;
-      
-      for(uint16_t f = 0; f &lt; action.frame_count; ++f) {
-        ActionFrame&amp; frame = action.frames[f];
-        if(frame.meshs == 0)
-          continue;
-        for(uint16_t m = 0; m &lt; mesh_count; ++m) {
-          MeshVertices&amp; vertices = frame.meshs[m];
-          delete[] vertices.vertices;
-        }
-        delete[] frame.meshs;
-        delete[] frame.bones;
-      }
-      delete[] action.frames;
-    }
-    delete[] actions;
-  }
-  mesh_count = 0;
-  action_count = 0;
-}
-
-const Action&amp;
-Sprite3DData::get_action(const std::string&amp; name) const
-{
-  for(uint16_t a = 0; a &lt; action_count; ++a) {
-    if(actions[a].name == name)
-      return actions[a];
-  }
-  std::ostringstream msg;
-  msg &lt;&lt; &quot;No action with name '&quot; &lt;&lt; name &lt;&lt; &quot;' defined&quot;;
-  throw std::runtime_error(msg.str());
-}
-
-const Marker&amp;
-Sprite3DData::get_marker(const Action* action, const std::string&amp; name) const
-{
-  for(uint16_t m = 0; m &lt; action-&gt;marker_count; ++m) {
-    if(action-&gt;markers[m].name == name)
-      return action-&gt;markers[m];
-  }
-  std::ostringstream msg;
-  msg &lt;&lt; &quot;No marker with name '&quot; &lt;&lt; name &lt;&lt; &quot;' defined in action '&quot;
-      &lt;&lt; action-&gt;name &lt;&lt; &quot;'&quot;;
-  throw std::runtime_error(msg.str());
-}
-
-uint16_t
-Sprite3DData::get_bone_id(const std::string&amp; name) const
-{
-  for(uint16_t b = 0; b &lt; bone_count; ++b) {
-    if(bones[b].name == name)
-      return b;
-  }
-
-  std::ostringstream msg;
-  msg &lt;&lt; &quot;No bone with name '&quot; &lt;&lt; name &lt;&lt; &quot;' defined&quot;;
-  throw std::runtime_error(msg.str());
-}
-

Deleted: trunk/src/sprite3d/sprite3d_data.hpp
===================================================================
--- trunk/src/sprite3d/sprite3d_data.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite3d/sprite3d_data.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -1,121 +0,0 @@
-//  $Id$
-// 
-//  Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-#ifndef HEADER_SPRITE3D_DATA_HPP
-#define HEADER_SPRITE3D_DATA_HPP
-
-#include &lt;stdint.h&gt;
-#include &lt;ClanLib/GL/opengl_surface.h&gt;
-
-struct Mesh;
-struct Bone;
-struct MeshVertices;
-struct ActionFrame;
-struct Action;
-struct Marker;
-
-/**
- * This class holds the data of a .wsprite file.
- */
-class Sprite3DData
-{
-public:
-  Sprite3DData(const std::string&amp; filename);
-  ~Sprite3DData();
-
-  const Action&amp; get_action(const std::string&amp; name) const;
-  const Marker&amp; get_marker(const Action* action, const std::string&amp; name) const;
-  uint16_t get_bone_id(const std::string&amp; name) const;
-
-  uint16_t mesh_count;
-  Mesh* meshs;
-  uint16_t bone_count;
-  Bone* bones;
-  uint16_t action_count;
-  Action* actions;
-
-private:
-  void clear();
-  
-  Sprite3DData (const Sprite3DData&amp;);
-  Sprite3DData&amp; operator= (const Sprite3DData&amp;);
-};
-
-struct Mesh
-{
-  Mesh()
-    : vertex_indices(0), tex_coords(0), normals(0)
-  { }
-
-  CL_OpenGLSurface texture;
-  uint16_t triangle_count;
-  uint16_t* vertex_indices;
-  float* tex_coords;
-  float* normals;
-  uint16_t vertex_count;
-};
-
-struct Bone
-{
-  std::string name;
-};
-
-struct MeshVertices
-{
-  MeshVertices()
-    : vertices(0)
-  { }
-  float* vertices;
-};
-
-struct BonePosition
-{
-  BonePosition()
-  { }
-  float pos[3]; // x, y, z
-  float quat[4]; // w, x, y, z
-};
-
-struct ActionFrame
-{
-  ActionFrame()
-    : meshs(0), bones(0)
-  { }
-  MeshVertices* meshs;
-  BonePosition* bones;
-};
-
-struct Marker
-{
-  std::string name;
-  uint16_t frame;
-};
-
-struct Action
-{
-  Action()
-    : markers(0), frames(0)
-  { }
-  std::string name;
-  float speed;
-  uint16_t marker_count;
-  Marker* markers;
-  uint16_t frame_count;
-  ActionFrame* frames;
-};
-
-#endif

Deleted: trunk/src/sprite3d/sprite3d_manager.cpp
===================================================================
--- trunk/src/sprite3d/sprite3d_manager.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite3d/sprite3d_manager.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -1,29 +0,0 @@
-#include &quot;sprite3d_manager.hpp&quot;
-#include &quot;sprite3d_data.hpp&quot;
-#include &quot;sprite3d.hpp&quot;
-
-Sprite3DManager* sprite3d_manager = 0;
-
-Sprite3DManager::Sprite3DManager()
-{
-}
-
-Sprite3DManager::~Sprite3DManager()
-{
-  for(Datas::iterator i = datas.begin(); i != datas.end(); ++i)
-    delete i-&gt;second;
-}
-
-Sprite3D*
-Sprite3DManager::create(const std::string&amp; filename)
-{
-  Datas::iterator i = datas.find(filename);
-  if(i == datas.end()) {
-    Sprite3DData* data = new Sprite3DData(filename);
-    datas.insert(std::make_pair(filename, data));
-    return new Sprite3D(data);
-  }
-
-  return new Sprite3D(i-&gt;second);
-}
-

Deleted: trunk/src/sprite3d/sprite3d_manager.hpp
===================================================================
--- trunk/src/sprite3d/sprite3d_manager.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/sprite3d/sprite3d_manager.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -1,26 +0,0 @@
-#ifndef __SPRITE3D_MANAGER_HPP__
-#define __SPRITE3D_MANAGER_HPP__
-
-#include &lt;string&gt;
-#include &lt;map&gt;
-
-class Sprite3D;
-class Sprite3DData;
-
-class Sprite3DManager
-{
-public:
-  Sprite3DManager();
-  ~Sprite3DManager();
-
-  Sprite3D* create(const std::string&amp; filename);
-
-private:
-  typedef std::map&lt;std::string, Sprite3DData*&gt; Datas;
-  Datas datas;
-};
-
-extern Sprite3DManager* sprite3d_manager;
-
-#endif
-

Modified: trunk/src/test_object.cpp
===================================================================
--- trunk/src/test_object.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/test_object.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -1,5 +1,5 @@
 #include &quot;test_object.hpp&quot;
-#include &quot;sprite3d/sprite3d_manager.hpp&quot;
+#include &quot;sprite3d/manager.hpp&quot;
 #include &quot;lisp/list_iterator.hpp&quot;
 
 TestObject::TestObject(const lisp::Lisp* lisp)
@@ -51,7 +51,7 @@
 TestObject::set_sprite(const std::string&amp; filename)
 {
   try {
-    Sprite3D* newsprite = sprite3d_manager-&gt;create(filename);
+    sprite3d::Sprite* newsprite = sprite3d_manager-&gt;create(filename);
     delete sprite;
     sprite = newsprite;
   } catch(std::exception&amp; e) {

Modified: trunk/src/test_object.hpp
===================================================================
--- trunk/src/test_object.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/test_object.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -2,7 +2,7 @@
 #define __TEST_OBJECT_HPP__
 
 #include &quot;game_object.hpp&quot;
-#include &quot;sprite3d/sprite3d.hpp&quot;
+#include &quot;sprite3d/sprite.hpp&quot;
 #include &quot;math/vector.hpp&quot;
 #include &quot;lisp/lisp.hpp&quot;
 
@@ -21,7 +21,7 @@
   void set_pos(const Vector&amp; pos);
 
 private:
-  Sprite3D* sprite;
+  sprite3d::Sprite* sprite;
   Vector pos;
 };
 

Modified: trunk/src/windstille_main.cpp
===================================================================
--- trunk/src/windstille_main.cpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/windstille_main.cpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -37,7 +37,9 @@
 #include &quot;tinygettext/gettext.hpp&quot;
 #include &quot;gameconfig.hpp&quot;
 #include &quot;util.hpp&quot;
-#include &quot;sprite3d/sprite3d_manager.hpp&quot;
+#include &quot;glutil/texture_manager.hpp&quot;
+#include &quot;sprite3d/manager.hpp&quot;
+#include &quot;sprite2d/manager.hpp&quot;
 
 using namespace Windstille;
 
@@ -159,6 +161,7 @@
 
   try {
     init_physfs(argv[0]);
+    init_sdl();
     
     dictionaryManager = new TinyGetText::DictionaryManager();
     dictionaryManager-&gt;set_charset(&quot;iso8859-1&quot;);
@@ -204,7 +207,7 @@
         screen = new GameSession(basename(levelfile));
         game_main_state = RUN_GAME;
       }
-    
+   
     console &lt;&lt; &quot;Press F1 to open the console&quot; &lt;&lt; std::endl;
     while (game_main());
     
@@ -264,8 +267,10 @@
   sound_manager-&gt;enable_music(config-&gt;music_enabled);
 
   if (debug) std::cout &lt;&lt; &quot;Initialising ScriptManager&quot; &lt;&lt; std::endl;
+  texture_manager = new TextureManager();
   script_manager   = new ScriptManager();
-  sprite3d_manager = new Sprite3DManager;
+  sprite2d_manager = new sprite2d::Manager();
+  sprite3d_manager = new sprite3d::Manager();
 
   script_manager-&gt;run_script_file(&quot;scripts/windstille.nut&quot;);
 }
@@ -276,8 +281,14 @@
   delete sprite3d_manager;
   sprite3d_manager = 0;
 
+  delete sprite2d_manager;
+  sprite2d_manager = 0;
+
   delete script_manager;
   script_manager = 0;
+
+  delete texture_manager;
+  texture_manager = 0;
   
   delete sound_manager;
   sound_manager = 0;
@@ -293,6 +304,16 @@
 }
 
 void
+WindstilleMain::init_sdl()
+{
+  if(SDL_Init(SDL_INIT_EVERYTHING) &lt; 0) {
+    std::stringstream msg;
+    msg &lt;&lt; &quot;Couldn't initialize SDL: &quot; &lt;&lt; SDL_GetError();
+    throw std::runtime_error(msg.str());
+  }
+}
+
+void
 WindstilleMain::init_physfs(const char* argv0)
 {
   if(!PHYSFS_init(argv0)) {

Modified: trunk/src/windstille_main.hpp
===================================================================
--- trunk/src/windstille_main.hpp	2005-07-17 18:50:01 UTC (rev 663)
+++ trunk/src/windstille_main.hpp	2005-07-17 23:46:17 UTC (rev 664)
@@ -43,6 +43,7 @@
   virtual int main(int argc, char** argv);
 
 private:
+  void init_sdl();
   void init_physfs(const char* argv0);
   void parse_command_line(int argc, char** argv);
   void init_modules();


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000316.html">[Windstille-commit] r663 - trunk/src
</A></li>
	<LI>Next message: <A HREF="000318.html">[Windstille-commit] r665 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#317">[ date ]</a>
              <a href="thread.html#317">[ thread ]</a>
              <a href="subject.html#317">[ subject ]</a>
              <a href="author.html#317">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/windstille-commit">More information about the Windstille-commit
mailing list</a><br>
</body></html>
