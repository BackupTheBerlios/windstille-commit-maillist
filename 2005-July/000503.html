<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Windstille-commit] r850 - in trunk/src: . sprite3d
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/windstille-commit/2005-July/index.html" >
   <LINK REL="made" HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r850%20-%20in%20trunk/src%3A%20.%20sprite3d&In-Reply-To=%3C200507292217.j6TMHqIV018557%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000502.html">
   <LINK REL="Next"  HREF="000504.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Windstille-commit] r850 - in trunk/src: . sprite3d</H1>
    <B>Ingo Ruhnke at BerliOS</B> 
    <A HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r850%20-%20in%20trunk/src%3A%20.%20sprite3d&In-Reply-To=%3C200507292217.j6TMHqIV018557%40sheep.berlios.de%3E"
       TITLE="[Windstille-commit] r850 - in trunk/src: . sprite3d">grumbel at berlios.de
       </A><BR>
    <I>Sat Jul 30 00:17:52 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000502.html">[Windstille-commit] r849 - in trunk/src: . badguy display scripting sprite2d
</A></li>
        <LI>Next message: <A HREF="000504.html">[Windstille-commit] r851 - trunk/src/particles
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#503">[ date ]</a>
              <a href="thread.html#503">[ thread ]</a>
              <a href="subject.html#503">[ subject ]</a>
              <a href="author.html#503">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: grumbel
Date: 2005-07-30 00:17:50 +0200 (Sat, 30 Jul 2005)
New Revision: 850

Added:
   trunk/src/sprite3d/sprite3d.cpp
   trunk/src/sprite3d/sprite3d.hpp
Removed:
   trunk/src/sprite3d/sprite.cpp
   trunk/src/sprite3d/sprite.hpp
Modified:
   trunk/src/character.cpp
   trunk/src/character.hpp
   trunk/src/player.cpp
   trunk/src/player.hpp
   trunk/src/sprite3d/Jamfile
   trunk/src/sprite3d/data.cpp
   trunk/src/sprite3d/manager.cpp
   trunk/src/sprite3d/manager.hpp
   trunk/src/test_object.cpp
   trunk/src/test_object.hpp
Log:
- renamed sprite3d::Sprite to Sprite3D

Modified: trunk/src/character.cpp
===================================================================
--- trunk/src/character.cpp	2005-07-29 22:02:41 UTC (rev 849)
+++ trunk/src/character.cpp	2005-07-29 22:17:50 UTC (rev 850)
@@ -43,7 +43,7 @@
   props.get(&quot;pos&quot;, pos);
   props.print_unused_warnings(&quot;character&quot;);
   
-  sprite = sprite3d::Sprite(&quot;3dsprites/heroken.wsprite&quot;);
+  sprite = Sprite3D(&quot;3dsprites/heroken.wsprite&quot;);
   sprite.set_action(&quot;Stand&quot;);
 }
 

Modified: trunk/src/character.hpp
===================================================================
--- trunk/src/character.hpp	2005-07-29 22:02:41 UTC (rev 849)
+++ trunk/src/character.hpp	2005-07-29 22:17:50 UTC (rev 850)
@@ -21,13 +21,13 @@
 #define HEADER_CHARACTER_HPP
 
 #include &quot;entity.hpp&quot;
-#include &quot;sprite3d/sprite.hpp&quot;
+#include &quot;sprite3d/sprite3d.hpp&quot;
 #include &quot;lisp/lisp.hpp&quot;
 
 class Character : public Entity
 {
 private:
-  sprite3d::Sprite sprite;
+  Sprite3D sprite;
     
 public:
   Character(const lisp::Lisp* lisp);

Modified: trunk/src/player.cpp
===================================================================
--- trunk/src/player.cpp	2005-07-29 22:02:41 UTC (rev 849)
+++ trunk/src/player.cpp	2005-07-29 22:17:50 UTC (rev 850)
@@ -43,7 +43,7 @@
   grenade(&quot;3dsprites/grenade.wsprite&quot;),
   state(STAND)
 {
-  sprite = sprite3d::Sprite(&quot;3dsprites/heroken.wsprite&quot;);
+  sprite = Sprite3D(&quot;3dsprites/heroken.wsprite&quot;);
   pos.x = 320;
   pos.y = 200;
   name = &quot;player&quot;;

Modified: trunk/src/player.hpp
===================================================================
--- trunk/src/player.hpp	2005-07-29 22:02:41 UTC (rev 849)
+++ trunk/src/player.hpp	2005-07-29 22:17:50 UTC (rev 850)
@@ -25,7 +25,7 @@
 #include &lt;ClanLib/display.h&gt;
 
 #include &quot;input/controller.hpp&quot;
-#include &quot;sprite3d/sprite.hpp&quot;
+#include &quot;sprite3d/sprite3d.hpp&quot;
 #include &quot;math/vector.hpp&quot;
 #include &quot;globals.hpp&quot;
 #include &quot;entity.hpp&quot;
@@ -40,8 +40,8 @@
   Controller controller;
 
   CL_Sprite light;
-  sprite3d::Sprite sprite;
-  sprite3d::Sprite grenade;
+  Sprite3D sprite;
+  Sprite3D grenade;
 
   bool jumping;
   bool bomb_placed;

Modified: trunk/src/sprite3d/Jamfile
===================================================================
--- trunk/src/sprite3d/Jamfile	2005-07-29 22:02:41 UTC (rev 849)
+++ trunk/src/sprite3d/Jamfile	2005-07-29 22:17:50 UTC (rev 850)
@@ -3,8 +3,8 @@
 sources =
   data.cpp
   data.hpp
-  sprite.cpp
-  sprite.hpp
+  sprite3d.cpp
+  sprite3d.hpp
   manager.cpp
   manager.hpp
 ;

Modified: trunk/src/sprite3d/data.cpp
===================================================================
--- trunk/src/sprite3d/data.cpp	2005-07-29 22:02:41 UTC (rev 849)
+++ trunk/src/sprite3d/data.cpp	2005-07-29 22:17:50 UTC (rev 850)
@@ -77,11 +77,11 @@
 
     mesh_count = read_uint16_t(file);
     if(mesh_count == 0)
-      throw std::runtime_error(&quot;Sprite contains no meshs&quot;);
+      throw std::runtime_error(&quot;Sprite3D contains no meshs&quot;);
     attachement_point_count = read_uint16_t(file);
     action_count = read_uint16_t(file);
     if(action_count == 0)
-      throw std::runtime_error(&quot;Sprite contains no actions&quot;);
+      throw std::runtime_error(&quot;Sprite3D contains no actions&quot;);
 
     // read meshs
     meshs = new Mesh[mesh_count];

Modified: trunk/src/sprite3d/manager.cpp
===================================================================
--- trunk/src/sprite3d/manager.cpp	2005-07-29 22:02:41 UTC (rev 849)
+++ trunk/src/sprite3d/manager.cpp	2005-07-29 22:17:50 UTC (rev 850)
@@ -2,7 +2,7 @@
 
 #include &quot;sprite3d/manager.hpp&quot;
 #include &quot;sprite3d/data.hpp&quot;
-#include &quot;sprite3d/sprite.hpp&quot;
+#include &quot;sprite3d/sprite3d.hpp&quot;
 
 sprite3d::Manager* sprite3d_manager = 0;
 

Modified: trunk/src/sprite3d/manager.hpp
===================================================================
--- trunk/src/sprite3d/manager.hpp	2005-07-29 22:02:41 UTC (rev 849)
+++ trunk/src/sprite3d/manager.hpp	2005-07-29 22:17:50 UTC (rev 850)
@@ -7,7 +7,6 @@
 namespace sprite3d
 {
 
-class Sprite;
 class Data;
 
 class Manager

Deleted: trunk/src/sprite3d/sprite.cpp
===================================================================
--- trunk/src/sprite3d/sprite.cpp	2005-07-29 22:02:41 UTC (rev 849)
+++ trunk/src/sprite3d/sprite.cpp	2005-07-29 22:17:50 UTC (rev 850)
@@ -1,427 +0,0 @@
-//  $Id$
-//
-//  Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include &lt;config.h&gt;
-#include &quot;sprite3d/sprite.hpp&quot;
-
-#include &lt;vector&gt;
-#include &lt;stdint.h&gt;
-#include &lt;sstream&gt;
-#include &lt;stdexcept&gt;
-#include &lt;ClanLib/gl.h&gt;
-#include &lt;ClanLib/display.h&gt;
-#include &lt;physfs.h&gt;
-#include &quot;display/drawing_request.hpp&quot;
-#include &quot;display/scene_context.hpp&quot;
-#include &quot;globals.hpp&quot;
-#include &quot;util.hpp&quot;
-#include &quot;timer.hpp&quot;
-#include &quot;sprite3d/manager.hpp&quot;
-#include &quot;sprite3d/data.hpp&quot;
-
-namespace sprite3d
-{
-
-Sprite::Sprite()
-  : data(0), actions_switched(false)
-{
-}
-
-Sprite::Sprite(const std::string&amp; filename)
-  : data(sprite3d_manager-&gt;create_data(filename)), actions_switched(false)
-{
-  frame1.action = &amp;data-&gt;actions[0];
-  frame1.frame = 0;
-  frame1.rot   = false;
-  frame1.speed = 1.0;
-  frame2       = frame1;
-  abort_at_frame.action = 0;
-  next_frame.action  = 0;
-  next_action.action = 0;
-  blend_time = 0.0;
-}
-
-Sprite::Sprite(const Data* data)
-  : data(data), actions_switched(false)
-{
-  frame1.action = &amp;data-&gt;actions[0];
-  frame1.frame = 0;
-  frame1.rot   = false;
-  frame1.speed = 1.0;
-  frame2       = frame1;
-  abort_at_frame.action = 0;
-  next_frame.action  = 0;
-  next_action.action = 0;
-  blend_time = 0.0;
-}
-
-Sprite::~Sprite()
-{
-}
-
-void
-Sprite::set_action(const std::string&amp; actionname, float speed)
-{
-  next_frame.action = &amp; data-&gt;get_action(actionname);
-  // set to last action so that next set_next_frame call will result in frame 0
-  if(speed &gt;= 0) {
-    next_frame.frame = 0;
-  } else {
-    next_frame.frame = next_frame.action-&gt;frame_count - 1;
-  }
-  next_frame.speed = speed;
-  next_frame.rot = frame2.rot;
-
-  next_action.action = 0;
-  actions_switched = false;
-}
-
-const std::string&amp;
-Sprite::get_action() const
-{
-  if(next_frame.action != 0)
-    return next_frame.action-&gt;name;
-  
-  return frame2.action-&gt;name;
-}
-
-void
-Sprite::set_next_action(const std::string&amp; name, float speed)
-{
-  next_action.action = &amp; data-&gt;get_action(name);
-  if(speed &gt;= 0) {
-    next_action.frame = 0;
-  } else {
-    next_action.frame = next_action.action-&gt;frame_count - 1;
-  }
-  next_action.speed = speed;
-  next_action.rot = frame2.rot;
-  actions_switched = false;
-
-  const Frame* frame = next_frame.action != 0 ? &amp;next_frame : &amp;frame2;
-  abort_at_frame.action = frame-&gt;action;
-  abort_at_frame.speed = frame-&gt;speed;
-  abort_at_frame.rot = frame-&gt;rot;
-  if(frame-&gt;speed &gt;= 0) {
-    abort_at_frame.frame = frame-&gt;action-&gt;frame_count - 1;
-  } else {
-    abort_at_frame.frame = 0;
-  }
-}
-
-void
-Sprite::set_next_rot(bool rot)
-{
-  next_action.rot = rot;
-}
-
-void
-Sprite::abort_at_marker(const std::string&amp; name)
-{
-  const Marker&amp; marker = data-&gt;get_marker(frame1.action, name);
-  abort_at_frame = frame1;
-  abort_at_frame.frame = marker.frame;
-}
-
-bool
-Sprite::before_marker(const std::string&amp; name) const
-{
-  const Marker&amp; marker = data-&gt;get_marker(frame1.action, name);  
-  return frame1.frame &lt; marker.frame;
-}
-
-bool
-Sprite::switched_actions()
-{
-  if(actions_switched) {
-    actions_switched = false;
-    return true;
-  }
-
-  return false;
-}
-
-void
-Sprite::set_speed(float speed)
-{
-  if(speed &lt; 0 &amp;&amp; frame1.speed &gt;= 0
-      || speed &gt;= 0 &amp;&amp; frame1.speed &lt; 0) {
-    blend_time = 1.0 - blend_time;
-    std::swap(frame1, frame2);
-  }
-  frame1.speed = speed;
-  frame2.speed = speed;
-}
-
-float
-Sprite::get_speed() const
-{
-  return frame1.speed;
-}
-
-void
-Sprite::set_rot(bool rot)
-{
-  next_frame.rot = rot;
-}
-
-bool
-Sprite::get_rot() const
-{
-  if(next_frame.action != 0)
-    return next_frame.rot;
-  
-  return frame1.rot;
-}
-
-PointID
-Sprite::get_attachement_point_id(const std::string&amp; name) const
-{
-  return data-&gt;get_attachement_point_id(name); 
-}
-
-static inline void set_matrix_from_quat(Matrix&amp; m, float w,
-    float x, float y, float z)
-{
-  //row1
-  m.matrix[0] = 1.0f - 2*y*y - 2*z*z;
-  m.matrix[4] = 2*x*y - 2*w*z;
-  m.matrix[8] = 2*x*z + 2*w*y;
-  m.matrix[12] = 0.0f;
-
-  //row2
-  m.matrix[1] = 2*x*y + 2*w*z;
-  m.matrix[5] = 1.0f - 2*x*x - 2*z*z;
-  m.matrix[9] = 2*y*z - 2*w*x;
-  m.matrix[13] = 0.0f;
-
-  //row3
-  m.matrix[2] = 2*x*z - 2*w*y;
-  m.matrix[6] = 2*y*z + 2*w*x;
-  m.matrix[10] = 1.0f - 2*x*x - 2*y*y;
-  m.matrix[14] = 0.0f;
-
-  //row4
-  m.matrix[3] = 0.0f;
-  m.matrix[7] = 0.0f;
-  m.matrix[11] = 0.0f;
-  m.matrix[15] = 1.0f;
-}
-
-Matrix
-Sprite::get_attachement_point_matrix(PointID id) const
-{
-  float t_1 = 1.0 - blend_time;
-  const AttachementPointPosition&amp; point1 
-	  = frame1.action-&gt;frames[frame1.frame].attachement_points[id];
-  const AttachementPointPosition&amp; point2 
-	  = frame2.action-&gt;frames[frame2.frame].attachement_points[id];
-
-  float pos[3];
-  float quat[4];
-  if(frame1.rot) {
-    pos[0] = -point1.pos[0] * t_1;
-    pos[1] = point1.pos[1] * t_1;
-    pos[2] = -point1.pos[2] * t_1;   
-  } else {
-    for(int i = 0; i &lt; 3; ++i)
-      pos[i] = point1.pos[i] * t_1;
-    for(int i = 0; i &lt; 4; ++i)
-      quat[i] = point1.quat[i] * t_1;
-  }
-  if(frame2.rot) {
-    pos[0] += -point2.pos[0] * blend_time;
-    pos[1] += point2.pos[1] * blend_time;
-    pos[2] += -point2.pos[2] * blend_time;
-  } else {
-    for(int i = 0; i &lt; 3; ++i)
-      pos[i] += point2.pos[i] * blend_time;
-    for(int i = 0; i &lt; 4; ++i)
-      quat[i] += point2.quat[i] * blend_time;
-  }
-
-  Matrix m      = Matrix::identity();
-  m.matrix[12] += pos[0];
-  m.matrix[13] += pos[1];
-  m.matrix[14] += pos[2];
-
-  return m;
-}
-
-class SpriteDrawingRequest : public DrawingRequest
-{
-private:
-  const Sprite* sprite;
-
-public:
-  SpriteDrawingRequest(const Sprite* sprite, const Vector&amp; pos, float z_pos,
-                       const Matrix&amp; modelview)
-    : DrawingRequest(pos, z_pos, modelview), sprite(sprite)
-  {}
-
-  void draw(CL_GraphicContext* gc)
-  {
-    sprite-&gt;draw(gc, pos, modelview);
-  }
-};
-
-void
-Sprite::set_next_frame()
-{
-  if(frame2.action != frame1.action &amp;&amp; abort_at_frame.action == 0) {
-    actions_switched = true;
-  }
-  
-  frame1 = frame2;
-  if(next_frame.action != 0) {
-    frame2 = next_frame;
-    next_frame.action = 0;
-    return;
-  }
-  if(frame2 == abort_at_frame &amp;&amp; next_action.action != 0) {
-    frame2 = next_action;
-    abort_at_frame.action = 0;
-    next_action.action = 0;
-    return;
-  }
-
-  frame2.action = frame1.action;
-  if(frame1.speed &lt; 0) {
-    frame2.frame = (frame1.frame + frame1.action-&gt;frame_count - 1)
-      % frame2.action-&gt;frame_count;
-  } else {
-    frame2.frame = (frame1.frame + 1) % frame1.action-&gt;frame_count;
-  }
-  frame2.speed = frame1.speed;
-  frame2.rot = frame1.rot;
-}
-
-void
-Sprite::update(float elapsed_time)
-{   
-  float time_delta = elapsed_time * frame1.action-&gt;speed * frame1.speed;
-  if(frame1.speed &lt; 0)
-    time_delta = -time_delta;
-  
-  while(blend_time + time_delta &gt;= 1.0) {
-    elapsed_time -= (1.0 - blend_time) / (frame1.action-&gt;speed * frame1.speed);
-    set_next_frame();
-
-    time_delta = elapsed_time * frame1.action-&gt;speed * frame1.speed;
-    if(frame1.speed &lt; 0)
-      time_delta = -time_delta;
-    blend_time = 0.0;
-  }
-  blend_time += time_delta;
-}
-
-void
-Sprite::draw(SceneContext&amp; sc, const Vector&amp; pos, float z_pos) const
-{
-  sc.color().draw(new SpriteDrawingRequest(this, pos, z_pos, sc.color().get_modelview()));
-}
-
-void
-Sprite::draw(SceneContext&amp; sc, const Matrix&amp; matrix, float z_pos) const
-{
-  sc.color().draw(new SpriteDrawingRequest(this, Vector(0, 0), 0.0f, sc.color().get_modelview()));
-}
-
-void
-Sprite::draw(CL_GraphicContext* gc, const Vector&amp; pos, const Matrix&amp; modelview) const
-{
-  CL_OpenGLState state(gc);
-  state.set_active();
-  state.setup_2d();
-
-  glMatrixMode(GL_MODELVIEW);
-  glPushMatrix(); 
-  glMultMatrixf(modelview.matrix);
-  glTranslatef(pos.x, pos.y, 0);
-  if(frame1.rot) {
-    glRotatef(180, 0, 1.0, 0);
-  } 
-
-  glClear(GL_DEPTH_BUFFER_BIT);
-  glEnable(GL_DEPTH_TEST);
-  glEnable(GL_TEXTURE_2D);
-
-  glEnableClientState(GL_VERTEX_ARRAY);
-  glEnableClientState(GL_NORMAL_ARRAY);
-  glEnableClientState(GL_TEXTURE_COORD_ARRAY);  
-
-  assert_gl(&quot;gl init before sprite&quot;);
-
-  const ActionFrame&amp; aframe1 = frame1.action-&gt;frames[frame1.frame];
-  const ActionFrame&amp; aframe2 = frame2.action-&gt;frames[frame2.frame];
-  
-  float t_1 = 1.0 - blend_time;
-  for(uint16_t m = 0; m &lt; data-&gt;mesh_count; ++m) {
-    const Mesh&amp; mesh = data-&gt;meshs[m];
-    const MeshVertices&amp; vertices1 = aframe1.meshs[m];
-    const MeshVertices&amp; vertices2 = aframe2.meshs[m];
-
-    // set texture
-    glBindTexture(GL_TEXTURE_2D, mesh.texture.get_handle());
-    
-    // blend between frame1 + frame2
-    float* verts = new float[mesh.vertex_count * 3];
-    if(frame1.rot == frame2.rot) {
-      for(uint16_t v = 0; v &lt; mesh.vertex_count*3; ++v) {
-        verts[v] 
-          = vertices1.vertices[v] * t_1 + vertices2.vertices[v] * blend_time;
-      }
-    } else {
-      // need to manually rotate 180 degree here because frames have different
-      // rot values (=&gt; x=-x, y=y, z=-z)
-      for(uint16_t v = 0; v &lt; mesh.vertex_count; ++v) {
-        verts[v*3] 
-          = vertices1.vertices[v*3] * t_1 
-              - vertices2.vertices[v*3] * blend_time;
-        verts[v*3+1]
-          = vertices1.vertices[v*3+1] * t_1 
-              + vertices2.vertices[v*3+1] * blend_time;
-        verts[v*3+2]
-          = vertices1.vertices[v*3+2] * t_1
-              - vertices2.vertices[v*3+2] * blend_time;
-      }
-    }
-   
-    // draw mesh
-    glVertexPointer(3, GL_FLOAT, 0, verts);
-    glNormalPointer(GL_FLOAT, 0, mesh.normals);
-    glTexCoordPointer(2, GL_FLOAT, 0, mesh.tex_coords);
-    glDrawElements(GL_TRIANGLES, mesh.triangle_count * 3, GL_UNSIGNED_SHORT,
-        mesh.vertex_indices);
-    delete[] verts;
-  }
-
-  assert_gl(&quot;rendering 3d sprite&quot;);      
-
-  glPopMatrix();
-}
-
-bool
-Sprite::is_valid() const
-{
-  return data != 0;
-}
-
-}
-
-/* EOF */

Deleted: trunk/src/sprite3d/sprite.hpp
===================================================================
--- trunk/src/sprite3d/sprite.hpp	2005-07-29 22:02:41 UTC (rev 849)
+++ trunk/src/sprite3d/sprite.hpp	2005-07-29 22:17:50 UTC (rev 850)
@@ -1,144 +0,0 @@
-//  $Id$
-// 
-//  Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-#ifndef HEADER_SPRITE3D_HPP
-#define HEADER_SPRITE3D_HPP
-
-#include &lt;string&gt;
-#include &lt;stdint.h&gt;
-#include &quot;game_object.hpp&quot;
-#include &quot;display/scene_context.hpp&quot;
-#include &quot;math/vector.hpp&quot;
-#include &quot;math/matrix.hpp&quot;
-#include &quot;sprite3d/data.hpp&quot;
-
-class SceneContext;
-
-namespace sprite3d
-{
-
-class Data;
-struct Action;
-struct ActionFrame;
-
-typedef uint16_t PointID;
-
-/**
- * This class is a 3d sprite. It's a set of textured meshs with different
- * animations (called actions) that are keyframe animated.
- */
-class Sprite
-{
-public:
-  Sprite();
-  Sprite(const std::string&amp; filename);
-  Sprite(const Data* data);
-  ~Sprite();
-
-  /**
-   * You should call this every frame
-   */
-  void update(float elapsed_time);
-  void draw(SceneContext&amp; sc, const Vector&amp; pos, float z_pos) const;
-  void draw(SceneContext&amp; sc, const Matrix&amp; matrix, float z_pos) const;
-  
-  /**
-   * Changes action (after the currently shown animation frame)
-   */
-  void set_action(const std::string&amp; name, float speed = 1.0);
-  
-  /**
-   * Return the name of the currently active action
-   */
-  const std::string&amp; get_action() const;
-
-  /**
-   * Set the next action and vflip value to be played after the current action
-   * has finished (or reached the point to be defined by abort_at_marker)
-   */
-  void set_next_action(const std::string&amp; name, float speed = 1.0);
-  void set_next_rot(bool rot);
-
-  /**
-   * Abort current action after a certain marker has been reached.
-   * (This only works if set_next_action has been used before)
-   */
-  void abort_at_marker(const std::string&amp; marker);
-
-  /**
-   * returns true if the current frame of the action is before a certain marker
-   */
-  bool before_marker(const std::string&amp; marker) const;
-
-  /**
-   * returns true exactly once after actions have been switched after a
-   * set_next_action call (another call to set_next_action resets this flag)
-   */
-  bool switched_actions();
-
-  /**
-   * The speed of the action is multiplied with this factor
-   */
-  void set_speed(float speed);
-  float get_speed() const;
-
-  /**
-   * Rotate (or not rotate) the model 180 degree
-   */
-  void set_rot(bool rot = true);
-  bool get_rot() const;
-
-  PointID get_attachement_point_id(const std::string&amp; name) const;
-  Matrix get_attachement_point_matrix(PointID id) const;
-
-  /** true if the Sprite is valid and usable, false if not */
-  bool is_valid() const;
-  
-private:  
-  friend class SpriteDrawingRequest;
-  void draw(CL_GraphicContext* gc, const Vector&amp; pos, const Matrix&amp; modelview) const;
-  
-  struct Frame {
-    const Action* action;
-    int   frame;
-    float speed;
-    bool  rot;
-
-    bool operator==(const Frame&amp; o) const
-    {
-      return action == o.action &amp;&amp; frame == o.frame &amp;&amp; speed == o.speed
-        &amp;&amp; rot == o.rot;
-    }
-  };
-
-  void set_next_frame();
-
-  const Data* data;
-  bool actions_switched;
-
-  Frame frame1;
-  Frame frame2;
-  float blend_time;
- 
-  Frame next_frame;
-  Frame next_action;
-  Frame abort_at_frame;
-};
-
-}
-
-#endif

Copied: trunk/src/sprite3d/sprite3d.cpp (from rev 847, trunk/src/sprite3d/sprite.cpp)
===================================================================
--- trunk/src/sprite3d/sprite.cpp	2005-07-29 12:38:19 UTC (rev 847)
+++ trunk/src/sprite3d/sprite3d.cpp	2005-07-29 22:17:50 UTC (rev 850)
@@ -0,0 +1,424 @@
+//  $Id$
+//
+//  Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include &lt;config.h&gt;
+#include &quot;sprite3d/sprite3d.hpp&quot;
+
+#include &lt;vector&gt;
+#include &lt;stdint.h&gt;
+#include &lt;sstream&gt;
+#include &lt;stdexcept&gt;
+#include &lt;ClanLib/gl.h&gt;
+#include &lt;ClanLib/display.h&gt;
+#include &lt;physfs.h&gt;
+#include &quot;display/drawing_request.hpp&quot;
+#include &quot;display/scene_context.hpp&quot;
+#include &quot;globals.hpp&quot;
+#include &quot;util.hpp&quot;
+#include &quot;timer.hpp&quot;
+#include &quot;sprite3d/manager.hpp&quot;
+#include &quot;sprite3d/data.hpp&quot;
+
+using namespace sprite3d;
+
+Sprite3D::Sprite3D()
+  : data(0), actions_switched(false)
+{
+}
+
+Sprite3D::Sprite3D(const std::string&amp; filename)
+  : data(sprite3d_manager-&gt;create_data(filename)), actions_switched(false)
+{
+  frame1.action = &amp;data-&gt;actions[0];
+  frame1.frame = 0;
+  frame1.rot   = false;
+  frame1.speed = 1.0;
+  frame2       = frame1;
+  abort_at_frame.action = 0;
+  next_frame.action  = 0;
+  next_action.action = 0;
+  blend_time = 0.0;
+}
+
+Sprite3D::Sprite3D(const Data* data)
+  : data(data), actions_switched(false)
+{
+  frame1.action = &amp;data-&gt;actions[0];
+  frame1.frame = 0;
+  frame1.rot   = false;
+  frame1.speed = 1.0;
+  frame2       = frame1;
+  abort_at_frame.action = 0;
+  next_frame.action  = 0;
+  next_action.action = 0;
+  blend_time = 0.0;
+}
+
+Sprite3D::~Sprite3D()
+{
+}
+
+void
+Sprite3D::set_action(const std::string&amp; actionname, float speed)
+{
+  next_frame.action = &amp; data-&gt;get_action(actionname);
+  // set to last action so that next set_next_frame call will result in frame 0
+  if(speed &gt;= 0) {
+    next_frame.frame = 0;
+  } else {
+    next_frame.frame = next_frame.action-&gt;frame_count - 1;
+  }
+  next_frame.speed = speed;
+  next_frame.rot = frame2.rot;
+
+  next_action.action = 0;
+  actions_switched = false;
+}
+
+const std::string&amp;
+Sprite3D::get_action() const
+{
+  if(next_frame.action != 0)
+    return next_frame.action-&gt;name;
+  
+  return frame2.action-&gt;name;
+}
+
+void
+Sprite3D::set_next_action(const std::string&amp; name, float speed)
+{
+  next_action.action = &amp; data-&gt;get_action(name);
+  if(speed &gt;= 0) {
+    next_action.frame = 0;
+  } else {
+    next_action.frame = next_action.action-&gt;frame_count - 1;
+  }
+  next_action.speed = speed;
+  next_action.rot = frame2.rot;
+  actions_switched = false;
+
+  const Frame* frame = next_frame.action != 0 ? &amp;next_frame : &amp;frame2;
+  abort_at_frame.action = frame-&gt;action;
+  abort_at_frame.speed = frame-&gt;speed;
+  abort_at_frame.rot = frame-&gt;rot;
+  if(frame-&gt;speed &gt;= 0) {
+    abort_at_frame.frame = frame-&gt;action-&gt;frame_count - 1;
+  } else {
+    abort_at_frame.frame = 0;
+  }
+}
+
+void
+Sprite3D::set_next_rot(bool rot)
+{
+  next_action.rot = rot;
+}
+
+void
+Sprite3D::abort_at_marker(const std::string&amp; name)
+{
+  const Marker&amp; marker = data-&gt;get_marker(frame1.action, name);
+  abort_at_frame = frame1;
+  abort_at_frame.frame = marker.frame;
+}
+
+bool
+Sprite3D::before_marker(const std::string&amp; name) const
+{
+  const Marker&amp; marker = data-&gt;get_marker(frame1.action, name);  
+  return frame1.frame &lt; marker.frame;
+}
+
+bool
+Sprite3D::switched_actions()
+{
+  if(actions_switched) {
+    actions_switched = false;
+    return true;
+  }
+
+  return false;
+}
+
+void
+Sprite3D::set_speed(float speed)
+{
+  if(speed &lt; 0 &amp;&amp; frame1.speed &gt;= 0
+      || speed &gt;= 0 &amp;&amp; frame1.speed &lt; 0) {
+    blend_time = 1.0 - blend_time;
+    std::swap(frame1, frame2);
+  }
+  frame1.speed = speed;
+  frame2.speed = speed;
+}
+
+float
+Sprite3D::get_speed() const
+{
+  return frame1.speed;
+}
+
+void
+Sprite3D::set_rot(bool rot)
+{
+  next_frame.rot = rot;
+}
+
+bool
+Sprite3D::get_rot() const
+{
+  if(next_frame.action != 0)
+    return next_frame.rot;
+  
+  return frame1.rot;
+}
+
+Sprite3D::PointID
+Sprite3D::get_attachement_point_id(const std::string&amp; name) const
+{
+  return data-&gt;get_attachement_point_id(name); 
+}
+
+static inline void set_matrix_from_quat(Matrix&amp; m, float w,
+    float x, float y, float z)
+{
+  //row1
+  m.matrix[0] = 1.0f - 2*y*y - 2*z*z;
+  m.matrix[4] = 2*x*y - 2*w*z;
+  m.matrix[8] = 2*x*z + 2*w*y;
+  m.matrix[12] = 0.0f;
+
+  //row2
+  m.matrix[1] = 2*x*y + 2*w*z;
+  m.matrix[5] = 1.0f - 2*x*x - 2*z*z;
+  m.matrix[9] = 2*y*z - 2*w*x;
+  m.matrix[13] = 0.0f;
+
+  //row3
+  m.matrix[2] = 2*x*z - 2*w*y;
+  m.matrix[6] = 2*y*z + 2*w*x;
+  m.matrix[10] = 1.0f - 2*x*x - 2*y*y;
+  m.matrix[14] = 0.0f;
+
+  //row4
+  m.matrix[3] = 0.0f;
+  m.matrix[7] = 0.0f;
+  m.matrix[11] = 0.0f;
+  m.matrix[15] = 1.0f;
+}
+
+Matrix
+Sprite3D::get_attachement_point_matrix(PointID id) const
+{
+  float t_1 = 1.0 - blend_time;
+  const AttachementPointPosition&amp; point1 
+	  = frame1.action-&gt;frames[frame1.frame].attachement_points[id];
+  const AttachementPointPosition&amp; point2 
+	  = frame2.action-&gt;frames[frame2.frame].attachement_points[id];
+
+  float pos[3];
+  float quat[4];
+  if(frame1.rot) {
+    pos[0] = -point1.pos[0] * t_1;
+    pos[1] = point1.pos[1] * t_1;
+    pos[2] = -point1.pos[2] * t_1;   
+  } else {
+    for(int i = 0; i &lt; 3; ++i)
+      pos[i] = point1.pos[i] * t_1;
+    for(int i = 0; i &lt; 4; ++i)
+      quat[i] = point1.quat[i] * t_1;
+  }
+  if(frame2.rot) {
+    pos[0] += -point2.pos[0] * blend_time;
+    pos[1] += point2.pos[1] * blend_time;
+    pos[2] += -point2.pos[2] * blend_time;
+  } else {
+    for(int i = 0; i &lt; 3; ++i)
+      pos[i] += point2.pos[i] * blend_time;
+    for(int i = 0; i &lt; 4; ++i)
+      quat[i] += point2.quat[i] * blend_time;
+  }
+
+  Matrix m      = Matrix::identity();
+  m.matrix[12] += pos[0];
+  m.matrix[13] += pos[1];
+  m.matrix[14] += pos[2];
+
+  return m;
+}
+
+class Sprite3DDrawingRequest : public DrawingRequest
+{
+private:
+  const Sprite3D* sprite;
+
+public:
+  Sprite3DDrawingRequest(const Sprite3D* sprite, const Vector&amp; pos, float z_pos,
+                       const Matrix&amp; modelview)
+    : DrawingRequest(pos, z_pos, modelview), sprite(sprite)
+  {}
+
+  void draw(CL_GraphicContext* gc)
+  {
+    sprite-&gt;draw(gc, pos, modelview);
+  }
+};
+
+void
+Sprite3D::set_next_frame()
+{
+  if(frame2.action != frame1.action &amp;&amp; abort_at_frame.action == 0) {
+    actions_switched = true;
+  }
+  
+  frame1 = frame2;
+  if(next_frame.action != 0) {
+    frame2 = next_frame;
+    next_frame.action = 0;
+    return;
+  }
+  if(frame2 == abort_at_frame &amp;&amp; next_action.action != 0) {
+    frame2 = next_action;
+    abort_at_frame.action = 0;
+    next_action.action = 0;
+    return;
+  }
+
+  frame2.action = frame1.action;
+  if(frame1.speed &lt; 0) {
+    frame2.frame = (frame1.frame + frame1.action-&gt;frame_count - 1)
+      % frame2.action-&gt;frame_count;
+  } else {
+    frame2.frame = (frame1.frame + 1) % frame1.action-&gt;frame_count;
+  }
+  frame2.speed = frame1.speed;
+  frame2.rot = frame1.rot;
+}
+
+void
+Sprite3D::update(float elapsed_time)
+{   
+  float time_delta = elapsed_time * frame1.action-&gt;speed * frame1.speed;
+  if(frame1.speed &lt; 0)
+    time_delta = -time_delta;
+  
+  while(blend_time + time_delta &gt;= 1.0) {
+    elapsed_time -= (1.0 - blend_time) / (frame1.action-&gt;speed * frame1.speed);
+    set_next_frame();
+
+    time_delta = elapsed_time * frame1.action-&gt;speed * frame1.speed;
+    if(frame1.speed &lt; 0)
+      time_delta = -time_delta;
+    blend_time = 0.0;
+  }
+  blend_time += time_delta;
+}
+
+void
+Sprite3D::draw(SceneContext&amp; sc, const Vector&amp; pos, float z_pos) const
+{
+  sc.color().draw(new Sprite3DDrawingRequest(this, pos, z_pos, sc.color().get_modelview()));
+}
+
+void
+Sprite3D::draw(SceneContext&amp; sc, const Matrix&amp; matrix, float z_pos) const
+{
+  sc.color().draw(new Sprite3DDrawingRequest(this, Vector(0, 0), 0.0f, sc.color().get_modelview()));
+}
+
+void
+Sprite3D::draw(CL_GraphicContext* gc, const Vector&amp; pos, const Matrix&amp; modelview) const
+{
+  CL_OpenGLState state(gc);
+  state.set_active();
+  state.setup_2d();
+
+  glMatrixMode(GL_MODELVIEW);
+  glPushMatrix(); 
+  glMultMatrixf(modelview.matrix);
+  glTranslatef(pos.x, pos.y, 0);
+  if(frame1.rot) {
+    glRotatef(180, 0, 1.0, 0);
+  } 
+
+  glClear(GL_DEPTH_BUFFER_BIT);
+  glEnable(GL_DEPTH_TEST);
+  glEnable(GL_TEXTURE_2D);
+
+  glEnableClientState(GL_VERTEX_ARRAY);
+  glEnableClientState(GL_NORMAL_ARRAY);
+  glEnableClientState(GL_TEXTURE_COORD_ARRAY);  
+
+  assert_gl(&quot;gl init before sprite&quot;);
+
+  const ActionFrame&amp; aframe1 = frame1.action-&gt;frames[frame1.frame];
+  const ActionFrame&amp; aframe2 = frame2.action-&gt;frames[frame2.frame];
+  
+  float t_1 = 1.0 - blend_time;
+  for(uint16_t m = 0; m &lt; data-&gt;mesh_count; ++m) {
+    const Mesh&amp; mesh = data-&gt;meshs[m];
+    const MeshVertices&amp; vertices1 = aframe1.meshs[m];
+    const MeshVertices&amp; vertices2 = aframe2.meshs[m];
+
+    // set texture
+    glBindTexture(GL_TEXTURE_2D, mesh.texture.get_handle());
+    
+    // blend between frame1 + frame2
+    float* verts = new float[mesh.vertex_count * 3];
+    if(frame1.rot == frame2.rot) {
+      for(uint16_t v = 0; v &lt; mesh.vertex_count*3; ++v) {
+        verts[v] 
+          = vertices1.vertices[v] * t_1 + vertices2.vertices[v] * blend_time;
+      }
+    } else {
+      // need to manually rotate 180 degree here because frames have different
+      // rot values (=&gt; x=-x, y=y, z=-z)
+      for(uint16_t v = 0; v &lt; mesh.vertex_count; ++v) {
+        verts[v*3] 
+          = vertices1.vertices[v*3] * t_1 
+              - vertices2.vertices[v*3] * blend_time;
+        verts[v*3+1]
+          = vertices1.vertices[v*3+1] * t_1 
+              + vertices2.vertices[v*3+1] * blend_time;
+        verts[v*3+2]
+          = vertices1.vertices[v*3+2] * t_1
+              - vertices2.vertices[v*3+2] * blend_time;
+      }
+    }
+   
+    // draw mesh
+    glVertexPointer(3, GL_FLOAT, 0, verts);
+    glNormalPointer(GL_FLOAT, 0, mesh.normals);
+    glTexCoordPointer(2, GL_FLOAT, 0, mesh.tex_coords);
+    glDrawElements(GL_TRIANGLES, mesh.triangle_count * 3, GL_UNSIGNED_SHORT,
+        mesh.vertex_indices);
+    delete[] verts;
+  }
+
+  assert_gl(&quot;rendering 3d sprite&quot;);      
+
+  glPopMatrix();
+}
+
+bool
+Sprite3D::is_valid() const
+{
+  return data != 0;
+}
+
+/* EOF */

Copied: trunk/src/sprite3d/sprite3d.hpp (from rev 847, trunk/src/sprite3d/sprite.hpp)
===================================================================
--- trunk/src/sprite3d/sprite.hpp	2005-07-29 12:38:19 UTC (rev 847)
+++ trunk/src/sprite3d/sprite3d.hpp	2005-07-29 22:17:50 UTC (rev 850)
@@ -0,0 +1,143 @@
+//  $Id$
+// 
+//  Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#ifndef HEADER_SPRITE3D_HPP
+#define HEADER_SPRITE3D_HPP
+
+#include &lt;string&gt;
+#include &lt;stdint.h&gt;
+#include &quot;game_object.hpp&quot;
+#include &quot;display/scene_context.hpp&quot;
+#include &quot;math/vector.hpp&quot;
+#include &quot;math/matrix.hpp&quot;
+#include &quot;sprite3d/data.hpp&quot;
+
+class SceneContext;
+
+namespace sprite3d {
+
+class Data;
+struct Action;
+struct ActionFrame;
+
+} // namespace sprite3d
+
+/**
+ * This class is a 3d sprite. It's a set of textured meshs with different
+ * animations (called actions) that are keyframe animated.
+ */
+class Sprite3D
+{
+public:
+  typedef uint16_t PointID;
+
+  Sprite3D();
+  Sprite3D(const std::string&amp; filename);
+  Sprite3D(const sprite3d::Data* data);
+  ~Sprite3D();
+
+  /**
+   * You should call this every frame
+   */
+  void update(float elapsed_time);
+  void draw(SceneContext&amp; sc, const Vector&amp; pos, float z_pos) const;
+  void draw(SceneContext&amp; sc, const Matrix&amp; matrix, float z_pos) const;
+  
+  /**
+   * Changes action (after the currently shown animation frame)
+   */
+  void set_action(const std::string&amp; name, float speed = 1.0);
+  
+  /**
+   * Return the name of the currently active action
+   */
+  const std::string&amp; get_action() const;
+
+  /**
+   * Set the next action and vflip value to be played after the current action
+   * has finished (or reached the point to be defined by abort_at_marker)
+   */
+  void set_next_action(const std::string&amp; name, float speed = 1.0);
+  void set_next_rot(bool rot);
+
+  /**
+   * Abort current action after a certain marker has been reached.
+   * (This only works if set_next_action has been used before)
+   */
+  void abort_at_marker(const std::string&amp; marker);
+
+  /**
+   * returns true if the current frame of the action is before a certain marker
+   */
+  bool before_marker(const std::string&amp; marker) const;
+
+  /**
+   * returns true exactly once after actions have been switched after a
+   * set_next_action call (another call to set_next_action resets this flag)
+   */
+  bool switched_actions();
+
+  /**
+   * The speed of the action is multiplied with this factor
+   */
+  void set_speed(float speed);
+  float get_speed() const;
+
+  /**
+   * Rotate (or not rotate) the model 180 degree
+   */
+  void set_rot(bool rot = true);
+  bool get_rot() const;
+
+  PointID get_attachement_point_id(const std::string&amp; name) const;
+  Matrix get_attachement_point_matrix(PointID id) const;
+
+  /** true if the Sprite3D is valid and usable, false if not */
+  bool is_valid() const;
+  
+private:  
+  friend class Sprite3DDrawingRequest;
+  void draw(CL_GraphicContext* gc, const Vector&amp; pos, const Matrix&amp; modelview) const;
+  
+  struct Frame {
+    const sprite3d::Action* action;
+    int   frame;
+    float speed;
+    bool  rot;
+
+    bool operator==(const Frame&amp; o) const
+    {
+      return action == o.action &amp;&amp; frame == o.frame &amp;&amp; speed == o.speed
+        &amp;&amp; rot == o.rot;
+    }
+  };
+
+  void set_next_frame();
+
+  const sprite3d::Data* data;
+  bool actions_switched;
+
+  Frame frame1;
+  Frame frame2;
+  float blend_time;
+ 
+  Frame next_frame;
+  Frame next_action;
+  Frame abort_at_frame;
+};
+
+#endif

Modified: trunk/src/test_object.cpp
===================================================================
--- trunk/src/test_object.cpp	2005-07-29 22:02:41 UTC (rev 849)
+++ trunk/src/test_object.cpp	2005-07-29 22:17:50 UTC (rev 850)
@@ -19,7 +19,7 @@
 
   if(spritename == &quot;&quot;)
     throw std::runtime_error(&quot;No sprite name specified in TestObject&quot;);
-  sprite = sprite3d::Sprite(spritename);
+  sprite = Sprite3D(spritename);
 }
 
 TestObject::~TestObject()
@@ -51,7 +51,7 @@
 TestObject::set_sprite(const std::string&amp; filename)
 {
   try {
-    sprite = sprite3d::Sprite(filename);
+    sprite = Sprite3D(filename);
   } catch(std::exception&amp; e) {
     std::cerr &lt;&lt; &quot;Couldn't change sprite to '&quot; &lt;&lt; filename &lt;&lt; &quot;': &quot; 
               &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;
@@ -86,7 +86,7 @@
                    const std::string&amp; attachement_point)
 {
   AttachedSprite asprite;
-  asprite.sprite = sprite3d::Sprite(spritename);
+  asprite.sprite = Sprite3D(spritename);
   asprite.attachpoint = sprite.get_attachement_point_id(attachement_point);
   attached_sprites.push_back(asprite);
 }

Modified: trunk/src/test_object.hpp
===================================================================
--- trunk/src/test_object.hpp	2005-07-29 22:02:41 UTC (rev 849)
+++ trunk/src/test_object.hpp	2005-07-29 22:17:50 UTC (rev 850)
@@ -3,7 +3,7 @@
 
 #include &lt;vector&gt;
 #include &quot;game_object.hpp&quot;
-#include &quot;sprite3d/sprite.hpp&quot;
+#include &quot;sprite3d/sprite3d.hpp&quot;
 #include &quot;math/vector.hpp&quot;
 #include &quot;lisp/lisp.hpp&quot;
 
@@ -24,10 +24,10 @@
 		      const std::string&amp; attachement_point);
 
 private:
-  sprite3d::Sprite sprite;
+  Sprite3D sprite;
   struct AttachedSprite {
-    sprite3d::Sprite sprite;
-	sprite3d::PointID attachpoint;
+    Sprite3D sprite;
+    Sprite3D::PointID attachpoint;
   };
   std::vector&lt;AttachedSprite&gt; attached_sprites;
   Vector pos;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000502.html">[Windstille-commit] r849 - in trunk/src: . badguy display scripting sprite2d
</A></li>
	<LI>Next message: <A HREF="000504.html">[Windstille-commit] r851 - trunk/src/particles
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#503">[ date ]</a>
              <a href="thread.html#503">[ thread ]</a>
              <a href="subject.html#503">[ subject ]</a>
              <a href="author.html#503">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/windstille-commit">More information about the Windstille-commit
mailing list</a><br>
</body></html>
