<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Windstille-commit] r2684 - in trunk/windstille: data src	src/display src/navigation src/screen
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/windstille-commit/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r2684%20-%20in%20trunk/windstille%3A%20data%20src%0A%09src/display%20src/navigation%20src/screen&In-Reply-To=%3C200903162225.n2GMP7WJ019013%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001680.html">
   <LINK REL="Next"  HREF="001682.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Windstille-commit] r2684 - in trunk/windstille: data src	src/display src/navigation src/screen</H1>
    <B>grumbel at BerliOS</B> 
    <A HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r2684%20-%20in%20trunk/windstille%3A%20data%20src%0A%09src/display%20src/navigation%20src/screen&In-Reply-To=%3C200903162225.n2GMP7WJ019013%40sheep.berlios.de%3E"
       TITLE="[Windstille-commit] r2684 - in trunk/windstille: data src	src/display src/navigation src/screen">grumbel at mail.berlios.de
       </A><BR>
    <I>Mon Mar 16 23:25:07 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001680.html">[Windstille-commit] r2683 - trunk/windstille/src/screen
</A></li>
        <LI>Next message: <A HREF="001682.html">[Windstille-commit] r2685 - trunk/windstille
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1681">[ date ]</a>
              <a href="thread.html#1681">[ thread ]</a>
              <a href="subject.html#1681">[ subject ]</a>
              <a href="author.html#1681">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: grumbel
Date: 2009-03-16 23:25:06 +0100 (Mon, 16 Mar 2009)
New Revision: 2684

Added:
   trunk/windstille/src/navigation/edge.cpp
   trunk/windstille/src/navigation/edge.hpp
   trunk/windstille/src/navigation/edge_position.cpp
   trunk/windstille/src/navigation/edge_position.hpp
Removed:
   trunk/windstille/src/navigation/segment.cpp
   trunk/windstille/src/navigation/segment.hpp
   trunk/windstille/src/navigation/segment_position.cpp
   trunk/windstille/src/navigation/segment_position.hpp
Modified:
   trunk/windstille/data/navigation.nav
   trunk/windstille/src/SConscript
   trunk/windstille/src/display/display.cpp
   trunk/windstille/src/display/display.hpp
   trunk/windstille/src/navigation/navigation_graph.cpp
   trunk/windstille/src/navigation/navigation_graph.hpp
   trunk/windstille/src/navigation/node.cpp
   trunk/windstille/src/navigation/node.hpp
   trunk/windstille/src/screen/navigation_test.cpp
   trunk/windstille/src/screen/navigation_test.hpp
Log:
Renamed Segment to Edge

Modified: trunk/windstille/data/navigation.nav
===================================================================
--- trunk/windstille/data/navigation.nav	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/data/navigation.nav	2009-03-16 22:25:06 UTC (rev 2684)
@@ -20,20 +20,20 @@
     (node (id  18) (pos 283.341 177.94))
  )
 
-  (segments
-    (segment (node1   1) (node2   2) (properties 0))
-    (segment (node1   2) (node2   3) (properties 0))
-    (segment (node1   3) (node2   4) (properties 0))
-    (segment (node1   4) (node2   5) (properties 0))
-    (segment (node1   5) (node2   6) (properties 0))
-    (segment (node1  10) (node2   9) (properties 0))
-    (segment (node1   9) (node2   8) (properties 0))
-    (segment (node1   8) (node2   7) (properties 0))
-    (segment (node1  11) (node2  12) (properties 0))
-    (segment (node1  12) (node2  13) (properties 0))
-    (segment (node1  13) (node2  14) (properties 0))
-    (segment (node1  15) (node2  16) (properties 0))
-    (segment (node1  17) (node2  18) (properties 0))
+  (edges
+    (edge (node1   1) (node2   2) (properties 0))
+    (edge (node1   2) (node2   3) (properties 0))
+    (edge (node1   3) (node2   4) (properties 0))
+    (edge (node1   4) (node2   5) (properties 0))
+    (edge (node1   5) (node2   6) (properties 0))
+    (edge (node1  10) (node2   9) (properties 0))
+    (edge (node1   9) (node2   8) (properties 0))
+    (edge (node1   8) (node2   7) (properties 0))
+    (edge (node1  11) (node2  12) (properties 0))
+    (edge (node1  12) (node2  13) (properties 0))
+    (edge (node1  13) (node2  14) (properties 0))
+    (edge (node1  15) (node2  16) (properties 0))
+    (edge (node1  17) (node2  18) (properties 0))
  )
 )
 

Modified: trunk/windstille/src/SConscript
===================================================================
--- trunk/windstille/src/SConscript	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/SConscript	2009-03-16 22:25:06 UTC (rev 2684)
@@ -122,8 +122,8 @@
 'navigation/navigation_graph.cpp',
 'navigation/node.cpp',
 'navigation/properties.cpp',
-'navigation/segment.cpp',
-'navigation/segment_position.cpp',
+'navigation/edge.cpp',
+'navigation/edge_position.cpp',
 'objects/background_gradient.cpp',
 'objects/bomb.cpp',
 'objects/box.cpp',

Modified: trunk/windstille/src/display/display.cpp
===================================================================
--- trunk/windstille/src/display/display.cpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/display/display.cpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -42,7 +42,7 @@
 }
 
 void
-Display::draw_segment(const Line&amp; line, const Color&amp; color)
+Display::draw_line_with_normal(const Line&amp; line, const Color&amp; color)
 {
   Vector2f normal = (line.p2 - line.p1);
 

Modified: trunk/windstille/src/display/display.hpp
===================================================================
--- trunk/windstille/src/display/display.hpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/display/display.hpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -42,7 +42,7 @@
   static void draw_rounded_rect(const Rectf&amp; rect, float radius, const Color&amp; color);
 
   /** Same as draw_line, but in addition draw a normal on top of the line */
-  static void draw_segment(const Line&amp; line, const Color&amp; color);
+  static void draw_line_with_normal(const Line&amp; line, const Color&amp; color);
 
   static void draw_line(const Line&amp; line, const Color&amp; color);
   static void draw_line(const Vector2f&amp; pos1, const Vector2f&amp; pos2, const Color&amp; color);

Copied: trunk/windstille/src/navigation/edge.cpp (from rev 2683, trunk/windstille/src/navigation/segment.cpp)
===================================================================
--- trunk/windstille/src/navigation/segment.cpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/navigation/edge.cpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -0,0 +1,58 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2007 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**  
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**  
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &lt;assert.h&gt;
+#include &quot;node.hpp&quot;
+#include &quot;edge.hpp&quot;
+
+Edge::Edge(Node* node1_, Node* node2_, Properties props_)
+  : node1(node1_), 
+    node2(node2_),
+    properties(props_)
+{
+  node1-&gt;add_edge(EdgePosition(this, 0.0f));
+  node2-&gt;add_edge(EdgePosition(this, 1.0f));
+}
+
+Edge::~Edge()
+{
+  node1-&gt;remove_edge(this);
+  node2-&gt;remove_edge(this);
+}
+
+float
+Edge::angle(Edge* /*seg*/)
+{
+  assert(!&quot;Implement me&quot;);
+  return 0.0f;
+}
+
+Line
+Edge::get_line() const
+{
+  return Line(node1-&gt;get_pos(),
+              node2-&gt;get_pos());
+}
+
+Vector2f
+Edge::get_vector() const
+{
+  return node2-&gt;get_pos() - node1-&gt;get_pos();
+}
+
+/* EOF */


Property changes on: trunk/windstille/src/navigation/edge.cpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Copied: trunk/windstille/src/navigation/edge.hpp (from rev 2683, trunk/windstille/src/navigation/segment.hpp)
===================================================================
--- trunk/windstille/src/navigation/segment.hpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/navigation/edge.hpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -0,0 +1,59 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2005 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**  
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**  
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef HEADER_WINDSTILLE_NAVIGATION_SEGMENT_HPP
+#define HEADER_WINDSTILLE_NAVIGATION_SEGMENT_HPP
+
+#include &quot;math/line.hpp&quot;
+#include &quot;math/vector2f.hpp&quot;
+#include &quot;properties.hpp&quot;
+
+class Node;
+
+/** */
+class Edge
+{
+private:
+  Node* node1;
+  Node* node2;
+  
+  Properties properties;
+
+public:
+  Edge(Node* node1_, Node* node2_, Properties props_ = 0);
+  ~Edge();
+
+  /** Calculate the angle between two segments */
+  float angle(Edge* seg);
+  
+  Node* get_node1() const { return node1; } 
+  Node* get_node2() const { return node2; } 
+
+  Properties get_properties()  const { return properties; }
+
+  Line   get_line() const;
+  Vector2f get_vector() const;
+  
+private:
+  Edge (const Edge&amp;);
+  Edge&amp; operator= (const Edge&amp;);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/src/navigation/edge.hpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Copied: trunk/windstille/src/navigation/edge_position.cpp (from rev 2683, trunk/windstille/src/navigation/segment_position.cpp)
===================================================================
--- trunk/windstille/src/navigation/segment_position.cpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/navigation/edge_position.cpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -0,0 +1,118 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2007 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**  
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**  
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;edge.hpp&quot;
+#include &quot;node.hpp&quot;
+#include &quot;display/display.hpp&quot;
+#include &quot;edge_position.hpp&quot;
+
+EdgePosition::EdgePosition()
+  : edge(0),
+    pos(0.0f)
+{
+}
+
+EdgePosition::EdgePosition(Edge* edge_, float pos_)
+  : edge(edge_),
+    pos(pos_)
+{  
+}
+
+void
+EdgePosition::set_pos(Edge* edge_, float pos_)
+{
+  edge = edge_;
+  pos     = pos_;
+}
+
+void
+EdgePosition::advance(float&amp; adv, Node*&amp; next_node)
+{
+  Vector2f p1 = edge-&gt;get_node1()-&gt;get_pos();
+  Vector2f p2 = edge-&gt;get_node2()-&gt;get_pos();
+  
+  float length = (p2 - p1).length();
+  
+  // convert from world co to [0,1] range
+  float adv_01 = adv / length;
+
+  if (adv_01 &gt; 0)
+    {
+      pos += adv_01;
+      if (pos &gt; 1.0f) {
+        adv = (pos - 1.0f) * length;
+        pos = 1.0f;
+        next_node = edge-&gt;get_node2();
+      } else {
+        adv = 0;
+      }
+    }
+  else
+    {
+      pos += adv_01;
+      if (pos &lt; 0.0f) {
+        adv = pos * length;
+        pos = 0;
+        next_node = edge-&gt;get_node1();
+      } else {
+        adv = 0;
+      }
+    }
+}
+
+void
+EdgePosition::advance(Vector2f&amp; adv, Node*&amp; next_node)
+{
+  // FIXME: This might be optimizable
+  Vector2f p1 = edge-&gt;get_node1()-&gt;get_pos();
+  Vector2f p2 = edge-&gt;get_node2()-&gt;get_pos();
+  
+  Vector2f edge_v = p2 - p1;
+
+  Vector2f proj = adv.project(edge_v);
+
+  float angle = atan2(edge_v.y, edge_v.x) - atan2(proj.y, proj.x);
+
+  // Check if we are going forward or backward
+  float advf;
+  if (angle &gt; M_PI/2 || angle &lt; -M_PI/2)
+    advf = -proj.length();
+  else
+    advf = proj.length();
+
+  // Move forward
+  advance(advf, next_node);
+  
+  // Calculate the rest Vector2f
+  // Calculate the rest Vector2f
+  if (advf == 0.0f)
+    adv = Vector2f(0,0);
+  else
+    adv -= (proj * ((proj.length() - advf)/proj.length()));
+}
+
+Vector2f
+EdgePosition::get_pos() const
+{
+  Vector2f p1 = edge-&gt;get_node1()-&gt;get_pos();
+  Vector2f p2 = edge-&gt;get_node2()-&gt;get_pos();
+
+  return p1 + pos*(p2 - p1);
+}
+
+/* EOF */


Property changes on: trunk/windstille/src/navigation/edge_position.cpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Copied: trunk/windstille/src/navigation/edge_position.hpp (from rev 2683, trunk/windstille/src/navigation/segment_position.hpp)
===================================================================
--- trunk/windstille/src/navigation/segment_position.hpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/navigation/edge_position.hpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -0,0 +1,78 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2007 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**  
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**  
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef HEADER_WINDSTILLE_NAVIGATION_EDGE_POSITION_HPP
+#define HEADER_WINDSTILLE_NAVIGATION_EDGE_POSITION_HPP
+
+#include &quot;math/vector2f.hpp&quot;
+
+class Edge;
+class Node;
+
+/** 
+ */
+class EdgePosition
+{
+public:
+  Edge* edge;
+
+  /** Position on the edge, stored with range [0,1], not
+      world-co */
+  float pos;
+
+public:
+  EdgePosition();
+  EdgePosition(Edge* edge_, float pos_);
+
+  void set_pos(Edge* edge_, float pos_);
+
+  /** Move forward \a adv of units in world-co, when a node is hit,
+   *  the function returns and let the user decide how to continue
+   *
+   *  @param[in,out] adv the amount of advancment to be done, the
+   *                     amount of units that wheren't use on the
+   *                     given edge
+   *
+   *  @param[out] next_node if the advance ends at a node, it gets
+   *                        returned in next_node
+   */
+  void advance(float&amp; adv, Node*&amp; next_node);
+  
+  /** Move forward \a adv of units in world-co, when a node is hit,
+   *  the function returns and let the user decide how to
+   *  continue. \a adv is projected onto the current edge to figure
+   *  out how far we should go
+   *
+   * @param[in,out] adv the amount of advancment to be done, the
+   *                    amount of units that wheren't use on the given
+   *                    edge
+   *
+   * @param[out] next_node if the advance ends at a node, it gets
+   *                       returned in next_node
+   */  
+  void advance(Vector2f&amp; adv, Node*&amp; next_node);
+
+  Edge* get_edge() const { return edge; }
+  float    get_float_pos() const { return pos; }
+
+  Vector2f get_pos() const;
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/src/navigation/edge_position.hpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Modified: trunk/windstille/src/navigation/navigation_graph.cpp
===================================================================
--- trunk/windstille/src/navigation/navigation_graph.cpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/navigation/navigation_graph.cpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -22,9 +22,9 @@
 #include &lt;algorithm&gt;
 #include &quot;display/display.hpp&quot;
 #include &quot;node.hpp&quot;
-#include &quot;segment.hpp&quot;
+#include &quot;edge.hpp&quot;
 #include &quot;util/file_reader.hpp&quot;
-#include &quot;segment_position.hpp&quot;
+#include &quot;edge_position.hpp&quot;
 #include &quot;navigation_graph.hpp&quot;
 
 NavigationGraph::NavigationGraph()
@@ -34,9 +34,9 @@
 
 NavigationGraph::~NavigationGraph()
 {
-  for(Segments::iterator i = segments.begin(); i != segments.end(); ++i)
+  for(Edges::iterator i = edges.begin(); i != edges.end(); ++i)
     delete *i;
-  segments.clear();
+  edges.clear();
 
   for (Nodes::iterator i = nodes.begin(); i != nodes.end(); ++i)
     delete *i;
@@ -52,14 +52,14 @@
 }
 
 void
-NavigationGraph::remove_segment(SegmentHandle segment)
+NavigationGraph::remove_edge(EdgeHandle edge)
 {
   // FIXME: Slow
-  Segments::iterator i = std::find(segments.begin(), segments.end(), segment.get());
-  if (i != segments.end())
+  Edges::iterator i = std::find(edges.begin(), edges.end(), edge.get());
+  if (i != edges.end())
     {
-      segments.erase(i);
-      delete segment.get();
+      edges.erase(i);
+      delete edge.get();
     }
 
   // FIXME: Throw exception here
@@ -70,8 +70,8 @@
 {
   // FIXME: Slow
 
-  // Remove all segments that would get invalid by removing the node
-  for(Segments::iterator i = segments.begin(); i != segments.end(); ++i)
+  // Remove all edges that would get invalid by removing the node
+  for(Edges::iterator i = edges.begin(); i != edges.end(); ++i)
     {
       if ((*i)-&gt;get_node1() == node.get() ||
           (*i)-&gt;get_node2() == node.get())
@@ -81,10 +81,10 @@
         }
     }
 
-  Segments::iterator new_end = std::remove(segments.begin(), segments.end(), (Segment*)0);
-  if (new_end != segments.end())
+  Edges::iterator new_end = std::remove(edges.begin(), edges.end(), (Edge*)0);
+  if (new_end != edges.end())
     { 
-      segments.erase(new_end, segments.end());
+      edges.erase(new_end, edges.end());
     }
   
   // Remove the node itself 
@@ -96,41 +96,41 @@
     }  
 }
 
-SegmentHandle
-NavigationGraph::add_segment(NodeHandle node1, NodeHandle node2)
+EdgeHandle
+NavigationGraph::add_edge(NodeHandle node1, NodeHandle node2)
 {
   if (node1.get() != node2.get()) // node links to themself are forbidden
-    { // FIXME: Find a way to figure out if the given segment already exists
-      Segment* segment = new Segment(node1.get(), node2.get());
-      segments.push_back(segment);
-      return SegmentHandle(segment);
+    { // FIXME: Find a way to figure out if the given edge already exists
+      Edge* edge = new Edge(node1.get(), node2.get());
+      edges.push_back(edge);
+      return EdgeHandle(edge);
     }
   else
     {
-      return SegmentHandle();
+      return EdgeHandle();
     }
 }
 
 void
-NavigationGraph::split_segment(SegmentHandle segment)
+NavigationGraph::split_edge(EdgeHandle edge)
 {
-  NodeHandle node1 = NodeHandle(segment-&gt;get_node1());
-  NodeHandle node3 = NodeHandle(segment-&gt;get_node2());
+  NodeHandle node1 = NodeHandle(edge-&gt;get_node1());
+  NodeHandle node3 = NodeHandle(edge-&gt;get_node2());
   NodeHandle node2 = add_node(0.5f * (node1-&gt;get_pos() + node3-&gt;get_pos()));
 
-  remove_segment(segment);
-  add_segment(node1, node2);  
-  add_segment(node2, node3);  
+  remove_edge(edge);
+  add_edge(node1, node2);  
+  add_edge(node2, node3);  
 }
 
-std::vector&lt;SegmentPosition&gt;
+std::vector&lt;EdgePosition&gt;
 NavigationGraph::find_intersections(const Line&amp; line)
 {
   // FIXME: we might want to only return the first intersection, not
   // all of them or alternativly return ua
-  std::vector&lt;SegmentPosition&gt; ret;
+  std::vector&lt;EdgePosition&gt; ret;
  
-  for(Segments::iterator i = segments.begin(); i != segments.end(); ++i)
+  for(Edges::iterator i = edges.begin(); i != edges.end(); ++i)
     {
       Line seg_line((*i)-&gt;get_node1()-&gt;get_pos(),
                     (*i)-&gt;get_node2()-&gt;get_pos());
@@ -138,7 +138,7 @@
       float ua, ub;
       if (line.intersect(seg_line, ua, ub))
         {
-          ret.push_back(SegmentPosition(*i, ub));
+          ret.push_back(EdgePosition(*i, ub));
         }
     }
 
@@ -163,18 +163,18 @@
   return ret;
 }
 
-std::vector&lt;SegmentHandle&gt;
-NavigationGraph::find_segments(const Vector2f&amp; pos, float radius)
+std::vector&lt;EdgeHandle&gt;
+NavigationGraph::find_edges(const Vector2f&amp; pos, float radius)
 {
-  std::vector&lt;SegmentHandle&gt; ret;
+  std::vector&lt;EdgeHandle&gt; ret;
  
-  for(Segments::iterator i = segments.begin(); i != segments.end(); ++i)
+  for(Edges::iterator i = edges.begin(); i != edges.end(); ++i)
     {
       float distance = Line((*i)-&gt;get_node1()-&gt;get_pos(),
                             (*i)-&gt;get_node2()-&gt;get_pos()).distance(pos);
       if (distance &lt; radius)
         {
-          ret.push_back(SegmentHandle(*i));
+          ret.push_back(EdgeHandle(*i));
         }
     }
 
@@ -201,34 +201,34 @@
   return NodeHandle(node);
 }
 
-SegmentHandle
-NavigationGraph::find_closest_segment(const Vector2f&amp; pos, float radius)
+EdgeHandle
+NavigationGraph::find_closest_edge(const Vector2f&amp; pos, float radius)
 {
-  Segment* segment   = 0;
+  Edge* edge   = 0;
   float min_distance = radius;
 
-  for(Segments::iterator i = segments.begin(); i != segments.end(); ++i)
+  for(Edges::iterator i = edges.begin(); i != edges.end(); ++i)
     {
       float current_distance = Line((*i)-&gt;get_node1()-&gt;get_pos(),
                                     (*i)-&gt;get_node2()-&gt;get_pos()).distance(pos);
       if (current_distance &lt; min_distance)
         {
           min_distance = current_distance;
-          segment = *i;
+          edge = *i;
         }
     }
 
-  return SegmentHandle(segment);
+  return EdgeHandle(edge);
 }
 
 void
 NavigationGraph::draw()
 {
-  for(Segments::iterator i = segments.begin(); i != segments.end(); ++i)
+  for(Edges::iterator i = edges.begin(); i != edges.end(); ++i)
     {
-      Display::draw_segment(Line((*i)-&gt;get_node1()-&gt;get_pos(),
-                                 (*i)-&gt;get_node2()-&gt;get_pos()),
-                            Color(1.0f, 0.0f, 0.0f));
+      Display::draw_line_with_normal(Line((*i)-&gt;get_node1()-&gt;get_pos(),
+                                          (*i)-&gt;get_node2()-&gt;get_pos()),
+                                     Color(1.0f, 0.0f, 0.0f));
     }
 
   for(Nodes::iterator i = nodes.begin(); i != nodes.end(); ++i)
@@ -271,13 +271,13 @@
         }
     }
   
-  FileReader segments_group_reader;
-  if (reader.get(&quot;segments&quot;, segments_group_reader))
+  FileReader edges_group_reader;
+  if (reader.get(&quot;edges&quot;, edges_group_reader))
     {
-      std::vector&lt;FileReader&gt; segments_reader = segments_group_reader.get_sections();
-      for(std::vector&lt;FileReader&gt;::iterator i = segments_reader.begin(); i != segments_reader.end(); ++i)
+      std::vector&lt;FileReader&gt; edges_reader = edges_group_reader.get_sections();
+      for(std::vector&lt;FileReader&gt;::iterator i = edges_reader.begin(); i != edges_reader.end(); ++i)
         {
-          if (i-&gt;get_name() == &quot;segment&quot;)
+          if (i-&gt;get_name() == &quot;edge&quot;)
             {
               int node_left;
               int node_right;
@@ -292,23 +292,23 @@
 
                   if (node_left_ptr != id2ptr.end() &amp;&amp; node_right_ptr != id2ptr.end())
                     {
-                      Segment* segment = new Segment(node_left_ptr-&gt;second, node_right_ptr-&gt;second, properties);
-                      segments.push_back(segment);
+                      Edge* edge = new Edge(node_left_ptr-&gt;second, node_right_ptr-&gt;second, properties);
+                      edges.push_back(edge);
                     }
                   else
                     {
-                      std::cout &lt;&lt; &quot;NavigationGraph: segment: Couldn't lookup ids: &quot;
+                      std::cout &lt;&lt; &quot;NavigationGraph: edge: Couldn't lookup ids: &quot;
                                 &lt;&lt; node_left &lt;&lt; &quot; &quot; &lt;&lt; node_right &lt;&lt; std::endl;
                     }
                 }
               else
                 {
-                  std::cout &lt;&lt; &quot;NavigationGraph:load: segments: segment: parse error&quot; &lt;&lt; std::endl;
+                  std::cout &lt;&lt; &quot;NavigationGraph:load: edges: edge: parse error&quot; &lt;&lt; std::endl;
                 }
             }
           else
             {
-              std::cout &lt;&lt; &quot;NavigationGraph:load: segments: Unknown tag: &quot; &lt;&lt; i-&gt;get_name() &lt;&lt; std::endl;
+              std::cout &lt;&lt; &quot;NavigationGraph:load: edges: Unknown tag: &quot; &lt;&lt; i-&gt;get_name() &lt;&lt; std::endl;
             }
         }      
     }
@@ -332,9 +332,9 @@
         &lt;&lt; std::setw(3) &lt;&lt; (*i)-&gt;get_pos().x &lt;&lt; &quot; &quot; &lt;&lt; (*i)-&gt;get_pos().y &lt;&lt; &quot;))\n&quot;;
   out &lt;&lt; &quot; )\n&quot;;
 
-  out &lt;&lt; &quot;  (segments\n&quot;;
-  for(Segments::iterator i = segments.begin(); i != segments.end(); ++i)  
-    out &lt;&lt; &quot;    (segment &quot;
+  out &lt;&lt; &quot;  (edges\n&quot;;
+  for(Edges::iterator i = edges.begin(); i != edges.end(); ++i)  
+    out &lt;&lt; &quot;    (edge &quot;
         &lt;&lt; &quot;(node1 &quot; &lt;&lt; std::setw(3) &lt;&lt; ptr2id[(*i)-&gt;get_node1()] &lt;&lt; &quot;) &quot;
         &lt;&lt; &quot;(node2 &quot; &lt;&lt; std::setw(3) &lt;&lt; ptr2id[(*i)-&gt;get_node2()] &lt;&lt; &quot;) &quot;
         &lt;&lt; &quot;(properties &quot; &lt;&lt; (*i)-&gt;get_properties() &lt;&lt; &quot;))\n&quot;;
@@ -346,10 +346,10 @@
 }
 
 bool
-NavigationGraph::valid(Segment* segment)
+NavigationGraph::valid(Edge* edge)
 {
   // FIXME: Slow
-  return std::find(segments.begin(), segments.end(), segment) != segments.end();
+  return std::find(edges.begin(), edges.end(), edge) != edges.end();
 }
 
 bool

Modified: trunk/windstille/src/navigation/navigation_graph.hpp
===================================================================
--- trunk/windstille/src/navigation/navigation_graph.hpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/navigation/navigation_graph.hpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -25,8 +25,8 @@
 
 class Node;
 class FileReader;
-class Segment;
-class SegmentPosition;
+class Edge;
+class EdgePosition;
 
 template&lt;typename Data&gt;
 class PointerHandle
@@ -60,18 +60,18 @@
   }
 };
 
-typedef PointerHandle&lt;Node&gt;    NodeHandle; 
-typedef PointerHandle&lt;Segment&gt; SegmentHandle; 
+typedef PointerHandle&lt;Node&gt; NodeHandle; 
+typedef PointerHandle&lt;Edge&gt; EdgeHandle; 
 
 /** */
 class NavigationGraph
 {
 private:
-  typedef std::vector&lt;Node*&gt;    Nodes;
-  typedef std::vector&lt;Segment*&gt; Segments;
+  typedef std::vector&lt;Node*&gt; Nodes;
+  typedef std::vector&lt;Edge*&gt; Edges;
 
-  Nodes    nodes;
-  Segments segments;
+  Nodes nodes;
+  Edges edges;
   
   // insert some spartial thingy here
 
@@ -81,16 +81,16 @@
 
   // FIXME: It might be worth it to return handles that can be
   // validated instead of pure pointers
-  NodeHandle    add_node(const Vector2f&amp; pos);
-  SegmentHandle add_segment(NodeHandle node1, NodeHandle node2);
+  NodeHandle add_node(const Vector2f&amp; pos);
+  EdgeHandle add_edge(NodeHandle node1, NodeHandle node2);
 
   void remove_node(NodeHandle node);
-  void remove_segment(SegmentHandle segment);
+  void remove_edge(EdgeHandle edge);
 
-  void split_segment(SegmentHandle segment);
+  void split_edge(EdgeHandle edge);
 
-  /** Find segments that intersect with the given line */
-  std::vector&lt;SegmentPosition&gt; find_intersections(const Line&amp; line);
+  /** Find edges that intersect with the given line */
+  std::vector&lt;EdgePosition&gt; find_intersections(const Line&amp; line);
 
   /** Find nodes that are near within the \a radius */
   std::vector&lt;NodeHandle&gt; find_nodes(const Vector2f&amp; pos, float radius);
@@ -98,10 +98,10 @@
   /** Find the closest node, limit search to nodes in radius */
   NodeHandle find_closest_node(const Vector2f&amp; pos, float radius);
 
-  SegmentHandle find_closest_segment(const Vector2f&amp; pos, float radius);
+  EdgeHandle find_closest_edge(const Vector2f&amp; pos, float radius);
 
-  /** Find segments that are near the given point */
-  std::vector&lt;SegmentHandle&gt; find_segments(const Vector2f&amp; pos, float radius);
+  /** Find edges that are near the given point */
+  std::vector&lt;EdgeHandle&gt; find_edges(const Vector2f&amp; pos, float radius);
 
   /** Draw the navigation graph, for debugging only */
   void draw();
@@ -109,8 +109,8 @@
   void load(FileReader&amp; reader);
   void save(std::ostream&amp; out);
 
-  bool valid(Segment* segment);
-  bool valid(Node*    node);
+  bool valid(Edge* edge);
+  bool valid(Node* node);
 
 private:
   NavigationGraph (const NavigationGraph&amp;);

Modified: trunk/windstille/src/navigation/node.cpp
===================================================================
--- trunk/windstille/src/navigation/node.cpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/navigation/node.cpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -30,19 +30,19 @@
 }
 
 void
-Node::add_segment(const SegmentPosition&amp; position)
+Node::add_edge(const EdgePosition&amp; position)
 {
-  segments.push_back(position);
+  edges.push_back(position);
 }
 
 void
-Node::remove_segment(Segment* segment)
+Node::remove_edge(Edge* edge)
 {
-  for(Segments::iterator i = segments.begin(); i != segments.end(); ++i)
+  for(Edges::iterator i = edges.begin(); i != edges.end(); ++i)
     {
-      if (i-&gt;segment == segment)
+      if (i-&gt;edge == edge)
         {
-          segments.erase(i);
+          edges.erase(i);
           return;
         }
     }

Modified: trunk/windstille/src/navigation/node.hpp
===================================================================
--- trunk/windstille/src/navigation/node.hpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/navigation/node.hpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -22,7 +22,7 @@
 #include &lt;vector&gt;
 #include &quot;math/vector2f.hpp&quot;
 
-#include &quot;segment_position.hpp&quot;
+#include &quot;edge_position.hpp&quot;
 
 /** */
 class Node
@@ -31,9 +31,9 @@
   Vector2f pos;
   
 public:
-  /** Segments connected to this node */
-  typedef std::vector&lt;SegmentPosition&gt; Segments;
-  Segments segments;
+  /** Edges connected to this node */
+  typedef std::vector&lt;EdgePosition&gt; Edges;
+  Edges edges;
 
 public:
   Node(const Vector2f&amp; pos_);
@@ -42,11 +42,11 @@
   Vector2f get_pos() const { return pos; }
   void     set_pos(const Vector2f&amp; p) { pos = p; }
 
-  /** Connect the given segment to the node, the position is used to
-      mark the end of the segment that is actually connected */
-  void add_segment(const SegmentPosition&amp; segment);
+  /** Connect the given edge to the node, the position is used to
+      mark the end of the edge that is actually connected */
+  void add_edge(const EdgePosition&amp; edge);
 
-  void remove_segment(Segment* segment);
+  void remove_edge(Edge* edge);
 
 private:
   Node(const Node&amp;);

Deleted: trunk/windstille/src/navigation/segment.cpp
===================================================================
--- trunk/windstille/src/navigation/segment.cpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/navigation/segment.cpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -1,58 +0,0 @@
-/*
-**  Windstille - A Sci-Fi Action-Adventure Game
-**  Copyright (C) 2007 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
-**
-**  This program is free software: you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation, either version 3 of the License, or
-**  (at your option) any later version.
-**  
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**  
-**  You should have received a copy of the GNU General Public License
-**  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#include &lt;assert.h&gt;
-#include &quot;node.hpp&quot;
-#include &quot;segment.hpp&quot;
-
-Segment::Segment(Node* node1_, Node* node2_, Properties props_)
-  : node1(node1_), 
-    node2(node2_),
-    properties(props_)
-{
-  node1-&gt;add_segment(SegmentPosition(this, 0.0f));
-  node2-&gt;add_segment(SegmentPosition(this, 1.0f));
-}
-
-Segment::~Segment()
-{
-  node1-&gt;remove_segment(this);
-  node2-&gt;remove_segment(this);
-}
-
-float
-Segment::angle(Segment* /*seg*/)
-{
-  assert(!&quot;Implement me&quot;);
-  return 0.0f;
-}
-
-Line
-Segment::get_line() const
-{
-  return Line(node1-&gt;get_pos(),
-              node2-&gt;get_pos());
-}
-
-Vector2f
-Segment::get_vector() const
-{
-  return node2-&gt;get_pos() - node1-&gt;get_pos();
-}
-
-/* EOF */

Deleted: trunk/windstille/src/navigation/segment.hpp
===================================================================
--- trunk/windstille/src/navigation/segment.hpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/navigation/segment.hpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -1,59 +0,0 @@
-/*
-**  Windstille - A Sci-Fi Action-Adventure Game
-**  Copyright (C) 2005 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
-**
-**  This program is free software: you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation, either version 3 of the License, or
-**  (at your option) any later version.
-**  
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**  
-**  You should have received a copy of the GNU General Public License
-**  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#ifndef HEADER_WINDSTILLE_NAVIGATION_SEGMENT_HPP
-#define HEADER_WINDSTILLE_NAVIGATION_SEGMENT_HPP
-
-#include &quot;math/line.hpp&quot;
-#include &quot;math/vector2f.hpp&quot;
-#include &quot;properties.hpp&quot;
-
-class Node;
-
-/** */
-class Segment
-{
-private:
-  Node* node1;
-  Node* node2;
-  
-  Properties properties;
-
-public:
-  Segment(Node* node1_, Node* node2_, Properties props_ = 0);
-  ~Segment();
-
-  /** Calculate the angle between two segments */
-  float angle(Segment* seg);
-  
-  Node* get_node1() const { return node1; } 
-  Node* get_node2() const { return node2; } 
-
-  Properties get_properties()  const { return properties; }
-
-  Line   get_line() const;
-  Vector2f get_vector() const;
-  
-private:
-  Segment (const Segment&amp;);
-  Segment&amp; operator= (const Segment&amp;);
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/windstille/src/navigation/segment_position.cpp
===================================================================
--- trunk/windstille/src/navigation/segment_position.cpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/navigation/segment_position.cpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -1,118 +0,0 @@
-/*
-**  Windstille - A Sci-Fi Action-Adventure Game
-**  Copyright (C) 2007 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
-**
-**  This program is free software: you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation, either version 3 of the License, or
-**  (at your option) any later version.
-**  
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**  
-**  You should have received a copy of the GNU General Public License
-**  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#include &quot;segment.hpp&quot;
-#include &quot;node.hpp&quot;
-#include &quot;display/display.hpp&quot;
-#include &quot;segment_position.hpp&quot;
-
-SegmentPosition::SegmentPosition()
-  : segment(0),
-    pos(0.0f)
-{
-}
-
-SegmentPosition::SegmentPosition(Segment* segment_, float pos_)
-  : segment(segment_),
-    pos(pos_)
-{  
-}
-
-void
-SegmentPosition::set_pos(Segment* segment_, float pos_)
-{
-  segment = segment_;
-  pos     = pos_;
-}
-
-void
-SegmentPosition::advance(float&amp; adv, Node*&amp; next_node)
-{
-  Vector2f p1 = segment-&gt;get_node1()-&gt;get_pos();
-  Vector2f p2 = segment-&gt;get_node2()-&gt;get_pos();
-  
-  float length = (p2 - p1).length();
-  
-  // convert from world co to [0,1] range
-  float adv_01 = adv / length;
-
-  if (adv_01 &gt; 0)
-    {
-      pos += adv_01;
-      if (pos &gt; 1.0f) {
-        adv = (pos - 1.0f) * length;
-        pos = 1.0f;
-        next_node = segment-&gt;get_node2();
-      } else {
-        adv = 0;
-      }
-    }
-  else
-    {
-      pos += adv_01;
-      if (pos &lt; 0.0f) {
-        adv = pos * length;
-        pos = 0;
-        next_node = segment-&gt;get_node1();
-      } else {
-        adv = 0;
-      }
-    }
-}
-
-void
-SegmentPosition::advance(Vector2f&amp; adv, Node*&amp; next_node)
-{
-  // FIXME: This might be optimizable
-  Vector2f p1 = segment-&gt;get_node1()-&gt;get_pos();
-  Vector2f p2 = segment-&gt;get_node2()-&gt;get_pos();
-  
-  Vector2f segment_v = p2 - p1;
-
-  Vector2f proj = adv.project(segment_v);
-
-  float angle = atan2(segment_v.y, segment_v.x) - atan2(proj.y, proj.x);
-
-  // Check if we are going forward or backward
-  float advf;
-  if (angle &gt; M_PI/2 || angle &lt; -M_PI/2)
-    advf = -proj.length();
-  else
-    advf = proj.length();
-
-  // Move forward
-  advance(advf, next_node);
-  
-  // Calculate the rest Vector2f
-  // Calculate the rest Vector2f
-  if (advf == 0.0f)
-    adv = Vector2f(0,0);
-  else
-    adv -= (proj * ((proj.length() - advf)/proj.length()));
-}
-
-Vector2f
-SegmentPosition::get_pos() const
-{
-  Vector2f p1 = segment-&gt;get_node1()-&gt;get_pos();
-  Vector2f p2 = segment-&gt;get_node2()-&gt;get_pos();
-
-  return p1 + pos*(p2 - p1);
-}
-
-/* EOF */

Deleted: trunk/windstille/src/navigation/segment_position.hpp
===================================================================
--- trunk/windstille/src/navigation/segment_position.hpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/navigation/segment_position.hpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -1,78 +0,0 @@
-/*
-**  Windstille - A Sci-Fi Action-Adventure Game
-**  Copyright (C) 2007 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
-**
-**  This program is free software: you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation, either version 3 of the License, or
-**  (at your option) any later version.
-**  
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**  
-**  You should have received a copy of the GNU General Public License
-**  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#ifndef HEADER_WINDSTILLE_NAVIGATION_SEGMENT_POSITION_HPP
-#define HEADER_WINDSTILLE_NAVIGATION_SEGMENT_POSITION_HPP
-
-#include &quot;math/vector2f.hpp&quot;
-
-class Segment;
-class Node;
-
-/** 
- */
-class SegmentPosition
-{
-public:
-  Segment* segment;
-
-  /** Position on the segment, stored with range [0,1], not
-      world-co */
-  float pos;
-
-public:
-  SegmentPosition();
-  SegmentPosition(Segment* segment_, float pos_);
-
-  void set_pos(Segment* segment_, float pos_);
-
-  /** Move forward \a adv of units in world-co, when a node is hit,
-   *  the function returns and let the user decide how to continue
-   *
-   *  @param[in,out] adv the amount of advancment to be done, the
-   *                     amount of units that wheren't use on the
-   *                     given segment
-   *
-   *  @param[out] next_node if the advance ends at a node, it gets
-   *                        returned in next_node
-   */
-  void advance(float&amp; adv, Node*&amp; next_node);
-  
-  /** Move forward \a adv of units in world-co, when a node is hit,
-   *  the function returns and let the user decide how to
-   *  continue. \a adv is projected onto the current segment to figure
-   *  out how far we should go
-   *
-   * @param[in,out] adv the amount of advancment to be done, the
-   *                    amount of units that wheren't use on the given
-   *                    segment
-   *
-   * @param[out] next_node if the advance ends at a node, it gets
-   *                       returned in next_node
-   */  
-  void advance(Vector2f&amp; adv, Node*&amp; next_node);
-
-  Segment* get_segment() const { return segment; }
-  float    get_float_pos() const { return pos; }
-
-  Vector2f get_pos() const;
-};
-
-#endif
-
-/* EOF */

Modified: trunk/windstille/src/screen/navigation_test.cpp
===================================================================
--- trunk/windstille/src/screen/navigation_test.cpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/screen/navigation_test.cpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -27,8 +27,8 @@
 #include &quot;app/menu_manager.hpp&quot;
 #include &quot;navigation/navigation_graph.hpp&quot;
 #include &quot;navigation/node.hpp&quot;
-#include &quot;navigation/segment_position.hpp&quot;
-#include &quot;navigation/segment.hpp&quot;
+#include &quot;navigation/edge_position.hpp&quot;
+#include &quot;navigation/edge.hpp&quot;
 #include &quot;navigation_test.hpp&quot;
 
 NavigationTest::NavigationTest()
@@ -36,7 +36,7 @@
     player(200,200),
     graph(new NavigationGraph()),
     connection(0),
-    selected_segment(0),
+    selected_edge(0),
     selected_node(0),
     node_to_connect(0)
 {
@@ -52,9 +52,9 @@
   //Node* node3 = graph-&gt;add_node(Vector2f(500, 300));
   //Node* node4 = graph-&gt;add_node(Vector2f(700, 400));
 
-  graph-&gt;add_segment(node1, node2);
-  //graph-&gt;add_segment(node2, node3);
-  //graph-&gt;add_segment(node3, node4);
+  graph-&gt;add_edge(node1, node2);
+  //graph-&gt;add_edge(node2, node3);
+  //graph-&gt;add_edge(node3, node4);
   
 }
 
@@ -84,8 +84,8 @@
   if (selected_node)
     Display::draw_circle(selected_node-&gt;get_pos(), 12.0f, Color(1.0f, 1.0f, 1.0f, 1.0f));
 
-  if (selected_segment)
-    Display::draw_line(selected_segment-&gt;get_line(), Color(1.0f, 1.0f, 1.0f, 1.0f));
+  if (selected_edge)
+    Display::draw_line(selected_edge-&gt;get_line(), Color(1.0f, 1.0f, 1.0f, 1.0f));
 
   Display::fill_circle(player, 12.0f, Color(0.0f, 0.0f, 1.0f, 1.0f));
 
@@ -119,7 +119,7 @@
       if (node_to_connect)
         {
           if (selected_node)
-            graph-&gt;add_segment(node_to_connect, selected_node);
+            graph-&gt;add_edge(node_to_connect, selected_node);
           
           node_to_connect = 0;
         }
@@ -127,10 +127,10 @@
         {
           node_to_connect = selected_node;
         }
-      else if (selected_segment)
+      else if (selected_edge)
         {
-          graph-&gt;split_segment(selected_segment);
-          selected_segment = 0;
+          graph-&gt;split_edge(selected_edge);
+          selected_edge = 0;
         }
       else
         {
@@ -164,28 +164,28 @@
       
       if (!advance.is_null())
         { // Not all advancement got used up, which means we have hit
-          // the end of a segment
+          // the end of a edge
 
           // FIXME: This should be a while loop, currently we are just
           // discarding the rest movement
 
-          SegmentPosition next_segment;
+          EdgePosition next_edge;
           float length = 0;
-          for(Node::Segments::iterator i = next_node-&gt;segments.begin(); i != next_node-&gt;segments.end(); ++i)
+          for(Node::Edges::iterator i = next_node-&gt;edges.begin(); i != next_node-&gt;edges.end(); ++i)
             {
-              if (connection-&gt;get_segment() != i-&gt;segment)
-                { // Find out into the direction of which segment the stick is pointing
-                  Vector2f proj = stick.project(i-&gt;segment-&gt;get_vector());
+              if (connection-&gt;get_edge() != i-&gt;edge)
+                { // Find out into the direction of which edge the stick is pointing
+                  Vector2f proj = stick.project(i-&gt;edge-&gt;get_vector());
                   
                   if (proj.length() &gt; length)
                     {
-                      next_segment = *i;
+                      next_edge = *i;
                       length       = proj.length();
                     }
                 }
             }
               
-          if (!next_segment.segment)
+          if (!next_edge.edge)
             {
               std::cout &lt;&lt; &quot;Dead End&quot; &lt;&lt; std::endl;
               connection.reset();
@@ -197,7 +197,7 @@
           else
             {
               std::cout &lt;&lt; &quot;transition&quot; &lt;&lt; std::endl;
-              *connection = next_segment;
+              *connection = next_edge;
             }
         }
 
@@ -221,11 +221,11 @@
           player.y -= 0.5f * 512.0f * delta;
         }
 
-      std::vector&lt;SegmentPosition&gt; positions = graph-&gt;find_intersections(Line(old_player, player));
+      std::vector&lt;EdgePosition&gt; positions = graph-&gt;find_intersections(Line(old_player, player));
       if (!positions.empty()) 
         {
           std::cout &lt;&lt; &quot;Doing connection&quot; &lt;&lt; std::endl;
-          connection.reset(new SegmentPosition(positions.front()));
+          connection.reset(new EdgePosition(positions.front()));
         }
     }
   
@@ -241,19 +241,19 @@
         selected_node = 0;
       } 
       
-      if (selected_segment) {
-        graph-&gt;remove_segment(selected_segment);
-        selected_segment = 0;
+      if (selected_edge) {
+        graph-&gt;remove_edge(selected_edge);
+        selected_edge = 0;
       }      
     }
 
   selected_node = graph-&gt;find_closest_node(cursor, 32.0f);
   if (!selected_node)
-    selected_segment = graph-&gt;find_closest_segment(cursor, 32.0f);
+    selected_edge = graph-&gt;find_closest_edge(cursor, 32.0f);
   else
-    selected_segment = 0;
+    selected_edge = 0;
 
-  if (connection.get() &amp;&amp; !graph-&gt;valid(connection-&gt;get_segment()))
+  if (connection.get() &amp;&amp; !graph-&gt;valid(connection-&gt;get_edge()))
     {
       connection.reset();
     }

Modified: trunk/windstille/src/screen/navigation_test.hpp
===================================================================
--- trunk/windstille/src/screen/navigation_test.hpp	2009-03-16 21:47:22 UTC (rev 2683)
+++ trunk/windstille/src/screen/navigation_test.hpp	2009-03-16 22:25:06 UTC (rev 2684)
@@ -23,8 +23,8 @@
 #include &quot;screen.hpp&quot;
 
 class NavigationGraph;
-class SegmentPosition;
-class Segment;
+class EdgePosition;
+class Edge;
 class Node;
 
 /** */
@@ -37,10 +37,10 @@
   Vector2f old_player;
   
   std::auto_ptr&lt;NavigationGraph&gt; graph;
-  std::auto_ptr&lt;SegmentPosition&gt; connection;
+  std::auto_ptr&lt;EdgePosition&gt; connection;
 
-  SegmentHandle selected_segment;
-  NodeHandle    selected_node;
+  EdgeHandle selected_edge;
+  NodeHandle selected_node;
 
   NodeHandle node_to_connect;
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001680.html">[Windstille-commit] r2683 - trunk/windstille/src/screen
</A></li>
	<LI>Next message: <A HREF="001682.html">[Windstille-commit] r2685 - trunk/windstille
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1681">[ date ]</a>
              <a href="thread.html#1681">[ thread ]</a>
              <a href="subject.html#1681">[ subject ]</a>
              <a href="author.html#1681">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/windstille-commit">More information about the Windstille-commit
mailing list</a><br>
</body></html>
