<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Windstille-commit] r446 - in trunk: . mk/jam src src/lisp src/sound src/tinygettext
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/windstille-commit/2005-June/index.html" >
   <LINK REL="made" HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r446%20-%20in%20trunk%3A%20.%20mk/jam%20src%20src/lisp%20src/sound%20src/tinygettext&In-Reply-To=%3C200506271335.j5RDZS2Q008152%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000102.html">
   <LINK REL="Next"  HREF="000104.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Windstille-commit] r446 - in trunk: . mk/jam src src/lisp src/sound src/tinygettext</H1>
    <B>Matthias Braun at BerliOS</B> 
    <A HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r446%20-%20in%20trunk%3A%20.%20mk/jam%20src%20src/lisp%20src/sound%20src/tinygettext&In-Reply-To=%3C200506271335.j5RDZS2Q008152%40sheep.berlios.de%3E"
       TITLE="[Windstille-commit] r446 - in trunk: . mk/jam src src/lisp src/sound src/tinygettext">matzebraun at sheep.berlios.de
       </A><BR>
    <I>Mon Jun 27 15:35:28 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000102.html">[Windstille-commit] r445 - in trunk: . src src/sound
</A></li>
        <LI>Next message: <A HREF="000104.html">[Windstille-commit] r447 - in trunk/src: . scripting
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#103">[ date ]</a>
              <a href="thread.html#103">[ thread ]</a>
              <a href="subject.html#103">[ subject ]</a>
              <a href="author.html#103">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: matzebraun
Date: 2005-06-27 15:35:27 +0200 (Mon, 27 Jun 2005)
New Revision: 446

Added:
   trunk/src/lisp/
   trunk/src/lisp/lexer.cpp
   trunk/src/lisp/lexer.hpp
   trunk/src/lisp/lisp.cpp
   trunk/src/lisp/lisp.hpp
   trunk/src/lisp/list_iterator.cpp
   trunk/src/lisp/list_iterator.hpp
   trunk/src/lisp/parser.cpp
   trunk/src/lisp/parser.hpp
   trunk/src/lisp/writer.cpp
   trunk/src/lisp/writer.hpp
   trunk/src/lisp_util.hpp
   trunk/src/tinygettext/
   trunk/src/tinygettext/tinygettext.cpp
   trunk/src/tinygettext/tinygettext.hpp
Modified:
   trunk/Jamfile
   trunk/mk/jam/autoconf.jam
   trunk/mk/jam/bisonflex.jam
   trunk/mk/jam/compiler.jam
   trunk/src/Jamfile
   trunk/src/sound/sound_manager.cpp
Log:
forgot to add some files

Modified: trunk/Jamfile
===================================================================
--- trunk/Jamfile	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/Jamfile	2005-06-27 13:35:27 UTC (rev 446)
@@ -1,6 +1,7 @@
 SubDir TOP ;
 
 # Decend into subdirs
+SubInclude TOP tools miniswig ;
 SubInclude TOP src ;
 SubInclude TOP data ;
 

Modified: trunk/mk/jam/autoconf.jam
===================================================================
--- trunk/mk/jam/autoconf.jam	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/mk/jam/autoconf.jam	2005-06-27 13:35:27 UTC (rev 446)
@@ -10,35 +10,16 @@
     CleanDir distclean : autom4te.cache out ;
     Depends distclean : clean ;
                                                                                 
-    Clean maintainer-clean : configure aclocal.m4 config.h.in Jamconfig.in ;
-    Depends maintainer-clean : distclean ;
+    Clean cvsclean : configure aclocal.m4 config.h.in Jamconfig.in ;
+    Depends cvsclean : distclean ;
                                                                                 
     Help clean : &quot;Cleanup objectfiles and targets&quot; ;
     Help distclean : &quot;Cleanup objectfiles and build configuration&quot; ;
-    Help maintainer-clean :
+    Help cvsclean :
         &quot;Cleanup all objectfiles, buildconfig and generated files.&quot; ;
     Package autogen.sh configure.ac configure config.h.in
             Jamrules Jamconfig.in ;
     Package [ Wildcard mk/jam : *.jam ] [ Wildcard mk/autoconf : *.m4 ]
-            [ Wildcard mk/autoconf : config.* ]
+            mk/autoconf/config.guess mk/autoconf/config.sub
             mk/autoconf/install-sh ;
-
-    actions CheckNewer {
-        echo Error: $(&gt;) is newer than $(&lt;).
-        echo &quot;&quot;
-        echo You should rerun ./autogen.sh and ./configure
-        exit 1
-    }
-
-    rule CheckNewer {
-        Depends $(&lt;) : $(&gt;) ;
-        Depends all : $(&lt;) ;
-    }
-
-    # Disabled for now because it often gives false alarm...
-    #configurefiles 
-    #        = configure.ac [ Wildcard mk/autoconf : *.m4 ] ;
-    #    SEARCH on $(configurefiles) = $(top_srcdir) ;
-    #    CheckNewer configure : $(configurefiles) ;
-    #    CheckNewer Jamconfig : $(configurefiles) ;
 }

Modified: trunk/mk/jam/bisonflex.jam
===================================================================
--- trunk/mk/jam/bisonflex.jam	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/mk/jam/bisonflex.jam	2005-06-27 13:35:27 UTC (rev 446)
@@ -6,7 +6,7 @@
 {
   rule LexRule
   {
-    local cfile = [ LocateTarget $(&lt;:S=.c) ] ;
+    local cfile = [ LocateTarget $(&lt;:S=.c) : $(SUBDIR) ] ;
     local object = [ CompileObjects $(cfile) ] ;
 
     Lex $(cfile) : $(&lt;) ;
@@ -17,14 +17,14 @@
   
   rule Lex++Rule
   {
-    local cppfile = [ LocateTarget $(&lt;:S=.cpp) ] ;
+    local cppfile = [ LocateTarget $(&lt;:S=.cpp) : $(SUBDIR) ] ;
     local object = [ CompileObjects $(cppfile) ] ;
 
     Lex $(cppfile) : $(&lt;) ;
 
     return $(object) ;
   }
-  RegisterFileType Flex++Rule : .ll ;
+  RegisterFileType Lex++Rule : .ll ;
 
   if $(COMPILER_TYPE) != &quot;GCC&quot;
   {
@@ -51,13 +51,13 @@
 {
   rule BisonRule
   {
-    local cfile = [ LocateTarget $(&lt;:S=.c) ] ;
-    local headerfile = [ LocateTarget $(&lt;:S=.h) ] ;
+    local cfile = [ LocateTarget $(&lt;:S=.c) : $(SUBDIR) ] ;
+    local headerfile = [ LocateTarget $(&lt;:S=.h) : $(SUBDIR) ] ;
     local object = [ CompileObjects $(cfile) ] ;
 
     Includes $(headerfile:G=) : $(headerfile) ;
     
-    Bison $(cfile) $(headerfile) : $(&lt;) ;
+    Bison $(cfile) : $(&lt;) ;
     # work around jam warning about independent target 
     Includes $(cfile) : $(headerfile) ;
 
@@ -67,8 +67,8 @@
 
   rule Bison++Rule
   {
-    local cppfile = [ LocateTarget $(&lt;:S=.cpp) ] ;
-    local headerfile = [ LocateTarget $(&lt;:S=.hpp) ] ;
+    local cppfile = [ LocateTarget $(&lt;:S=.cpp) : $(SUBDIR) ] ;
+    local headerfile = [ LocateTarget $(&lt;:S=.hpp) : $(SUBDIR) ] ;
     headerfile = $(headerfile:G=) ;
     local object = [ CompileObjects $(cppfile) ] ;
 
@@ -76,8 +76,8 @@
     # here
     Includes $(headerfile:G=) : $(headerfile) ;
 
-    Bison $(cppfile) $(headerfile) : $(&lt;) ;
-    Includes $(cppfile) : $(headerfile) ;
+    Bison $(cppfile) $(headerfile:G=) : $(&lt;) ;
+#Includes $(cppfile) : $(headerfile:G=) ;
 
     return $(object) ;
   }

Modified: trunk/mk/jam/compiler.jam
===================================================================
--- trunk/mk/jam/compiler.jam	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/mk/jam/compiler.jam	2005-06-27 13:35:27 UTC (rev 446)
@@ -51,7 +51,8 @@
     Depends $(object) : $(&lt;) ;
     return $(object) ;
 }
-RegisterFileType C++Rule : .cpp .cxx .cc .c++ ;
+RegisterFileType C++Rule : .cpp .cxx .cc .c++ ; # we can't register .C here because
+                                           # of windows being case-insensitive.
 RegisterHeaderRule HeaderRule : $(HDRPATTERN) : .cpp .cxx .cc .c++ ;
 
 actions C++

Modified: trunk/src/Jamfile
===================================================================
--- trunk/src/Jamfile	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/src/Jamfile	2005-06-27 13:35:27 UTC (rev 446)
@@ -1,6 +1,7 @@
 SubDir TOP src ;
 
 SubInclude TOP src squirrel ;
+SubInclude TOP src scripting ;
 
 Application windstille 
     :   display/drawing_context.hxx
@@ -144,5 +145,11 @@
         windstille_main.hxx
         windstille_menu.cxx
         windstille_menu.hxx
+
+        $(wrapper_objects)
 ;
 ExternalLibs windstille : CLANLIB PHYSFS OPENAL ;
+C++Flags windstille : -DAPPDATADIR='\&quot;$(appdatadir)\&quot;' ;
+LinkWith windstille : squirrel ;
+IncludeDir windstille : squirrel/include ;
+Help windstille : &quot;Build the windstille executable&quot; ;

Added: trunk/src/lisp/lexer.cpp
===================================================================
--- trunk/src/lisp/lexer.cpp	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/src/lisp/lexer.cpp	2005-06-27 13:35:27 UTC (rev 446)
@@ -0,0 +1,217 @@
+//  $Id: lexer.cpp 2379 2005-05-01 19:02:16Z matzebraun $
+//
+//  Copyright (C) 2004 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
+//  code in this file based on lispreader from Mark Probst
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#include &lt;config.h&gt;
+
+#include &lt;sstream&gt;
+#include &lt;stdexcept&gt;
+#include &lt;iostream&gt;
+
+#include &quot;lexer.hpp&quot;
+
+namespace lisp
+{
+
+class EOFException
+{
+};
+
+Lexer::Lexer(std::istream&amp; newstream)
+    : stream(newstream), eof(false), linenumber(0)
+{
+  try {
+    // trigger a refill of the buffer
+    c = 0;
+    bufend = 0;
+    nextChar();
+  } catch(EOFException&amp; e) {
+  }
+}
+
+Lexer::~Lexer()
+{
+}
+
+void
+Lexer::nextChar()
+{
+  ++c;
+  if(c &gt;= bufend) {
+    if(eof)
+      throw EOFException();
+    stream.read(buffer, BUFFER_SIZE);
+    size_t bytes_read = stream.gcount();
+    
+    c = buffer;
+    bufend = buffer + bytes_read;
+
+    // the following is a hack that appends an additional ' ' at the end of
+    // the file to avoid problems when parsing symbols/elements and a sudden
+    // EOF. This is faster than relying on unget and IMO also nicer.
+    if(bytes_read == 0 || stream.eof()) {
+      eof = true;
+      *bufend = ' ';
+      ++bufend;
+    }
+  }
+}
+
+Lexer::TokenType
+Lexer::getNextToken()
+{
+  static const char* delims = &quot;\&quot;();&quot;;
+
+  try {
+    while(isspace(*c)) {
+      if(*c == '\n')
+        ++linenumber;
+      nextChar();
+    };
+    
+    token_length = 0;
+    
+    switch(*c) {
+      case ';': // comment
+        while(true) {
+          nextChar();
+          if(*c == '\n') {
+            ++linenumber;
+            break;
+          }
+        }
+        return getNextToken(); // and again
+      case '(':
+        nextChar();
+        return TOKEN_OPEN_PAREN;
+      case ')':
+        nextChar();
+        return TOKEN_CLOSE_PAREN;
+      case '&quot;': {  // string
+        int startline = linenumber;
+        try {
+          while(1) {
+            nextChar();
+            if(*c == '&quot;')
+              break;
+            else if(*c == '\n')
+              linenumber++;
+            else if(*c == '\\') {
+              nextChar();
+              switch(*c) {
+                case 'n':
+                  *c = '\n';
+                  break;
+                case 't':
+                  *c = '\t';
+                  break;
+              }
+            }
+            if(token_length &lt; MAX_TOKEN_LENGTH)
+              token_string[token_length++] = *c;
+          }
+          token_string[token_length] = 0;
+        } catch(EOFException&amp; ) {
+          std::stringstream msg;
+          msg &lt;&lt; &quot;Parse error in line &quot; &lt;&lt; startline &lt;&lt; &quot;: &quot;
+            &lt;&lt; &quot;EOF while parsing string.&quot;;
+          throw std::runtime_error(msg.str());
+        }
+        nextChar();
+        return TOKEN_STRING;
+      }
+      case '#': // constant
+        try {
+          nextChar();
+          
+          while(isalnum(*c) || *c == '_') {
+            if(token_length &lt; MAX_TOKEN_LENGTH)
+              token_string[token_length++] = *c;
+            nextChar();
+          }
+          token_string[token_length] = 0;
+        } catch(EOFException&amp; ) {
+          std::stringstream msg;
+          msg &lt;&lt; &quot;Parse Error in line &quot; &lt;&lt; linenumber &lt;&lt; &quot;: &quot;
+            &lt;&lt; &quot;EOF while parsing constant.&quot;;
+          throw std::runtime_error(msg.str());
+        }
+
+        if(strcmp(token_string, &quot;t&quot;) == 0)
+          return TOKEN_TRUE;
+        if(strcmp(token_string, &quot;f&quot;) == 0)
+          return TOKEN_FALSE;
+
+        // we only handle #t and #f constants at the moment...
+
+        {
+          std::stringstream msg;
+          msg &lt;&lt; &quot;Parse Error in line &quot; &lt;&lt; linenumber &lt;&lt; &quot;: &quot;
+            &lt;&lt; &quot;Unknown constant '&quot; &lt;&lt; token_string &lt;&lt; &quot;'.&quot;;
+          throw std::runtime_error(msg.str());
+        }
+
+      default:
+        if(isdigit(*c) || *c == '-') {
+          bool have_nondigits = false;
+          bool have_digits = false;
+          int have_floating_point = 0;
+          
+          do {
+            if(isdigit(*c))
+              have_digits = true;
+            else if(*c == '.')
+              ++have_floating_point;
+            else if(isalnum(*c) || *c == '_')
+              have_nondigits = true;  
+            
+            if(token_length &lt; MAX_TOKEN_LENGTH)
+              token_string[token_length++] = *c;
+
+            nextChar();
+          } while(!isspace(*c) &amp;&amp; !strchr(delims, *c));
+
+          token_string[token_length] = 0;
+          
+          // no nextChar
+
+          if(have_nondigits || !have_digits || have_floating_point &gt; 1)
+            return TOKEN_SYMBOL;
+          else if(have_floating_point == 1)
+            return TOKEN_REAL;
+          else
+            return TOKEN_INTEGER;
+        } else {
+          do {
+            if(token_length &lt; MAX_TOKEN_LENGTH)
+              token_string[token_length++] = *c;
+            nextChar();
+          } while(!isspace(*c) &amp;&amp; !strchr(delims, *c));
+          token_string[token_length] = 0;
+          
+          // no nextChar
+
+          return TOKEN_SYMBOL;
+        }       
+    }
+  } catch(EOFException&amp; ) {
+    return TOKEN_EOF;
+  }
+}
+
+} // end of namespace lisp
+

Added: trunk/src/lisp/lexer.hpp
===================================================================
--- trunk/src/lisp/lexer.hpp	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/src/lisp/lexer.hpp	2005-06-27 13:35:27 UTC (rev 446)
@@ -0,0 +1,70 @@
+//  $Id: lexer.h 2379 2005-05-01 19:02:16Z matzebraun $
+//
+//  Copyright (C) 2004 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
+//  code in this file based on lispreader from Mark Probst
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#ifndef __LISPLEXER_H__
+#define __LISPLEXER_H__
+
+namespace lisp
+{
+
+class Lexer
+{
+public:
+  enum TokenType {
+    TOKEN_EOF,
+    TOKEN_OPEN_PAREN,
+    TOKEN_CLOSE_PAREN,
+    TOKEN_SYMBOL,
+    TOKEN_STRING,
+    TOKEN_INTEGER,
+    TOKEN_REAL,
+    TOKEN_TRUE,
+    TOKEN_FALSE
+  };
+    
+  Lexer(std::istream&amp; stream);
+  ~Lexer();
+
+  TokenType getNextToken();
+  const char* getString() const
+  { return token_string; }
+  int getLineNumber() const
+  { return linenumber; }
+    
+private:
+  enum {
+    MAX_TOKEN_LENGTH = 16384,
+    BUFFER_SIZE = 1024
+  };
+    
+  inline void nextChar();
+    
+  std::istream&amp; stream;
+  bool eof;
+  int linenumber;
+  char buffer[BUFFER_SIZE+1];
+  char* bufend;
+  char* c;
+  char token_string[MAX_TOKEN_LENGTH + 1];
+  int token_length;
+};
+
+} // end of namespace lisp
+
+#endif
+

Added: trunk/src/lisp/lisp.cpp
===================================================================
--- trunk/src/lisp/lisp.cpp	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/src/lisp/lisp.cpp	2005-06-27 13:35:27 UTC (rev 446)
@@ -0,0 +1,99 @@
+//  $Id: lisp.cpp 2379 2005-05-01 19:02:16Z matzebraun $
+//
+//  TuxKart - a fun racing game with go-kart
+//  Copyright (C) 2004 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
+//  code in this file based on lispreader from Mark Probst
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#include &lt;config.h&gt;
+
+#include &quot;lisp.hpp&quot;
+
+namespace lisp
+{
+    
+Lisp::Lisp(LispType newtype)
+  : type(newtype)
+{
+}
+
+Lisp::~Lisp()
+{
+  if(type == TYPE_SYMBOL || type == TYPE_STRING)
+    delete[] v.string;
+  if(type == TYPE_CONS) {
+    delete v.cons.cdr;
+    delete v.cons.car;
+  }
+}
+
+Lisp*
+Lisp::get_lisp(const char* name) const
+{
+  for(const Lisp* p = this; p != 0; p = p-&gt;get_cdr()) {
+    Lisp* child = p-&gt;get_car();
+    if(!child || child-&gt;get_type() != TYPE_CONS)
+      continue;
+    Lisp* childname = child-&gt;get_car();
+    if(!childname)
+      continue;
+    std::string childName;
+    if(!childname-&gt;get(childName))
+      continue;
+    if(childName == name) {
+      return child-&gt;get_cdr();
+    }
+  }
+
+  return 0;
+}
+
+void
+Lisp::print(std::ostream&amp; out, int indent) const
+{
+  for(int i = 0; i &lt; indent; ++i)
+    out &lt;&lt; ' ';
+  
+  if(type == TYPE_CONS) {
+    out &lt;&lt; &quot;(\n&quot;;
+    const Lisp* lisp = this;
+    while(lisp) {
+      if(lisp-&gt;v.cons.car)
+        lisp-&gt;v.cons.car-&gt;print(out, indent + 1);
+      lisp = lisp-&gt;v.cons.cdr;
+    }
+    for(int i = 0; i &lt; indent; ++i)
+      out &lt;&lt; ' ';
+    out &lt;&lt; ')';
+  }
+  if(type == TYPE_STRING) {
+    out &lt;&lt; '\'' &lt;&lt; v.string &lt;&lt; '\'';
+  }
+  if(type == TYPE_INTEGER) {
+    out &lt;&lt; v.integer;
+  }
+  if(type == TYPE_REAL) {
+    out &lt;&lt; v.real;
+  }
+  if(type == TYPE_SYMBOL) {
+    out &lt;&lt; v.string;
+  }
+  if(type == TYPE_BOOLEAN) {
+    out &lt;&lt; (v.boolean ? &quot;true&quot; : &quot;false&quot;);
+  }
+  out &lt;&lt; '\n';
+}
+
+} // end of namespace lisp

Added: trunk/src/lisp/lisp.hpp
===================================================================
--- trunk/src/lisp/lisp.hpp	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/src/lisp/lisp.hpp	2005-06-27 13:35:27 UTC (rev 446)
@@ -0,0 +1,239 @@
+//  $Id: lisp.h 2419 2005-05-06 19:08:24Z matzebraun $
+//
+//  TuxKart - a fun racing game with go-kart
+//  Copyright (C) 2004 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
+//  code in this file based on lispreader from Mark Probst
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#ifndef __LISPREADER_HPP__
+#define __LISPREADER_HPP__
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;iostream&gt;
+#include &lt;sstream&gt;
+#include &lt;stdexcept&gt;
+
+namespace lisp
+{
+
+class Lisp
+{
+public:
+  ~Lisp();
+    
+  enum LispType {
+    TYPE_CONS,
+    TYPE_SYMBOL,
+    TYPE_INTEGER,
+    TYPE_STRING,
+    TYPE_REAL,
+    TYPE_BOOLEAN
+  };
+
+  LispType get_type() const
+  { return type; } 
+
+  Lisp* get_car() const
+  { return v.cons.car; }
+  Lisp* get_cdr() const
+  { return v.cons.cdr; }
+
+  std::string get_string() const
+  {
+    std::string result;
+    if(!get(result)) {
+      std::ostringstream msg;
+      msg &lt;&lt; &quot;Expected string, got &quot;;
+      print(msg);
+      throw std::runtime_error(msg.str());
+    }
+    return result;
+  }
+
+  int get_int() const
+  {
+    int result;
+    if(!get(result)) {
+      std::ostringstream msg;
+      msg &lt;&lt; &quot;Expected integer, got &quot;;
+      print(msg);
+      throw std::runtime_error(msg.str());
+    }
+    return result;
+  }
+
+  float get_float() const
+  {
+    float result;
+    if(!get(result)) {
+      std::ostringstream msg;
+      msg &lt;&lt; &quot;Expected float, got &quot;;
+      print(msg);
+      throw std::runtime_error(msg.str());
+    }
+    return result;
+  }
+
+  bool get_bool() const
+  {
+    bool result;
+    if(!get(result)) {
+      std::ostringstream msg;
+      msg &lt;&lt; &quot;Expected bool, got &quot;;
+      print(msg);
+      throw std::runtime_error(msg.str());
+    }
+    return result;
+  }
+
+  template&lt;class T&gt;
+  void get_vector(std::vector&lt;T&gt;&amp; vec) const
+  {
+    vec.clear();
+ 
+    for(const lisp::Lisp* child = this ; child != 0; child = child-&gt;get_cdr()) {
+      if(type != TYPE_CONS)
+        throw std::runtime_error(&quot;get_vector called on non-list&quot;);
+      
+      T val;
+      if(!child-&gt;get_car())                           
+        continue;
+      if(child-&gt;get_car()-&gt;get(val)) {
+        vec.push_back(val);
+      }
+    }
+  }
+
+  /** conveniance functions which traverse the list until a child with a
+   * specified name is found. The value part is then interpreted in a specific
+   * way. The functions return true, if a child was found and could be
+   * interpreted correctly, otherwise false is returned and the variable value
+   * is not changed.
+   * (Please note that searching the lisp structure is O(n) so these functions
+   *  are no good idea for performance critical areas)
+   */
+  template&lt;class T&gt;
+  bool get(const char* name, T&amp; val) const
+  {
+    const Lisp* lisp = get_lisp(name);
+    if(!lisp)
+      return false;
+
+    if(lisp-&gt;get_type() != TYPE_CONS)
+      return false;
+    lisp = lisp-&gt;get_car();
+    if(!lisp)
+      return false;
+    return lisp-&gt;get(val);
+  }
+
+  template&lt;class T&gt;
+  bool get_vector(const char* name, std::vector&lt;T&gt;&amp; vec) const
+  {
+    vec.clear();
+    
+    const Lisp* child = get_lisp(name);
+    if(!child)
+      return false;
+    
+    for( ; child != 0; child = child-&gt;get_cdr()) {
+      T val;
+      if(!child-&gt;get_car())
+        continue;
+      if(child-&gt;get_car()-&gt;get(val)) {
+        vec.push_back(val);
+      }
+    }
+    
+    return true;
+  }
+  
+  Lisp* get_lisp(const char* name) const;
+  Lisp* get_lisp(const std::string&amp; name) const
+  { return get_lisp(name.c_str()); }
+
+  // for debugging/error messages
+  void print(std::ostream&amp; out, int indent = 0) const;
+
+private:
+  bool get(std::string&amp; val) const
+  { 
+    if(type != TYPE_STRING &amp;&amp; type != TYPE_SYMBOL)
+      return false;
+    val = v.string;
+    return true;
+  }
+  
+  bool get(unsigned int&amp; val) const
+  {
+    if(type != TYPE_INTEGER)
+      return false;
+    val = v.integer;
+    return true;
+  }
+  
+  bool get(int&amp; val) const
+  {
+    if(type != TYPE_INTEGER)
+      return false;
+    val = v.integer;
+    return true;
+  }
+  
+  bool get(float&amp; val) const
+  {
+    if(type != TYPE_REAL) {
+      if(type == TYPE_INTEGER) {
+        val = v.integer;
+        return true;
+      }
+      return false;
+    }
+    val = v.real;
+    return true;
+  }
+  
+  bool get(bool&amp; val) const
+  {
+    if(type != TYPE_BOOLEAN)
+      return false;
+    val = v.boolean;
+    return true;
+  }
+ 
+  friend class Parser;
+  Lisp(LispType newtype);
+
+  LispType type;
+  union
+  {
+    struct
+    {
+      Lisp* car;
+      Lisp* cdr;
+    } cons;
+
+    char* string;
+    int integer;
+    bool boolean;
+    float real;
+  } v;
+};
+
+} // end of namespace lisp
+
+#endif
+

Added: trunk/src/lisp/list_iterator.cpp
===================================================================
--- trunk/src/lisp/list_iterator.cpp	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/src/lisp/list_iterator.cpp	2005-06-27 13:35:27 UTC (rev 446)
@@ -0,0 +1,55 @@
+//  $Id: list_iterator.cpp 2575 2005-06-07 15:59:27Z matzebraun $
+// 
+//  SuperTux
+//  Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+//  02111-1307, USA.
+
+#include &lt;config.h&gt;
+
+#include &quot;list_iterator.hpp&quot;
+#include &lt;stdexcept&gt;
+
+namespace lisp
+{
+
+ListIterator::ListIterator(const lisp::Lisp* newlisp)
+  : current_lisp(0), cur(newlisp)
+{
+}
+
+bool
+ListIterator::next()
+{
+  if(cur == 0)
+    return false;
+
+  const lisp::Lisp* child = cur-&gt;get_car();
+  if(!child)
+    throw std::runtime_error(&quot;child is 0 in list entry&quot;);
+  if(child-&gt;get_type() != lisp::Lisp::TYPE_CONS)
+    throw std::runtime_error(&quot;Expected CONS&quot;);
+  const lisp::Lisp* name = child-&gt;get_car();
+  if(!name || name-&gt;get_type() != lisp::Lisp::TYPE_SYMBOL)
+    throw std::runtime_error(&quot;Expected symbol&quot;);
+  current_item = name-&gt;get_string();
+  current_lisp = child-&gt;get_cdr();
+
+  cur = cur-&gt;get_cdr();
+  return true;
+}
+
+}

Added: trunk/src/lisp/list_iterator.hpp
===================================================================
--- trunk/src/lisp/list_iterator.hpp	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/src/lisp/list_iterator.hpp	2005-06-27 13:35:27 UTC (rev 446)
@@ -0,0 +1,55 @@
+//  $Id: list_iterator.h 2379 2005-05-01 19:02:16Z matzebraun $
+// 
+//  SuperTux
+//  Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+//  02111-1307, USA.
+
+#ifndef __LISP_ITERATOR_H__
+#define __LISP_ITERATOR_H__
+
+#include &quot;lisp/lisp.hpp&quot;
+
+namespace lisp
+{
+
+/**
+ * Small and a bit hacky helper class that helps parsing lisp lists where all
+ * entries are lists again themselves
+ */
+class ListIterator
+{
+public:
+  ListIterator(const lisp::Lisp* cur);
+  
+  const std::string&amp; item() const
+  { return current_item; }
+  lisp::Lisp* lisp() const
+  { return current_lisp; }
+  lisp::Lisp&amp; value() const
+  { return *(current_lisp-&gt;get_car()); }
+  bool next();
+
+private:
+  std::string current_item;
+  lisp::Lisp* current_lisp;
+  const lisp::Lisp* cur;
+};
+
+}
+
+#endif
+

Added: trunk/src/lisp/parser.cpp
===================================================================
--- trunk/src/lisp/parser.cpp	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/src/lisp/parser.cpp	2005-06-27 13:35:27 UTC (rev 446)
@@ -0,0 +1,191 @@
+//  $Id: parser.cpp 2575 2005-06-07 15:59:27Z matzebraun $
+//
+//  TuxKart - a fun racing game with go-kart
+//  Copyright (C) 2004 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
+//  code in this file based on lispreader from Mark Probst
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#include &lt;config.h&gt;
+
+#include &lt;sstream&gt;
+#include &lt;stdexcept&gt;
+#include &lt;fstream&gt;
+#include &lt;cassert&gt;
+#include &lt;iostream&gt;
+
+#include &quot;tinygettext/tinygettext.hpp&quot;
+#include &quot;physfs/physfs_stream.hpp&quot;
+#include &quot;parser.hpp&quot;
+#include &quot;lisp.hpp&quot;
+
+namespace lisp
+{
+
+Parser::Parser()
+  : lexer(0), dictionary_manager(0), dictionary(0)
+{
+  dictionary_manager = new TinyGetText::DictionaryManager();
+  dictionary_manager-&gt;set_charset(&quot;UTF-8&quot;);
+}
+
+Parser::~Parser()
+{
+  delete lexer;
+  delete dictionary_manager;
+}
+
+static std::string dirname(std::string filename)
+{
+  std::string::size_type p = filename.find_last_of('/');
+  if(p == std::string::npos)
+    return &quot;&quot;;
+
+  return filename.substr(0, p+1);
+}
+
+Lisp*
+Parser::parse(const std::string&amp; filename)
+{
+  IFileStream in(filename);
+  if(!in.good()) {
+    std::stringstream msg;
+    msg &lt;&lt; &quot;Parser problem: Couldn't open file '&quot; &lt;&lt; filename &lt;&lt; &quot;'.&quot;;
+    throw std::runtime_error(msg.str());
+  }
+
+  return parse(in, dirname(filename));
+}
+
+Lisp*
+Parser::parse(std::istream&amp; stream, const std::string&amp; basedir)
+{
+  std::auto_ptr&lt;Parser&gt; parser (new Parser());
+  
+  parser-&gt;dictionary_manager-&gt;add_directory(basedir);   
+  parser-&gt;dictionary = &amp; (parser-&gt;dictionary_manager-&gt;get_dictionary());
+  parser-&gt;lexer = new Lexer(stream);
+
+  parser-&gt;token = parser-&gt;lexer-&gt;getNextToken();
+  Lisp* result = new Lisp(Lisp::TYPE_CONS);
+  result-&gt;v.cons.car = parser-&gt;read();
+  result-&gt;v.cons.cdr = 0; 
+
+  return result;    
+}
+
+Lisp*
+Parser::read()
+{
+  Lisp* result;
+  switch(token) {
+    case Lexer::TOKEN_EOF: {
+      std::stringstream msg;
+      msg &lt;&lt; &quot;Parse Error at line &quot; &lt;&lt; lexer-&gt;getLineNumber() &lt;&lt; &quot;: &quot;
+        &lt;&lt; &quot;Unexpected EOF.&quot;;
+      throw std::runtime_error(msg.str());
+    }
+    case Lexer::TOKEN_CLOSE_PAREN: {
+      std::stringstream msg;
+      msg &lt;&lt; &quot;Parse Error at line &quot; &lt;&lt; lexer-&gt;getLineNumber() &lt;&lt; &quot;: &quot;
+        &lt;&lt; &quot;Unexpected ')'.&quot;;
+      throw std::runtime_error(msg.str());
+    }
+    case Lexer::TOKEN_OPEN_PAREN: {
+      result = new Lisp(Lisp::TYPE_CONS);
+      
+      token = lexer-&gt;getNextToken();
+      if(token == Lexer::TOKEN_CLOSE_PAREN) {
+        result-&gt;v.cons.car = 0;
+        result-&gt;v.cons.cdr = 0;
+        break;
+      }
+
+      if(token == Lexer::TOKEN_SYMBOL &amp;&amp;
+          strcmp(lexer-&gt;getString(), &quot;_&quot;) == 0) {
+        // evaluate translation function (_ str) in place here
+        token = lexer-&gt;getNextToken();
+        if(token != Lexer::TOKEN_STRING)
+          throw std::runtime_error(&quot;Expected string after '(_'&quot;);
+        
+        result = new Lisp(Lisp::TYPE_STRING);
+        if(dictionary) {
+          std::string translation = dictionary-&gt;translate(lexer-&gt;getString());
+          result-&gt;v.string = new char[translation.size()+1];
+          memcpy(result-&gt;v.string, translation.c_str(), translation.size()+1);
+        } else {
+          size_t len = strlen(lexer-&gt;getString()) + 1;                                
+          result-&gt;v.string = new char[len];
+          memcpy(result-&gt;v.string, lexer-&gt;getString(), len);
+        }
+        token = lexer-&gt;getNextToken();
+        if(token != Lexer::TOKEN_CLOSE_PAREN)
+          throw std::runtime_error(&quot;Expected ')' after '(_ string'&quot;);
+        break;
+      }
+
+      Lisp* cur = result;
+      do {
+        cur-&gt;v.cons.car = read();
+        if(token == Lexer::TOKEN_CLOSE_PAREN) {
+          cur-&gt;v.cons.cdr = 0;
+          break;
+        }
+        cur-&gt;v.cons.cdr = new Lisp(Lisp::TYPE_CONS);
+        cur = cur-&gt;v.cons.cdr;
+      } while(1);
+
+      break;
+    }
+    case Lexer::TOKEN_SYMBOL: {
+      result = new Lisp(Lisp::TYPE_SYMBOL);
+      size_t len = strlen(lexer-&gt;getString()) + 1;
+      result-&gt;v.string = new char[len];
+      memcpy(result-&gt;v.string, lexer-&gt;getString(), len);
+      break;
+    }
+    case Lexer::TOKEN_STRING: {
+      result = new Lisp(Lisp::TYPE_STRING);
+      size_t len = strlen(lexer-&gt;getString()) + 1;
+      result-&gt;v.string = new char[len];
+      memcpy(result-&gt;v.string, lexer-&gt;getString(), len);
+      break;
+    }
+    case Lexer::TOKEN_INTEGER:
+      result = new Lisp(Lisp::TYPE_INTEGER);
+      sscanf(lexer-&gt;getString(), &quot;%d&quot;, &amp;result-&gt;v.integer);
+      break;
+    case Lexer::TOKEN_REAL:
+      result = new Lisp(Lisp::TYPE_REAL);
+      sscanf(lexer-&gt;getString(), &quot;%f&quot;, &amp;result-&gt;v.real);
+      break;
+    case Lexer::TOKEN_TRUE:
+      result = new Lisp(Lisp::TYPE_BOOLEAN);
+      result-&gt;v.boolean = true;
+      break;
+    case Lexer::TOKEN_FALSE:
+      result = new Lisp(Lisp::TYPE_BOOLEAN);
+      result-&gt;v.boolean = false;
+      break;
+
+    default:
+      // this should never happen
+      assert(false);
+  }
+
+  token = lexer-&gt;getNextToken();
+  return result;
+}
+
+} // end of namespace lisp

Added: trunk/src/lisp/parser.hpp
===================================================================
--- trunk/src/lisp/parser.hpp	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/src/lisp/parser.hpp	2005-06-27 13:35:27 UTC (rev 446)
@@ -0,0 +1,57 @@
+//  $Id: parser.h 2379 2005-05-01 19:02:16Z matzebraun $
+//
+//  TuxKart - a fun racing game with go-kart
+//  Copyright (C) 2004 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;
+//  code in this file based on lispreader from Mark Probst
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#ifndef __LISPPARSER_H__
+#define __LISPPARSER_H__
+
+#include &lt;string&gt;
+#include &quot;lexer.hpp&quot;
+
+namespace TinyGetText {
+class Dictionary;
+class DictionaryManager;
+}
+
+namespace lisp
+{
+
+class Lisp;
+
+class Parser
+{
+public:
+  ~Parser();
+  static Lisp* parse(const std::string&amp; filename);
+  static Lisp* parse(std::istream&amp; stream, const std::string&amp; basedir = &quot;&quot;);
+
+private:
+  Parser();
+  
+  Lisp* read();
+    
+  Lexer* lexer;
+  TinyGetText::DictionaryManager* dictionary_manager;
+  TinyGetText::Dictionary* dictionary;
+  Lexer::TokenType token;
+};
+
+} // end of namespace lisp
+
+#endif
+

Added: trunk/src/lisp/writer.cpp
===================================================================
--- trunk/src/lisp/writer.cpp	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/src/lisp/writer.cpp	2005-06-27 13:35:27 UTC (rev 446)
@@ -0,0 +1,152 @@
+//  $Id: writer.cpp 2575 2005-06-07 15:59:27Z matzebraun $
+//
+//  SuperTux -  A Jump'n Run
+//  Copyright (C) 2004 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include &lt;config.h&gt;
+
+#include &lt;iostream&gt;
+
+#include &quot;writer.hpp&quot;
+#include &quot;physfs/physfs_stream.hpp&quot;
+
+namespace lisp
+{
+
+Writer::Writer(const std::string&amp; filename)
+{
+  out = new OFileStream(filename);
+  out_owned = true;
+  indent_depth = 0;
+}
+  
+Writer::Writer(std::ostream* newout)
+{
+  out = newout;
+  out_owned = false;
+  indent_depth = 0;
+}
+
+Writer::~Writer()
+{
+  if(lists.size() &gt; 0) {
+    std::cerr &lt;&lt; &quot;Warning: Not all sections closed in lispwriter!\n&quot;;
+  }
+  if(out_owned)
+    delete out;
+}
+
+void
+Writer::write_comment(const std::string&amp; comment)
+{
+  *out &lt;&lt; &quot;; &quot; &lt;&lt; comment &lt;&lt; &quot;\n&quot;;
+}
+
+void
+Writer::start_list(const std::string&amp; listname)
+{
+  indent();
+  *out &lt;&lt; '(' &lt;&lt; listname &lt;&lt; '\n';
+  indent_depth += 2;
+
+  lists.push_back(listname);
+}
+
+void
+Writer::end_list(const std::string&amp; listname)
+{
+  if(lists.size() == 0) {
+    std::cerr &lt;&lt; &quot;Trying to close list '&quot; &lt;&lt; listname 
+              &lt;&lt; &quot;', which is not open.\n&quot;;
+    return;
+  }
+  if(lists.back() != listname) {
+    std::cerr &lt;&lt; &quot;Warning: trying to close list '&quot; &lt;&lt; listname 
+              &lt;&lt; &quot;' while list '&quot; &lt;&lt; lists.back() &lt;&lt; &quot;' is open.\n&quot;;
+    return;
+  }
+  lists.pop_back();
+  
+  indent_depth -= 2;
+  indent();
+  *out &lt;&lt; &quot;)\n&quot;;
+}
+
+void
+Writer::write_int(const std::string&amp; name, int value)
+{
+  indent();
+  *out &lt;&lt; '(' &lt;&lt; name &lt;&lt; ' ' &lt;&lt; value &lt;&lt; &quot;)\n&quot;;
+}
+
+void
+Writer::write_float(const std::string&amp; name, float value)
+{
+  indent();
+  *out &lt;&lt; '(' &lt;&lt; name &lt;&lt; ' ' &lt;&lt; value &lt;&lt; &quot;)\n&quot;;
+}
+
+void
+Writer::write_string(const std::string&amp; name, const std::string&amp; value,
+    bool translatable)
+{
+  indent();
+  *out &lt;&lt; '(' &lt;&lt; name;
+  if(translatable) {
+    *out &lt;&lt; &quot; (_ \&quot;&quot; &lt;&lt; value &lt;&lt; &quot;\&quot;))\n&quot;;
+  } else {
+    *out &lt;&lt; &quot; \&quot;&quot; &lt;&lt; value &lt;&lt; &quot;\&quot;)\n&quot;;
+  }
+}
+
+void
+Writer::write_bool(const std::string&amp; name, bool value)
+{
+  indent();
+  *out &lt;&lt; '(' &lt;&lt; name &lt;&lt; ' ' &lt;&lt; (value ? &quot;#t&quot; : &quot;#f&quot;) &lt;&lt; &quot;)\n&quot;;
+}
+
+void
+Writer::write_int_vector(const std::string&amp; name,
+    const std::vector&lt;int&gt;&amp; value)
+{
+  indent();
+  *out &lt;&lt; '(' &lt;&lt; name;
+  for(std::vector&lt;int&gt;::const_iterator i = value.begin(); i != value.end(); ++i)
+    *out &lt;&lt; &quot; &quot; &lt;&lt; *i;
+  *out &lt;&lt; &quot;)\n&quot;;
+}
+
+void
+Writer::write_int_vector(const std::string&amp; name,
+    const std::vector&lt;unsigned int&gt;&amp; value)
+{
+  indent();
+  *out &lt;&lt; '(' &lt;&lt; name;
+  for(std::vector&lt;unsigned int&gt;::const_iterator i = value.begin(); i != value.end(); ++i)
+    *out &lt;&lt; &quot; &quot; &lt;&lt; *i;
+  *out &lt;&lt; &quot;)\n&quot;;
+}
+
+void
+Writer::indent()
+{
+  for(int i = 0; i&lt;indent_depth; ++i)
+    *out &lt;&lt; ' ';
+}
+
+} // end of namespace lisp

Added: trunk/src/lisp/writer.hpp
===================================================================
--- trunk/src/lisp/writer.hpp	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/src/lisp/writer.hpp	2005-06-27 13:35:27 UTC (rev 446)
@@ -0,0 +1,64 @@
+//  $Id: writer.h 2575 2005-06-07 15:59:27Z matzebraun $
+//
+//  SuperTux -  A Jump'n Run
+//  Copyright (C) 2004 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef SUPERTUX_LISPWRITER_H
+#define SUPERTUX_LISPWRITER_H
+
+#include &lt;iostream&gt;
+#include &lt;string&gt;
+#include &lt;vector&gt;
+
+namespace lisp
+{
+
+  class Writer
+  {
+  public:
+    Writer(const std::string&amp; filename);
+    Writer(std::ostream* out);
+    ~Writer();
+
+    void write_comment(const std::string&amp; comment);
+
+    void start_list(const std::string&amp; listname);
+
+    void write_int(const std::string&amp; name, int value);
+    void write_float(const std::string&amp; name, float value);
+    void write_string(const std::string&amp; name, const std::string&amp; value,
+        bool translatable = false);
+    void write_bool(const std::string&amp; name, bool value);
+    void write_int_vector(const std::string&amp; name, const std::vector&lt;int&gt;&amp; value);
+    void write_int_vector(const std::string&amp; name, const std::vector&lt;unsigned int&gt;&amp; value);
+    // add more write-functions when needed...
+
+    void end_list(const std::string&amp; listname);
+
+  private:
+    void indent();
+
+    std::ostream* out;
+    bool out_owned;
+    int indent_depth;
+    std::vector&lt;std::string&gt; lists;
+  };
+  
+} //namespace lisp
+
+#endif //SUPERTUX_LISPWRITER_H
+

Added: trunk/src/lisp_util.hpp
===================================================================
--- trunk/src/lisp_util.hpp	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/src/lisp_util.hpp	2005-06-27 13:35:27 UTC (rev 446)
@@ -0,0 +1,22 @@
+#ifndef __LISP_UTIL_HPP__
+#define __LISP_UTIL_HPP__
+
+#include &quot;lisp/lisp.hpp&quot;
+
+static inline const lisp::Lisp* lisp_get_list_nth(const lisp::Lisp* lisp, int nth)
+{
+  for(int i = 0; i &lt; nth; ++i) {
+    if(lisp-&gt;get_type() != lisp::Lisp::TYPE_CONS)
+      throw std::runtime_error(&quot;Invalid data when reading lisp list&quot;);
+    if(lisp-&gt;get_cdr() == 0)
+      throw std::runtime_error(&quot;lisp list too short&quot;);
+    lisp = lisp-&gt;get_cdr();
+  }
+  if(lisp-&gt;get_type() != lisp::Lisp::TYPE_CONS)
+    throw std::runtime_error(&quot;Invalid data when reading lisp list&quot;);
+
+  return lisp-&gt;get_car();
+}
+
+#endif
+

Modified: trunk/src/sound/sound_manager.cpp
===================================================================
--- trunk/src/sound/sound_manager.cpp	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/src/sound/sound_manager.cpp	2005-06-27 13:35:27 UTC (rev 446)
@@ -157,7 +157,7 @@
   if(fade) {
     if(music_source
         &amp;&amp; music_source-&gt;getFadeState() != StreamSoundSource::FadingOff)
-      music_source-&gt;setFading(StreamSoundSource::FadingOff, 1);
+      music_source-&gt;setFading(StreamSoundSource::FadingOff, .7f);
   } else {
     delete music_source;
     music_source = 0;
@@ -182,7 +182,7 @@
     if(fade) {
       if(music_source 
           &amp;&amp; music_source-&gt;getFadeState() != StreamSoundSource::FadingOff)
-        music_source-&gt;setFading(StreamSoundSource::FadingOff, .5f);
+        music_source-&gt;setFading(StreamSoundSource::FadingOff, .7f);
       delete next_music_source;
       next_music_source = newmusic;
     } else {

Added: trunk/src/tinygettext/tinygettext.cpp
===================================================================
--- trunk/src/tinygettext/tinygettext.cpp	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/src/tinygettext/tinygettext.cpp	2005-06-27 13:35:27 UTC (rev 446)
@@ -0,0 +1,725 @@
+//  $Id: tinygettext.cpp 2575 2005-06-07 15:59:27Z matzebraun $
+// 
+//  TinyGetText - A small flexible gettext() replacement
+//  Copyright (C) 2004 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#include &lt;config.h&gt;
+
+#include &lt;sys/types.h&gt;
+#include &lt;iconv.h&gt;
+#include &lt;fstream&gt;
+#include &lt;iostream&gt;
+#include &lt;ctype.h&gt;
+#include &lt;errno.h&gt;
+
+#include &quot;tinygettext.hpp&quot;
+#include &quot;physfs/physfs_stream.hpp&quot;
+
+//#define TRANSLATION_DEBUG
+
+namespace TinyGetText {
+
+/** Convert \a which is in \a from_charset to \a to_charset and return it */
+std::string convert(const std::string&amp; text,
+                    const std::string&amp; from_charset,
+                    const std::string&amp; to_charset)
+{
+  if (from_charset == to_charset)
+    return text;
+
+  iconv_t cd = iconv_open(to_charset.c_str(), from_charset.c_str());
+  
+  size_t in_len = text.length();
+  size_t out_len = text.length()*3; // FIXME: cross fingers that this is enough
+
+  char*  out_orig = new char[out_len];
+  char*  in_orig  = new char[in_len+1];
+  strcpy(in_orig, text.c_str());
+
+  char* out = out_orig;
+  ICONV_CONST char* in  = in_orig;
+  size_t out_len_temp = out_len; // iconv is counting down the bytes it has
+                                 // written from this...
+
+  size_t retval = iconv(cd, &amp;in, &amp;in_len, &amp;out, &amp;out_len_temp);
+  out_len -= out_len_temp; // see above
+  if (retval == (size_t) -1)
+    {
+      std::cerr &lt;&lt; strerror(errno) &lt;&lt; std::endl;
+      std::cerr &lt;&lt; &quot;Error: conversion from &quot; &lt;&lt; from_charset
+                &lt;&lt; &quot; to &quot; &lt;&lt; to_charset &lt;&lt; &quot; went wrong: &quot; &lt;&lt; retval &lt;&lt; std::endl;
+      return &quot;&quot;;
+    }
+  iconv_close(cd);
+
+  std::string ret(out_orig, out_len);
+  delete[] out_orig;
+  delete[] in_orig;
+  return ret;
+}
+
+bool has_suffix(const std::string&amp; lhs, const std::string rhs)
+{
+  if (lhs.length() &lt; rhs.length())
+    return false;
+  else
+    return lhs.compare(lhs.length() - rhs.length(), rhs.length(), rhs) == 0;
+}
+
+bool has_prefix(const std::string&amp; lhs, const std::string rhs)
+{
+  if (lhs.length() &lt; rhs.length())
+    return false;
+  else
+    return lhs.compare(0, rhs.length(), rhs) == 0;
+}
+
+int plural1(int )     { return 0; }
+int plural2_1(int n)  { return (n != 1); }
+int plural2_2(int n)  { return (n &gt; 1); }
+int plural3_lv(int n) { return (n%10==1 &amp;&amp; n%100!=11 ? 0 : n != 0 ? 1 : 2); }
+int plural3_ga(int n) { return n==1 ? 0 : n==2 ? 1 : 2; }
+int plural3_lt(int n) { return (n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2); }
+int plural3_1(int n)  { return (n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2); }
+int plural3_sk(int n) { return (n==1) ? 0 : (n&gt;=2 &amp;&amp; n&lt;=4) ? 1 : 2; }
+int plural3_pl(int n) { return (n==1 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2); }
+int plural3_sl(int n) { return (n%100==1 ? 0 : n%100==2 ? 1 : n%100==3 || n%100==4 ? 2 : 3); }
+
+/** Language Definitions */
+//*{
+LanguageDef lang_hu(&quot;hu&quot;, &quot;Hungarian&quot;,         1, plural1); // &quot;nplurals=1; plural=0;&quot;
+LanguageDef lang_ja(&quot;ja&quot;, &quot;Japanese&quot;,          1, plural1); // &quot;nplurals=1; plural=0;&quot;
+LanguageDef lang_ko(&quot;ko&quot;, &quot;Korean&quot;,            1, plural1); // &quot;nplurals=1; plural=0;&quot;
+LanguageDef lang_tr(&quot;tr&quot;, &quot;Turkish&quot;,           1, plural1); // &quot;nplurals=1; plural=0;&quot;
+LanguageDef lang_da(&quot;da&quot;, &quot;Danish&quot;,            2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_nl(&quot;nl&quot;, &quot;Dutch&quot;,             2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_en(&quot;en&quot;, &quot;English&quot;,           2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_fo(&quot;fo&quot;, &quot;Faroese&quot;,           2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_de(&quot;de&quot;, &quot;German&quot;,            2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_nb(&quot;nb&quot;, &quot;Norwegian Bokmal&quot;,  2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_no(&quot;no&quot;, &quot;Norwegian&quot;,         2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_nn(&quot;nn&quot;, &quot;Norwegian Nynorsk&quot;, 2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_sv(&quot;sv&quot;, &quot;Swedish&quot;,           2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_et(&quot;et&quot;, &quot;Estonian&quot;,          2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_fi(&quot;fi&quot;, &quot;Finnish&quot;,           2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_el(&quot;el&quot;, &quot;Greek&quot;,             2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_he(&quot;he&quot;, &quot;Hebrew&quot;,            2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_it(&quot;it&quot;, &quot;Italian&quot;,           2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_pt(&quot;pt&quot;, &quot;Portuguese&quot;,        2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_es(&quot;es&quot;, &quot;Spanish&quot;,           2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_eo(&quot;eo&quot;, &quot;Esperanto&quot;,         2, plural2_1); // &quot;nplurals=2; plural=(n != 1);&quot;
+LanguageDef lang_fr(&quot;fr&quot;, &quot;French&quot;,            2, plural2_2); // &quot;nplurals=2; plural=(n &gt; 1);&quot;
+LanguageDef lang_pt_BR(&quot;pt_BR&quot;, &quot;Brazilian&quot;,   2, plural2_2); // &quot;nplurals=2; plural=(n &gt; 1);&quot;
+LanguageDef lang_lv(&quot;lv&quot;, &quot;Latvian&quot;,           3, plural3_lv); // &quot;nplurals=3; plural=(n%10==1 &amp;&amp; n%100!=11 ? 0 : n != 0 ? 1 : 2);&quot;
+LanguageDef lang_ga(&quot;ga&quot;, &quot;Irish&quot;,             3, plural3_ga); // &quot;nplurals=3; plural=n==1 ? 0 : n==2 ? 1 : 2;&quot;
+LanguageDef lang_lt(&quot;lt&quot;, &quot;Lithuanian&quot;,        3, plural3_lt); // &quot;nplurals=3; plural=(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2);&quot;
+LanguageDef lang_hr(&quot;hr&quot;, &quot;Croatian&quot;,          3, plural3_1); // &quot;nplurals=3; plural=(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2);&quot;
+LanguageDef lang_cs(&quot;cs&quot;, &quot;Czech&quot;,             3, plural3_1); // &quot;nplurals=3; plural=(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2);&quot;
+LanguageDef lang_ru(&quot;ru&quot;, &quot;Russian&quot;,           3, plural3_1); // &quot;nplurals=3; plural=(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2);&quot;
+LanguageDef lang_uk(&quot;uk&quot;, &quot;Ukrainian&quot;,         3, plural3_1); // &quot;nplurals=3; plural=(n%10==1 &amp;&amp; n%100!=11 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2);&quot;
+LanguageDef lang_sk(&quot;sk&quot;, &quot;Slovak&quot;,            3, plural3_sk); // &quot;nplurals=3; plural=(n==1) ? 0 : (n&gt;=2 &amp;&amp; n&lt;=4) ? 1 : 2;&quot;
+LanguageDef lang_pl(&quot;pl&quot;, &quot;Polish&quot;,            3, plural3_pl); // &quot;nplurals=3; plural=(n==1 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2);
+LanguageDef lang_sl(&quot;sl&quot;, &quot;Slovenian&quot;,         3, plural3_sl); // &quot;nplurals=4; plural=(n%100==1 ? 0 : n%100==2 ? 1 : n%100==3 || n%100==4 ? 2 : 3);&quot;
+//*}
+
+LanguageDef&amp;
+get_language_def(const std::string&amp; name)
+{
+  if (name == &quot;hu&quot;) return lang_hu;
+  else if (name == &quot;ja&quot;) return lang_ja;
+  else if (name == &quot;ko&quot;) return lang_ko;
+  else if (name == &quot;tr&quot;) return lang_tr;
+  else if (name == &quot;da&quot;) return lang_da;
+  else if (name == &quot;nl&quot;) return lang_nl;
+  else if (name == &quot;en&quot;) return lang_en;
+  else if (name == &quot;fo&quot;) return lang_fo;
+  else if (name == &quot;de&quot;) return lang_de;
+  else if (name == &quot;nb&quot;) return lang_nb;
+  else if (name == &quot;no&quot;) return lang_no;
+  else if (name == &quot;nn&quot;) return lang_nn;
+  else if (name == &quot;sv&quot;) return lang_sv;
+  else if (name == &quot;et&quot;) return lang_et;
+  else if (name == &quot;fi&quot;) return lang_fi;
+  else if (name == &quot;el&quot;) return lang_el;
+  else if (name == &quot;he&quot;) return lang_he;
+  else if (name == &quot;it&quot;) return lang_it;
+  else if (name == &quot;pt&quot;) return lang_pt;
+  else if (name == &quot;es&quot;) return lang_es;
+  else if (name == &quot;eo&quot;) return lang_eo;
+  else if (name == &quot;fr&quot;) return lang_fr;
+  else if (name == &quot;pt_BR&quot;) return lang_pt_BR;
+  else if (name == &quot;lv&quot;) return lang_lv;
+  else if (name == &quot;ga&quot;) return lang_ga;
+  else if (name == &quot;lt&quot;) return lang_lt;
+  else if (name == &quot;hr&quot;) return lang_hr;
+  else if (name == &quot;cs&quot;) return lang_cs;
+  else if (name == &quot;ru&quot;) return lang_ru;
+  else if (name == &quot;uk&quot;) return lang_uk;
+  else if (name == &quot;sk&quot;) return lang_sk;
+  else if (name == &quot;pl&quot;) return lang_pl;
+  else if (name == &quot;sl&quot;) return lang_sl;
+  else return lang_en; 
+}
+
+DictionaryManager::DictionaryManager()
+  : current_dict(&amp;empty_dict)
+{
+  parseLocaleAliases();
+  // setup language from environment vars
+  const char* lang = getenv(&quot;LC_ALL&quot;);
+  if(!lang)
+    lang = getenv(&quot;LC_MESSAGES&quot;);
+  if(!lang)
+    lang = getenv(&quot;LANG&quot;);
+  
+  if(lang)
+    set_language(lang);
+}
+
+void
+DictionaryManager::parseLocaleAliases()
+{
+  // try to parse language alias list
+  std::ifstream in(&quot;/usr/share/locale/locale.alias&quot;);
+  
+  char c = ' ';
+  while(in.good() &amp;&amp; !in.eof()) {
+    while(isspace(c) &amp;&amp; !in.eof())
+      in.get(c);
+    
+    if(c == '#') { // skip comments
+      while(c != '\n' &amp;&amp; !in.eof())
+        in.get(c);
+      continue;
+    }
+    
+    std::string alias;
+    while(!isspace(c) &amp;&amp; !in.eof()) {
+      alias += c;
+      in.get(c);
+    }
+    while(isspace(c) &amp;&amp; !in.eof())
+      in.get(c);
+    std::string language;
+    while(!isspace(c) &amp;&amp; !in.eof()) {
+      language += c;
+      in.get(c);
+    }
+
+    if(in.eof())
+      break;
+    set_language_alias(alias, language);
+  }
+}
+  
+Dictionary&amp;
+DictionaryManager::get_dictionary(const std::string&amp; spec)
+{
+  std::string lang = get_language_from_spec(spec);
+  Dictionaries::iterator i = dictionaries.find(get_language_from_spec(lang));
+  if (i != dictionaries.end())
+    {
+      return i-&gt;second;
+    }
+  else // Dictionary for languages lang isn't loaded, so we load it
+    {
+      //std::cout &lt;&lt; &quot;get_dictionary: &quot; &lt;&lt; lang &lt;&lt; std::endl;
+      Dictionary&amp; dict = dictionaries[lang];
+
+      dict.set_language(get_language_def(lang));
+      if(charset != &quot;&quot;)
+        dict.set_charset(charset);
+
+      for (SearchPath::iterator p = search_path.begin(); p != search_path.end(); ++p)
+        {
+          char** files = PHYSFS_enumerateFiles(p-&gt;c_str());
+          if(!files) 
+            {
+              std::cerr &lt;&lt; &quot;Error: enumerateFiles() failed on &quot; &lt;&lt; *p &lt;&lt; std::endl;
+            }
+          else
+            {
+              for(const char* const* filename = files;
+                      *filename != 0; filename++) {
+                if(std::string(*filename) == lang + &quot;.po&quot;) {
+                  std::string pofile = *p + &quot;/&quot; + *filename;
+                  try {
+                      IFileStream in(pofile);
+                      read_po_file(dict, in);
+                  } catch(std::exception&amp; e) {
+                      std::cerr &lt;&lt; &quot;Error: Failure file opening: &quot; &lt;&lt; pofile &lt;&lt; std::endl;
+                      std::cerr &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;
+                  }
+                }
+              }
+              PHYSFS_freeList(files);
+            }
+        }
+
+      return dict;
+    }
+}
+
+std::set&lt;std::string&gt;
+DictionaryManager::get_languages()
+{
+  std::set&lt;std::string&gt; languages;
+
+  for (SearchPath::iterator p = search_path.begin(); p != search_path.end(); ++p)
+    {
+      char** files = PHYSFS_enumerateFiles(p-&gt;c_str());
+      if (!files)
+        {
+          std::cerr &lt;&lt; &quot;Error: opendir() failed on &quot; &lt;&lt; *p &lt;&lt; std::endl;
+        }
+      else
+        {
+          for(const char* const* file = files; *file != 0; file++) {
+              if(has_suffix(*file, &quot;.po&quot;)) {
+                  std::string filename = *file;
+                  languages.insert(filename.substr(0, filename.length()-3));
+              }
+          }
+          PHYSFS_freeList(files);
+        }
+    }  
+  return languages;
+}
+
+void
+DictionaryManager::set_language(const std::string&amp; lang)
+{
+  language = get_language_from_spec(lang);
+  current_dict = &amp; (get_dictionary(language));
+}
+
+const std::string&amp;
+DictionaryManager::get_language() const
+{
+  return language;
+}
+
+void
+DictionaryManager::set_charset(const std::string&amp; charset)
+{
+  dictionaries.clear(); // changing charset invalidates cache
+  this-&gt;charset = charset;
+  set_language(language);
+}
+
+void
+DictionaryManager::set_language_alias(const std::string&amp; alias,
+    const std::string&amp; language)
+{
+  language_aliases.insert(std::make_pair(alias, language));
+}
+
+std::string
+DictionaryManager::get_language_from_spec(const std::string&amp; spec)
+{
+  std::string lang = spec;
+  Aliases::iterator i = language_aliases.find(lang);
+  if(i != language_aliases.end()) {
+    lang = i-&gt;second;
+  }
+  
+  std::string::size_type s = lang.find_first_of(&quot;_.&quot;);
+  if(s == std::string::npos)
+    return lang;
+
+  return std::string(lang, 0, s);  
+}
+
+void
+DictionaryManager::add_directory(const std::string&amp; pathname)
+{
+  dictionaries.clear(); // adding directories invalidates cache
+  search_path.push_back(pathname);
+  set_language(language);
+}
+
+//---------------------------------------------------------------------------
+
+Dictionary::Dictionary(const LanguageDef&amp; language_, const std::string&amp; charset_)
+  : language(language_), charset(charset_)
+{
+}
+
+Dictionary::Dictionary()
+  : language(lang_en)
+{
+}
+
+std::string
+Dictionary::get_charset() const
+{
+  return charset;
+}
+
+void
+Dictionary::set_charset(const std::string&amp; charset_)
+{
+  charset = charset_;
+}
+
+void
+Dictionary::set_language(const LanguageDef&amp; lang)
+{
+  language = lang;
+}
+
+std::string
+Dictionary::translate(const std::string&amp; msgid, const std::string&amp; msgid2, int num) 
+{
+  PluralEntries::iterator i = plural_entries.find(msgid);
+  std::map&lt;int, std::string&gt;&amp; msgstrs = i-&gt;second;
+
+  if (i != plural_entries.end() &amp;&amp; !msgstrs.empty())
+    {
+      int g = language.plural(num);
+      std::map&lt;int, std::string&gt;::iterator j = msgstrs.find(g);
+      if (j != msgstrs.end())
+        {
+          return j-&gt;second;
+        }
+      else
+        {
+          // Return the first translation, in case we can't translate the specific number
+          return msgstrs.begin()-&gt;second;
+        }
+    }
+  else
+    {
+#ifdef TRANSLATION_DEBUG
+      std::cerr &lt;&lt; &quot;Warning: Couldn't translate: &quot; &lt;&lt; msgid &lt;&lt; std::endl;
+      std::cerr &lt;&lt; &quot;Candidates: &quot; &lt;&lt; std::endl;
+      for (PluralEntries::iterator i = plural_entries.begin(); i != plural_entries.end(); ++i)
+        std::cout &lt;&lt; &quot;'&quot; &lt;&lt; i-&gt;first &lt;&lt; &quot;'&quot; &lt;&lt; std::endl;
+#endif
+
+      if (plural2_1(num)) // default to english rules
+        return msgid2;
+      else
+        return msgid;
+    }
+}
+
+const char*
+Dictionary::translate(const char* msgid)
+{
+  Entries::iterator i = entries.find(msgid);
+  if (i != entries.end() &amp;&amp; !i-&gt;second.empty())
+    {
+      return i-&gt;second.c_str();
+    }
+  else
+    {
+#ifdef TRANSLATION_DBEUG
+      std::cout &lt;&lt; &quot;Error: Couldn't translate: &quot; &lt;&lt; msgid &lt;&lt; std::endl;
+#endif
+      return msgid;
+    }
+}
+
+std::string
+Dictionary::translate(const std::string&amp; msgid) 
+{
+  Entries::iterator i = entries.find(msgid);
+  if (i != entries.end() &amp;&amp; !i-&gt;second.empty())
+    {
+      return i-&gt;second;
+    }
+  else
+    {
+#ifdef TRANSLATION_DBEUG
+      std::cout &lt;&lt; &quot;Error: Couldn't translate: &quot; &lt;&lt; msgid &lt;&lt; std::endl;
+#endif
+      return msgid;
+    }
+}
+  
+void
+Dictionary::add_translation(const std::string&amp; msgid, const std::string&amp; ,
+                            const std::map&lt;int, std::string&gt;&amp; msgstrs)
+{
+  // Do we need msgid2 for anything? its after all supplied to the
+  // translate call, so we just throw it away
+  plural_entries[msgid] = msgstrs;
+}
+
+void 
+Dictionary::add_translation(const std::string&amp; msgid, const std::string&amp; msgstr) 
+{
+  entries[msgid] = msgstr;
+}
+
+class POFileReader
+{
+private:
+  struct Token
+  {
+    std::string keyword;
+    std::string content;
+  };
+
+  Dictionary&amp; dict;
+
+  std::string from_charset;
+  std::string to_charset;
+
+  std::string current_msgid;
+  std::string current_msgid_plural;
+  std::map&lt;int, std::string&gt; msgstr_plural;
+
+  int line_num;
+
+  enum { WANT_MSGID, WANT_MSGSTR, WANT_MSGSTR_PLURAL, WANT_MSGID_PLURAL } state;
+
+public:
+  POFileReader(std::istream&amp; in, Dictionary&amp; dict_)
+    : dict(dict_)
+  {
+    state = WANT_MSGID;
+    line_num = 0;
+    char c = in.get();
+    if(c == (char) 0xef) { // skip UTF-8 intro that some texteditors produce
+        in.get();
+        in.get();
+    } else {
+        in.unget();
+    }
+    tokenize_po(in);
+  }
+
+  void parse_header(const std::string&amp; header)
+  {
+    // Seperate the header in lines
+    typedef std::vector&lt;std::string&gt; Lines;
+    Lines lines;
+    
+    std::string::size_type start = 0;
+    for(std::string::size_type i = 0; i &lt; header.length(); ++i)
+      {
+        if (header[i] == '\n')
+          {
+            lines.push_back(header.substr(start, i - start));
+            start = i+1;
+          }
+      }
+
+    for(Lines::iterator i = lines.begin(); i != lines.end(); ++i)
+      {
+        if (has_prefix(*i, &quot;Content-Type: text/plain; charset=&quot;)) {
+          from_charset = i-&gt;substr(strlen(&quot;Content-Type: text/plain; charset=&quot;));
+        }
+      }
+
+    if (from_charset.empty() || from_charset == &quot;CHARSET&quot;)
+      {
+        std::cerr &lt;&lt; &quot;Error: Charset not specified for .po, fallback to ISO-8859-1&quot; &lt;&lt; std::endl;
+        from_charset = &quot;ISO-8859-1&quot;;
+      }
+
+    to_charset = dict.get_charset();
+    if (to_charset.empty())
+      { // No charset requested from the dict, use utf-8
+        to_charset = &quot;utf-8&quot;;
+        dict.set_charset(from_charset);
+      }
+  }
+
+  void add_token(const Token&amp; token)
+  {
+    switch(state) 
+      {
+      case WANT_MSGID:
+        if (token.keyword == &quot;msgid&quot;) 
+          {
+            current_msgid = token.content;
+            state = WANT_MSGID_PLURAL;
+          }
+        else if (token.keyword.empty())
+          {
+            //std::cerr &lt;&lt; &quot;Got EOF, everything looks ok.&quot; &lt;&lt; std::endl;
+          }
+        else
+          {
+            std::cerr &lt;&lt; &quot;tinygettext: expected 'msgid' keyword, got &quot; &lt;&lt; token.keyword 
+                      &lt;&lt; &quot; at line &quot; &lt;&lt; line_num &lt;&lt; std::endl;
+          }
+        break;
+    
+      case WANT_MSGID_PLURAL:
+        if (token.keyword == &quot;msgid_plural&quot;) 
+          {
+            current_msgid_plural = token.content;
+            state = WANT_MSGSTR_PLURAL;
+          } 
+        else
+          {
+            state = WANT_MSGSTR;
+            add_token(token);
+          }
+        break;
+
+      case WANT_MSGSTR:
+        if (token.keyword == &quot;msgstr&quot;) 
+          {
+            if (current_msgid == &quot;&quot;) 
+              { // .po Header is hidden in the msgid with the empty string
+                parse_header(token.content);
+              }
+            else
+              {
+                dict.add_translation(current_msgid, convert(token.content, from_charset, to_charset));
+              }
+            state = WANT_MSGID;
+          } 
+        else
+          {
+            std::cerr &lt;&lt; &quot;tinygettext: expected 'msgstr' keyword, got &quot; &lt;&lt; token.keyword 
+                      &lt;&lt; &quot; at line &quot; &lt;&lt; line_num &lt;&lt; std::endl;
+          }
+        break;
+
+      case WANT_MSGSTR_PLURAL:
+        if (has_prefix(token.keyword, &quot;msgstr[&quot;)) 
+          {
+            int num;
+            if (sscanf(token.keyword.c_str(), &quot;msgstr[%d]&quot;, &amp;num) != 1) 
+              {
+                std::cerr &lt;&lt; &quot;Error: Couldn't parse: &quot; &lt;&lt; token.keyword &lt;&lt; std::endl;
+              } 
+            else 
+              {
+                msgstr_plural[num] = convert(token.content, from_charset, to_charset);
+              }
+          }
+        else 
+          {
+            dict.add_translation(current_msgid, current_msgid_plural, msgstr_plural);
+
+            state = WANT_MSGID;
+            add_token(token);
+          }
+        break;
+      }
+  }
+  
+  inline int getchar(std::istream&amp; in) 
+  {
+    int c = in.get();
+    if (c == '\n')
+      line_num += 1;
+    return c;
+  }
+  
+  void tokenize_po(std::istream&amp; in)
+  {
+    enum State { READ_KEYWORD, 
+                 READ_CONTENT,
+                 READ_CONTENT_IN_STRING,
+                 SKIP_COMMENT };
+
+    State state = READ_KEYWORD;
+    int c;
+    Token token;
+
+    while((c = getchar(in)) != EOF)
+      {
+        //std::cout &lt;&lt; &quot;Lexing char: &quot; &lt;&lt; char(c) &lt;&lt; &quot; &quot; &lt;&lt; state &lt;&lt; std::endl;
+        switch(state)
+          {
+          case READ_KEYWORD:
+            if (c == '#')
+              {
+                state = SKIP_COMMENT;
+              }
+            else
+              {
+                // Read a new token
+                token = Token();
+                
+                do { // Read keyword 
+                  token.keyword += c;
+                } while((c = getchar(in)) != EOF &amp;&amp; !isspace(c));
+                in.unget();
+
+                state = READ_CONTENT;
+              }
+            break;
+
+          case READ_CONTENT:
+            while((c = getchar(in)) != EOF)
+              {
+                if (c == '&quot;') { 
+                  // Found start of content
+                  state = READ_CONTENT_IN_STRING;
+                  break;
+                } else if (isspace(c)) {
+                  // skip
+                } else { // Read something that may be a keyword
+                  in.unget();
+                  state = READ_KEYWORD;
+                  add_token(token);
+                  break;
+                }
+              }
+            break;
+
+          case READ_CONTENT_IN_STRING:
+            if (c == '\\') {
+              c = getchar(in);
+              if (c != EOF)
+                {
+                  if (c == 'n') token.content += '\n';
+                  else if (c == 't') token.content += '\t';
+                  else if (c == 'r') token.content += '\r';
+                  else if (c == '&quot;') token.content += '&quot;';
+                  else
+                    {
+                      std::cout &lt;&lt; &quot;Unhandled escape character: &quot; &lt;&lt; char(c) &lt;&lt; std::endl;
+                    }
+                }
+              else
+                {
+                  std::cout &lt;&lt; &quot;Unterminated string&quot; &lt;&lt; std::endl;
+                }
+            } else if (c == '&quot;') { // Content string is terminated
+              state = READ_CONTENT;
+            } else {
+              token.content += c;
+            }
+            break;
+
+          case SKIP_COMMENT:
+            if (c == '\n')
+              state = READ_KEYWORD;
+            break;
+          }
+      }
+    add_token(token);
+  }
+};
+
+void read_po_file(Dictionary&amp; dict_, std::istream&amp; in) 
+{
+  POFileReader reader(in, dict_);
+}
+
+} // namespace TinyGetText
+
+/* EOF */

Added: trunk/src/tinygettext/tinygettext.hpp
===================================================================
--- trunk/src/tinygettext/tinygettext.hpp	2005-06-27 00:03:58 UTC (rev 445)
+++ trunk/src/tinygettext/tinygettext.hpp	2005-06-27 13:35:27 UTC (rev 446)
@@ -0,0 +1,158 @@
+//  $Id: tinygettext.h 2575 2005-06-07 15:59:27Z matzebraun $
+// 
+//  TinyGetText - A small flexible gettext() replacement
+//  Copyright (C) 2004 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#ifndef HEADER_TINYGETTEXT_H
+#define HEADER_TINYGETTEXT_H
+
+#include &lt;map&gt;
+#include &lt;vector&gt;
+#include &lt;set&gt;
+#include &lt;string&gt;
+
+namespace TinyGetText {
+
+typedef int (*PluralFunc)(int n);
+
+struct LanguageDef {
+  const char* code;
+  const char* name;
+  int         nplural;
+  PluralFunc  plural;
+
+  LanguageDef(const char* code_, const char* name_,  int nplural_, PluralFunc plural_)
+    : code(code_), name(name_), nplural(nplural_), plural(plural_)
+  {}
+};
+
+/** A simple dictionary class that mimics gettext() behaviour. Each
+    Dictionary only works for a single language, for managing multiple
+    languages and .po files at once use the DictionaryManager. */
+class Dictionary
+{
+private:
+  typedef std::map&lt;std::string, std::string&gt; Entries;
+  Entries entries;
+
+  typedef std::map&lt;std::string, std::map&lt;int, std::string&gt; &gt; PluralEntries;
+  PluralEntries plural_entries;
+
+  LanguageDef language;
+  std::string charset;
+public:
+  /** */
+  Dictionary(const LanguageDef&amp; language_, const std::string&amp; charset = &quot;&quot;);
+
+  Dictionary();
+
+  /** Return the charset used for this dictionary */
+  std::string get_charset() const;
+
+  /** Set a charset for this dictionary, this will NOT convert stuff,
+      it is for information only, you have to convert stuff yourself
+      when you add it with \a add_translation() */
+  void set_charset(const std::string&amp; charset);
+
+  /** Set the language that is used for this dictionary, this is
+      mainly needed to evaluate plural forms */
+  void set_language(const LanguageDef&amp; lang);
+
+  /** Translate the string \a msgid to its correct plural form, based
+      on the number of items given by \a num. \a msgid2 is \a msgid in
+      plural form. */
+  std::string translate(const std::string&amp; msgid, const std::string&amp; msgid2, int num);
+
+  /** Translate the string \a msgid. */
+  std::string translate(const std::string&amp; msgid);
+  /** Translate the string \a msgid. */
+  const char* translate(const char* msgid);
+    
+  /** Add a translation from \a msgid to \a msgstr to the dictionary,
+      where \a msgid is the singular form of the message, msgid2 the
+      plural form and msgstrs a table of translations. The right
+      translation will be calculated based on the \a num argument to
+      translate(). */
+  void add_translation(const std::string&amp; msgid, const std::string&amp; msgid2,
+                       const std::map&lt;int, std::string&gt;&amp; msgstrs);
+
+  /** Add a translation from \a msgid to \a msgstr to the
+      dictionary */
+  void add_translation(const std::string&amp; msgid, const std::string&amp; msgstr);
+};
+
+/** Manager class for dictionaries, you give it a bunch of directories
+    with .po files and it will then automatically load the right file
+    on demand depending on which language was set. */
+class DictionaryManager
+{
+private:
+  typedef std::map&lt;std::string, Dictionary&gt; Dictionaries;
+  Dictionaries dictionaries;
+  typedef std::vector&lt;std::string&gt; SearchPath;
+  SearchPath search_path;
+  typedef std::map&lt;std::string, std::string&gt; Aliases;
+  Aliases language_aliases;
+  std::string charset;
+  std::string language;
+  Dictionary* current_dict;
+  Dictionary empty_dict;
+
+public:
+  DictionaryManager();
+
+  /** Return the currently active dictionary, if none is set, an empty
+      dictionary is returned. */
+  Dictionary&amp; get_dictionary()
+  { return *current_dict; }
+
+  /** Get dictionary for lang */
+  Dictionary&amp; get_dictionary(const std::string&amp; langspec);
+
+  /** Set a language based on a four? letter country code */
+  void set_language(const std::string&amp; langspec);
+
+  /** returns the (normalized) country code of the currently used language */
+  const std::string&amp; get_language() const;
+
+  /** Set a charset that will be set on the returned dictionaries */
+  void set_charset(const std::string&amp; charset);
+
+  /** Define an alias for a language */
+  void set_language_alias(const std::string&amp; alias, const std::string&amp; lang);
+
+  /** Add a directory to the search path for dictionaries */
+  void add_directory(const std::string&amp; pathname);
+  
+  /** Return a set of the available languages in their country code */
+  std::set&lt;std::string&gt; get_languages();
+
+private:
+  void parseLocaleAliases();
+  /// returns the language part in a language spec (like de_DE.UTF-8 -&gt; de)
+  std::string get_language_from_spec(const std::string&amp; spec);
+};
+
+/** Read the content of the .po file given as \a in into the
+    dictionary given as \a dict */
+void read_po_file(Dictionary&amp; dict, std::istream&amp; in);
+LanguageDef&amp; get_language_def(const std::string&amp; name);
+
+} // namespace TinyGetText
+
+#endif
+
+/* EOF */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000102.html">[Windstille-commit] r445 - in trunk: . src src/sound
</A></li>
	<LI>Next message: <A HREF="000104.html">[Windstille-commit] r447 - in trunk/src: . scripting
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#103">[ date ]</a>
              <a href="thread.html#103">[ thread ]</a>
              <a href="subject.html#103">[ subject ]</a>
              <a href="author.html#103">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/windstille-commit">More information about the Windstille-commit
mailing list</a><br>
</body></html>
