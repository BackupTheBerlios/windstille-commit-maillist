<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Windstille-commit] r444 - in trunk: data/controller src src/input
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/windstille-commit/2005-June/index.html" >
   <LINK REL="made" HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r444%20-%20in%20trunk%3A%20data/controller%20src%20src/input&In-Reply-To=%3C200506262249.j5QMnAv0027726%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000100.html">
   <LINK REL="Next"  HREF="000102.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Windstille-commit] r444 - in trunk: data/controller src src/input</H1>
    <B>Matthias Braun at BerliOS</B> 
    <A HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r444%20-%20in%20trunk%3A%20data/controller%20src%20src/input&In-Reply-To=%3C200506262249.j5QMnAv0027726%40sheep.berlios.de%3E"
       TITLE="[Windstille-commit] r444 - in trunk: data/controller src src/input">matzebraun at sheep.berlios.de
       </A><BR>
    <I>Mon Jun 27 00:49:10 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000100.html">[Windstille-commit] r443 - in trunk: . src src/input src/physfs
</A></li>
        <LI>Next message: <A HREF="000102.html">[Windstille-commit] r445 - in trunk: . src src/sound
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#101">[ date ]</a>
              <a href="thread.html#101">[ thread ]</a>
              <a href="subject.html#101">[ subject ]</a>
              <a href="author.html#101">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: matzebraun
Date: 2005-06-27 00:49:00 +0200 (Mon, 27 Jun 2005)
New Revision: 444

Removed:
   trunk/src/lispreader.cxx
   trunk/src/lispreader.hxx
Modified:
   trunk/data/controller/gamepad.scm
   trunk/data/controller/gamepad2.scm
   trunk/data/controller/keyboard.scm
   trunk/src/Jamfile
   trunk/src/input/axis_button.cxx
   trunk/src/input/axis_factory.cxx
   trunk/src/input/axis_factory.hxx
   trunk/src/input/button_factory.cxx
   trunk/src/input/button_factory.hxx
   trunk/src/input/input_axis.hxx
   trunk/src/input/input_axis_input_device.hxx
   trunk/src/input/input_button.hxx
   trunk/src/input/input_button_input_device.hxx
   trunk/src/input/input_manager.cxx
   trunk/src/input/input_manager_custom.cxx
   trunk/src/input/input_manager_custom.hxx
   trunk/src/input/input_manager_player.cxx
   trunk/src/input/input_manager_player.hxx
   trunk/src/sprite3d.cxx
   trunk/src/windstille_main.cxx
Log:
removed last usage of old lispreader

Modified: trunk/data/controller/gamepad.scm
===================================================================
--- trunk/data/controller/gamepad.scm	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/data/controller/gamepad.scm	2005-06-26 22:49:00 UTC (rev 444)
@@ -1,4 +1,4 @@
-(feuerkraft-controller
+(windstille-controller
  (up    (axis-button (joystick-axis 0 1) #f))
  (down  (axis-button (joystick-axis 0 1) #t))
  (left  (axis-button (joystick-axis 0 0) #f))

Modified: trunk/data/controller/gamepad2.scm
===================================================================
--- trunk/data/controller/gamepad2.scm	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/data/controller/gamepad2.scm	2005-06-26 22:49:00 UTC (rev 444)
@@ -1,4 +1,4 @@
-(feuerkraft-controller
+(windstille-controller
  (up    (axis-button (joystick-axis 1 1) #f))
  (down  (axis-button (joystick-axis 1 1) #t))
  (left  (axis-button (joystick-axis 1 0) #f))

Modified: trunk/data/controller/keyboard.scm
===================================================================
--- trunk/data/controller/keyboard.scm	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/data/controller/keyboard.scm	2005-06-26 22:49:00 UTC (rev 444)
@@ -1,4 +1,4 @@
-(feuerkraft-controller
+(windstille-controller
  (up    (keyboard-button &quot;up&quot;))
  (down  (keyboard-button &quot;down&quot;))
  (left  (keyboard-button &quot;left&quot;))

Modified: trunk/src/Jamfile
===================================================================
--- trunk/src/Jamfile	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/Jamfile	2005-06-26 22:49:00 UTC (rev 444)
@@ -100,8 +100,6 @@
         igel.hxx
         laser_shoot.cxx
         laser_shoot.hxx
-        lispreader.cxx
-        lispreader.hxx
         math.hxx
         music_manager.cxx
         music_manager.hxx

Modified: trunk/src/input/axis_button.cxx
===================================================================
--- trunk/src/input/axis_button.cxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/input/axis_button.cxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -34,7 +34,7 @@
 }
 
 void
-AxisButton::update(float delta)
+AxisButton::update(float )
 {
 }
 

Modified: trunk/src/input/axis_factory.cxx
===================================================================
--- trunk/src/input/axis_factory.cxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/input/axis_factory.cxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -19,58 +19,48 @@
 
 #include &lt;ClanLib/Display/joystick.h&gt;
 #include &quot;input_axis_input_device.hxx&quot;
-#include &quot;../windstille_error.hxx&quot;
+#include &quot;windstille_error.hxx&quot;
 #include &quot;button_factory.hxx&quot;
 #include &quot;button_axis.hxx&quot;
 #include &quot;axis_factory.hxx&quot;
+#include &quot;lisp_util.hpp&quot;
+#include &quot;lisp/lisp.hpp&quot;
+#include &quot;lisp/list_iterator.hpp&quot;
 
 InputAxis* 
-AxisFactory::create(lisp_object_t* lst)
+AxisFactory::create(const lisp::Lisp* lisp)
 {
-  while(lisp_cons_p(lst))
-    {
-      lisp_object_t* sym  = lisp_car(lst);
-      lisp_object_t* data = lisp_cdr(lst);
-      
-      if (strcmp(lisp_symbol(sym), &quot;joystick-axis&quot;) == 0)
-        {
-          return create_joystick_axis(data);
-        }
-      else if (strcmp(lisp_symbol(sym), &quot;button-axis&quot;) == 0)
-        {
-          return create_button_axis(data);
-        }
-      else
-        {
-          throw WindstilleError(&quot;AxisFactory::create: parse error&quot;);
-        }
-
-      lst = lisp_cdr(lst);
+  lisp::ListIterator iter(lisp);
+  while(iter.next()) {
+    if(iter.item() == &quot;joystick-axis&quot;) {
+      return create_joystick_axis(iter.lisp());
+    } else if(iter.item() == &quot;button-axis&quot;) {
+      return create_button_axis(iter.lisp());
+    } else {
+      std::cerr &lt;&lt; &quot;Skipping unknown tag '&quot; &lt;&lt; iter.item() &lt;&lt; &quot;' in axis.\n&quot;;
     }
+  }
+
   return 0;
 }
 
 InputAxis*
-AxisFactory::create_joystick_axis(lisp_object_t* lst)
+AxisFactory::create_joystick_axis(const lisp::Lisp* lisp)
 {
-  int device_num = lisp_integer(lisp_list_nth(lst, 0));
-  int axis_num   = lisp_integer(lisp_list_nth(lst, 1));
+  int device_num = lisp_get_list_nth(lisp, 0)-&gt;get_int();
+  int axis_num   = lisp_get_list_nth(lisp, 1)-&gt;get_int();
 
   if (device_num &gt;= 0 &amp;&amp; device_num &lt; CL_Joystick::get_device_count())
     return new InputAxisInputDevice(CL_Joystick::get_device(device_num), axis_num);
   else
-    {
-      throw WindstilleError(&quot;Error: AxisFactory::create_joystick_axis: &quot;);
-      //                            + lisp_string(lst));
-      return 0;
-    }
+    throw WindstilleError(&quot;Error: AxisFactory::create_joystick_axis: &quot;);
 }
 
 InputAxis*
-AxisFactory::create_button_axis(lisp_object_t* lst)
+AxisFactory::create_button_axis(const lisp::Lisp* lisp)
 {
-  InputButton* left  = ButtonFactory::create(lisp_list_nth(lst, 0));
-  InputButton* right = ButtonFactory::create(lisp_list_nth(lst, 1));
+  InputButton* left  = ButtonFactory::create(lisp_get_list_nth(lisp, 0));
+  InputButton* right = ButtonFactory::create(lisp_get_list_nth(lisp, 1));
 
   return new ButtonAxis(left, right);
 }

Modified: trunk/src/input/axis_factory.hxx
===================================================================
--- trunk/src/input/axis_factory.hxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/input/axis_factory.hxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -20,17 +20,17 @@
 #ifndef HEADER_AXIS_FACTORY_HXX
 #define HEADER_AXIS_FACTORY_HXX
 
-#include &quot;../lispreader.hxx&quot;
+#include &quot;lisp/lisp.hpp&quot;
 #include &quot;input_axis.hxx&quot;
 
 /** */
 class AxisFactory
 {
 public:
-  static InputAxis* create(lisp_object_t* lst);
+  static InputAxis* create(const lisp::Lisp* lisp);
 private:
-  static InputAxis* create_joystick_axis(lisp_object_t* lst);
-  static InputAxis* create_button_axis(lisp_object_t* lst);
+  static InputAxis* create_joystick_axis(const lisp::Lisp* lisp);
+  static InputAxis* create_button_axis(const lisp::Lisp* lisp);
 };
 
 #endif

Modified: trunk/src/input/button_factory.cxx
===================================================================
--- trunk/src/input/button_factory.cxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/input/button_factory.cxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -19,74 +19,64 @@
 
 #include &lt;ClanLib/Display/joystick.h&gt;
 #include &lt;ClanLib/Display/keyboard.h&gt;
-#include &quot;../lispreader.hxx&quot;
-#include &quot;../windstille_error.hxx&quot;
+#include &quot;windstille_error.hxx&quot;
 #include &quot;input_button.hxx&quot;
 #include &quot;input_axis.hxx&quot;
 #include &quot;input_button_input_device.hxx&quot;
+#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;lisp_util.hpp&quot;
 #include &quot;axis_factory.hxx&quot;
 #include &quot;axis_button.hxx&quot;
 #include &quot;multi_button.hxx&quot;
 #include &quot;button_factory.hxx&quot;
 
 InputButton* 
-ButtonFactory::create(lisp_object_t* lst)
+ButtonFactory::create(const lisp::Lisp* lisp)
 {
-  lisp_object_t* sym = lisp_car(lst);
-
-  if (strcmp(lisp_symbol(sym), &quot;joystick-button&quot;) == 0)
-    {
-      return create_joystick_button(lisp_cdr(lst));
+  lisp::ListIterator iter(lisp);
+  while(iter.next()) {
+    if(iter.item() == &quot;joystick-button&quot;) {
+      return create_joystick_button(iter.lisp());
+    } else if(iter.item() == &quot;keyboard-button&quot;) {
+      return create_keyboard_button(iter.lisp());
+    } else if(iter.item() == &quot;axis-button&quot;) {
+      return create_axis_button(iter.lisp());
+    } else if(iter.item() == &quot;multi-button&quot;) {
+      return create_multi_button(iter.lisp());
+    } else {
+      std::cerr &lt;&lt; &quot;Skipping unknown tag '&quot; &lt;&lt; iter.item() 
+        &lt;&lt; &quot;' in controller file\n&quot;;
     }
-  else if (strcmp(lisp_symbol(sym), &quot;keyboard-button&quot;) == 0)
-    {
-      return create_keyboard_button(lisp_cdr(lst));
-    }
-  else if (strcmp(lisp_symbol(sym), &quot;axis-button&quot;) == 0)
-    {
-      return create_axis_button(lisp_cdr(lst));
-    }
-  else if (strcmp(lisp_symbol(sym), &quot;multi-button&quot;) == 0)
-    {
-      return create_multi_button(lisp_cdr(lst));
-    }
-  else
-    {
-      throw WindstilleError(&quot;ButtonFactory::create: parse error: '&quot;);
-                            //                            + Guile::scm2string(lst) + &quot;'&quot;);
-    }
+  }
       
   return 0;
 }
 
 InputButton*
-ButtonFactory::create_axis_button(lisp_object_t* lst)
+ButtonFactory::create_axis_button(const lisp::Lisp* lisp)
 {
-  InputAxis* axis = AxisFactory::create(lisp_list_nth(lst, 0));
-  bool top = lisp_boolean(lisp_list_nth(lst, 1));
+  InputAxis* axis = AxisFactory::create(lisp_get_list_nth(lisp, 0));
+  bool top = lisp_get_list_nth(lisp, 1)-&gt;get_bool();
   
   return new AxisButton(axis, top);
 }
 
 InputButton*
-ButtonFactory::create_joystick_button(lisp_object_t* lst)
+ButtonFactory::create_joystick_button(const lisp::Lisp* lisp)
 {
-  int device_num = lisp_integer(lisp_list_nth(lst, 0));
-  int button_num = lisp_integer(lisp_list_nth(lst, 1));
+  int device_num = lisp_get_list_nth(lisp, 0)-&gt;get_int();
+  int button_num = lisp_get_list_nth(lisp, 1)-&gt;get_int();
   
   if (device_num &gt;= 0 &amp;&amp; device_num &lt; CL_Joystick::get_device_count())
     return new InputButtonInputDevice(CL_Joystick::get_device(device_num), button_num);
   else
-    {
-      throw WindstilleError(&quot;Error: ButtonFactory::create_joystick_button: device out of range&quot;);
-                            //                            + to_string(device_num) + &quot; &quot; + Guile::scm2string(lst));
-    }
+    throw WindstilleError(&quot;Error: ButtonFactory::create_joystick_button: device out of range&quot;);
 }
 
 InputButton*
-ButtonFactory::create_keyboard_button(lisp_object_t* lst)
+ButtonFactory::create_keyboard_button(const lisp::Lisp* lisp)
 {
-  std::string key_str = lisp_string(lisp_car(lst));
+  std::string key_str = lisp-&gt;get_car()-&gt;get_string();
   int key_num         = CL_Keyboard::get_device().string_to_keyid(key_str);
 
   // FIXME: No error checking
@@ -94,16 +84,14 @@
 }
 
 InputButton*
-ButtonFactory::create_multi_button(lisp_object_t* lst)
+ButtonFactory::create_multi_button(const lisp::Lisp* lisp)
 {
   MultiButton* button = new MultiButton();
+ 
+  for( ; lisp != 0; lisp = lisp-&gt;get_cdr()) {
+    button-&gt;add(create(lisp-&gt;get_car()));
+  }
   
-  while (!lisp_nil_p(lst))
-    {
-      button-&gt;add(create(lisp_car(lst)));
-      lst = lisp_cdr(lst);
-    }
-  
   return button;
 }
 

Modified: trunk/src/input/button_factory.hxx
===================================================================
--- trunk/src/input/button_factory.hxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/input/button_factory.hxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -20,7 +20,7 @@
 #ifndef HEADER_BUTTON_FACTORY_HXX
 #define HEADER_BUTTON_FACTORY_HXX
 
-#include &quot;../lispreader.hxx&quot;
+#include &quot;lisp/lisp.hpp&quot;
 
 class InputButton;
 
@@ -29,13 +29,13 @@
 {
 private:
 public:
-  static InputButton* create(lisp_object_t* lst);
+  static InputButton* create(const lisp::Lisp* lisp);
 
 private:
-  static InputButton* create_joystick_button(lisp_object_t* lst);
-  static InputButton* create_keyboard_button(lisp_object_t* lst);
-  static InputButton* create_axis_button(lisp_object_t* lst);
-  static InputButton* create_multi_button(lisp_object_t* lst);
+  static InputButton* create_joystick_button(const lisp::Lisp* lisp);
+  static InputButton* create_keyboard_button(const lisp::Lisp* lisp);
+  static InputButton* create_axis_button(const lisp::Lisp* lisp);
+  static InputButton* create_multi_button(const lisp::Lisp* lisp);
 
   ButtonFactory (const ButtonFactory&amp;);
   ButtonFactory&amp; operator= (const ButtonFactory&amp;);

Modified: trunk/src/input/input_axis.hxx
===================================================================
--- trunk/src/input/input_axis.hxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/input/input_axis.hxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -33,7 +33,7 @@
   InputAxis() {}
   virtual ~InputAxis() {}
 
-  virtual void update(float delta) {}
+  virtual void update(float ) {}
   CL_Signal_v1&lt;float&gt;&amp; on_move() { return move; }
 };
 

Modified: trunk/src/input/input_axis_input_device.hxx
===================================================================
--- trunk/src/input/input_axis_input_device.hxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/input/input_axis_input_device.hxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -33,7 +33,7 @@
 
 public:
   InputAxisInputDevice(CL_InputDevice&amp; dev, int num);
-  void update(float delta) {}
+  void update(float ) {}
 };
 
 #endif

Modified: trunk/src/input/input_button.hxx
===================================================================
--- trunk/src/input/input_button.hxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/input/input_button.hxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -35,7 +35,7 @@
   InputButton() {}
   virtual ~InputButton() {}
   
-  virtual void update(float delta) {}
+  virtual void update(float ) {}
 
   CL_Signal_v0&amp; on_key_down() { return button_down; }
   CL_Signal_v0&amp; on_key_up()   { return button_up; }

Modified: trunk/src/input/input_button_input_device.hxx
===================================================================
--- trunk/src/input/input_button_input_device.hxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/input/input_button_input_device.hxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -35,7 +35,7 @@
 public:
   InputButtonInputDevice(CL_InputDevice&amp; dev, int keycode);
   
-  void update(float delta) {}
+  void update(float ) {}
 };
 
 #endif

Modified: trunk/src/input/input_manager.cxx
===================================================================
--- trunk/src/input/input_manager.cxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/input/input_manager.cxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -21,9 +21,11 @@
 #include &lt;assert.h&gt;
 #include &lt;stdexcept&gt;
 #include &lt;sstream&gt;
+#include &lt;memory&gt;
 #include &lt;ClanLib/Display/joystick.h&gt;
 
-#include &quot;../windstille_error.hxx&quot;
+#include &quot;lisp/parser.hpp&quot;
+#include &quot;windstille_error.hxx&quot;
 #include &quot;input_manager_custom.hxx&quot;
 #include &quot;input_manager_player.hxx&quot;
 #include &quot;input_manager_impl.hxx&quot;
@@ -42,17 +44,16 @@
 void
 InputManager::init(const std::string&amp; filename)
 {
-  lisp_object_t* lst = lisp_read_from_file(filename.c_str());
+  std::auto_ptr&lt;lisp::Lisp&gt; root (lisp::Parser::parse(filename));
 
-  if (strcmp(&quot;feuerkraft-controller&quot;, lisp_symbol(lisp_car(lst))) == 0)
-    {
-      impl = new InputManagerCustom(lisp_cdr(lst));
-    }
-  else
-    {
-      throw WindstilleError(&quot;Error: not a valid controller file: &quot; + filename);
-    }
-  lisp_free(lst);
+  const lisp::Lisp* controller = root-&gt;get_lisp(&quot;windstille-controller&quot;);
+  if(controller == 0) {
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;'&quot; &lt;&lt; filename &lt;&lt; &quot;' is not a windstille-controller file&quot;;
+    throw std::runtime_error(msg.str());
+  }
+  
+  impl = new InputManagerCustom(controller);
 }
 
 void

Modified: trunk/src/input/input_manager_custom.cxx
===================================================================
--- trunk/src/input/input_manager_custom.cxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/input/input_manager_custom.cxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -23,9 +23,9 @@
 #include &lt;ClanLib/Display/display_iostream.h&gt;
 #include &lt;ClanLib/Display/keys.h&gt;
 
-#include &quot;../lispreader.hxx&quot;
-#include &quot;../assert.hxx&quot;
-#include &quot;../controller_def.hxx&quot;
+#include &quot;lisp/list_iterator.hpp&quot;
+#include &quot;assert.hxx&quot;
+#include &quot;controller_def.hxx&quot;
 #include &quot;input_button_input_device.hxx&quot;
 #include &quot;input_axis_input_device.hxx&quot;
 #include &quot;button_factory.hxx&quot;
@@ -33,9 +33,9 @@
 
 #include &quot;input_manager_custom.hxx&quot;
 
-InputManagerCustom::InputManagerCustom(lisp_object_t* lst)
+InputManagerCustom::InputManagerCustom(const lisp::Lisp* lisp)
 {
-  init(lst);
+  init(lisp);
 
   for (int i = 0; i &lt; (int)buttons.size(); ++i)
     {
@@ -66,39 +66,34 @@
 }
 
 void 
-InputManagerCustom::init(lisp_object_t* lst)
+InputManagerCustom::init(const lisp::Lisp* lisp)
 {
   buttons.resize(ControllerDef::get_button_count());
   axes.resize(ControllerDef::get_axis_count());
-  
-  while (lisp_cons_p(lst))
-    {
-      lisp_object_t* sym  = lisp_cxr(lst, &quot;aa&quot;);
-      lisp_object_t* data = lisp_cxr(lst, &quot;ada&quot;);
 
-      std::string name = lisp_symbol(sym);
+  lisp::ListIterator iter(lisp);
+  while(iter.next()) {
+    std::string name = iter.item();
 
-      int id = ControllerDef::button_name2id(name);
+    int id = ControllerDef::button_name2id(name);
+    if (id != -1)
+    {
+      buttons[id] = ButtonFactory::create(iter.lisp());
+    }
+    else
+    {
+      id = ControllerDef::axis_name2id(name);
       if (id != -1)
-        {
-          buttons[id] = ButtonFactory::create(data);
-        }
+      {
+        axes[id] = AxisFactory::create(iter.lisp());
+      }
       else
-        {
-          id = ControllerDef::axis_name2id(name);
-          if (id != -1)
-            {
-              axes[id] = AxisFactory::create(data);
-            }
-          else
-            {
-              std::cout &lt;&lt; &quot;# Warning: InputManagerCustom::init: Error unknown tag: &quot; &lt;&lt; std::endl;
-                //                        &lt;&lt; Guile::scm2string(sym) &lt;&lt; std::endl;
-            }
-        }
-
-      lst = lisp_cdr(lst);
+      {
+        std::cout &lt;&lt; &quot;# Warning: InputManagerCustom::init: Error unknown tag: &quot; &lt;&lt; std::endl;
+        //                        &lt;&lt; Guile::scm2string(sym) &lt;&lt; std::endl;
+      }
     }
+  }
 }  
 
 void

Modified: trunk/src/input/input_manager_custom.hxx
===================================================================
--- trunk/src/input/input_manager_custom.hxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/input/input_manager_custom.hxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -20,13 +20,13 @@
 #ifndef HEADER_INPUT_MANAGER_CUSTOM_HXX
 #define HEADER_INPUT_MANAGER_CUSTOM_HXX
 
-#include &quot;../lispreader.hxx&quot;
 #include &lt;ClanLib/Display/input_device.h&gt;
 #include &lt;ClanLib/Display/input_event.h&gt;
 #include &quot;input_event.hxx&quot;
 #include &quot;input_button.hxx&quot;
 #include &quot;input_axis.hxx&quot;
 #include &quot;input_manager_impl.hxx&quot;
+#include &quot;lisp/lisp.hpp&quot;
 
 /** */
 class InputManagerCustom : public InputManagerImpl
@@ -41,7 +41,7 @@
   Buttons buttons;
 
 public:
-  InputManagerCustom(lisp_object_t* lst);
+  InputManagerCustom(const lisp::Lisp* lisp);
   
   void update(float delta);
 
@@ -49,7 +49,7 @@
   void on_button_down(int name);
   void on_axis_move(float pos, int name);
 private:
-  void init(lisp_object_t* lst);
+  void init(const lisp::Lisp* lisp);
 
   InputManagerCustom (const InputManagerCustom&amp;);
   InputManagerCustom&amp; operator= (const InputManagerCustom&amp;);

Modified: trunk/src/input/input_manager_player.cxx
===================================================================
--- trunk/src/input/input_manager_player.cxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/input/input_manager_player.cxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -18,7 +18,6 @@
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 #include &lt;iostream&gt;
-#include &quot;../lispreader.hxx&quot;
 #include &quot;input_manager_player.hxx&quot;
 
 InputManagerPlayer::InputManagerPlayer(const std::string&amp; filename)
@@ -48,9 +47,10 @@
 }
 
 InputEvent
-InputManagerPlayer::scm2event(lisp_object_t* entry)
+InputManagerPlayer::scm2event(const lisp::Lisp* )
 {
   InputEvent event;
+#if 0
   lisp_object_t* sym  = lisp_car(entry);
   lisp_object_t* data = lisp_cdr(entry);
 
@@ -70,6 +70,7 @@
     {
       std::cout &lt;&lt; &quot;scm2event: Unknown sym: &quot; &lt;&lt; std::endl; //Guile::scm2string(sym) &lt;&lt; std::endl;
     }
+#endif
   return event;
 }
   

Modified: trunk/src/input/input_manager_player.hxx
===================================================================
--- trunk/src/input/input_manager_player.hxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/input/input_manager_player.hxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -22,8 +22,8 @@
 
 #include &lt;queue&gt;
 #include &lt;string&gt;
-#include &quot;../lispreader.hxx&quot;
 #include &quot;input_manager_impl.hxx&quot;
+#include &quot;lisp/lisp.hpp&quot;
 
 /** Playback class for events recorded my the InputRecorder */
 class InputManagerPlayer : public InputManagerImpl
@@ -44,7 +44,7 @@
   
   void update(float delta);
 private:
-  InputEvent scm2event(lisp_object_t* lst);
+  InputEvent scm2event(const lisp::Lisp* lisp);
 
   InputManagerPlayer (const InputManagerPlayer&amp;);
   InputManagerPlayer&amp; operator= (const InputManagerPlayer&amp;);

Deleted: trunk/src/lispreader.cxx
===================================================================
--- trunk/src/lispreader.cxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/lispreader.cxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -1,1403 +0,0 @@
-/* $Id: lispreader.cpp,v 1.19 2004/05/11 22:16:12 sik0fewl Exp $ */
-/*
- * lispreader.c
- *
- * Copyright (C) 1998-2000 Mark Probst
- * Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include &lt;iostream&gt;
-#include &lt;string&gt;
-#include &lt;ctype.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ClanLib/Core/System/clanstring.h&gt;
-#include &lt;ClanLib/Core/Math/cl_vector.h&gt;
-#include &quot;lispreader.hxx&quot;
-
-#define TOKEN_ERROR                   -1
-#define TOKEN_EOF                     0
-#define TOKEN_OPEN_PAREN              1
-#define TOKEN_CLOSE_PAREN             2
-#define TOKEN_SYMBOL                  3
-#define TOKEN_STRING                  4
-#define TOKEN_INTEGER                 5
-#define TOKEN_REAL                    6
-#define TOKEN_PATTERN_OPEN_PAREN      7
-#define TOKEN_DOT                     8
-#define TOKEN_TRUE                    9
-#define TOKEN_FALSE                   10
-
-
-#define MAX_TOKEN_LENGTH           1024
-
-static char token_string[MAX_TOKEN_LENGTH + 1] = &quot;&quot;;
-static int token_length = 0;
-
-static lisp_object_t end_marker = { LISP_TYPE_EOF, {{0, 0}} };
-static lisp_object_t error_object = { LISP_TYPE_PARSE_ERROR , {{0,0}}  };
-static lisp_object_t close_paren_marker = { LISP_TYPE_PARSE_ERROR , {{0,0}}  };
-static lisp_object_t dot_marker = { LISP_TYPE_PARSE_ERROR , {{0,0}} };
-
-static void
-_token_clear (void)
-{
-  token_string[0] = '\0';
-  token_length = 0;
-}
-
-static void
-_token_append (char c)
-{
-  if (token_length &gt;= MAX_TOKEN_LENGTH)
-    throw LispReaderException(&quot;_token_append()&quot;, __FILE__, __LINE__);
-
-  token_string[token_length++] = c;
-  token_string[token_length] = '\0';
-}
-
-static int
-_next_char (lisp_stream_t *stream)
-{
-  switch (stream-&gt;type)
-    {
-    case LISP_STREAM_FILE :
-      return getc(stream-&gt;v.file);
-
-    case LISP_STREAM_STRING :
-      {
-        char c = stream-&gt;v.string.buf[stream-&gt;v.string.pos];
-
-        if (c == 0)
-          return EOF;
-
-        ++stream-&gt;v.string.pos;
-
-        return c;
-      }
-
-    case LISP_STREAM_ANY:
-      return stream-&gt;v.any.next_char(stream-&gt;v.any.data);
-    }
-
-  throw LispReaderException(&quot;_next_char()&quot;, __FILE__, __LINE__);
-  return EOF;
-}
-
-static void
-_unget_char (char c, lisp_stream_t *stream)
-{
-  switch (stream-&gt;type)
-    {
-    case LISP_STREAM_FILE :
-      ungetc(c, stream-&gt;v.file);
-      break;
-
-    case LISP_STREAM_STRING :
-      --stream-&gt;v.string.pos;
-      break;
-
-    case LISP_STREAM_ANY:
-      stream-&gt;v.any.unget_char(c, stream-&gt;v.any.data);
-      break;
-
-    default :
-      throw LispReaderException(&quot;_unget_char()&quot;, __FILE__, __LINE__);
-    }
-}
-
-static int
-_scan (lisp_stream_t *stream)
-{
-  static char *delims = &quot;\&quot;();&quot;;
-
-  int c;
-
-  _token_clear();
-
-  do
-    {
-      c = _next_char(stream);
-      if (c == EOF)
-        return TOKEN_EOF;
-      else if (c == ';')     	 /* comment start */
-        while (1)
-          {
-            c = _next_char(stream);
-            if (c == EOF)
-              return TOKEN_EOF;
-            else if (c == '\n')
-              break;
-          }
-    }
-  while (isspace(c));
-
-  switch (c)
-    {
-    case '(' :
-      return TOKEN_OPEN_PAREN;
-
-    case ')' :
-      return TOKEN_CLOSE_PAREN;
-
-    case '&quot;' :
-      while (1)
-        {
-          c = _next_char(stream);
-          if (c == EOF)
-            return TOKEN_ERROR;
-          if (c == '&quot;')
-            break;
-          if (c == '\\')
-            {
-              c = _next_char(stream);
-
-              switch (c)
-                {
-                case EOF :
-                  return TOKEN_ERROR;
-
-                case 'n' :
-                  c = '\n';
-                  break;
-
-                case 't' :
-                  c = '\t';
-                  break;
-                }
-            }
-
-          _token_append(c);
-        }
-      return TOKEN_STRING;
-
-    case '#' :
-      c = _next_char(stream);
-      if (c == EOF)
-        return TOKEN_ERROR;
-
-      switch (c)
-        {
-        case 't' :
-          return TOKEN_TRUE;
-
-        case 'f' :
-          return TOKEN_FALSE;
-
-        case '?' :
-          c = _next_char(stream);
-          if (c == EOF)
-            return TOKEN_ERROR;
-
-          if (c == '(')
-            return TOKEN_PATTERN_OPEN_PAREN;
-          else
-            return TOKEN_ERROR;
-        }
-      return TOKEN_ERROR;
-
-    default :
-      if (isdigit(c) || c == '-')
-        {
-          int have_nondigits = 0;
-          int have_digits = 0;
-          int have_floating_point = 0;
-
-          do
-            {
-              if (isdigit(c))
-                have_digits = 1;
-              else if (c == '.')
-                have_floating_point++;
-              _token_append(c);
-
-              c = _next_char(stream);
-
-              if (c != EOF &amp;&amp; !isdigit(c) &amp;&amp; !isspace(c) &amp;&amp; c != '.' &amp;&amp; !strchr(delims, c))
-                have_nondigits = 1;
-            }
-          while (c != EOF &amp;&amp; !isspace(c) &amp;&amp; !strchr(delims, c));
-
-          if (c != EOF)
-            _unget_char(c, stream);
-
-          if (have_nondigits || !have_digits || have_floating_point &gt; 1)
-            return TOKEN_SYMBOL;
-          else if (have_floating_point == 1)
-            return TOKEN_REAL;
-          else
-            return TOKEN_INTEGER;
-        }
-      else
-        {
-          if (c == '.')
-            {
-              c = _next_char(stream);
-              if (c != EOF &amp;&amp; !isspace(c) &amp;&amp; !strchr(delims, c))
-                _token_append('.');
-              else
-                {
-                  _unget_char(c, stream);
-                  return TOKEN_DOT;
-                }
-            }
-          do
-            {
-              _token_append(c);
-              c = _next_char(stream);
-            }
-          while (c != EOF &amp;&amp; !isspace(c) &amp;&amp; !strchr(delims, c));
-          if (c != EOF)
-            _unget_char(c, stream);
-
-          return TOKEN_SYMBOL;
-        }
-    }
-
-  throw LispReaderException(&quot;_scan()&quot;, __FILE__, __LINE__);
-  return TOKEN_ERROR;
-}
-
-static lisp_object_t*
-lisp_object_alloc (int type)
-{
-  lisp_object_t *obj = (lisp_object_t*)malloc(sizeof(lisp_object_t));
-
-  obj-&gt;type = type;
-
-  return obj;
-}
-
-lisp_stream_t*
-lisp_stream_init_file (lisp_stream_t *stream, FILE *file)
-{
-  stream-&gt;type = LISP_STREAM_FILE;
-  stream-&gt;v.file = file;
-
-  return stream;
-}
-
-lisp_stream_t*
-lisp_stream_init_string (lisp_stream_t *stream, char *buf)
-{
-  stream-&gt;type = LISP_STREAM_STRING;
-  stream-&gt;v.string.buf = buf;
-  stream-&gt;v.string.pos = 0;
-
-  return stream;
-}
-
-lisp_stream_t*
-lisp_stream_init_any (lisp_stream_t *stream, void *data,
-                      int (*next_char) (void *data),
-                      void (*unget_char) (char c, void *data))
-{
-  if (next_char == 0 || unget_char == 0)
-    throw LispReaderException(&quot;lisp_stream_init_any()&quot;, __FILE__, __LINE__);
-
-  stream-&gt;type = LISP_STREAM_ANY;
-  stream-&gt;v.any.data = data;
-  stream-&gt;v.any.next_char= next_char;
-  stream-&gt;v.any.unget_char = unget_char;
-
-  return stream;
-}
-
-lisp_object_t*
-lisp_make_integer (int value)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_INTEGER);
-
-  obj-&gt;v.integer = value;
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_make_real (float value)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_REAL);
-
-  obj-&gt;v.real = value;
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_make_symbol (const char *value)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_SYMBOL);
-
-  obj-&gt;v.string = strdup(value);
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_make_string (const char *value)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_STRING);
-
-  obj-&gt;v.string = strdup(value);
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_make_cons (lisp_object_t *car, lisp_object_t *cdr)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_CONS);
-
-  obj-&gt;v.cons.car = car;
-  obj-&gt;v.cons.cdr = cdr;
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_make_boolean (int value)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_BOOLEAN);
-
-  obj-&gt;v.integer = value ? 1 : 0;
-
-  return obj;
-}
-
-static lisp_object_t*
-lisp_make_pattern_cons (lisp_object_t *car, lisp_object_t *cdr)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_PATTERN_CONS);
-
-  obj-&gt;v.cons.car = car;
-  obj-&gt;v.cons.cdr = cdr;
-
-  return obj;
-}
-
-static lisp_object_t*
-lisp_make_pattern_var (int type, int index, lisp_object_t *sub)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_PATTERN_VAR);
-
-  obj-&gt;v.pattern.type = type;
-  obj-&gt;v.pattern.index = index;
-  obj-&gt;v.pattern.sub = sub;
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_read (lisp_stream_t *in)
-{
-  int token = _scan(in);
-  lisp_object_t *obj = lisp_nil();
-
-  if (token == TOKEN_EOF)
-    return &amp;end_marker;
-
-  switch (token)
-    {
-    case TOKEN_ERROR :
-      return &amp;error_object;
-
-    case TOKEN_EOF :
-      return &amp;end_marker;
-
-    case TOKEN_OPEN_PAREN :
-    case TOKEN_PATTERN_OPEN_PAREN :
-      {
-        lisp_object_t *last = lisp_nil(), *car;
-
-        do
-          {
-            car = lisp_read(in);
-            if (car == &amp;error_object || car == &amp;end_marker)
-              {
-                lisp_free(obj);
-                return &amp;error_object;
-              }
-            else if (car == &amp;dot_marker)
-              {
-                if (lisp_nil_p(last))
-                  {
-                    lisp_free(obj);
-                    return &amp;error_object;
-                  }
-
-                car = lisp_read(in);
-                if (car == &amp;error_object || car == &amp;end_marker)
-                  {
-                    lisp_free(obj);
-                    return car;
-                  }
-                else
-                  {
-                    last-&gt;v.cons.cdr = car;
-
-                    if (_scan(in) != TOKEN_CLOSE_PAREN)
-                      {
-                        lisp_free(obj);
-                        return &amp;error_object;
-                      }
-
-                    car = &amp;close_paren_marker;
-                  }
-              }
-            else if (car != &amp;close_paren_marker)
-              {
-                if (lisp_nil_p(last))
-                  obj = last = (token == TOKEN_OPEN_PAREN ? lisp_make_cons(car, lisp_nil()) : lisp_make_pattern_cons(car, lisp_nil()));
-                else
-                  last = last-&gt;v.cons.cdr = lisp_make_cons(car, lisp_nil());
-              }
-          }
-        while (car != &amp;close_paren_marker);
-      }
-      return obj;
-
-    case TOKEN_CLOSE_PAREN :
-      return &amp;close_paren_marker;
-
-    case TOKEN_SYMBOL :
-      return lisp_make_symbol(token_string);
-
-    case TOKEN_STRING :
-      return lisp_make_string(token_string);
-
-    case TOKEN_INTEGER :
-      return lisp_make_integer(atoi(token_string));
-
-    case TOKEN_REAL :
-      return lisp_make_real((float)atof(token_string));
-
-    case TOKEN_DOT :
-      return &amp;dot_marker;
-
-    case TOKEN_TRUE :
-      return lisp_make_boolean(1);
-
-    case TOKEN_FALSE :
-      return lisp_make_boolean(0);
-    }
-
-  throw LispReaderException(&quot;lisp_read()&quot;, __FILE__, __LINE__);
-  return &amp;error_object;
-}
-
-void
-lisp_free (lisp_object_t *obj)
-{
-  if (obj == 0)
-    return;
-
-  switch (obj-&gt;type)
-    {
-    case LISP_TYPE_INTERNAL :
-    case LISP_TYPE_PARSE_ERROR :
-    case LISP_TYPE_EOF :
-      return;
-
-    case LISP_TYPE_SYMBOL :
-    case LISP_TYPE_STRING :
-      free(obj-&gt;v.string);
-      break;
-
-    case LISP_TYPE_CONS :
-    case LISP_TYPE_PATTERN_CONS :
-      lisp_free(obj-&gt;v.cons.car);
-      lisp_free(obj-&gt;v.cons.cdr);
-      break;
-
-    case LISP_TYPE_PATTERN_VAR :
-      lisp_free(obj-&gt;v.pattern.sub);
-      break;
-    }
-
-  free(obj);
-}
-
-lisp_object_t*
-lisp_read_from_string (const char *buf)
-{
-  lisp_stream_t stream;
-
-  lisp_stream_init_string(&amp;stream, (char*)buf);
-  return lisp_read(&amp;stream);
-}
-
-static int
-_compile_pattern (lisp_object_t **obj, int *index)
-{
-  if (*obj == 0)
-    return 1;
-
-  switch (lisp_type(*obj))
-    {
-    case LISP_TYPE_PATTERN_CONS :
-      {
-        struct
-          {
-            char *name;
-            int type;
-          }
-        types[] =
-          {
-            { &quot;any&quot;, LISP_PATTERN_ANY },
-            { &quot;symbol&quot;, LISP_PATTERN_SYMBOL },
-            { &quot;string&quot;, LISP_PATTERN_STRING },
-            { &quot;integer&quot;, LISP_PATTERN_INTEGER },
-            { &quot;real&quot;, LISP_PATTERN_REAL },
-            { &quot;boolean&quot;, LISP_PATTERN_BOOLEAN },
-            { &quot;list&quot;, LISP_PATTERN_LIST },
-            { &quot;or&quot;, LISP_PATTERN_OR },
-            { 0, 0 }
-          };
-        char *type_name;
-        int type;
-        int i;
-        lisp_object_t *pattern;
-        type = -1;
-	
-        if (lisp_type(lisp_car(*obj)) != LISP_TYPE_SYMBOL)
-          return 0;
-
-        type_name = lisp_symbol(lisp_car(*obj));
-        for (i = 0; types[i].name != 0; ++i)
-          {
-            if (strcmp(types[i].name, type_name) == 0)
-              {
-                type = types[i].type;
-                break;
-              }
-          }
-
-        if (types[i].name == 0)
-          return 0;
-
-        if (type != LISP_PATTERN_OR &amp;&amp; lisp_cdr(*obj) != 0)
-          return 0;
-
-        pattern = lisp_make_pattern_var(type, (*index)++, lisp_nil());
-
-        if (type == LISP_PATTERN_OR)
-          {
-            lisp_object_t *cdr = lisp_cdr(*obj);
-
-            if (!_compile_pattern(&amp;cdr, index))
-              {
-                lisp_free(pattern);
-                return 0;
-              }
-
-            pattern-&gt;v.pattern.sub = cdr;
-
-            (*obj)-&gt;v.cons.cdr = lisp_nil();
-          }
-
-        lisp_free(*obj);
-
-        *obj = pattern;
-      }
-      break;
-
-    case LISP_TYPE_CONS :
-      if (!_compile_pattern(&amp;(*obj)-&gt;v.cons.car, index))
-        return 0;
-      if (!_compile_pattern(&amp;(*obj)-&gt;v.cons.cdr, index))
-        return 0;
-      break;
-    }
-
-  return 1;
-}
-
-int
-lisp_compile_pattern (lisp_object_t **obj, int *num_subs)
-{
-  int index = 0;
-  int result;
-
-  result = _compile_pattern(obj, &amp;index);
-
-  if (result &amp;&amp; num_subs != 0)
-    *num_subs = index;
-
-  return result;
-}
-
-static int _match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars);
-
-static int
-_match_pattern_var (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars)
-{
-  if (lisp_type(pattern) != LISP_TYPE_PATTERN_VAR)
-    throw LispReaderException(&quot;_match_pattern_var&quot;, __FILE__, __LINE__);
-
-  switch (pattern-&gt;v.pattern.type)
-    {
-    case LISP_PATTERN_ANY :
-      break;
-
-    case LISP_PATTERN_SYMBOL :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_SYMBOL)
-        return 0;
-      break;
-
-    case LISP_PATTERN_STRING :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_STRING)
-        return 0;
-      break;
-
-    case LISP_PATTERN_INTEGER :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_INTEGER)
-        return 0;
-      break;
-
-    case LISP_PATTERN_REAL :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_REAL)
-        return 0;
-      break;
-
-    case LISP_PATTERN_BOOLEAN :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_BOOLEAN)
-        return 0;
-      break;
-
-    case LISP_PATTERN_LIST :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_CONS)
-        return 0;
-      break;
-
-    case LISP_PATTERN_OR :
-      {
-        lisp_object_t *sub;
-        int matched = 0;
-
-        for (sub = pattern-&gt;v.pattern.sub; sub != 0; sub = lisp_cdr(sub))
-          {
-            if (lisp_type(sub) != LISP_TYPE_CONS)
-              throw LispReaderException(&quot;_match_pattern_var()&quot;, __FILE__, __LINE__);
-
-            if (_match_pattern(lisp_car(sub), obj, vars))
-              matched = 1;
-          }
-
-        if (!matched)
-          return 0;
-      }
-      break;
-
-    default :
-      throw LispReaderException(&quot;_match_pattern_var()&quot;, __FILE__, __LINE__);
-    }
-
-  if (vars != 0)
-    vars[pattern-&gt;v.pattern.index] = obj;
-
-  return 1;
-}
-
-static int
-_match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars)
-{
-  if (pattern == 0)
-    return obj == 0;
-
-  if (obj == 0)
-    return 0;
-
-  if (lisp_type(pattern) == LISP_TYPE_PATTERN_VAR)
-    return _match_pattern_var(pattern, obj, vars);
-
-  if (lisp_type(pattern) != lisp_type(obj))
-    return 0;
-
-  switch (lisp_type(pattern))
-    {
-    case LISP_TYPE_SYMBOL :
-      return strcmp(lisp_symbol(pattern), lisp_symbol(obj)) == 0;
-
-    case LISP_TYPE_STRING :
-      return strcmp(lisp_string(pattern), lisp_string(obj)) == 0;
-
-    case LISP_TYPE_INTEGER :
-      return lisp_integer(pattern) == lisp_integer(obj);
-
-    case LISP_TYPE_REAL :
-      return lisp_real(pattern) == lisp_real(obj);
-
-    case LISP_TYPE_CONS :
-      {
-        int result1, result2;
-
-        result1 = _match_pattern(lisp_car(pattern), lisp_car(obj), vars);
-        result2 = _match_pattern(lisp_cdr(pattern), lisp_cdr(obj), vars);
-
-        return result1 &amp;&amp; result2;
-      }
-      break;
-
-    default :
-      throw LispReaderException(&quot;_match_pattern()&quot;, __FILE__, __LINE__);
-    }
-
-  return 0;
-}
-
-int
-lisp_match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars, int num_subs)
-{
-  int i;
-
-  if (vars != 0)
-    for (i = 0; i &lt; num_subs; ++i)
-      vars[i] = &amp;error_object;
-
-  return _match_pattern(pattern, obj, vars);
-}
-
-int
-lisp_match_string (const char *pattern_string, lisp_object_t *obj, lisp_object_t **vars)
-{
-  lisp_object_t *pattern;
-  int result;
-  int num_subs;
-
-  pattern = lisp_read_from_string(pattern_string);
-
-  if (pattern != 0 &amp;&amp; (lisp_type(pattern) == LISP_TYPE_EOF
-                       || lisp_type(pattern) == LISP_TYPE_PARSE_ERROR))
-    return 0;
-
-  if (!lisp_compile_pattern(&amp;pattern, &amp;num_subs))
-    {
-      lisp_free(pattern);
-      return 0;
-    }
-
-  result = lisp_match_pattern(pattern, obj, vars, num_subs);
-
-  lisp_free(pattern);
-
-  return result;
-}
-
-int
-lisp_type (lisp_object_t *obj)
-{
-  if (obj == 0)
-    return LISP_TYPE_NIL;
-  return obj-&gt;type;
-}
-
-int
-lisp_integer (lisp_object_t *obj)
-{
-  if (obj-&gt;type != LISP_TYPE_INTEGER)
-    throw LispReaderException(&quot;lisp_integer()&quot;, __FILE__, __LINE__);
-
-  return obj-&gt;v.integer;
-}
-
-char*
-lisp_symbol (lisp_object_t *obj)
-{
-  if (obj-&gt;type != LISP_TYPE_SYMBOL)
-    throw LispReaderException(&quot;lisp_symbol()&quot;, __FILE__, __LINE__);
-
-  return obj-&gt;v.string;
-}
-
-char*
-lisp_string (lisp_object_t *obj)
-{
-  if (obj-&gt;type != LISP_TYPE_STRING)
-    throw LispReaderException(&quot;lisp_string()&quot;, __FILE__, __LINE__);
-
-  return obj-&gt;v.string;
-}
-
-int
-lisp_boolean (lisp_object_t *obj)
-{
-  if (obj-&gt;type != LISP_TYPE_BOOLEAN)
-    throw LispReaderException(&quot;lisp_boolean()&quot;, __FILE__, __LINE__);
-
-  return obj-&gt;v.integer;
-}
-
-float
-lisp_real (lisp_object_t *obj)
-{
-  if (obj-&gt;type != LISP_TYPE_REAL &amp;&amp; obj-&gt;type != LISP_TYPE_INTEGER)
-    throw LispReaderException(&quot;lisp_real()&quot;, __FILE__, __LINE__);
-
-  if (obj-&gt;type == LISP_TYPE_INTEGER)
-    return obj-&gt;v.integer;
-  return obj-&gt;v.real;
-}
-
-lisp_object_t*
-lisp_car (lisp_object_t *obj)
-{
-  if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
-    throw LispReaderException(&quot;lisp_car()&quot;, __FILE__, __LINE__);
-
-  return obj-&gt;v.cons.car;
-}
-
-lisp_object_t*
-lisp_cdr (lisp_object_t *obj)
-{
-  if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
-    throw LispReaderException(&quot;lisp_cdr()&quot;, __FILE__, __LINE__);
-
-  return obj-&gt;v.cons.cdr;
-}
-
-lisp_object_t*
-lisp_cxr (lisp_object_t *obj, const char *x)
-{
-  int i;
-
-  for (i = strlen(x) - 1; i &gt;= 0; --i)
-    if (x[i] == 'a')
-      obj = lisp_car(obj);
-    else if (x[i] == 'd')
-      obj = lisp_cdr(obj);
-    else
-      throw LispReaderException(&quot;lisp_cxr()&quot;, __FILE__, __LINE__);
-
-  return obj;
-}
-
-int
-lisp_list_length (lisp_object_t *obj)
-{
-  int length = 0;
-
-  while (obj != 0)
-    {
-      if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
-        throw LispReaderException(&quot;lisp_list_length()&quot;, __FILE__, __LINE__);
-
-      ++length;
-      obj = obj-&gt;v.cons.cdr;
-    }
-
-  return length;
-}
-
-lisp_object_t*
-lisp_list_nth_cdr (lisp_object_t *obj, int index)
-{
-  while (index &gt; 0)
-    {
-      if (obj == 0)
-        throw LispReaderException(&quot;lisp_list_nth_cdr()&quot;, __FILE__, __LINE__);
-      if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
-        throw LispReaderException(&quot;lisp_list_nth_cdr()&quot;, __FILE__, __LINE__);
-
-      --index;
-      obj = obj-&gt;v.cons.cdr;
-    }
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_list_nth (lisp_object_t *obj, int index)
-{
-  obj = lisp_list_nth_cdr(obj, index);
-
-  if (obj == 0)
-    throw LispReaderException(&quot;lisp_list_nth()&quot;, __FILE__, __LINE__);
-
-  return obj-&gt;v.cons.car;
-}
-
-void
-lisp_dump (lisp_object_t *obj, FILE *out)
-{
-  if (obj == 0)
-    {
-      fprintf(out, &quot;()&quot;);
-      return;
-    }
-
-  switch (lisp_type(obj))
-    {
-    case LISP_TYPE_EOF :
-      fputs(&quot;#&lt;eof&gt;&quot;, out);
-      break;
-
-    case LISP_TYPE_PARSE_ERROR :
-      fputs(&quot;#&lt;error&gt;&quot;, out);
-      break;
-
-    case LISP_TYPE_INTEGER :
-      fprintf(out, &quot;%d&quot;, lisp_integer(obj));
-      break;
-
-    case LISP_TYPE_REAL :
-      fprintf(out, &quot;%f&quot;, lisp_real(obj));
-      break;
-
-    case LISP_TYPE_SYMBOL :
-      fputs(lisp_symbol(obj), out);
-      break;
-
-    case LISP_TYPE_STRING :
-      {
-        char *p;
-
-        fputc('&quot;', out);
-        for (p = lisp_string(obj); *p != 0; ++p)
-          {
-            if (*p == '&quot;' || *p == '\\')
-              fputc('\\', out);
-            fputc(*p, out);
-          }
-        fputc('&quot;', out);
-      }
-      break;
-
-    case LISP_TYPE_CONS :
-    case LISP_TYPE_PATTERN_CONS :
-      fputs(lisp_type(obj) == LISP_TYPE_CONS ? &quot;(&quot; : &quot;#?(&quot;, out);
-      while (obj != 0)
-        {
-          lisp_dump(lisp_car(obj), out);
-          obj = lisp_cdr(obj);
-          if (obj != 0)
-            {
-              if (lisp_type(obj) != LISP_TYPE_CONS
-                  &amp;&amp; lisp_type(obj) != LISP_TYPE_PATTERN_CONS)
-                {
-                  fputs(&quot; . &quot;, out);
-                  lisp_dump(obj, out);
-                  break;
-                }
-              else
-                fputc(' ', out);
-            }
-        }
-      fputc(')', out);
-      break;
-
-    case LISP_TYPE_BOOLEAN :
-      if (lisp_boolean(obj))
-        fputs(&quot;#t&quot;, out);
-      else
-        fputs(&quot;#f&quot;, out);
-      break;
-
-    default :
-      throw LispReaderException(&quot;lisp_dump()&quot;, __FILE__, __LINE__);
-    }
-}
-
-using namespace std;
-
-LispReader::LispReader (lisp_object_t* l)
-    : lst (l)
-{
-  //std::cout &lt;&lt; &quot;LispReader: &quot; &lt;&lt; std::flush;
-  //lisp_dump(lst, stdout);
-  //std::cout &lt;&lt; std::endl;
-}
-
-lisp_object_t*
-LispReader::get(const char* name)
-{
-  //std::cout &lt;&lt; &quot;LispReader::get(&quot; &lt;&lt; name &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
-  lisp_object_t* cursor = lst;
-
-  while(!lisp_nil_p(cursor))
-    {
-      lisp_object_t* cur = lisp_car(cursor);
-
-      if (!lisp_cons_p(cur) || !lisp_symbol_p (lisp_car(cur)))
-        {
-          lisp_dump(cur, stdout);
-          //throw ConstruoError (std::string(&quot;LispReader: Read error in get &quot;) + name);
-	  printf(&quot;LispReader: Read error in search\n&quot;);
-        }
-      else
-        {
-          if (strcmp(lisp_symbol(lisp_car(cur)), name) == 0)
-            {
-              return lisp_cdr(cur);
-            }
-        }
-
-      cursor = lisp_cdr (cursor);
-    }
-  return 0;
-}
-
-bool
-LispReader::read_int (const char* name, int* i)
-{
-  lisp_object_t* obj = get (name);
-  if (obj)
-    {
-      if (!lisp_integer_p(lisp_car(obj)))
-      {
-        //st_abort(&quot;LispReader expected type integer at token: &quot;, name); /* Instead of giving up, we return with false now. */
-	return false;
-	}
-      *i = lisp_integer(lisp_car(obj));
-      return true;
-    }
-  return false;
-}
-
-bool
-LispReader::read_lisp(const char* name, lisp_object_t** b)
-{
-  lisp_object_t* obj = get (name);
-  if (obj)
-    {
-      *b = obj;
-      return true;
-    }
-  else
-    return false;
-}
-
-bool
-LispReader::read_vector (const char* name, CL_Vector* f)
-{
-  lisp_object_t* obj = get (name);
-  if (obj)
-    {
-      if (!lisp_real_p(lisp_car(obj)) &amp;&amp; !lisp_integer_p(lisp_car(obj)))
-        throw LispReaderException(&quot;LispReader expected type 3 reals at token: &quot;,
-                                  __FILE__, __LINE__);
-      f-&gt;x = lisp_real(lisp_list_nth(obj, 0));
-      f-&gt;y = lisp_real(lisp_list_nth(obj, 1));
-      f-&gt;z = lisp_real(lisp_list_nth(obj, 2));
-      return true;
-    }
-  return false; 
-}
-
-bool
-LispReader::read_float (const char* name, float* f)
-{
-  lisp_object_t* obj = get (name);
-  if (obj)
-    {
-      if (!lisp_real_p(lisp_car(obj)) &amp;&amp; !lisp_integer_p(lisp_car(obj)))
-        throw LispReaderException(&quot;LispReader expected type real at token: &quot;,
-                                  __FILE__, __LINE__);
-      *f = lisp_real(lisp_car(obj));
-      return true;
-    }
-  return false;
-}
-
-bool
-LispReader::read_string_vector (const char* name, std::vector&lt;std::string&gt;* vec)
-{
-  lisp_object_t* obj = get (name);
-  if (obj)
-    {
-      vec-&gt;clear();
-  
-      while(!lisp_nil_p(obj))
-        {
-          if (!lisp_string_p(lisp_car(obj)))
-            throw LispReaderException(&quot;LispReader expected type string at token: &quot;, name);
-          vec-&gt;push_back(lisp_string(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
-    }
-  return false;    
-}
-
-bool
-LispReader::read_unsigned_char_vector (const char* name, std::vector&lt;unsigned char&gt;* vec)
-{
-  lisp_object_t* obj = get (name);
-  if (obj)
-    {
-      vec-&gt;clear();
-
-      while(!lisp_nil_p(obj))
-        {
-          if (!lisp_integer_p(lisp_car(obj)))
-            throw LispReaderException(&quot;LispReader expected type integer at token: &quot;, name);
-          vec-&gt;push_back(lisp_integer(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
-    }
-  return false;    
-}
-
-bool
-LispReader::read_int_vector (const char* name, std::vector&lt;int&gt;* vec)
-{
-  lisp_object_t* obj = get (name);
-  if (obj)
-    {
-      vec-&gt;clear();
-
-      while(!lisp_nil_p(obj))
-        {
-          if (!lisp_integer_p(lisp_car(obj)))
-            throw LispReaderException(&quot;LispReader expected type integer at token: &quot;, name);
-          vec-&gt;push_back(lisp_integer(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
-    }
-  return false;    
-}
-
-bool
-LispReader::read_char_vector (const char* name, std::vector&lt;char&gt;* vec)
-{
-  lisp_object_t* obj = get (name);
-  if (obj)
-    {
-      vec-&gt;clear();
-
-      while(!lisp_nil_p(obj))
-        {
-          vec-&gt;push_back(*lisp_string(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
-    }
-  return false;    
-}
-
-bool
-LispReader::read_string (const char* name, std::string* str)
-{
-  lisp_object_t* obj = get (name);
-  if (obj)
-    {
-      if (!lisp_string_p(lisp_car(obj)))
-        throw LispReaderException(&quot;LispReader expected type string at token: &quot;, name);
-     *str = lisp_string(lisp_car(obj));
-      return true;
-    }
-  return false;  
-}
-
-bool
-LispReader::read_bool (const char* name, bool* b)
-{
-  lisp_object_t* obj = get (name);
-  if (obj)
-    {
-      if (!lisp_boolean_p(lisp_car(obj)))
-        throw LispReaderException(&quot;LispReader expected type bool at token: &quot;);
-      *b = lisp_boolean(lisp_car(obj));
-      return true;
-    }
-  return false;
-}
-
-LispWriter::LispWriter (const char* name)
-{
-  lisp_objs.push_back(lisp_make_symbol (name));
-}
-
-void
-LispWriter::append (lisp_object_t* obj)
-{
-  lisp_objs.push_back(obj);
-}
-
-lisp_object_t*
-LispWriter::make_list3 (lisp_object_t* a, lisp_object_t* b, lisp_object_t* c)
-{
-  return lisp_make_cons (a, lisp_make_cons(b, lisp_make_cons(c, lisp_nil())));
-}
-
-lisp_object_t*
-LispWriter::make_list2 (lisp_object_t* a, lisp_object_t* b)
-{
-  return lisp_make_cons (a, lisp_make_cons(b, lisp_nil()));
-}
-
-void
-LispWriter::write_float (const char* name, float f)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lisp_make_real(f)));
-}
-
-void
-LispWriter::write_int (const char* name, int i)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lisp_make_integer(i)));
-}
-
-void
-LispWriter::write_string (const char* name, const char* str)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lisp_make_string(str)));
-}
-
-void
-LispWriter::write_symbol (const char* name, const char* symname)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lisp_make_symbol(symname)));
-}
-
-void
-LispWriter::write_lisp_obj(const char* name, lisp_object_t* lst)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lst));
-}
-
-void
-LispWriter::write_boolean (const char* name, bool b)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lisp_make_boolean(b)));
-}
-
-lisp_object_t*
-LispWriter::create_lisp ()
-{
-  lisp_object_t* lisp_obj = lisp_nil();
-
-  for(std::vector&lt;lisp_object_t*&gt;::reverse_iterator i = lisp_objs.rbegin ();
-      i != lisp_objs.rend (); ++i)
-    {
-      lisp_obj = lisp_make_cons (*i, lisp_obj);
-    }
-  lisp_objs.clear();
-
-  return lisp_obj;
-}
-
-#if 0
-void mygzungetc(char c, void* file)
-{
-  gzungetc(c, file);
-}
-
-lisp_stream_t* lisp_stream_init_gzfile (lisp_stream_t *stream, gzFile file)
-{
-  return lisp_stream_init_any (stream, file, gzgetc, mygzungetc);
-}
-#endif
-
-lisp_object_t* lisp_read_from_gzfile(const char* filename)
-{
-  bool done = false;
-  lisp_object_t* root_obj = 0;
-  int chunk_size = 128 * 1024;
-  int buf_pos = 0;
-  int try_number = 1;
-  char* buf = static_cast&lt;char*&gt;(malloc(chunk_size));
-  if (!buf)
-    throw LispReaderException(&quot;lisp_read_from_gzfile()&quot;, __FILE__, __LINE__);
-
-  gzFile in = gzopen(filename, &quot;r&quot;);
-
-  while (!done)
-    {
-      int ret = gzread(in, buf + buf_pos, chunk_size);
-      if (ret == -1)
-        {
-          free (buf);
-          throw LispReaderException(&quot;Error while reading from file&quot;, __FILE__, __LINE__);
-        }
-      else if (ret == chunk_size) // buffer got full, eof not yet there so resize
-        {
-          buf_pos = chunk_size * try_number;
-          try_number += 1;
-          buf = static_cast&lt;char*&gt;(realloc(buf, chunk_size * try_number));
-
-          if (!buf)
-            throw LispReaderException(&quot;lisp_read_from_gzfile()&quot;, __FILE__, __LINE__);
-        }
-      else 
-        {
-          // everything fine, encountered EOF 
-          done = true;
-        }
-    }
-      
-  lisp_stream_t stream;
-  lisp_stream_init_string (&amp;stream, buf);
-  root_obj = lisp_read (&amp;stream);
-      
-  free(buf);
-  gzclose(in);
-
-  return root_obj;
-}
-
-bool has_suffix(const char* data, const char* suffix)
-{
-  int suffix_len = strlen(suffix);
-  int data_len   = strlen(data);
-  
-  const char* data_suffix = (data + data_len - suffix_len);
-
-  if (data_suffix &gt;= data)
-    {
-      return (strcmp(data_suffix, suffix) == 0);
-    }
-  else
-    {
-      return false;
-    }
-}
-
-lisp_object_t* lisp_read_from_file(const std::string&amp; filename)
-{
-  lisp_stream_t stream;
-
-  if (CL_String::get_extension(filename) == &quot;gz&quot;)
-    {
-      return lisp_read_from_gzfile(filename.c_str());
-    }
-  else
-    {
-      lisp_object_t* obj = 0;
-      FILE* in = fopen(filename.c_str(), &quot;r&quot;);
-
-      if (in)
-        {
-          lisp_stream_init_file(&amp;stream, in);
-          obj = lisp_read(&amp;stream);
-          fclose(in);
-        }
-
-      return obj;
-    }
-}
-
-// EOF //

Deleted: trunk/src/lispreader.hxx
===================================================================
--- trunk/src/lispreader.hxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/lispreader.hxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -1,229 +0,0 @@
-/* $Id: lispreader.h,v 1.9 2004/05/11 22:16:12 sik0fewl Exp $ */
-/*
- * lispreader.h
- *
- * Copyright (C) 1998-2000 Mark Probst
- * Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __LISPREADER_H__
-#define __LISPREADER_H__
-
-#include &lt;stdio.h&gt;
-#include &lt;zlib.h&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;exception&gt;
-
-#define LISP_STREAM_FILE       1
-#define LISP_STREAM_STRING     2
-#define LISP_STREAM_ANY        3
-
-#define LISP_TYPE_INTERNAL      -3
-#define LISP_TYPE_PARSE_ERROR   -2
-#define LISP_TYPE_EOF           -1
-#define LISP_TYPE_NIL           0
-#define LISP_TYPE_SYMBOL        1
-#define LISP_TYPE_INTEGER       2
-#define LISP_TYPE_STRING        3
-#define LISP_TYPE_REAL          4
-#define LISP_TYPE_CONS          5
-#define LISP_TYPE_PATTERN_CONS  6
-#define LISP_TYPE_BOOLEAN       7
-#define LISP_TYPE_PATTERN_VAR   8
-
-#define LISP_PATTERN_ANY        1
-#define LISP_PATTERN_SYMBOL     2
-#define LISP_PATTERN_STRING     3
-#define LISP_PATTERN_INTEGER    4
-#define LISP_PATTERN_REAL       5
-#define LISP_PATTERN_BOOLEAN    6
-#define LISP_PATTERN_LIST       7
-#define LISP_PATTERN_OR         8
-
-class CL_Vector;
-
-class LispReaderException : public std::exception
-{
-  public:
-    LispReaderException(const char* _message, const char* _file = &quot;&quot;, const unsigned int _line = 0)
-      : message(_message), file(_file), line(_line) { };
-    virtual ~LispReaderException() throw() { };
-
-    const char* what() const throw() { return message; };
-    const char* what_file() const throw() { return file; };
-    const unsigned int what_line() const throw() { return line; };
-    
-  private:
-    const char* message;
-    const char* file;
-    const unsigned int line;
-};
-
-typedef struct
-{
-  int type;
-
-  union
-  {
-    FILE *file;
-    struct
-    {
-      char *buf;
-      int pos;
-    }
-    string;
-    struct
-    {
-      void *data;
-      int (*next_char) (void *data);
-      void (*unget_char) (char c, void *data);
-    }
-    any;
-  } v;
-}
-lisp_stream_t;
-
-typedef struct _lisp_object_t lisp_object_t;
-struct _lisp_object_t
-{
-  int type;
-
-  union
-  {
-    struct
-    {
-      struct _lisp_object_t *car;
-      struct _lisp_object_t *cdr;
-    }
-    cons;
-
-    char *string;
-    int integer;
-    float real;
-
-    struct
-    {
-      int type;
-      int index;
-      struct _lisp_object_t *sub;
-    }
-    pattern;
-  } v;
-};
-
-lisp_stream_t* lisp_stream_init_gzfile (lisp_stream_t *stream, gzFile file);
-lisp_stream_t* lisp_stream_init_file (lisp_stream_t *stream, FILE *file);
-lisp_stream_t* lisp_stream_init_string (lisp_stream_t *stream, char *buf);
-lisp_stream_t* lisp_stream_init_any (lisp_stream_t *stream, void *data,
-                                     int (*next_char) (void *data),
-                                     void (*unget_char) (char c, void *data));
-
-lisp_object_t* lisp_read (lisp_stream_t *in);
-lisp_object_t* lisp_read_from_file(const std::string&amp; filename);
-void lisp_free (lisp_object_t *obj);
-
-lisp_object_t* lisp_read_from_string (const char *buf);
-
-int lisp_compile_pattern (lisp_object_t **obj, int *num_subs);
-int lisp_match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars, int num_subs);
-int lisp_match_string (const char *pattern_string, lisp_object_t *obj, lisp_object_t **vars);
-
-int lisp_type (lisp_object_t *obj);
-int lisp_integer (lisp_object_t *obj);
-float lisp_real (lisp_object_t *obj);
-char* lisp_symbol (lisp_object_t *obj);
-char* lisp_string (lisp_object_t *obj);
-int lisp_boolean (lisp_object_t *obj);
-lisp_object_t* lisp_car (lisp_object_t *obj);
-lisp_object_t* lisp_cdr (lisp_object_t *obj);
-
-lisp_object_t* lisp_cxr (lisp_object_t *obj, const char *x);
-
-lisp_object_t* lisp_make_integer (int value);
-lisp_object_t* lisp_make_real (float value);
-lisp_object_t* lisp_make_symbol (const char *value);
-lisp_object_t* lisp_make_string (const char *value);
-lisp_object_t* lisp_make_cons (lisp_object_t *car, lisp_object_t *cdr);
-lisp_object_t* lisp_make_boolean (int value);
-
-int lisp_list_length (lisp_object_t *obj);
-lisp_object_t* lisp_list_nth_cdr (lisp_object_t *obj, int index);
-lisp_object_t* lisp_list_nth (lisp_object_t *obj, int index);
-
-void lisp_dump (lisp_object_t *obj, FILE *out);
-
-#define lisp_nil()           ((lisp_object_t*)0)
-
-#define lisp_nil_p(obj)      (obj == 0)
-#define lisp_integer_p(obj)  (lisp_type((obj)) == LISP_TYPE_INTEGER)
-#define lisp_real_p(obj)     (lisp_type((obj)) == LISP_TYPE_REAL)
-#define lisp_symbol_p(obj)   (lisp_type((obj)) == LISP_TYPE_SYMBOL)
-#define lisp_string_p(obj)   (lisp_type((obj)) == LISP_TYPE_STRING)
-#define lisp_cons_p(obj)     (lisp_type((obj)) == LISP_TYPE_CONS)
-#define lisp_boolean_p(obj)  (lisp_type((obj)) == LISP_TYPE_BOOLEAN)
-
-/** */
-class LispReader
-{
-private:
-  lisp_object_t* lst;
-
-public:
-  lisp_object_t* get(const char* name);
-
-  /** cur == ((pos 1 2 3) (id 12 3 4)...) */
-  LispReader (lisp_object_t* l);
-
-
-  bool read_int_vector (const char* name, std::vector&lt;int&gt;* vec);
-  bool read_unsigned_char_vector (const char* name, std::vector&lt;unsigned char&gt;* vec);
-
-  bool read_char_vector (const char* name, std::vector&lt;char&gt;* vec);
-  bool read_string_vector (const char* name, std::vector&lt;std::string&gt;* vec);
-  bool read_string (const char* name, std::string* str);
-  bool read_int (const char* name, int* i);
-  bool read_float (const char* name, float* f);
-  bool read_vector (const char* name, CL_Vector* f);
-  bool read_bool (const char* name, bool* b);
-  bool read_lisp (const char* name, lisp_object_t** b);
-};
-
-/** */
-class LispWriter
-{
-private:
-  std::vector&lt;lisp_object_t*&gt; lisp_objs;
-
-  void append (lisp_object_t* obj);
-  lisp_object_t* make_list3 (lisp_object_t*, lisp_object_t*, lisp_object_t*);
-  lisp_object_t* make_list2 (lisp_object_t*, lisp_object_t*);
-public:
-  LispWriter (const char* name);
-  void write_float (const char* name, float f);
-  void write_int (const char* name, int i);
-  void write_boolean (const char* name, bool b);
-  void write_string (const char* name, const char* str);
-  void write_symbol (const char* name, const char* symname);
-  void write_lisp_obj(const char* name, lisp_object_t* lst);
-
-  /** caller is responible to free the returned lisp_object_t */
-  lisp_object_t* create_lisp ();
-};
-
-#endif

Modified: trunk/src/sprite3d.cxx
===================================================================
--- trunk/src/sprite3d.cxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/sprite3d.cxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -26,6 +26,7 @@
 #include &quot;display/drawing_request.hxx&quot;
 #include &quot;display/scene_context.hxx&quot;
 #include &quot;sprite3d.hxx&quot;
+#include &quot;lisp_util.hpp&quot;
 #include &quot;globals.hxx&quot;
 
 struct Vertex
@@ -48,7 +49,7 @@
   Vert v[3];
 };
 
-static void read_vector(const lisp::Lisp* lisp, CL_Vector&amp; vec)
+static inline void read_vector(const lisp::Lisp* lisp, CL_Vector&amp; vec)
 {
   if(lisp-&gt;get_type() != lisp::Lisp::TYPE_CONS || lisp-&gt;get_car() == 0)
     throw std::runtime_error(&quot;Invalid data when reading CL_Vector&quot;);
@@ -175,8 +176,6 @@
           &lt;&lt; iter.item() &lt;&lt; &quot;' in sprite3d\n&quot;;
       }
     }
-
-    printf(&quot;Sprite Loaded %d %d.\n&quot;, faces.size(), vertices.size());
   }
 };
 

Modified: trunk/src/windstille_main.cxx
===================================================================
--- trunk/src/windstille_main.cxx	2005-06-26 21:42:17 UTC (rev 443)
+++ trunk/src/windstille_main.cxx	2005-06-26 22:49:00 UTC (rev 444)
@@ -210,7 +210,7 @@
         if (!controller_file.empty())
           InputManager::init(controller_file);
         else
-          InputManager::init(datadir + &quot;controller/keyboard.scm&quot;);
+          InputManager::init(&quot;controller/keyboard.scm&quot;);
       }
     else
       {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000100.html">[Windstille-commit] r443 - in trunk: . src src/input src/physfs
</A></li>
	<LI>Next message: <A HREF="000102.html">[Windstille-commit] r445 - in trunk: . src src/sound
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#101">[ date ]</a>
              <a href="thread.html#101">[ thread ]</a>
              <a href="subject.html#101">[ subject ]</a>
              <a href="author.html#101">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/windstille-commit">More information about the Windstille-commit
mailing list</a><br>
</body></html>
