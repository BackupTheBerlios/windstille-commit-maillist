<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Windstille-commit] r1554 - in trunk/griv: . epeg
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/windstille-commit/2007-November/index.html" >
   <LINK REL="made" HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r1554%20-%20in%20trunk/griv%3A%20.%20epeg&In-Reply-To=%3C200711161514.lAGFEUxw015597%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001204.html">
   <LINK REL="Next"  HREF="001206.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Windstille-commit] r1554 - in trunk/griv: . epeg</H1>
    <B>grumbel at BerliOS</B> 
    <A HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r1554%20-%20in%20trunk/griv%3A%20.%20epeg&In-Reply-To=%3C200711161514.lAGFEUxw015597%40sheep.berlios.de%3E"
       TITLE="[Windstille-commit] r1554 - in trunk/griv: . epeg">grumbel at mail.berlios.de
       </A><BR>
    <I>Fri Nov 16 16:14:30 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="001204.html">[Windstille-commit] r1553 - trunk/griv
</A></li>
        <LI>Next message: <A HREF="001206.html">[Windstille-commit] r1555 - in trunk/griv: . obsolete
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1205">[ date ]</a>
              <a href="thread.html#1205">[ thread ]</a>
              <a href="subject.html#1205">[ subject ]</a>
              <a href="author.html#1205">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: grumbel
Date: 2007-11-16 16:14:29 +0100 (Fri, 16 Nov 2007)
New Revision: 1554

Added:
   trunk/griv/epeg/
   trunk/griv/epeg/COPYING
   trunk/griv/epeg/Epeg.h
   trunk/griv/epeg/epeg_main.c
   trunk/griv/epeg/epeg_private.h
Modified:
   trunk/griv/SConstruct
   trunk/griv/thumbgen.cpp
   trunk/griv/thumbget.cpp
   trunk/griv/thumbnail_store.cpp
   trunk/griv/thumbnail_store.hpp
Log:
- added epeg into the source

Modified: trunk/griv/SConstruct
===================================================================
--- trunk/griv/SConstruct	2007-11-16 14:27:37 UTC (rev 1553)
+++ trunk/griv/SConstruct	2007-11-16 15:14:29 UTC (rev 1554)
@@ -1,9 +1,12 @@
 # -*- python -*-
 
-libgriv_env = Environment(CCFLAGS=[&quot;-Wall&quot;, &quot;-Werror&quot;, &quot;-O0&quot;, &quot;-g&quot;])
+libgriv_env = Environment(CCFLAGS=[&quot;-Wall&quot;, &quot;-Werror&quot;, &quot;-O2&quot;, &quot;-g&quot;])
 libgriv = libgriv_env.StaticLibrary('griv', ['filesystem.cpp', 'md5.cpp'])
 
-griv_env = Environment(CCFLAGS=[&quot;-Wall&quot;, &quot;-Werror&quot;, &quot;-O0&quot;, &quot;-g&quot;], LIBS=[libgriv, 'SDL_image', 'mhash', 'GL', 'GLU', 'epeg'])
+libepeg_env = Environment(CCFLAGS=[&quot;-Wall&quot;, &quot;-O2&quot;, &quot;-g&quot;])
+libepeg = libepeg_env.StaticLibrary('epeg', ['epeg/epeg_main.c'])
+
+griv_env = Environment(CCFLAGS=[&quot;-Wall&quot;, &quot;-Werror&quot;, &quot;-O2&quot;, &quot;-g&quot;], LIBS=[libgriv, libepeg, 'SDL_image', 'jpeg', 'mhash', 'GL', 'GLU'])
 griv_env.ParseConfig(&quot;sdl-config --libs --cflags&quot;)
 
 griv_env.Program('griv', ['griv.cpp',
@@ -14,10 +17,10 @@
                           'texture.cpp', 
                           'workspace.cpp'])
 
-thumbget_env = Environment(CCFLAGS=['-Wall', '-Werror', '-O0', '-g'], LIBS=['epeg'])
+thumbget_env = Environment(CCFLAGS=['-Wall', '-Werror', '-O2', '-g'], LIBS=[libepeg, 'jpeg'])
 thumbget_env.Program('thumbget', ['thumbget.cpp'])
 
-thumbgen_env = Environment(CCFLAGS=['-Wall', '-Werror', '-O0', '-g'], LIBS=[libgriv, 'epeg', 'mhash'])
+thumbgen_env = Environment(CCFLAGS=['-Wall', '-Werror', '-O2', '-g'], LIBS=[libgriv, libepeg, 'jpeg', 'mhash'])
 thumbgen_env.Program('thumbgen', ['thumbgen.cpp'])
 
 # EOF #

Added: trunk/griv/epeg/COPYING
===================================================================
--- trunk/griv/epeg/COPYING	2007-11-16 14:27:37 UTC (rev 1553)
+++ trunk/griv/epeg/COPYING	2007-11-16 15:14:29 UTC (rev 1554)
@@ -0,0 +1,28 @@
+Copyright (C) 2000 Carsten Haitzler and various contributors (see AUTHORS)
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the &quot;Software&quot;), to
+deal in the Software without restriction, including without limitation the
+rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies of the Software and its Copyright notices. In addition publicly
+documented acknowledgment must be given that this software has been used if no
+source code of this software is made available publicly. This includes
+acknowledgments in either Copyright notices, Manuals, Publicity and Marketing
+documents or any documentation provided with any product containing this
+software. This License does not apply to any software that links to the
+libraries provided by this software (statically or dynamically), but only to
+the software provided.
+
+Please see the COPYING.PLAIN for a plain-english explanation of this notice
+and it's intent.
+
+THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Added: trunk/griv/epeg/Epeg.h
===================================================================
--- trunk/griv/epeg/Epeg.h	2007-11-16 14:27:37 UTC (rev 1553)
+++ trunk/griv/epeg/Epeg.h	2007-11-16 15:14:29 UTC (rev 1554)
@@ -0,0 +1,76 @@
+#ifndef _EPEG_H
+#define _EPEG_H
+
+#ifdef EAPI
+#undef EAPI
+#endif
+#ifdef WIN32
+# ifdef BUILDING_DLL
+#  define EAPI __declspec(dllexport)
+# else
+#  define EAPI __declspec(dllimport)
+# endif
+#else
+# ifdef __GNUC__
+#  if __GNUC__ &gt;= 4
+#   define EAPI __attribute__ ((visibility(&quot;default&quot;)))
+#  else
+#   define EAPI
+#  endif
+# else
+#  define EAPI
+# endif
+#endif
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+   typedef enum _Epeg_Colorspace
+     {
+	EPEG_GRAY8,
+	  EPEG_YUV8,
+	  EPEG_RGB8,
+	  EPEG_BGR8,
+	  EPEG_RGBA8,
+	  EPEG_BGRA8,
+	  EPEG_ARGB32,
+	  EPEG_CMYK
+     }
+   Epeg_Colorspace;
+   
+   typedef struct _Epeg_Image          Epeg_Image;
+   typedef struct _Epeg_Thumbnail_Info Epeg_Thumbnail_Info;
+
+   struct _Epeg_Thumbnail_Info
+     {
+	char                   *uri;
+	unsigned long long int  mtime;
+	int                     w, h;
+	char                   *mimetype;
+     };
+   
+   EAPI Epeg_Image   *epeg_file_open                 (const char *file);
+   EAPI Epeg_Image   *epeg_memory_open               (unsigned char *data, int size);
+   EAPI void          epeg_size_get                  (Epeg_Image *im, int *w, int *h);
+   EAPI void          epeg_decode_size_set           (Epeg_Image *im, int w, int h);
+   EAPI void          epeg_colorspace_get            (Epeg_Image *im, int *space);
+   EAPI void          epeg_decode_colorspace_set     (Epeg_Image *im, Epeg_Colorspace colorspace);
+   EAPI const void   *epeg_pixels_get                (Epeg_Image *im, int x, int y, int w, int h);
+   EAPI void          epeg_pixels_free               (Epeg_Image *im, const void *data);
+   EAPI const char   *epeg_comment_get               (Epeg_Image *im);
+   EAPI void          epeg_thumbnail_comments_get    (Epeg_Image *im, Epeg_Thumbnail_Info *info);
+   EAPI void          epeg_comment_set               (Epeg_Image *im, const char *comment);
+   EAPI void          epeg_quality_set               (Epeg_Image *im, int quality);
+   EAPI void          epeg_thumbnail_comments_enable (Epeg_Image *im, int onoff);
+   EAPI void          epeg_file_output_set           (Epeg_Image *im, const char *file);
+   EAPI void          epeg_memory_output_set         (Epeg_Image *im, unsigned char **data, int *size);
+   EAPI int           epeg_encode                    (Epeg_Image *im);
+   EAPI int           epeg_trim                      (Epeg_Image *im);
+   EAPI void          epeg_close                     (Epeg_Image *im);
+   
+#ifdef __cplusplus
+}
+#endif
+
+#endif


Property changes on: trunk/griv/epeg/Epeg.h
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Added: trunk/griv/epeg/epeg_main.c
===================================================================
--- trunk/griv/epeg/epeg_main.c	2007-11-16 14:27:37 UTC (rev 1553)
+++ trunk/griv/epeg/epeg_main.c	2007-11-16 15:14:29 UTC (rev 1554)
@@ -0,0 +1,1361 @@
+#include &quot;Epeg.h&quot;
+#include &quot;epeg_private.h&quot;
+#include &lt;jerror.h&gt;
+
+static Epeg_Image   *_epeg_open_header         (Epeg_Image *im);
+static int           _epeg_decode              (Epeg_Image *im);
+static int           _epeg_scale               (Epeg_Image *im);
+static int           _epeg_decode_for_trim     (Epeg_Image *im);
+static int           _epeg_trim                (Epeg_Image *im);
+static int           _epeg_encode              (Epeg_Image *im);
+
+static void          _epeg_fatal_error_handler (j_common_ptr cinfo);
+
+#define MIN(__x,__y) ((__x) &lt; (__y) ? (__x) : (__y))
+#define MAX(__x,__y) ((__x) &gt; (__y) ? (__x) : (__y))
+
+static const JOCTET fake_EOI[2] = { 0xFF, JPEG_EOI };
+
+/**
+ * Open a JPEG image by filename.
+ * @param file The file path to open.
+ * @return A handle to the opened JPEG file, with the header decoded.
+ * 
+ * This function opens the file indicated by the @p file parameter, and
+ * attempts to decode it as a jpeg file. If this failes, NULL is returned.
+ * Otherwise a valid handle to an open JPEG file is returned that can be used
+ * by other Epeg calls.
+ * 
+ * The @p file must be a pointer to a valid C string, NUL (0 byte) terminated
+ * thats is a relative or absolute file path. If not results are not
+ * determined.
+ * 
+ * See also: epeg_memory_open(), epeg_close()
+ */
+EAPI Epeg_Image *
+epeg_file_open(const char *file)
+{
+   Epeg_Image *im;
+   
+   im = calloc(1, sizeof(Epeg_Image));
+   if (!im) return NULL;
+   
+   im-&gt;in.file = strdup(file);
+   if (!im-&gt;in.file)
+     {
+	free(im);
+	return NULL;
+     }
+   
+   im-&gt;in.f = fopen(im-&gt;in.file, &quot;rb&quot;);
+   if (!im-&gt;in.f)
+     {
+	epeg_close(im);
+	return NULL;
+     }
+   fstat(fileno(im-&gt;in.f), &amp;(im-&gt;stat_info));
+   im-&gt;out.quality = 75;
+   return _epeg_open_header(im);
+}
+
+/**
+ * Open a JPEG image stored in memory.
+ * @param data A pointer to the memory containing the JPEG data.
+ * @param size The size of the memory segment containing the JPEG.
+ * @return  A handle to the opened JPEG, with the header decoded.
+ * 
+ * This function opens a JPEG file that is stored in memory pointed to by
+ * @p data, and that is @p size bytes in size. If successful a valid handle
+ * is returned, or on failure NULL is returned.
+ * 
+ * See also: epeg_file_open(), epeg_close()
+ */
+EAPI EAPI Epeg_Image *
+epeg_memory_open(unsigned char *data, int size)
+{
+   Epeg_Image *im;
+   
+   im = calloc(1, sizeof(Epeg_Image));
+   if (!im) return NULL;
+   
+   im-&gt;out.quality = 75;
+   im-&gt;in.mem.data = (unsigned char **)data;
+   im-&gt;in.mem.size = size;
+   im-&gt;in.f = NULL;
+   im-&gt;in.w = 0;
+   im-&gt;in.h = 0;
+   return _epeg_open_header(im);
+}
+
+/**
+ * Return the original JPEG pixel size.
+ * @param im A handle to an opened Epeg image.
+ * @param w A pointer to the width value in pixels to be filled in.
+ * @param h A pointer to the height value in pixels to be filled in.
+ * 
+ * Returns the image size in pixels.
+ * 
+ */
+EAPI void
+epeg_size_get(Epeg_Image *im, int *w, int *h)
+{
+   if (w) *w = im-&gt;in.w;
+   if (h) *h = im-&gt;in.h;
+}
+
+/**
+ * Return the original JPEG pixel color space.
+ * @param im A handle to an opened Epeg image.
+ * @param space A pointer to the color space value to be filled in.
+ * 
+ * Returns the image color space.
+ * 
+ */
+EAPI void
+epeg_colorspace_get(Epeg_Image *im, int *space)
+{
+   if (space) *space = im-&gt;color_space;
+}
+
+/**
+ * Set the size of the image to decode in pixels.
+ * @param im A handle to an opened Epeg image.
+ * @param w The width of the image to decode at, in pixels.
+ * @param h The height of the image to decode at, in pixels.
+ * 
+ * Sets the size at which to deocode the JPEG image, giving an optimised load
+ * that only decodes the pixels needed.
+ * 
+ */
+EAPI void
+epeg_decode_size_set(Epeg_Image *im, int w, int h)
+{
+   if      (im-&gt;pixels) return;
+   if      (w &lt; 1)        w = 1;
+   else if (w &gt; im-&gt;in.w) w = im-&gt;in.w;
+   if      (h &lt; 1)        h = 1;
+   else if (h &gt; im-&gt;in.h) h = im-&gt;in.h;
+   im-&gt;out.w = w;
+   im-&gt;out.h = h;
+   im-&gt;out.x = 0;
+   im-&gt;out.y = 0;
+}
+
+EAPI void
+epeg_decode_bounds_set(Epeg_Image *im, int x, int y, int w, int h)
+{
+   if      (im-&gt;pixels) return;
+   if      (w &lt; 1)        w = 1;
+   else if (w &gt; im-&gt;in.w) w = im-&gt;in.w;
+   if      (h &lt; 1)        h = 1;
+   else if (h &gt; im-&gt;in.h) h = im-&gt;in.h;
+   im-&gt;out.w = w;
+   im-&gt;out.h = h;
+   if      (x &lt; 0)        x = 0;
+   if      (y &lt; 0)        y = 0;
+   im-&gt;out.x = x;
+   im-&gt;out.y = y;
+}
+
+/**
+ * Set the colorspace in which to decode the image.
+ * @param im A handle to an opened Epeg image.
+ * @param colorspace The colorspace to decode the image in.
+ * 
+ * This sets the colorspace to decode the image in. The default is EPEG_YUV8,
+ * as this is normally the native colorspace of a JPEG file, avoiding any
+ * colorspace conversions for a faster load and/or save.
+ */
+EAPI void
+epeg_decode_colorspace_set(Epeg_Image *im, Epeg_Colorspace colorspace)
+{
+   if (im-&gt;pixels) return;
+   if ((colorspace &lt; EPEG_GRAY8) || (colorspace &gt; EPEG_CMYK)) return;
+   im-&gt;color_space = colorspace;
+}
+
+/**
+ * Get a segment of decoded pixels from an image.
+ * @param im A handle to an opened Epeg image.
+ * @param x Rectangle X.
+ * @param y Rectangle Y.
+ * @param w Rectangle width.
+ * @param h Rectangle height.
+ * @return Pointer to the top left of the requested pixel block.
+ * 
+ * Return image pixels in the decoded format from the specified location
+ * rectangle bounded with the box @p x, @p y @p w X @p y. The pixel block is
+ * packed with no row padding, and it organsied from top-left to bottom right,
+ * row by row. You must free the pixel block using epeg_pixels_free() before
+ * you close the image handle, and assume the pixels to be read-only memory.
+ * 
+ * On success the pointer is returned, on failure, NULL is returned. Failure
+ * may be because the rectangle is out of the bounds of the image, memory
+ * allocations failed or the image data cannot be decoded.
+ * 
+ */
+EAPI const void *
+epeg_pixels_get(Epeg_Image *im, int x, int y,  int w, int h)
+{
+   int xx, yy, ww, hh, bpp, ox, oy, ow, oh, iw, ih;
+   
+   if (!im-&gt;pixels)
+     {
+	if (_epeg_decode(im) != 0) return NULL;
+     }
+   
+   if (!im-&gt;pixels) return NULL;
+   if ((im-&gt;out.w &lt; 1) || (im-&gt;out.h &lt; 1)) return NULL;
+   
+   if (_epeg_scale(im) != 0) return NULL;
+   
+   bpp = im-&gt;in.jinfo.output_components;
+   iw = im-&gt;out.w;
+   ih = im-&gt;out.h;
+   ow = w;
+   oh = h;
+   ox = 0;
+   oy = 0;
+   if ((x + ow) &gt; iw) ow = iw - x;
+   if ((y + oh) &gt; ih) oh = ih - y;
+   if (ow &lt; 1) return NULL;
+   if (oh &lt; 1) return NULL;
+   if (x &lt; 0)
+     {
+	ow += x;
+	ox = -x;
+     }
+   if (y &lt; 0)
+     {
+	oh += y;
+	oy = -y;
+     }
+   if (ow &lt; 1) return NULL;
+   if (oh &lt; 1) return NULL;
+
+   ww = x + ox + ow;
+   hh = y + oy + oh;
+
+   if (im-&gt;color_space == EPEG_GRAY8)
+     {
+	unsigned char *pix, *p;
+	
+	pix = malloc(w * h * 1);
+	if (!pix) return NULL;
+	for (yy = y + oy; yy &lt; hh; yy++)
+	  {
+	     unsigned char *s;
+	     
+	     s = im-&gt;lines[yy] + ((x + ox) * bpp);
+	     p = pix + ((((yy - y) * w) + ox));
+	     for (xx = x + ox; xx &lt; ww; xx++)
+	       {
+		  p[0] = s[0];
+		  p++;
+		  s += bpp;
+	       }
+	  }
+	return pix;
+     }
+   else if (im-&gt;color_space == EPEG_YUV8)
+     {
+	unsigned char *pix, *p;
+	
+	pix = malloc(w * h * 3);
+	if (!pix) return NULL;
+	for (yy = y + oy; yy &lt; hh; yy++)
+	  {
+	     unsigned char *s;
+	     
+	     s = im-&gt;lines[yy] + ((x + ox) * bpp);
+	     p = pix + ((((yy - y) * w) + ox) * 3);
+	     for (xx = x + ox; xx &lt; ww; xx++)
+	       {
+		  p[0] = s[0];
+		  p[1] = s[1];
+		  p[2] = s[2];
+		  p += 3;
+		  s += bpp;
+	       }
+	  }
+	return pix;
+     }
+   else if (im-&gt;color_space == EPEG_RGB8)
+     {
+	unsigned char *pix, *p;
+	
+	pix = malloc(w * h * 3);
+	if (!pix) return NULL;
+	for (yy = y + oy; yy &lt; hh; yy++)
+	  {
+	     unsigned char *s;
+	     
+	     s = im-&gt;lines[yy] + ((x + ox) * bpp);
+	     p = pix + ((((yy - y) * w) + ox) * 3);
+	     for (xx = x + ox; xx &lt; ww; xx++)
+	       {
+		  p[0] = s[0];
+		  p[1] = s[1];
+		  p[2] = s[2];
+		  p += 3;
+		  s += bpp;
+	       }
+	  }
+	return pix;
+     }
+   else if (im-&gt;color_space == EPEG_BGR8)
+     {
+	unsigned char *pix, *p;
+	
+	pix = malloc(w * h * 3);
+	if (!pix) return NULL;
+	for (yy = y + oy; yy &lt; hh; yy++)
+	  {
+	     unsigned char *s;
+	     
+	     s = im-&gt;lines[yy] + ((x + ox) * bpp);
+	     p = pix + ((((yy - y) * w) + ox) * 3);
+	     for (xx = x + ox; xx &lt; ww; xx++)
+	       {
+		  p[0] = s[2];
+		  p[1] = s[1];
+		  p[2] = s[0];
+		  p += 3;
+		  s += bpp;
+	       }
+	  }
+	return pix;
+     }
+   else if (im-&gt;color_space == EPEG_RGBA8)
+     {
+	unsigned char *pix, *p;
+	
+	pix = malloc(w * h * 4);
+	if (!pix) return NULL;
+	for (yy = y + oy; yy &lt; hh; yy++)
+	  {
+	     unsigned char *s;
+	     
+	     s = im-&gt;lines[yy] + ((x + ox) * bpp);
+	     p = pix + ((((yy - y) * w) + ox) * 4);
+	     for (xx = x + ox; xx &lt; ww; xx++)
+	       {
+		  p[0] = s[0];
+		  p[1] = s[1];
+		  p[2] = s[2];
+		  p[3] = 0xff;
+		  p += 4;
+		  s += bpp;
+	       }
+	  }
+	return pix;
+     }
+   else if (im-&gt;color_space == EPEG_BGRA8)
+     {
+	unsigned char *pix, *p;
+	
+	pix = malloc(w * h * 4);
+	if (!pix) return NULL;
+	for (yy = y + oy; yy &lt; hh; yy++)
+	  {
+	     unsigned char *s;
+	     
+	     s = im-&gt;lines[yy] + ((x + ox) * bpp);
+	     p = pix + ((((yy - y) * w) + ox) * 4);
+	     for (xx = x + ox; xx &lt; ww; xx++)
+	       {
+		  p[0] = 0xff;
+		  p[1] = s[2];
+		  p[2] = s[1];
+		  p[3] = s[0];
+		  p += 4;
+		  s += bpp;
+	       }
+	  }
+	return pix;
+     }
+   else if (im-&gt;color_space == EPEG_ARGB32)
+     {
+	unsigned int *pix, *p;
+	
+	pix = malloc(w * h * 4);
+	if (!pix) return NULL;
+	for (yy = y + oy; yy &lt; hh; yy++)
+	  {
+	     unsigned char *s;
+	     
+	     s = im-&gt;lines[yy] + ((x + ox) * bpp);
+	     p = pix + ((((yy - y) * w) + ox));
+	     for (xx = x + ox; xx &lt; ww; xx++)
+	       {
+		  p[0] = 0xff000000 | (s[0] &lt;&lt; 16) | (s[1] &lt;&lt; 8) | (s[2]);
+		  p++;
+		  s += bpp;
+	       }
+	  }
+	return pix;
+     }
+   else if (im-&gt;color_space == EPEG_CMYK)
+     {
+	unsigned char *pix, *p;
+	
+	pix = malloc(w * h * 4);
+	if (!pix) return NULL;
+	for (yy = y + oy; yy &lt; hh; yy++)
+	  {
+	     unsigned char *s;
+	     
+	     s = im-&gt;lines[yy] + ((x + ox) * bpp);
+	     p = pix + ((((yy - y) * w) + ox) * 4);
+	     for (xx = x + ox; xx &lt; ww; xx++)
+	       {
+		  p[0] = s[0];
+		  p[1] = s[1];
+		  p[2] = s[2];
+		  p[3] = 0xff;
+		  p += 4;
+		  s += bpp;
+	       }
+	  }
+	return pix;
+     }
+   return NULL;
+}
+
+/**
+ * Get a segment of decoded pixels from an image.
+ * @param im A handle to an opened Epeg image.
+ * @param x Rectangle X.
+ * @param y Rectangle Y.
+ * @param w Rectangle width.
+ * @param h Rectangle height.
+ * @return Pointer to the top left of the requested pixel block.
+ * 
+ * Return image pixels in the decoded format from the specified location
+ * rectangle bounded with the box @p x, @p y @p w X @p y. The pixel block is
+ * packed with no row padding, and it organsied from top-left to bottom right,
+ * row by row. You must free the pixel block using epeg_pixels_free() before
+ * you close the image handle, and assume the pixels to be read-only memory.
+ * 
+ * On success the pointer is returned, on failure, NULL is returned. Failure
+ * may be because the rectangle is out of the bounds of the image, memory
+ * allocations failed or the image data cannot be decoded.
+ * 
+ */
+EAPI const void *
+epeg_pixels_get_as_RGB8(Epeg_Image *im, int x, int y,  int w, int h)
+{
+   int xx, yy, ww, hh, bpp, ox, oy, ow, oh, iw, ih;
+   
+   if (!im-&gt;pixels)
+     {
+	if (_epeg_decode(im) != 0) return NULL;
+     }
+	
+   if (!im-&gt;pixels) return NULL;
+   if ((im-&gt;out.w &lt; 1) || (im-&gt;out.h &lt; 1)) return NULL;
+   
+   bpp = im-&gt;in.jinfo.output_components;
+   iw = im-&gt;out.w;
+   ih = im-&gt;out.h;
+   ow = w;
+   oh = h;
+   ox = 0;
+   oy = 0;
+   if ((x + ow) &gt; iw) ow = iw - x;
+   if ((y + oh) &gt; ih) oh = ih - y;
+   if (ow &lt; 1) return NULL;
+   if (oh &lt; 1) return NULL;
+   if (x &lt; 0)
+     {
+	ow += x;
+	ox = -x;
+     }
+   if (y &lt; 0)
+     {
+	oh += y;
+	oy = -y;
+     }
+   if (ow &lt; 1) return NULL;
+   if (oh &lt; 1) return NULL;
+   
+   ww = x + ox + ow;
+   hh = y + oy + oh;
+   
+   if (im-&gt;color_space == EPEG_GRAY8)
+     {
+	unsigned char *pix, *p;
+	
+	pix = malloc(w * h * 3);
+	if (!pix) return NULL;
+	for (yy = y + oy; yy &lt; hh; yy++)
+	  {
+	     unsigned char *s;
+	     
+	     s = im-&gt;lines[yy] + ((x + ox) * bpp);
+	     p = pix + ((((yy - y) * w) + ox) * 3);
+	     for (xx = x + ox; xx &lt; ww; xx++)
+	       {
+		  p[0] = s[0];
+		  p[1] = s[0];
+		  p[2] = s[0];
+		  p += 3;
+		  s += bpp;
+	       }
+	  }
+	return pix;
+     }
+   if (im-&gt;color_space == EPEG_RGB8)
+     {
+	unsigned char *pix, *p;
+	
+	pix = malloc(w * h * 3);
+	if (!pix) return NULL;
+	for (yy = y + oy; yy &lt; hh; yy++)
+	  {
+	     unsigned char *s;
+	     
+	     s = im-&gt;lines[yy] + ((x + ox) * bpp);
+	     p = pix + ((((yy - y) * w) + ox) * 3);
+	     for (xx = x + ox; xx &lt; ww; xx++)
+	       {
+		  p[0] = s[0];
+		  p[1] = s[1];
+		  p[2] = s[2];
+		  p += 3;
+		  s += bpp;
+	       }
+	  }
+	return pix;
+     }
+   if (im-&gt;color_space == EPEG_CMYK)
+     {
+	unsigned char *pix, *p;
+	
+	pix = malloc(w * h * 3);
+	if (!pix) return NULL;
+	for (yy = y + oy; yy &lt; hh; yy++)
+	  {
+	     unsigned char *s;
+	     
+	     s = im-&gt;lines[yy] + ((x + ox) * bpp);
+	     p = pix + ((((yy - y) * w) + ox) * 3);
+	     for (xx = x + ox; xx &lt; ww; xx++)
+	       {
+		  p[0] = (unsigned char)(MIN(255, (s[0] * s[3]) / 255));
+		  p[1] = (unsigned char)(MIN(255, (s[1] * s[3]) / 255));
+		  p[2] = (unsigned char)(MIN(255, (s[2] * s[3]) / 255));
+		  p += 3;
+		  s += bpp;
+	       }
+	  }
+	return pix;
+     }
+   return NULL;
+}
+
+/**
+ * Free requested pixel block from an image.
+ * @param im A handle to an opened Epeg image.
+ * @param data The pointer to the image pixels.
+ * 
+ * This frees the data for a block of pixels requested from image @p im.
+ * @p data must be a valid (non NULL) pointer to a pixel block taken from the
+ * image @p im by epeg_pixels_get() and mustbe called before the image is
+ * closed by epeg_close().
+ */
+EAPI void
+epeg_pixels_free(Epeg_Image *im, const void *data)
+{
+   free((void *)data);
+}
+
+/**
+ * Get the image comment field as a string.
+ * @param im A handle to an opened Epeg image.
+ * @return A pointer to the loaded image comments.
+ * 
+ * This function returns the comment field as a string (NUL byte terminated)
+ * of the loaded image @p im, if there is a comment, or NULL if no comment is
+ * saved with the image. Consider the string returned to be read-only.
+ * 
+ */
+EAPI const char *
+epeg_comment_get(Epeg_Image *im)
+{
+   return im-&gt;in.comment;
+}
+
+/**
+ * Get thumbnail comments of loaded image.
+ * @param im A handle to an opened Epeg image.
+ * @param info Pointer to a thumbnail info struct to be filled in.
+ * 
+ * This function retrieves thumbnail comments written by Epeg to any saved
+ * JPEG files. If no thumbnail comments were saved, the fields will be 0 in
+ * the @p info struct on return.
+ * 
+ */
+EAPI void
+epeg_thumbnail_comments_get(Epeg_Image *im, Epeg_Thumbnail_Info *info)
+{
+   if (!info) return;
+   info-&gt;uri      = im-&gt;in.thumb_info.uri;
+   info-&gt;mtime    = im-&gt;in.thumb_info.mtime;
+   info-&gt;w        = im-&gt;in.thumb_info.w;
+   info-&gt;h        = im-&gt;in.thumb_info.h;
+   info-&gt;mimetype = im-&gt;in.thumb_info.mime;
+}
+
+/**
+ * Set the comment field of the image for saving.
+ * @param im A handle to an opened Epeg image.
+ * @param comment The comment to set.
+ * 
+ * Set the comment for the image file for when it gets saved. This is a NUL
+ * byte terminated C string. If @p comment is NULL the output file will have
+ * no comment field.
+ * 
+ * The default comment will be any comment loaded from the input file.
+ * 
+ */
+EAPI void
+epeg_comment_set(Epeg_Image *im, const char *comment)
+{
+   if (im-&gt;out.comment) free(im-&gt;out.comment);
+   if (!comment) im-&gt;out.comment = NULL;
+   else im-&gt;out.comment = strdup(comment);
+}
+
+/**
+ * Set the encoding quality of the saved image.
+ * @param im A handle to an opened Epeg image.
+ * @param quality The quality of encoding from 0 to 100.
+ * 
+ * Set the quality of the output encoded image. Values from 0 to 100
+ * inclusive are valid, with 100 being the maximum quality, and 0 being the
+ * minimum. If the quality is set equal to or above 90%, the output U and V
+ * color planes are encoded at 1:1 with the Y plane.
+ * 
+ * The default quality is 75.
+ * 
+ */
+EAPI void
+epeg_quality_set(Epeg_Image *im, int quality)
+{
+   if      (quality &lt; 0)   quality = 0;
+   else if (quality &gt; 100) quality = 100;
+   im-&gt;out.quality = quality;
+}
+
+/**
+ * Enable thumbnail comments in saved image.
+ * @param im A handle to an opened Epeg image.
+ * @param onoff A boolean on and off enabling flag.
+ * 
+ * if @p onoff is 1, the output file will have thumbnail comments added to
+ * it, and if it is 0, it will not. The default is 0.
+ * 
+ */
+EAPI void
+epeg_thumbnail_comments_enable(Epeg_Image *im, int onoff)
+{
+   im-&gt;out.thumbnail_info = onoff;
+}
+
+/**
+ * Set the output file path for the image when saved.
+ * @param im A handle to an opened Epeg image.
+ * @param file The path to the output file.
+ * 
+ * This sets the output file path name (either a full or relative path name)
+ * to where the file will be written when saved. @p file must be a NUL
+ * terminated C string conatining the path to the file to be saved to. If it is
+ * NULL, the image will not be saved to a file when calling epeg_encode().
+ */
+EAPI void
+epeg_file_output_set(Epeg_Image *im, const char *file)
+{
+   if (im-&gt;out.file) free(im-&gt;out.file);
+   if (!file) im-&gt;out.file = NULL;
+   else im-&gt;out.file = strdup(file);
+}
+
+/**
+ * Set the output file to be a block of allocated memory.
+ * @param im A handle to an opened Epeg image.
+ * @param data A pointer to a pointer to a memory block.
+ * @param size A pointer to a counter of the size of the memory block.
+ * 
+ * This sets the output encoding of the image when saved to be allocated
+ * memory. After epeg_close() is called the pointer pointed to by @p data
+ * and the integer pointed to by @p size will contain the pointer to the
+ * memory block and its size in bytes, respecitvely. The memory block can be
+ * freed with the free() function call. If the save fails the pointer to the
+ * memory block will be unaffected, as will the size.
+ * 
+ */
+EAPI void
+epeg_memory_output_set(Epeg_Image *im, unsigned char **data, int *size)
+{
+   im-&gt;out.mem.data = data;
+   im-&gt;out.mem.size = size;
+   im-&gt;out.file = NULL;
+}
+
+/**
+ * This saves the image to its specified destination.
+ * @param im A handle to an opened Epeg image.
+ * 
+ * This saves the image @p im to its destination specified by
+ * epeg_file_output_set() or epeg_memory_output_set(). The image will be
+ * encoded at the deoded pixel size, using the quality, comment and thumbnail
+ * comment settings set on the image.
+ *
+ * retval 1 - error scale
+ *        2 - error encode
+ *        3 - error decode
+ *        4 - error decode ( setjmp )
+ */
+EAPI int
+epeg_encode(Epeg_Image *im)
+{
+   int ret;
+   if ((ret = _epeg_decode(im)) != 0)
+     return (ret == 2 ? 4 : 3);
+   if (_epeg_scale(im) != 0)
+     return 1;
+   if (_epeg_encode(im) != 0)
+     return 2;
+   return 0;
+}
+
+/**
+ * FIXME: Document this
+ * @param im A handle to an opened Epeg image.
+ * 
+ * FIXME: Document this.
+ */
+EAPI int
+epeg_trim(Epeg_Image *im)
+{
+   if (_epeg_decode_for_trim(im) != 0)
+     return 1;
+   if (_epeg_trim(im) != 0)
+     return 1;
+   if (_epeg_encode(im) != 0)
+     return 1;
+   return 0;
+}
+
+/**
+ * Close an image handle.
+ * @param im A handle to an opened Epeg image.
+ * 
+ * This closes an opened image handle and frees all memory associated with it.
+ * It does not free encoded data generated by epeg_memory_output_set() followed
+ * by epeg_encode() nor does it guarantee to free any data recieved by
+ * epeg_pixels_get(). Once an image handle is closed consider it invalid.
+ */
+EAPI void
+epeg_close(Epeg_Image *im)
+{
+   if (!im) return;
+   if (im-&gt;pixels)                   free(im-&gt;pixels);
+   if (im-&gt;lines)                    free(im-&gt;lines);
+   if (im-&gt;in.file)                  free(im-&gt;in.file);
+   if (!im-&gt;in.file)                 free(im-&gt;in.jinfo.src);
+   if (im-&gt;in.f || im-&gt;in.mem.data)  jpeg_destroy_decompress(&amp;(im-&gt;in.jinfo));
+   if (im-&gt;in.f)                     fclose(im-&gt;in.f);
+   if (im-&gt;in.comment)               free(im-&gt;in.comment);
+   if (im-&gt;in.thumb_info.uri)        free(im-&gt;in.thumb_info.uri);
+   if (im-&gt;in.thumb_info.mime)       free(im-&gt;in.thumb_info.mime);
+   if (im-&gt;out.file)                 free(im-&gt;out.file);
+   if (!im-&gt;out.file)                free(im-&gt;out.jinfo.dest);
+   if (im-&gt;out.f || im-&gt;in.mem.data) jpeg_destroy_compress(&amp;(im-&gt;out.jinfo));
+   if (im-&gt;out.f)                    fclose(im-&gt;out.f);
+   if (im-&gt;out.comment)              free(im-&gt;out.comment);
+   free(im);
+}
+
+static Epeg_Image *
+_epeg_open_header(Epeg_Image *im)
+{
+   struct jpeg_marker_struct *m;
+   struct jpeg_source_mgr *src_mgr = NULL;
+
+   im-&gt;in.jinfo.err = jpeg_std_error(&amp;(im-&gt;jerr.pub));
+   im-&gt;jerr.pub.error_exit = _epeg_fatal_error_handler;
+#ifdef NOWARNINGS
+   im-&gt;jerr.pub.emit_message = _emit_message;
+   im-&gt;jerr.pub.output_message = _output_message;
+   im-&gt;jerr.pub.format_message = _format_message;
+#endif
+   
+   if (setjmp(im-&gt;jerr.setjmp_buffer))
+     {
+	error:
+	epeg_close(im);
+	im = NULL;
+	return NULL;
+     }
+   
+   jpeg_create_decompress(&amp;(im-&gt;in.jinfo));
+   jpeg_save_markers(&amp;(im-&gt;in.jinfo), JPEG_APP0 + 7, 1024);
+   jpeg_save_markers(&amp;(im-&gt;in.jinfo), JPEG_COM,      65535);
+   if (im-&gt;in.f != NULL)
+     {
+	jpeg_stdio_src(&amp;(im-&gt;in.jinfo), im-&gt;in.f);
+     }
+   else
+     {
+	/* Setup RAM source manager. */
+	src_mgr = calloc(1, sizeof(struct jpeg_source_mgr));
+	if (!src_mgr) goto error;
+	src_mgr-&gt;init_source = _jpeg_init_source;
+	src_mgr-&gt;fill_input_buffer = _jpeg_fill_input_buffer;
+	src_mgr-&gt;skip_input_data = _jpeg_skip_input_data;
+	src_mgr-&gt;resync_to_restart = jpeg_resync_to_restart;
+	src_mgr-&gt;term_source = _jpeg_term_source;
+	src_mgr-&gt;bytes_in_buffer = im-&gt;in.mem.size;
+	src_mgr-&gt;next_input_byte = (JOCTET *) im-&gt;in.mem.data;
+   	im-&gt;in.jinfo.src = (struct jpeg_source_mgr *) src_mgr;
+     }
+
+   jpeg_read_header(&amp;(im-&gt;in.jinfo), TRUE);
+   im-&gt;in.w = im-&gt;in.jinfo.image_width;
+   im-&gt;in.h = im-&gt;in.jinfo.image_height;
+   if (im-&gt;in.w &lt; 1) goto error;
+   if (im-&gt;in.h &lt; 1) goto error;
+   
+   im-&gt;out.w = im-&gt;in.w;
+   im-&gt;out.h = im-&gt;in.h;
+
+   im-&gt;color_space = ((im-&gt;in.color_space = im-&gt;in.jinfo.out_color_space) == JCS_GRAYSCALE) ? EPEG_GRAY8 : EPEG_RGB8;
+   if (im-&gt;in.color_space == JCS_CMYK) im-&gt;color_space = EPEG_CMYK;
+   
+   for (m = im-&gt;in.jinfo.marker_list; m; m = m-&gt;next)
+     {
+	if (m-&gt;marker == JPEG_COM)
+	  {
+	     if (im-&gt;in.comment) free(im-&gt;in.comment);
+	     im-&gt;in.comment = malloc(m-&gt;data_length + 1);
+	     if (im-&gt;in.comment)
+	       {
+		  memcpy(im-&gt;in.comment, m-&gt;data, m-&gt;data_length);
+		  im-&gt;in.comment[m-&gt;data_length] = 0;
+	       }
+	  }
+	else if (m-&gt;marker == (JPEG_APP0 + 7))
+	  {
+	     if ((m-&gt;data_length &gt; 7) &amp;&amp;
+		 (!strncmp((char *)m-&gt;data, &quot;Thumb::&quot;, 7)))
+	       {
+		  char *p, *p2;
+		  
+		  p = malloc(m-&gt;data_length + 1);
+		  if (p)
+		    {
+		       memcpy(p, m-&gt;data, m-&gt;data_length);
+		       p[m-&gt;data_length] = 0;
+		       p2 = strchr(p, '\n');
+		       if (p2)
+			 {
+			    p2[0] = 0;
+			    if (!strcmp(p, &quot;Thumb::URI&quot;))
+
+			      im-&gt;in.thumb_info.uri = strdup(p2 + 1);
+			    else if (!strcmp(p, &quot;Thumb::MTime&quot;))
+			      sscanf(p2 + 1, &quot;%llu&quot;, &amp;(im-&gt;in.thumb_info.mtime));
+			    else if (!strcmp(p, &quot;Thumb::Image::Width&quot;))
+			      im-&gt;in.thumb_info.w = atoi(p2 + 1);
+			    else if (!strcmp(p, &quot;Thumb::Image::Height&quot;))
+			      im-&gt;in.thumb_info.h = atoi(p2 + 1);
+			    else if (!strcmp(p, &quot;Thumb::Mimetype&quot;))
+			      im-&gt;in.thumb_info.mime = strdup(p2 + 1);
+			 }
+		       free(p);
+		    }
+	       }
+	  }
+     }
+   return im;
+}
+
+/**
+  retval 1 - malloc or other
+         2 - setjmp error
+*/
+static int
+_epeg_decode(Epeg_Image *im)
+{
+   int scale, scalew, scaleh, y;
+   JDIMENSION old_output_scanline = 1;
+   
+   if (im-&gt;pixels) return 1;
+   if ((im-&gt;out.w &lt; 1) || (im-&gt;out.h &lt; 1)) return 1;
+   
+   scalew = im-&gt;in.w / im-&gt;out.w;
+   scaleh = im-&gt;in.h / im-&gt;out.h;
+   
+   scale = scalew;   
+   if (scaleh &lt; scalew) scale = scaleh;
+
+   if      (scale &gt; 8) scale = 8;
+   else if (scale &lt; 1) scale = 1;
+   
+   im-&gt;in.jinfo.scale_num           = 1;
+   im-&gt;in.jinfo.scale_denom         = scale;
+   im-&gt;in.jinfo.do_fancy_upsampling = FALSE;
+   im-&gt;in.jinfo.do_block_smoothing  = FALSE;
+   im-&gt;in.jinfo.dct_method          = JDCT_IFAST;
+
+   switch (im-&gt;color_space)
+     {
+      case EPEG_GRAY8:
+	im-&gt;in.jinfo.out_color_space = JCS_GRAYSCALE;
+	im-&gt;in.jinfo.output_components = 1;
+	break;
+		
+      case EPEG_YUV8:
+	im-&gt;in.jinfo.out_color_space = JCS_YCbCr;
+	break;
+		
+      case EPEG_RGB8:
+      case EPEG_BGR8:
+      case EPEG_RGBA8:
+      case EPEG_BGRA8:
+      case EPEG_ARGB32:
+	im-&gt;in.jinfo.out_color_space = JCS_RGB;
+	break;
+		
+      case EPEG_CMYK:
+	im-&gt;in.jinfo.out_color_space = JCS_CMYK;
+	im-&gt;in.jinfo.output_components = 4;
+	break;
+	
+      default:
+	break;
+     }
+   
+   im-&gt;out.jinfo.err			= jpeg_std_error(&amp;(im-&gt;jerr.pub));
+   im-&gt;jerr.pub.error_exit		= _epeg_fatal_error_handler;
+#ifdef NOWARNINGS
+   im-&gt;jerr.pub.emit_message = _emit_message;
+   im-&gt;jerr.pub.output_message = _output_message;
+   im-&gt;jerr.pub.format_message = _format_message;
+#endif
+
+   if (setjmp(im-&gt;jerr.setjmp_buffer))
+     return 2;
+
+   jpeg_calc_output_dimensions(&amp;(im-&gt;in.jinfo));
+   
+   im-&gt;pixels = malloc(im-&gt;in.jinfo.output_width * im-&gt;in.jinfo.output_height * im-&gt;in.jinfo.output_components);
+   if (!im-&gt;pixels) return 1;
+	
+   im-&gt;lines = malloc(im-&gt;in.jinfo.output_height * sizeof(char *));
+   if (!im-&gt;lines)
+     {
+	free(im-&gt;pixels);
+	im-&gt;pixels = NULL;
+	return 1;
+     }
+	
+   jpeg_start_decompress(&amp;(im-&gt;in.jinfo));
+   
+   for (y = 0; y &lt; im-&gt;in.jinfo.output_height; y++)
+     im-&gt;lines[y] = im-&gt;pixels + (y * im-&gt;in.jinfo.output_components * im-&gt;in.jinfo.output_width);
+   
+   while (im-&gt;in.jinfo.output_scanline &lt; im-&gt;in.jinfo.output_height)
+     {
+	if (old_output_scanline == im-&gt;in.jinfo.output_scanline)
+	  {
+	     jpeg_abort_decompress(&amp;(im-&gt;in.jinfo));
+	     return 1;
+	  }
+	old_output_scanline = im-&gt;in.jinfo.output_scanline;
+	jpeg_read_scanlines(&amp;(im-&gt;in.jinfo), 
+			    &amp;(im-&gt;lines[im-&gt;in.jinfo.output_scanline]), 
+			    im-&gt;in.jinfo.rec_outbuf_height);
+     }
+   
+   jpeg_finish_decompress(&amp;(im-&gt;in.jinfo));
+   
+   return 0;
+}
+
+static int
+_epeg_scale(Epeg_Image *im)
+{
+   unsigned char *dst, *row, *src;
+   int            x, y, w, h, i;
+   
+   if ((im-&gt;in.w == im-&gt;out.w) &amp;&amp; (im-&gt;in.h == im-&gt;out.h)) return 0;
+   if (im-&gt;scaled) return 0;
+   
+   if ((im-&gt;out.w &lt; 1) || (im-&gt;out.h &lt; 1)) return 0;
+   
+   im-&gt;scaled = 1;
+   w = im-&gt;out.w;
+   h = im-&gt;out.h;
+   for (y = 0; y &lt; h; y++)
+     {
+	row = im-&gt;pixels + (((y * im-&gt;in.jinfo.output_height) / h) * im-&gt;in.jinfo.output_components * im-&gt;in.jinfo.output_width);
+	dst = im-&gt;pixels + (y * im-&gt;in.jinfo.output_components * im-&gt;in.jinfo.output_width);
+	
+	for (x = 0; x &lt; im-&gt;out.w; x++)
+	  {
+	     src = row + (((x * im-&gt;in.jinfo.output_width) / w) * im-&gt;in.jinfo.output_components);
+	     for (i = 0; i &lt; im-&gt;in.jinfo.output_components; i++)
+	       dst[i] = src[i];
+	     dst += im-&gt;in.jinfo.output_components;
+	  }
+     }
+   return 0;
+}
+
+static int
+_epeg_decode_for_trim(Epeg_Image *im)
+{
+   int		y;
+   
+   if (im-&gt;pixels) return 1;
+
+   im-&gt;in.jinfo.scale_num           = 1;
+   im-&gt;in.jinfo.scale_denom         = 1;
+   im-&gt;in.jinfo.do_fancy_upsampling = FALSE;
+   im-&gt;in.jinfo.do_block_smoothing  = FALSE;
+   im-&gt;in.jinfo.dct_method          = JDCT_ISLOW;
+   
+   switch (im-&gt;color_space)
+     {
+      case EPEG_GRAY8:
+	im-&gt;in.jinfo.out_color_space = JCS_GRAYSCALE;
+	im-&gt;in.jinfo.output_components = 1;
+	break;
+	
+      case EPEG_YUV8:
+	im-&gt;in.jinfo.out_color_space = JCS_YCbCr;
+	break;
+	
+      case EPEG_RGB8:
+      case EPEG_BGR8:
+      case EPEG_RGBA8:
+      case EPEG_BGRA8:
+      case EPEG_ARGB32:
+	im-&gt;in.jinfo.out_color_space = JCS_RGB;
+	break;
+	
+      case EPEG_CMYK:
+	im-&gt;in.jinfo.out_color_space = JCS_CMYK;
+	im-&gt;in.jinfo.output_components = 4;
+	break;
+	
+      default:
+	break;
+     }
+   
+   im-&gt;out.jinfo.err = jpeg_std_error(&amp;(im-&gt;jerr.pub));
+   im-&gt;jerr.pub.error_exit = _epeg_fatal_error_handler;
+#ifdef NOWARNINGS
+   im-&gt;jerr.pub.emit_message = _emit_message;
+   im-&gt;jerr.pub.output_message = _output_message;
+   im-&gt;jerr.pub.format_message = _format_message;
+#endif
+   
+   if (setjmp(im-&gt;jerr.setjmp_buffer))
+     return 1;
+
+   jpeg_calc_output_dimensions(&amp;(im-&gt;in.jinfo));
+
+   im-&gt;pixels = malloc(im-&gt;in.jinfo.output_width * im-&gt;in.jinfo.output_height * im-&gt;in.jinfo.output_components);
+   if (!im-&gt;pixels) return 1;
+   
+   im-&gt;lines = malloc(im-&gt;in.jinfo.output_height * sizeof(char *));
+   if (!im-&gt;lines)
+     {
+	free(im-&gt;pixels);
+	im-&gt;pixels = NULL;
+	return 1;
+     }
+   
+   jpeg_start_decompress(&amp;(im-&gt;in.jinfo));
+   
+   for (y = 0; y &lt; im-&gt;in.jinfo.output_height; y++)
+     im-&gt;lines[y] = im-&gt;pixels + (y * im-&gt;in.jinfo.output_components * im-&gt;in.jinfo.output_width);
+   
+   while (im-&gt;in.jinfo.output_scanline &lt; im-&gt;in.jinfo.output_height)
+     jpeg_read_scanlines(&amp;(im-&gt;in.jinfo), 
+			 &amp;(im-&gt;lines[im-&gt;in.jinfo.output_scanline]), 
+			 im-&gt;in.jinfo.rec_outbuf_height);
+   
+   jpeg_finish_decompress(&amp;(im-&gt;in.jinfo));
+   
+   return 0;
+}
+
+static int
+_epeg_trim(Epeg_Image *im)
+{
+   int            y, a, b, w, h;
+   
+   if ((im-&gt;in.w == im-&gt;out.w) &amp;&amp; (im-&gt;in.h == im-&gt;out.h)) return 1;
+   if (im-&gt;scaled) return 1;
+   
+   im-&gt;scaled = 1;
+   w = im-&gt;out.w;
+   h = im-&gt;out.h;
+   a = im-&gt;out.x;
+   b = im-&gt;out.y;
+   
+   for (y = 0; y &lt; h; y++)
+     im-&gt;lines[y] = im-&gt;pixels + ((y+b) * im-&gt;in.jinfo.output_components * im-&gt;in.jinfo.output_width) + (a * im-&gt;in.jinfo.output_components);
+   
+   return 0;
+}
+
+struct epeg_destination_mgr
+{
+   struct jpeg_destination_mgr dst_mgr;
+   Epeg_Image *im;
+   unsigned char *buf;
+};
+
+static int
+_epeg_encode(Epeg_Image *im)
+{
+   struct epeg_destination_mgr *dst_mgr = NULL;
+   int ok = 0;
+
+   if ((im-&gt;out.w &lt; 1) || (im-&gt;out.h &lt; 1)) return 1;
+   if (im-&gt;out.f) return 1;
+   
+   if (im-&gt;out.file)
+     {
+	im-&gt;out.f = fopen(im-&gt;out.file, &quot;wb&quot;);
+	if (!im-&gt;out.f)
+   	  {
+	     im-&gt;error = 1;
+	     return 1;
+	  }
+     }
+   else
+     im-&gt;out.f = NULL;
+   
+   im-&gt;out.jinfo.err = jpeg_std_error(&amp;(im-&gt;jerr.pub));
+   im-&gt;jerr.pub.error_exit = _epeg_fatal_error_handler;
+#ifdef NOWARNINGS
+   im-&gt;jerr.pub.emit_message = _emit_message;
+   im-&gt;jerr.pub.output_message = _output_message;
+   im-&gt;jerr.pub.format_message = _format_message;
+#endif
+   
+   if (setjmp(im-&gt;jerr.setjmp_buffer))
+     {
+	ok = 1;
+	im-&gt;error = 1;
+	goto done;
+     }
+
+   jpeg_create_compress(&amp;(im-&gt;out.jinfo));
+   if (im-&gt;out.f)
+     jpeg_stdio_dest(&amp;(im-&gt;out.jinfo), im-&gt;out.f);
+   else
+     {
+	*(im-&gt;out.mem.data) = NULL;
+	*(im-&gt;out.mem.size) = 0;
+	/* Setup RAM destination manager */
+	dst_mgr = calloc(1, sizeof(struct epeg_destination_mgr));
+	if (!dst_mgr) return 1;
+	dst_mgr-&gt;dst_mgr.init_destination = _jpeg_init_destination;
+	dst_mgr-&gt;dst_mgr.empty_output_buffer = _jpeg_empty_output_buffer;
+	dst_mgr-&gt;dst_mgr.term_destination = _jpeg_term_destination;
+	dst_mgr-&gt;im = im;
+	dst_mgr-&gt;buf = malloc(65536);
+	if (!dst_mgr-&gt;buf)
+	  {
+	     ok = 1;
+	     im-&gt;error = 1;
+	     goto done;
+	  }
+   	im-&gt;out.jinfo.dest = (struct jpeg_destination_mgr *)dst_mgr;
+     }
+   im-&gt;out.jinfo.image_width      = im-&gt;out.w;
+   im-&gt;out.jinfo.image_height     = im-&gt;out.h;
+   im-&gt;out.jinfo.input_components = im-&gt;in.jinfo.output_components;
+   im-&gt;out.jinfo.in_color_space   = im-&gt;in.jinfo.out_color_space;
+   im-&gt;out.jinfo.dct_method	  = im-&gt;in.jinfo.dct_method;
+   jpeg_set_defaults(&amp;(im-&gt;out.jinfo));
+   jpeg_set_quality(&amp;(im-&gt;out.jinfo), im-&gt;out.quality, TRUE);   
+   
+   if (im-&gt;out.quality &gt;= 90)
+     {
+	im-&gt;out.jinfo.comp_info[0].h_samp_factor = 1;
+	im-&gt;out.jinfo.comp_info[0].v_samp_factor = 1;
+	im-&gt;out.jinfo.comp_info[1].h_samp_factor = 1;
+	im-&gt;out.jinfo.comp_info[1].v_samp_factor = 1;
+	im-&gt;out.jinfo.comp_info[2].h_samp_factor = 1;
+	im-&gt;out.jinfo.comp_info[2].v_samp_factor = 1;
+     }
+   jpeg_start_compress(&amp;(im-&gt;out.jinfo), TRUE);
+
+   if (im-&gt;out.comment)
+     jpeg_write_marker(&amp;(im-&gt;out.jinfo), JPEG_COM, im-&gt;out.comment, strlen(im-&gt;out.comment));
+   
+   if (im-&gt;out.thumbnail_info)
+     {
+	char buf[8192];
+	
+	if (im-&gt;in.file)
+	  {
+	     snprintf(buf, sizeof(buf), &quot;Thumb::URI\<A HREF="nfile://%s">nfile://%s</A>&quot;, im-&gt;in.file);
+	     jpeg_write_marker(&amp;(im-&gt;out.jinfo), JPEG_APP0 + 7, buf, strlen(buf));
+	     snprintf(buf, sizeof(buf), &quot;Thumb::MTime\n%llu&quot;, (unsigned long long int)im-&gt;stat_info.st_mtime);
+	  }
+	jpeg_write_marker(&amp;(im-&gt;out.jinfo), JPEG_APP0 + 7, buf, strlen(buf));
+	snprintf(buf, sizeof(buf), &quot;Thumb::Image::Width\n%i&quot;, im-&gt;in.w);
+	jpeg_write_marker(&amp;(im-&gt;out.jinfo), JPEG_APP0 + 7, buf, strlen(buf));
+	snprintf(buf, sizeof(buf), &quot;Thumb::Image::Height\n%i&quot;, im-&gt;in.h);
+	jpeg_write_marker(&amp;(im-&gt;out.jinfo), JPEG_APP0 + 7, buf, strlen(buf));
+	snprintf(buf, sizeof(buf), &quot;Thumb::Mimetype\nimage/jpeg&quot;);
+	jpeg_write_marker(&amp;(im-&gt;out.jinfo), JPEG_APP0 + 7, buf, strlen(buf));
+     }
+   
+   while (im-&gt;out.jinfo.next_scanline &lt; im-&gt;out.h)
+     jpeg_write_scanlines(&amp;(im-&gt;out.jinfo), &amp;(im-&gt;lines[im-&gt;out.jinfo.next_scanline]), 1);
+   jpeg_finish_compress(&amp;(im-&gt;out.jinfo));
+
+   done:
+   if ((im-&gt;in.f) || (im-&gt;in.mem.data != NULL)) jpeg_destroy_decompress(&amp;(im-&gt;in.jinfo));
+   if ((im-&gt;in.f) &amp;&amp; (im-&gt;in.file)) fclose(im-&gt;in.f);
+   if (dst_mgr)
+     {
+	if (dst_mgr-&gt;buf) free(dst_mgr-&gt;buf);
+	free(dst_mgr);
+	im-&gt;out.jinfo.dest = NULL;
+     }
+   jpeg_destroy_compress(&amp;(im-&gt;out.jinfo));
+   if ((im-&gt;out.f) &amp;&amp; (im-&gt;out.file)) fclose(im-&gt;out.f); 
+   im-&gt;in.f = NULL;
+   im-&gt;out.f = NULL;
+   
+   return ok;
+}
+
+static void 
+_epeg_fatal_error_handler(j_common_ptr cinfo)
+{
+   emptr errmgr;
+   
+   errmgr = (emptr)cinfo-&gt;err;
+   longjmp(errmgr-&gt;setjmp_buffer, 1);
+   return;
+}
+
+/* Source manager methods */
+METHODDEF(void)
+_jpeg_decompress_error_exit(j_common_ptr cinfo)
+{
+}
+
+
+METHODDEF(void)
+_jpeg_init_source(j_decompress_ptr cinfo)
+{
+}
+
+METHODDEF(boolean)
+_jpeg_fill_input_buffer(j_decompress_ptr cinfo)
+{
+   WARNMS(cinfo, JWRN_JPEG_EOF);
+   
+   /* Insert a fake EOI marker */
+   cinfo-&gt;src-&gt;next_input_byte = fake_EOI;
+   cinfo-&gt;src-&gt;bytes_in_buffer = sizeof(fake_EOI);
+   return TRUE;
+}
+
+
+METHODDEF(void)
+_jpeg_skip_input_data(j_decompress_ptr cinfo, long num_bytes)
+{
+   if (num_bytes &gt; (long)(cinfo)-&gt;src-&gt;bytes_in_buffer)
+     ERREXIT(cinfo, 0);
+   
+   (cinfo)-&gt;src-&gt;next_input_byte += num_bytes;
+   (cinfo)-&gt;src-&gt;bytes_in_buffer -= num_bytes;
+}
+
+METHODDEF(void)
+_jpeg_term_source(j_decompress_ptr cinfo)
+{
+}
+
+
+/* destination manager methods */
+METHODDEF(void)
+_jpeg_init_destination(j_compress_ptr cinfo)
+{
+   struct epeg_destination_mgr *dst_mgr;
+   
+   dst_mgr = (struct epeg_destination_mgr *)cinfo-&gt;dest;
+   dst_mgr-&gt;dst_mgr.free_in_buffer = 65536;
+   dst_mgr-&gt;dst_mgr.next_output_byte = (JOCTET *)dst_mgr-&gt;buf;
+}
+
+METHODDEF(boolean)
+_jpeg_empty_output_buffer(j_compress_ptr cinfo)
+{
+   struct epeg_destination_mgr *dst_mgr;
+   unsigned char *p;
+   int psize;
+   
+   dst_mgr = (struct epeg_destination_mgr *)cinfo-&gt;dest;
+   psize = *(dst_mgr-&gt;im-&gt;out.mem.size);
+   *(dst_mgr-&gt;im-&gt;out.mem.size) += 65536;
+   p = realloc(*(dst_mgr-&gt;im-&gt;out.mem.data), *(dst_mgr-&gt;im-&gt;out.mem.size));
+   if (p)
+     {
+	memcpy(p + psize, dst_mgr-&gt;buf, 65536);
+	dst_mgr-&gt;dst_mgr.free_in_buffer = 65536;
+	dst_mgr-&gt;dst_mgr.next_output_byte = (JOCTET *)dst_mgr-&gt;buf;
+     }
+   else
+     return FALSE;
+   return TRUE;
+}
+
+METHODDEF(void)
+_jpeg_term_destination(j_compress_ptr cinfo)
+{
+   struct epeg_destination_mgr *dst_mgr;
+   unsigned char *p;
+   int psize;
+   
+   dst_mgr = (struct epeg_destination_mgr *)cinfo-&gt;dest;
+   psize = *(dst_mgr-&gt;im-&gt;out.mem.size);
+   *(dst_mgr-&gt;im-&gt;out.mem.size) += 65536 - dst_mgr-&gt;dst_mgr.free_in_buffer;
+   p = realloc(*(dst_mgr-&gt;im-&gt;out.mem.data), *(dst_mgr-&gt;im-&gt;out.mem.size));
+   if (p)
+     {
+	*(dst_mgr-&gt;im-&gt;out.mem.data) = p;
+	memcpy(p + psize, dst_mgr-&gt;buf, 65536 - dst_mgr-&gt;dst_mgr.free_in_buffer);
+     }
+}
+
+/* be noisy - not */
+METHODDEF(void)
+_emit_message(j_common_ptr cinfo, int msg_level)
+{
+}
+
+METHODDEF(void)
+_output_message(j_common_ptr cinfo)
+{
+}
+
+METHODDEF(void)
+_format_message(j_common_ptr cinfo, char * buffer)
+{
+}


Property changes on: trunk/griv/epeg/epeg_main.c
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Added: trunk/griv/epeg/epeg_private.h
===================================================================
--- trunk/griv/epeg/epeg_private.h	2007-11-16 14:27:37 UTC (rev 1553)
+++ trunk/griv/epeg/epeg_private.h	2007-11-16 15:14:29 UTC (rev 1554)
@@ -0,0 +1,86 @@
+#ifndef _EPEG_PRIVATE_H
+#define _EPEG_PRIVATE_H
+
+#include &lt;stdio.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;limits.h&gt;
+#include &lt;time.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;setjmp.h&gt;
+#include &lt;jpeglib.h&gt;
+
+//#include &quot;config.h&quot;
+
+typedef struct _epeg_error_mgr *emptr;
+
+struct _epeg_error_mgr
+{
+      struct     jpeg_error_mgr pub;
+      jmp_buf    setjmp_buffer;
+};
+
+struct _Epeg_Image
+{
+   struct _epeg_error_mgr          jerr;
+   struct stat                     stat_info;
+   unsigned char                  *pixels;
+   unsigned char                 **lines;
+   
+   char                            scaled : 1;
+   
+   int                             error;
+   
+   Epeg_Colorspace                 color_space;
+   
+   struct {
+      char                          *file;
+      struct {
+	 unsigned char           **data;
+	 int                       size;
+      } mem;
+      int                            w, h;
+      char                          *comment;
+      FILE                          *f;
+      J_COLOR_SPACE                  color_space;
+      struct jpeg_decompress_struct  jinfo;
+      struct {
+	 char                       *uri;
+	 unsigned long long int      mtime;
+	 int                         w, h;
+	 char                       *mime;
+      } thumb_info;
+   } in;
+   struct {
+      char                        *file;
+      struct {
+	 unsigned char           **data;
+	 int                      *size;
+      } mem;
+      int                          x, y;
+      int                          w, h;
+      char                        *comment;
+      FILE                        *f;
+      struct jpeg_compress_struct  jinfo;
+      int                          quality;
+      char                         thumbnail_info : 1;
+   } out;
+};
+
+METHODDEF(void) _jpeg_decompress_error_exit(j_common_ptr cinfo);
+METHODDEF(void) _jpeg_init_source(j_decompress_ptr cinfo);
+METHODDEF(boolean) _jpeg_fill_input_buffer(j_decompress_ptr cinfo);
+METHODDEF(void) _jpeg_skip_input_data(j_decompress_ptr cinfo, long num_bytes);
+METHODDEF(void) _jpeg_term_source(j_decompress_ptr cinfo);
+
+METHODDEF(void) _jpeg_init_destination(j_compress_ptr cinfo);
+METHODDEF(boolean) _jpeg_empty_output_buffer (j_compress_ptr cinfo);
+METHODDEF(void) _jpeg_term_destination (j_compress_ptr cinfo);
+    
+METHODDEF(void) _emit_message (j_common_ptr cinfo, int msg_level);
+METHODDEF(void) _output_message (j_common_ptr cinfo);
+METHODDEF(void) _format_message (j_common_ptr cinfo, char * buffer);
+#endif


Property changes on: trunk/griv/epeg/epeg_private.h
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Modified: trunk/griv/thumbgen.cpp
===================================================================
--- trunk/griv/thumbgen.cpp	2007-11-16 14:27:37 UTC (rev 1553)
+++ trunk/griv/thumbgen.cpp	2007-11-16 15:14:29 UTC (rev 1554)
@@ -3,7 +3,7 @@
 #include &lt;stdexcept&gt;
 #include &lt;iomanip&gt;
 #include &lt;iostream&gt;
-#include &lt;Epeg.h&gt;
+#include &quot;epeg/Epeg.h&quot;
 #include &lt;mhash.h&gt;
 #include &quot;filesystem.hpp&quot;
 
@@ -53,7 +53,7 @@
 
           if (w &gt; sizes[i] || h &gt; sizes[i])
             {
-              epeg_quality_set(img, 75);
+              epeg_quality_set(img, 80);
               epeg_thumbnail_comments_enable(img, 1);
 
               if (w &gt; h)

Modified: trunk/griv/thumbget.cpp
===================================================================
--- trunk/griv/thumbget.cpp	2007-11-16 14:27:37 UTC (rev 1553)
+++ trunk/griv/thumbget.cpp	2007-11-16 15:14:29 UTC (rev 1554)
@@ -1,6 +1,6 @@
 // Little experimental epeg test app
 
-#include &lt;Epeg.h&gt;
+#include &quot;epeg/Epeg.h&quot;
 #include &lt;iostream&gt;
 
 int main(int argc, char** argv)

Modified: trunk/griv/thumbnail_store.cpp
===================================================================
--- trunk/griv/thumbnail_store.cpp	2007-11-16 14:27:37 UTC (rev 1553)
+++ trunk/griv/thumbnail_store.cpp	2007-11-16 15:14:29 UTC (rev 1554)
@@ -23,7 +23,7 @@
 **  02111-1307, USA.
 */
 
-#include &lt;Epeg.h&gt;
+#include &quot;epeg/Epeg.h&quot;
 #include &lt;sstream&gt;
 #include &lt;iostream&gt;
 #include &lt;stdexcept&gt;
@@ -83,7 +83,7 @@
 
   if (w &gt; thumb_size || h &gt; thumb_size)
     {
-      epeg_quality_set(img, 75);
+      epeg_quality_set(img, 80);
       epeg_thumbnail_comments_enable(img, 1);
 
       if (w &gt; h)

Modified: trunk/griv/thumbnail_store.hpp
===================================================================
--- trunk/griv/thumbnail_store.hpp	2007-11-16 14:27:37 UTC (rev 1553)
+++ trunk/griv/thumbnail_store.hpp	2007-11-16 15:14:29 UTC (rev 1554)
@@ -33,6 +33,7 @@
 class ThumbnailStore
 {
 private:
+
 public:
   ThumbnailStore();
   ~ThumbnailStore();


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001204.html">[Windstille-commit] r1553 - trunk/griv
</A></li>
	<LI>Next message: <A HREF="001206.html">[Windstille-commit] r1555 - in trunk/griv: . obsolete
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1205">[ date ]</a>
              <a href="thread.html#1205">[ thread ]</a>
              <a href="subject.html#1205">[ subject ]</a>
              <a href="author.html#1205">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/windstille-commit">More information about the Windstille-commit
mailing list</a><br>
</body></html>
