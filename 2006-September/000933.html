<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Windstille-commit] r1281 - in trunk/windstille-nds: sketches	windstille windstille/source windstille/tools
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/windstille-commit/2006-September/index.html" >
   <LINK REL="made" HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r1281%20-%20in%20trunk/windstille-nds%3A%20sketches%0A%09windstille%20windstille/source%20windstille/tools&In-Reply-To=%3C200609082014.k88KENUa004848%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000932.html">
   <LINK REL="Next"  HREF="000934.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Windstille-commit] r1281 - in trunk/windstille-nds: sketches	windstille windstille/source windstille/tools</H1>
    <B>grumbel at BerliOS</B> 
    <A HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r1281%20-%20in%20trunk/windstille-nds%3A%20sketches%0A%09windstille%20windstille/source%20windstille/tools&In-Reply-To=%3C200609082014.k88KENUa004848%40sheep.berlios.de%3E"
       TITLE="[Windstille-commit] r1281 - in trunk/windstille-nds: sketches	windstille windstille/source windstille/tools">grumbel at mail.berlios.de
       </A><BR>
    <I>Fri Sep  8 22:14:23 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000932.html">[Windstille-commit] r1280 - in trunk/windstille-nds/windstille:	data source
</A></li>
        <LI>Next message: <A HREF="000934.html">[Windstille-commit] r1282 - in trunk/windstille-nds/windstille:	source tools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#933">[ date ]</a>
              <a href="thread.html#933">[ thread ]</a>
              <a href="subject.html#933">[ subject ]</a>
              <a href="author.html#933">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: grumbel
Date: 2006-09-08 22:14:10 +0200 (Fri, 08 Sep 2006)
New Revision: 1281

Added:
   trunk/windstille-nds/sketches/dialog_topscreen.xcf
   trunk/windstille-nds/sketches/subtitlescreen.xcf
   trunk/windstille-nds/sketches/titlescreen.xcf
   trunk/windstille-nds/sketches/use_icon.xcf
   trunk/windstille-nds/windstille/source/glyph.hpp
   trunk/windstille-nds/windstille/tools/
   trunk/windstille-nds/windstille/tools/Makefile
   trunk/windstille-nds/windstille/tools/SConstruct
   trunk/windstille-nds/windstille/tools/main.cpp
Modified:
   trunk/windstille-nds/windstille/source/main.cpp
Log:
- added some tools for variable width font handling

Added: trunk/windstille-nds/sketches/dialog_topscreen.xcf
===================================================================
(Binary files differ)


Property changes on: trunk/windstille-nds/sketches/dialog_topscreen.xcf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/windstille-nds/sketches/subtitlescreen.xcf
===================================================================
(Binary files differ)


Property changes on: trunk/windstille-nds/sketches/subtitlescreen.xcf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/windstille-nds/sketches/titlescreen.xcf
===================================================================
(Binary files differ)


Property changes on: trunk/windstille-nds/sketches/titlescreen.xcf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/windstille-nds/sketches/use_icon.xcf
===================================================================
(Binary files differ)


Property changes on: trunk/windstille-nds/sketches/use_icon.xcf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/windstille-nds/windstille/source/glyph.hpp
===================================================================
--- trunk/windstille-nds/windstille/source/glyph.hpp	2006-09-07 18:46:54 UTC (rev 1280)
+++ trunk/windstille-nds/windstille/source/glyph.hpp	2006-09-08 20:14:10 UTC (rev 1281)
@@ -0,0 +1,44 @@
+/*  $Id: windstille_main.hpp 1274 2006-09-05 19:10:18Z grumbel $
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  &gt; |__| |__|____/____/\___  &gt;
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2006 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_GLYPH_HPP
+#define HEADER_GLYPH_HPP
+
+struct Glyph
+{
+  char chr;
+
+  u8  x;
+  u8  y;
+
+  u8  width;
+  u8  height;
+
+  u8* data;
+};
+
+#endif
+
+/* EOF */

Modified: trunk/windstille-nds/windstille/source/main.cpp
===================================================================
--- trunk/windstille-nds/windstille/source/main.cpp	2006-09-07 18:46:54 UTC (rev 1280)
+++ trunk/windstille-nds/windstille/source/main.cpp	2006-09-08 20:14:10 UTC (rev 1281)
@@ -9,6 +9,9 @@
 #include &lt;nds/arm9/sound.h&gt;             // sound functions
 #include &lt;nds/arm9/video.h&gt;             // sound functions
 
+#include &quot;glyph.hpp&quot;
+#include &quot;verdana10.hpp&quot;
+
 //makefile automaticly makes a header file for access
 //to the binary data in any file ending in .bin that is in
 //the data folder.  It also links in that data to your project
@@ -33,6 +36,9 @@
 #include &quot;subcomm_img_bin.h&quot;
 #include &quot;subweapon_img_bin.h&quot;
 
+#include &quot;use_icon_img_bin.h&quot;
+#include &quot;use_icon_pal_bin.h&quot;
+
 #include &quot;realmap_img_bin.h&quot;
 #include &quot;subscreen_pal_bin.h&quot;
 
@@ -84,10 +90,17 @@
 #include &quot;walk_frame14_pal_bin.h&quot;
 #include &quot;walk_frame15_pal_bin.h&quot;
 
+#include &quot;smalldoor_img_bin.h&quot;
+#include &quot;smalldoor_pal_bin.h&quot;
 
 #include &quot;doorbg_img_bin.h&quot;
 #include &quot;doorbg_pal_bin.h&quot;
 
+#include &quot;dialog_subscreen_pal_bin.h&quot;
+#include &quot;dialog_topscreen_pal_bin.h&quot;
+#include &quot;dialog_subscreen_img_bin.h&quot;
+#include &quot;dialog_topscreen_img_bin.h&quot;
+
 #include &quot;doorfg_img_bin.h&quot;
 #include &quot;doorfg_pal_bin.h&quot;
 
@@ -96,6 +109,24 @@
 
 SpriteEntry sprites[128];
 
+
+bool allow_scrolling_x = true;
+bool allow_scrolling_y = true;
+
+int x;
+int y;
+int px;
+int py;
+int oldx;
+int oldy;
+bool drag;
+touchPosition touch_down;
+touchPosition touch;
+int pressed;
+int held;
+
+enum SubscreenMode { DOOR_MINIGAME, PDA, DIALOG } subscreen_mode = PDA;
+
 //turn off all the sprites
 void initSprites(void)
 {
@@ -123,6 +154,38 @@
   dmaCopy(sprites, OAM, 128 * sizeof(SpriteEntry));
 }
 
+void glyph_blit(Glyph&amp; glyph, int px, int py)
+{
+  px += glyph.x;
+  py += glyph.y;
+
+  px /= 2;
+
+  for(int y = 0; y &lt; glyph.height; ++y)
+    for(int x = 0; x &lt; glyph.width/2; ++x)
+      {
+        ((u16*)BG_GFX_SUB)[(py + y) * 128 + (px + x)] = ((u16*)glyph.data)[(y * glyph.width/2) + x];
+      }
+}
+
+void print_hello_world()
+{
+  char chr2idx[256];;
+
+  for(int i = 0; i &lt; 256; ++i)
+    chr2idx[i] = 0;
+    
+  for(int i = 0; i &lt; verdana10_glyphs_size; ++i)
+    chr2idx[int(verdana10_glyphs[i].chr)] = i;
+               
+  char* str = &quot;# ; &gt;? = C D ,&lt;&quot;;
+  int x = 10;
+  int y = 10;
+  for(unsigned int i = 0; i &lt; strlen(str); ++i)
+    glyph_blit(verdana10_glyphs[int(chr2idx[int(int(str[i]))])], 
+               x += verdana10_glyphs[int(chr2idx[int(str[i])])].width + 2, y);
+}
+
 void titlescreen()
 {
   videoSetMode(MODE_5_2D | DISPLAY_BG3_ACTIVE);
@@ -162,6 +225,8 @@
     BG_GFX_SUB[i] = ((u16*)subtitlescreen_img_bin)[i];
   for(int i = 0; i &lt; 256; ++i)
     BG_PALETTE_SUB[i] = ((u16*)subtitlescreen_pal_bin)[i];
+
+  print_hello_world();
   
   int count = 0;
   while(1) 
@@ -181,8 +246,62 @@
     }
 }
 
-void doorminigame()
+
+void init_dialog()
 {
+  videoSetMode(MODE_5_2D | DISPLAY_BG3_ACTIVE);
+  videoSetModeSub(MODE_5_2D | DISPLAY_BG3_ACTIVE);
+
+  vramSetMainBanks(VRAM_A_MAIN_BG_0x6000000, VRAM_B_MAIN_SPRITE, //VRAM_B_MAIN_BG_0x6020000,
+                   VRAM_C_SUB_BG, VRAM_D_MAIN_BG_0x6020000);
+
+  BG3_CR = BG_BMP8_256x256;
+  SUB_BG3_CR = BG_BMP8_256x256;
+
+  BG3_XDX = 1 &lt;&lt; 8;
+  BG3_XDY = 0;
+  BG3_YDX = 0;
+  BG3_YDY = 1 &lt;&lt; 8;
+
+  BG3_CX = 0;
+  BG3_CY = 0; //32 &lt;&lt; 8;
+
+
+  SUB_BG3_XDX = 1 &lt;&lt; 8;
+  SUB_BG3_XDY = 0;
+  SUB_BG3_YDX = 0;
+  SUB_BG3_YDY = 1 &lt;&lt; 8;
+
+  SUB_BG3_CX = 0;
+  SUB_BG3_CY = 0; //32 &lt;&lt; 8;
+
+
+  for(int i = 0; i &lt; 256; ++i)
+    BG_PALETTE_SUB[i] = ((u16*)dialog_subscreen_pal_bin)[i];
+  
+  for(int i = 0; i &lt; 256; ++i)
+    BG_PALETTE[i] = ((u16*)dialog_topscreen_pal_bin)[i];
+
+  for(int i = 0; i &lt; 256*256/2; ++i)
+    ((u16*)BG_BMP_RAM(0))[i] = ((u16*)dialog_topscreen_img_bin)[i];
+
+  for(int i = 0; i &lt; 256*256/2; ++i)
+    ((u16*)BG_BMP_RAM_SUB(0))[i] = ((u16*)dialog_subscreen_img_bin)[i];
+}
+
+void init_pda();
+
+void update_dialog()
+{
+  if (pressed &amp; KEY_TOUCH)
+    {
+      init_pda();
+      subscreen_mode = PDA;
+    }
+}
+
+void init_doorminigame()
+{
   videoSetModeSub(MODE_5_2D | DISPLAY_BG3_ACTIVE | DISPLAY_BG2_ACTIVE);  
 
   vramSetMainBanks(VRAM_A_MAIN_BG_0x6000000, VRAM_B_MAIN_SPRITE, //VRAM_B_MAIN_BG_0x6020000,
@@ -215,51 +334,208 @@
 
   for(int i = 0; i &lt; 256*256/2; ++i)
     ((u16*)BG_BMP_RAM_SUB(4))[i] = ((u16*)doorfg_img_bin)[i];
+}
 
-  bool dragging = false;
-  touchPosition touch_down = touchReadXY();;
-  int door_pos = 0;
-  int old_pos = 0;
-  while(1) 
+bool dragging = false;
+int door_pos = 0;
+int old_pos = 0;
+
+void update_doorminigame()
+{
+  if (pressed &amp; KEY_TOUCH)
     {
-      swiWaitForVBlank();
-      scanKeys();    
+      touch_down = touchReadXY();
+          
+      if (touch_down.px &gt; 64 &amp;&amp; touch_down.py &gt; 88 &amp;&amp;
+          touch_down.px &lt; door_pos + 64+16 &amp;&amp; touch_down.py &lt; door_pos + 88 + 32)
+        {
+          dragging = true;
+          old_pos = door_pos;
+        }
+    }
 
-      int pressed = keysDown();
-      int held    = keysHeld();
-      if (pressed &amp; KEY_TOUCH)
+  if ((held &amp; KEY_TOUCH) &amp;&amp; dragging == true)
+    {
+      //int scrollpos = abs(std::max(std::min(0, (touch_down.px - cur.px)), -128));
+  
+      door_pos = std::min(std::max(0, old_pos + (touch.px - touch_down.px)), 128);
+    }
+  else
+    {
+      dragging = false;
+    }
+
+  SUB_BG2_CX = -door_pos &lt;&lt; 8;
+  if (door_pos &lt; 4)
+    SUB_BG2_CY = door_pos &lt;&lt; 8;
+  else
+    SUB_BG2_CY = 4 &lt;&lt; 8;
+}
+
+
+void update_pda()
+{
+  if (allow_scrolling_x)
+    SUB_BG3_CX  = x&lt;&lt;8;
+  else
+    SUB_BG3_CX  = 0;
+
+  if (allow_scrolling_y)
+    SUB_BG3_CY  = y&lt;&lt;8;
+  else
+    SUB_BG3_CY  = 0;
+      
+  //SUB_BG2_CX  = -x;
+  //SUB_BG2_CY  = -y;
+
+  if (pressed &amp; KEY_TOUCH)
+    {
+      const u8* picture = 0;
+      const u8* subpicture = 0;
+          
+      if (touch.px &lt; 48)
         {
-          touch_down = touchReadXY();
-          
-          if (touch_down.px &gt; 64 &amp;&amp; touch_down.py &gt; 88 &amp;&amp;
-              touch_down.px &lt; door_pos + 64+16 &amp;&amp; touch_down.py &lt; door_pos + 88 + 32)
+          if (touch.py &lt; 48)
             {
-              dragging = true;
-              old_pos = door_pos;
+              picture = map_img_bin;
+              subpicture = submap_img_bin;
+              allow_scrolling_x = true;
+              allow_scrolling_y = true;
             }
+          else if (touch.py &gt;= 48 &amp;&amp; touch.py &lt; 48*2)
+            {
+              picture = health_img_bin;
+              subpicture = subhealth_img_bin;
+              allow_scrolling_x = false;
+              allow_scrolling_y = false;
+            }
+          else if (touch.py &gt;= 2*48 &amp;&amp; touch.py &lt; 48*3)
+            {
+              picture = log_img_bin;
+              subpicture = sublog_img_bin;
+              allow_scrolling_x = false;
+              allow_scrolling_y = true;
+            }
+          else if (touch.py &gt;= 3*48 &amp;&amp; touch.py &lt; 48*4)
+            {
+              picture = debug_img_bin;
+              subpicture = subdebug_img_bin;
+              allow_scrolling_x = false;
+              allow_scrolling_y = false;
+            }
         }
+      else if (touch.px &gt; 256 - 48)
+        {
+          if (touch.py &lt; 48)
+            {
+              picture = items_img_bin;
+              subpicture = subitems_img_bin;
+              allow_scrolling_x = false;
+              allow_scrolling_y = false;
+            }
+          else if (touch.py &gt;= 48 &amp;&amp; touch.py &lt; 48*2)
+            {
+              picture = scan_img_bin;
+              subpicture = subscan_img_bin;
+              allow_scrolling_x = true;
+              allow_scrolling_y = true;
+            }
+          else if (touch.py &gt;= 2*48 &amp;&amp; touch.py &lt; 48*3)
+            {
+              picture = comm_img_bin;
+              subpicture = subcomm_img_bin;
+              allow_scrolling_x = false;
+              allow_scrolling_y = false;
+            }
+          else if (touch.py &gt;= 3*48 &amp;&amp; touch.py &lt; 48*4)
+            {
+              picture = weapon_img_bin;
+              subpicture = subweapon_img_bin;
+              allow_scrolling_x = false;
+              allow_scrolling_y = false;
+            }
+        }
 
-      if ((held &amp; KEY_TOUCH) &amp;&amp; dragging == true)
+      if (picture)
         {
-          touchPosition cur = touchReadXY();
+          for(int i = 0; i &lt; 256*192/2; ++i)
+            ((u16*)BG_BMP_RAM_SUB(4))[i] = ((u16*)picture)[i];
           
-          //int scrollpos = abs(std::max(std::min(0, (touch_down.px - cur.px)), -128));
-  
-          door_pos = std::min(std::max(0, old_pos + (cur.px - touch_down.px)), 128);
+          
+          TransferSoundData blaster = {
+            blaster_bin,            /* Sample address */
+            blaster_bin_size,       /* Sample length */
+            11025,                  /* Sample rate */
+            127,                    /* Volume */
+            64,                     /* panning */
+            1                       /* format */
+          };
+
+          playSound(&amp;blaster);
+
+          if (subpicture)
+            {
+              for(int i = 0; i &lt; 256*256/2; ++i)
+                ((u16*)BG_BMP_RAM_SUB(0))[i] = ((u16*)subpicture)[i];
+            }
         }
-      else
+      else 
         {
-          dragging = false;
+          // Didn't click on anything, so we assume middle region
+          touch_down = touch;
+          oldx = x;
+          oldy = y;
+          drag = true;
         }
+    }  
+}
 
-      SUB_BG2_CX = -door_pos &lt;&lt; 8;
-      if (door_pos &lt; 4)
-        SUB_BG2_CY = door_pos &lt;&lt; 8;
-      else
-        SUB_BG2_CY = 4 &lt;&lt; 8;
-    }
+void update_subscreen()
+{
+  if (subscreen_mode == PDA)
+    update_pda();
+  else if (subscreen_mode == DIALOG)
+    update_dialog();
+  else
+    update_doorminigame();
 }
 
+void init_pda()
+{
+
+  // set the sub background up for text display (we could just print to one
+  // of the main display text backgrounds just as easily
+  videoSetModeSub(MODE_5_2D | DISPLAY_BG3_ACTIVE | DISPLAY_BG2_ACTIVE);
+  SUB_BG2_CR = BG_BMP8_256x256 | BG_WRAP_ON | BG_BMP_BASE(4);
+  SUB_BG3_CR = BG_BMP8_256x256 | BG_WRAP_ON;
+
+  SUB_BG3_XDX = 1 &lt;&lt; 8;
+  SUB_BG3_XDY = 0;
+  SUB_BG3_YDX = 0;
+  SUB_BG3_YDY = 1 &lt;&lt; 8;
+
+  SUB_BG2_XDX = 1 &lt;&lt; 8;
+  SUB_BG2_XDY = 0;
+  SUB_BG2_YDX = 0;
+  SUB_BG2_YDY = 1 &lt;&lt; 8;
+  
+
+  SUB_BG3_CX = 0;
+  SUB_BG3_CY = 0; //32 &lt;&lt; 8;
+
+  SUB_BG2_CX = 0;//2000;
+  SUB_BG2_CY = 0;//2000; //32 &lt;&lt; 8;
+
+  for(int i = 0; i &lt; 256; ++i)
+    BG_PALETTE_SUB[i] = ((u16*)subscreen_pal_bin)[i];
+
+  for(int i = 0; i &lt; 256*192/2; ++i)
+    ((u16*)BG_BMP_RAM_SUB(4))[i] = ((u16*)map_img_bin)[i];
+
+  for(int i = 0; i &lt; 256*256/2; ++i)
+    ((u16*)BG_BMP_RAM_SUB(0))[i] = ((u16*)realmap_img_bin)[i];
+}
+
 void gamescreen()
 {
   // set the mode for 2 text layers and two extended background layers
@@ -269,10 +545,6 @@
                DISPLAY_SPR_ACTIVE | DISPLAY_SPR_1D_LAYOUT
                );
 
-  // set the sub background up for text display (we could just print to one
-  // of the main display text backgrounds just as easily
-  videoSetModeSub(MODE_5_2D | DISPLAY_BG3_ACTIVE | DISPLAY_BG2_ACTIVE);
-
   // set the first bank as background memory and the third as sub background memory
   // B and D are not used (if you want a bitmap greater than 256x256 you will need more
   // memory so another vram bank must be used and mapped consecutivly
@@ -285,8 +557,6 @@
   
   BG1_CR = BG_32x32 | BG_TILE_BASE(0) | BG_MAP_BASE(8) | BG_256_COLOR;
 
-  SUB_BG2_CR = BG_BMP8_256x256 | BG_WRAP_ON | BG_BMP_BASE(4);
-  SUB_BG3_CR = BG_BMP8_256x256 | BG_WRAP_ON;
 
   // these are rotation backgrounds so you must set the rotation attributes:
   // these are fixed point numbers with the low 8 bits the fractional part
@@ -301,16 +571,7 @@
   BG2_YDX = 0;
   BG2_YDY = 1 &lt;&lt; 8;
 
-  SUB_BG3_XDX = 1 &lt;&lt; 8;
-  SUB_BG3_XDY = 0;
-  SUB_BG3_YDX = 0;
-  SUB_BG3_YDY = 1 &lt;&lt; 8;
 
-  SUB_BG2_XDX = 1 &lt;&lt; 8;
-  SUB_BG2_XDY = 0;
-  SUB_BG2_YDX = 0;
-  SUB_BG2_YDY = 1 &lt;&lt; 8;
-
   //our bitmap looks a bit better if we center it so scroll down (256 - 192) / 2
   BG3_CX = 0;
   BG3_CY = 0;
@@ -318,12 +579,6 @@
   BG2_CX = 0;
   BG2_CY = 0;
 
-  SUB_BG3_CX = 0;
-  SUB_BG3_CY = 0; //32 &lt;&lt; 8;
-
-  SUB_BG2_CX = 0;//2000;
-  SUB_BG2_CY = 0;//2000; //32 &lt;&lt; 8;
-
   for(int i = 0; i &lt; 512*256; i++)
     BG_GFX[i] = ((u16*)topscreen_img_bin)[i];
 
@@ -332,32 +587,15 @@
   //for(int i = 0; i &lt; 256; ++i)
   //BG_PALETTE[i] = ((u16*)numbers_pal_bin)[i];
 
-  for(int i = 0; i &lt; 256; ++i)
-    BG_PALETTE_SUB[i] = ((u16*)subscreen_pal_bin)[i];
-
-  for(int i = 0; i &lt; 256*192/2; ++i)
-    ((u16*)BG_BMP_RAM_SUB(4))[i] = ((u16*)health_img_bin)[i];
-
-  for(int i = 0; i &lt; 256*256/2; ++i)
-    ((u16*)BG_BMP_RAM_SUB(0))[i] = ((u16*)realmap_img_bin)[i];
-
-  TransferSoundData blaster = {
-    blaster_bin,            /* Sample address */
-    blaster_bin_size,       /* Sample length */
-    11025,                  /* Sample rate */
-    127,                    /* Volume */
-    64,                     /* panning */
-    1                       /* format */
-  };
         
-  int x = 0;
-  int y = 0;
-  int px = 128-32;
-  int py = 103;
-  int oldx = x;
-  int oldy = y;
-  bool drag = false;
-  touchPosition touch_down = touchReadXY();
+  x = 0;
+  y = 0;
+  px = 128-32;
+  py = 103;
+  oldx = x;
+  oldy = y;
+  drag = false;
+  touch_down = touchReadXY();
 
   initSprites();
   
@@ -417,7 +655,13 @@
   for(int i=0;i&lt;64*32; ++i)
     SPRITE_GFX[i] = ((u16*)sprite_img_bin)[i];
 
+  for(int i=0;i&lt;32*32/2; ++i)
+    SPRITE_GFX[i+64*32] = ((u16*)use_icon_img_bin)[i];
+
   for(int i=0;i&lt;64*32; ++i)
+    SPRITE_GFX[i+ (64*32) + (32*16)] = ((u16*)smalldoor_img_bin)[i];
+
+  for(int i=0;i&lt;64*32; ++i)
     SPRITE_GFX[i] = ((u16*)walk_frame00_img_bin)[i];
 
   for(int i = 0; i &lt; 256; ++i)
@@ -428,12 +672,24 @@
   sprites[0].attribute[1] = ATTR1_SIZE_64 | py  | ATTR1_FLIP_Y;
   sprites[0].attribute[2] = 0;
 
+  sprites[1].attribute[0] = ATTR0_SQUARE | ATTR0_COLOR_256 | (192-32-8) | ATTR0_DISABLED;
+  sprites[1].attribute[1] = ATTR1_SIZE_32 | (256-32-8);
+  sprites[1].attribute[2] = 64*2;//64*64;//64*32;
+
+  sprites[2].attribute[0] = ATTR0_SQUARE | ATTR0_COLOR_256 | 90-6;
+  sprites[2].attribute[1] = ATTR1_SIZE_64 | 200+16+2;
+  sprites[2].attribute[2] = 64*2+32;
+
   int frame_index = 0;
   int sx = 0;
   //int sy = 0;
-  bool allow_scrolling_x = true;
-  bool allow_scrolling_y = true;
   bool left = true;;
+
+  if (subscreen_mode == PDA)
+    init_pda();
+  else
+    init_doorminigame();
+
   while(1) 
     {
       swiWaitForVBlank();
@@ -446,16 +702,28 @@
 
       // read the button states
       scanKeys();
-      touchPosition touch = touchReadXY();
+      touch = touchReadXY();
 
-      int pressed = keysDown();	// buttons pressed this loop
-      int held = keysHeld();		// buttons currently held
-
+      pressed = keysDown();	// buttons pressed this loop
+      held = keysHeld();		// buttons currently held
       
-      sprites[0].attribute[0] = ATTR0_SQUARE | ATTR0_COLOR_256 | mod(103,512);
-      sprites[0].attribute[1] = ATTR1_SIZE_64 | mod(128-32,512) | (left ? 0: ATTR1_FLIP_X);
-      sprites[0].attribute[2] = 0;
+      if (subscreen_mode != DIALOG)
+        {
+          sprites[0].attribute[0] = ATTR0_SQUARE | ATTR0_COLOR_256 | mod(103,512);
+          sprites[0].attribute[1] = ATTR1_SIZE_64 | mod(128-32,512) | (left ? 0: ATTR1_FLIP_X);
+          sprites[0].attribute[2] = 0;
 
+          sprites[2].attribute[0] = ATTR0_SQUARE | ATTR0_COLOR_256 | mod(90-6, 512);
+          sprites[2].attribute[1] = ATTR1_SIZE_64 | mod((200+16+2 - px + 128-32 + door_pos/4),512);
+          sprites[2].attribute[2] = 64*2+32;
+        }
+      else
+        {
+          sprites[0].attribute[0] |=  ATTR0_DISABLED;
+          sprites[1].attribute[0] |=  ATTR0_DISABLED;
+          sprites[2].attribute[0] |=  ATTR0_DISABLED;
+        }
+
       if ((held &amp; KEY_L) &amp;&amp; (held &amp; KEY_R))
         swiSoftReset();
 
@@ -502,9 +770,45 @@
       else if (held &amp; KEY_UP)
         py -= 1;
 
+
+      if ((px + 128) &gt; 328-16 &amp;&amp; 
+          (px + 128) &lt; (328+35+16))
+        {
+          sprites[1].attribute[0] &amp;=  ~ATTR0_DISABLED;
+          //if (pressed &amp; KEY_X)
+          //            {
+          if (subscreen_mode == PDA)
+            {
+              init_doorminigame();
+              subscreen_mode = DOOR_MINIGAME;
+            }
+          else if (subscreen_mode == DOOR_MINIGAME)
+            {
+              init_pda();
+              subscreen_mode = PDA;
+            }
+          //}
+        }
+      else if ((px + 128) &gt; 133-16 &amp;&amp;
+               (px + 128) &lt; 133-16+32)
+        {
+          init_dialog();
+          subscreen_mode = DIALOG;
+        }
+      else
+        {
+          sprites[1].attribute[0] |= ATTR0_DISABLED;
+          if (subscreen_mode == DOOR_MINIGAME)
+            {
+              init_pda();
+              subscreen_mode = PDA;
+            }
+        }
+
+
       sx = px;
       //sx += 1;
-
+      
       if ((held &amp; KEY_TOUCH)  &amp;&amp; drag)
         {
           x = oldx + (touch_down.px - touch.px);
@@ -513,116 +817,17 @@
 
       if (!(held &amp; KEY_TOUCH))
         drag = false;
-
-      BG3_CX  = x*500 + sx&lt;&lt;8 ;
-      BG3_CY  = y*500 + (32&lt;&lt;8);
-
+      
+      if (subscreen_mode != DIALOG)
+        {
+          BG3_CX  = x*500 + sx&lt;&lt;8 ;
+          BG3_CY  = y*500 + (32&lt;&lt;8);
+        }
       //2_CX  = -x;
       //2_CY  = -y;
-
-      if (allow_scrolling_x)
-        SUB_BG3_CX  = x&lt;&lt;8;
-      else
-        SUB_BG3_CX  = 0;
-
-      if (allow_scrolling_y)
-        SUB_BG3_CY  = y&lt;&lt;8;
-      else
-        SUB_BG3_CY  = 0;
       
-      //SUB_BG2_CX  = -x;
-      //SUB_BG2_CY  = -y;
+      update_subscreen();
 
-      if (pressed &amp; KEY_TOUCH)
-        {
-          const u8* picture = 0;
-          const u8* subpicture = 0;
-          
-          if (touch.px &lt; 48)
-            {
-              if (touch.py &lt; 48)
-                {
-                  picture = map_img_bin;
-                  subpicture = submap_img_bin;
-                  allow_scrolling_x = true;
-                  allow_scrolling_y = true;
-                }
-              else if (touch.py &gt;= 48 &amp;&amp; touch.py &lt; 48*2)
-                {
-                  picture = health_img_bin;
-                  subpicture = subhealth_img_bin;
-                  allow_scrolling_x = false;
-                  allow_scrolling_y = false;
-                }
-              else if (touch.py &gt;= 2*48 &amp;&amp; touch.py &lt; 48*3)
-                {
-                  picture = log_img_bin;
-                  subpicture = sublog_img_bin;
-                  allow_scrolling_x = false;
-                  allow_scrolling_y = true;
-                }
-              else if (touch.py &gt;= 3*48 &amp;&amp; touch.py &lt; 48*4)
-                {
-                  picture = debug_img_bin;
-                  subpicture = subdebug_img_bin;
-                  allow_scrolling_x = false;
-                  allow_scrolling_y = false;
-                }
-            }
-          else if (touch.px &gt; 256 - 48)
-            {
-              if (touch.py &lt; 48)
-                {
-                  picture = items_img_bin;
-                  subpicture = subitems_img_bin;
-                  allow_scrolling_x = false;
-                  allow_scrolling_y = false;
-                }
-              else if (touch.py &gt;= 48 &amp;&amp; touch.py &lt; 48*2)
-                {
-                  picture = scan_img_bin;
-                  subpicture = subscan_img_bin;
-                  allow_scrolling_x = true;
-                  allow_scrolling_y = true;
-                }
-              else if (touch.py &gt;= 2*48 &amp;&amp; touch.py &lt; 48*3)
-                {
-                  picture = comm_img_bin;
-                  subpicture = subcomm_img_bin;
-                  allow_scrolling_x = false;
-                  allow_scrolling_y = false;
-                }
-              else if (touch.py &gt;= 3*48 &amp;&amp; touch.py &lt; 48*4)
-                {
-                  picture = weapon_img_bin;
-                  subpicture = subweapon_img_bin;
-                  allow_scrolling_x = false;
-                  allow_scrolling_y = false;
-                }
-            }
-
-          if (picture)
-            {
-              for(int i = 0; i &lt; 256*192/2; ++i)
-                ((u16*)BG_BMP_RAM_SUB(4))[i] = ((u16*)picture)[i];
-              
-              playSound(&amp;blaster);
-
-              if (subpicture)
-                {
-                  for(int i = 0; i &lt; 256*256/2; ++i)
-                    ((u16*)BG_BMP_RAM_SUB(0))[i] = ((u16*)subpicture)[i];
-                }
-            }
-          else 
-            {
-              // Didn't click on anything, so we assume middle region
-              touch_down = touch;
-              oldx = x;
-              oldy = y;
-              drag = true;
-            }
-        }
       updateOAM();
     }
 }
@@ -633,9 +838,9 @@
   irqInit();
   irqEnable(IRQ_VBLANK);
 
-  //titlescreen();
-  //gamescreen();
-  doorminigame();
+  titlescreen();
+  gamescreen();
+  //doorminigame();
 
   return 0;
 }

Added: trunk/windstille-nds/windstille/tools/Makefile
===================================================================
--- trunk/windstille-nds/windstille/tools/Makefile	2006-09-07 18:46:54 UTC (rev 1280)
+++ trunk/windstille-nds/windstille/tools/Makefile	2006-09-08 20:14:10 UTC (rev 1281)
@@ -0,0 +1,7 @@
+all:
+	scons
+
+clean:
+	scons -c
+
+# EOF #

Added: trunk/windstille-nds/windstille/tools/SConstruct
===================================================================
--- trunk/windstille-nds/windstille/tools/SConstruct	2006-09-07 18:46:54 UTC (rev 1280)
+++ trunk/windstille-nds/windstille/tools/SConstruct	2006-09-08 20:14:10 UTC (rev 1281)
@@ -0,0 +1,7 @@
+# -*- python -*- 
+
+env = Environment()
+env.ParseConfig(&quot;pkg-config --cflags --libs libpng&quot;)
+env.Program('convert', ['main.cpp'])
+
+# EOF #

Added: trunk/windstille-nds/windstille/tools/main.cpp
===================================================================
--- trunk/windstille-nds/windstille/tools/main.cpp	2006-09-07 18:46:54 UTC (rev 1280)
+++ trunk/windstille-nds/windstille/tools/main.cpp	2006-09-08 20:14:10 UTC (rev 1281)
@@ -0,0 +1,475 @@
+/* To compile this programm:
+
+    % g++ -o png2stratagus  png2stratagus.cpp -lpng
+ */
+
+/* This programm can be used to fix the palette of a indexed png file
+   to be suitable for Stratagus. It works like this:
+
+   1) You create a RGBA image in Gimp
+
+   2) You convert it to indexed with 227 colors
+   
+   [Generate Optimal Palette # Colors 227] (MAX_COLORS - 1)
+   
+   3) You run png2stratagus on the image
+
+   4) The final images will be written to out.png in the current
+      directory
+ */
+
+#include &lt;string&gt;
+#include &lt;fstream&gt;
+#include &lt;sstream&gt;
+#include &lt;vector&gt;
+#include &lt;iostream&gt;
+#include &lt;iomanip&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;png.h&gt;
+#include &lt;assert.h&gt;
+
+class Color
+{
+public:
+  unsigned int red;
+  unsigned int green;
+  unsigned int blue;
+
+  Color ()
+    : red (0), green (255), blue (0)
+  {
+  }
+
+  Color (int r, int g, int b) 
+    : red (r), green (g), blue (b)
+  {    
+  }
+};
+
+class Image
+{
+private:
+  int m_width;
+  int m_height;
+  int m_transcol;
+  std::vector&lt;unsigned char&gt; m_image;
+  std::vector&lt;Color&gt; m_palette;
+  
+public:
+  /** Load an image from a given png source */
+  Image (const std::string&amp; filename) 
+  {
+    FILE* fp;
+    png_structp png_ptr;
+    png_infop info_ptr;
+    png_uint_32 pwidth, pheight;
+    int bit_depth, color_type, interlace_type, compression_type, filter_type;
+    //int row_bytes; // row_bytes is useless when png_set_packing is used
+
+    if ((fp = fopen(filename.c_str (), &quot;rb&quot;)) == NULL)
+      {
+	perror (filename.c_str ());
+	exit (EXIT_FAILURE);
+      }
+
+    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,
+				     NULL, NULL, NULL);
+
+    // Use one byte per pixel, always
+    png_set_packing(png_ptr);
+
+    info_ptr = png_create_info_struct(png_ptr);
+
+    png_init_io(png_ptr, fp);
+    png_read_info(png_ptr, info_ptr);
+    png_get_IHDR(png_ptr, info_ptr, &amp;pwidth, &amp;pheight,
+		 &amp;bit_depth, &amp;color_type, &amp;interlace_type,
+		 &amp;compression_type, &amp;filter_type);
+
+    //row_bytes = png_get_rowbytes(png_ptr, info_ptr);
+
+    //std::cout &lt;&lt; &quot;Bit Depth: &quot; &lt;&lt; bit_depth &lt;&lt; std::endl;
+    //std::cout &lt;&lt; &quot;ROw Bytes: &quot; &lt;&lt; row_bytes &lt;&lt; std::endl;
+    
+    // Create the 'data' array
+    png_bytep row_pointers[pheight];
+    for (unsigned int i = 0; i &lt; pheight; i++)
+      row_pointers[i] = new png_byte[pwidth]; // row_bytes];
+
+    png_read_image(png_ptr, row_pointers);
+
+    if (color_type != PNG_COLOR_TYPE_PALETTE)
+	{
+	  std::cout &lt;&lt; &quot;Unsupported color type&quot; &lt;&lt; std::endl;
+	  exit (EXIT_FAILURE);
+	}
+    
+    int num_colors;
+    int num_trans = 0;
+    png_colorp lpalette;
+    png_bytep trans;
+    png_color_16p trans_values;
+
+    // Read some more data
+    png_get_PLTE(png_ptr, info_ptr, &amp;lpalette, &amp;num_colors);
+    png_get_tRNS(png_ptr, info_ptr, &amp;trans, &amp;num_trans, &amp;trans_values);
+
+    // not sure what trans_values stand for
+
+    //for (int i = 0; i &lt; num_trans; ++i)
+    //std::cout &lt;&lt;  &quot;transcolors: &quot; &lt;&lt; trans_values[i] &lt;&lt; std::endl;
+
+    if (num_trans &gt; 1)
+      {
+	std::cout &lt;&lt; &quot;Multiple transcolors not supported&quot; &lt;&lt; std::endl;
+	exit (EXIT_FAILURE);
+      }
+    else if (num_trans == 1)
+      m_transcol = trans[0];
+    else
+      m_transcol = -1;
+
+    if (0)
+    for (int i = 0; i &lt; num_trans; i++)
+      std::cout &lt;&lt; &quot;transcolor: &quot; &lt;&lt; int(trans[i]) &lt;&lt; std::endl;
+    
+    m_width  = pwidth;
+    m_height = pheight;
+
+    m_image.resize(m_width * m_height);
+
+    // Convert the png into our internal data structure
+    for (int y = 0; y &lt; m_height; y++)
+      {
+	for (int i = 0; i &lt; pwidth /*row_bytes*/; i++)
+	  {
+            //std::cout &lt;&lt; std::setw(3) &lt;&lt; int(row_pointers[y][i]) &lt;&lt; &quot; &quot;;
+	    m_image[i + (m_width * y)] = row_pointers[y][i];
+	  }
+        //std::cout &lt;&lt; std::endl;
+      }
+
+    assert(num_colors &lt;= 256);
+    if (0) std::cout &lt;&lt; &quot;Num Colors: &quot; &lt;&lt; num_colors &lt;&lt; std::endl;
+
+    m_palette.resize(256);
+    for (int i = 0; i &lt; num_colors; ++i)
+      {
+	m_palette[i].red   = lpalette[i].red;
+	m_palette[i].green = lpalette[i].green;
+	m_palette[i].blue  = lpalette[i].blue;
+
+        if (0)
+          std::cout &lt;&lt; &quot;Color: &quot; 
+                  &lt;&lt; m_palette[i].red &lt;&lt; &quot;, &quot;
+                  &lt;&lt; m_palette[i].green &lt;&lt; &quot;, &quot;
+                  &lt;&lt; m_palette[i].blue &lt;&lt; std::endl;
+      }
+
+    // Following line causes a crash in combination with png_set_packing
+    png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, (png_infopp)NULL);
+
+    fclose (fp);
+  }
+  
+  ~Image () 
+  {
+  }
+
+  void write_palette16bit(const std::string&amp; filename)
+  {
+#define RGB5(r,g,b)     ((r)|((g)&lt;&lt;5)|((b)&lt;&lt;10))
+
+    std::ofstream out(filename.c_str());
+    for(std::vector&lt;Color&gt;::iterator i = m_palette.begin(); i != m_palette.end(); ++i)
+      {
+        unsigned short c = RGB5(i-&gt;red/8, i-&gt;green/8, i-&gt;blue/8);
+        out.write(reinterpret_cast&lt;char*&gt;(&amp;c), sizeof(unsigned short));
+      }
+  }
+
+  void write_palette(const std::string&amp; filename)
+  {
+    std::ofstream out(filename.c_str());
+    out.write(reinterpret_cast&lt;char*&gt;(&amp;*m_palette.begin()), m_palette.size()); 
+  }
+
+  void write_image(const std::string&amp; filename)
+  {
+    if (1)
+      {
+        // Simple dump of the image data
+        std::ofstream out(filename.c_str());
+        out.write(reinterpret_cast&lt;char*&gt;(&amp;*m_image.begin()), m_image.size());
+      }
+    else
+      {
+        std::cout &lt;&lt; &quot;Writing tileset&quot; &lt;&lt; std::endl;
+        std::ofstream out(filename.c_str());
+        unsigned char* ptr = &amp;*m_image.begin();
+        int num_tiles = (get_width() * get_height()) / 64;
+        int pitch = get_width();
+        int tile_width = get_width()/8;
+        for(int i = 0; i &lt; num_tiles; ++i)
+          {
+            char* tile_start = reinterpret_cast&lt;char*&gt;(ptr + 64*tile_width*(i/tile_width) + 8*(i%tile_width));
+            for(int y = 0; y &lt; 8; ++y)
+              {
+                out.write(tile_start + y*pitch, 8);
+              }
+          }
+      }
+  }
+
+  void set_color (int i, Color c) {
+    m_palette[i] = c;
+  }
+
+  int get_transcolor () {
+    return m_transcol;
+  }
+  
+  int num_colors () {
+    return m_palette.size ();
+  }
+
+  int get_width () const {
+    return m_width;
+  }
+  
+  int get_height () const {
+    return m_height;
+  }
+
+  unsigned char at(int x, int y) const {
+    assert(x &gt;= 0 &amp;&amp; x &lt; m_width);
+    assert(y &gt;= 0 &amp;&amp; y &lt; m_height);
+    return m_image[(y * m_width) + x];
+  }
+};
+
+bool vline_empty(Image&amp; image, int x)
+{
+  //std::cout &lt;&lt; &quot;Vline: X: &quot; &lt;&lt; x &lt;&lt; &quot;  -  &quot;;
+  for(int y = 0; y &lt; image.get_height(); ++y)
+    {
+      //std::cout &lt;&lt; std::setw(4) &lt;&lt; (int)image.at(x, y) &lt;&lt; &quot; &quot;;
+      if (image.at(x, y) != image.get_transcolor())
+        {
+          //std::cout &lt;&lt; &quot;!EMPTY&quot; &lt;&lt; std::endl;
+          return false;
+        }
+    }
+  //std::cout &lt;&lt; std::endl;
+  return true;
+}
+
+bool hline_emppty(Image&amp; image, int start_x, int end_x, int y)
+{
+  for(int x = start_x; x &lt; end_x; ++x)
+    if (image.at(x, y) != image.get_transcolor())
+      return false;
+  return true;
+}
+
+struct Char
+{
+  char chr;
+
+  // Pixeldata goes from [x1, x2) and [y1, y2)
+  int x;
+  int y;
+  int w;
+  int h;
+};
+
+void detect_characters(Image&amp; image, char* str, char* fontname)
+{
+  std::stringstream out1;
+  std::stringstream out2;
+  //  std::stringstream out3;
+
+  int width  = image.get_width();
+  int height = image.get_height();
+
+  //out2 &lt;&lt; &quot;Image: &quot; &lt;&lt; image.get_width() &lt;&lt; &quot;x&quot; &lt;&lt; image.get_height() &lt;&lt; std::endl;
+  
+  bool last_was_empty = true;
+
+  int char_start = 0;
+  int char_end   = 0;
+  
+  int i = 0;
+
+  Char last_char;
+  last_char.chr = 0;
+  last_char.x = 0;
+  last_char.y = 0;
+  last_char.w = 0;
+  last_char.h = 0;
+
+  out2 &lt;&lt; &quot;Glyph &quot; &lt;&lt; fontname &lt;&lt; &quot;_glyphs[&quot; &lt;&lt; fontname &lt;&lt; &quot;_glyphs_size&quot; &lt;&lt; &quot;] = { &quot; &lt;&lt; std::endl;
+  //out3 &lt;&lt; &quot;char &quot; &lt;&lt; fontname &lt;&lt; &quot;_chr2idx[256] = {}&quot; &lt;&lt; std::endl;
+
+  for(int x = 0; x &lt; width; ++x)
+    {
+      //std::cout &lt;&lt; x &lt;&lt; &quot; -&gt; &quot; &lt;&lt; vline_empty(image, x) &lt;&lt; std::endl;
+      if (!vline_empty(image, x))
+        {
+          if (last_was_empty)
+            {
+              // beginning of char
+              last_was_empty = false;
+              char_start = x;
+            }
+          else
+            {
+              // in a character
+            }
+        }
+      else
+        {
+          if (!last_was_empty)
+            {
+              char_end = x;
+              // end of char
+              int y_start = image.get_height();
+              int y_end   = 0;
+              for(int y = 0; y &lt; height; ++y)
+                {
+                  if (!hline_emppty(image, char_start, char_end, y))
+                    {
+                      y_start = std::min(y, y_start);
+                      y_end   = std::max(y+1, y_end);
+                    }
+                }
+              
+              if (str[i] == '\0')
+                assert(!&quot;Premature end of character list&quot;);
+
+              
+              Char new_char;
+              
+              new_char.chr = str[i];
+              new_char.x = char_start;
+              new_char.y = y_start;
+              new_char.w = char_end - char_start;
+              new_char.h = y_end - y_start;
+
+              if (last_char.chr != 0)
+                { // merge char with previous one
+                  int last_x2 = last_char.x + last_char.w;
+                  int last_y2 = last_char.y + last_char.h;
+                  
+                  int x2 = new_char.x + new_char.w;
+                  int y2 = new_char.y + new_char.h;
+
+                  new_char.x = std::min(new_char.x, last_char.x);
+                  new_char.y = std::min(new_char.y, last_char.y);
+
+                  new_char.w = std::max(x2, last_x2) - new_char.x;
+                  new_char.h = std::max(y2, last_y2) - new_char.y;
+                }
+
+              if (str[i+1] == str[i])
+                { // Character consisting of multiple rects
+                  last_char = new_char;
+                }
+              else
+                {
+                  out2 
+                    &lt;&lt; &quot; { &quot; 
+                    &lt;&lt; &quot;'&quot;  &lt;&lt; (new_char.chr == '\'' || new_char.chr == '\\' ? &quot;\\&quot; : &quot;&quot;) &lt;&lt; new_char.chr &lt;&lt; &quot;', &quot; 
+                    &lt;&lt; std::dec &lt;&lt; std::setfill(' ') &lt;&lt; std::setw(3) &lt;&lt; 0 /*new_char.x*/ &lt;&lt; &quot;, &quot; 
+                    &lt;&lt; std::dec &lt;&lt; std::setfill(' ') &lt;&lt; std::setw(3) &lt;&lt; new_char.y &lt;&lt; &quot;, &quot; 
+                    &lt;&lt; std::dec &lt;&lt; std::setfill(' ') &lt;&lt; std::setw(2) &lt;&lt; new_char.w &lt;&lt; &quot;, &quot;
+                    &lt;&lt; std::dec &lt;&lt; std::setfill(' ') &lt;&lt; std::setw(2) &lt;&lt; new_char.h &lt;&lt; &quot;, &quot;
+                    &lt;&lt; fontname &lt;&lt; &quot;_glyph_0x&quot; &lt;&lt; std::hex &lt;&lt; int(new_char.chr) &lt;&lt; &quot; },&quot;;
+                  
+                  {
+                    out1 &lt;&lt; &quot;\n// Character: '&quot;&lt;&lt; new_char.chr &lt;&lt; &quot;'\n&quot;;
+                    out1 &lt;&lt; &quot;unsigned char &quot; &lt;&lt; fontname &lt;&lt; &quot;_glyph_0x&quot; &lt;&lt; std::hex &lt;&lt; int(new_char.chr)
+                         &lt;&lt; &quot;[] = {\n&quot;;
+                    for(int y = new_char.y; y &lt; new_char.y + new_char.h; ++y)
+                      {
+                        out1 &lt;&lt; &quot;    &quot;;
+                        for(int x = new_char.x; x &lt; new_char.x + new_char.w; ++x)
+                          {
+                            out1 &lt;&lt; &quot;0x&quot; &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; std::hex &lt;&lt; int(image.at(x, y));
+                            out1 &lt;&lt; &quot;, &quot;;
+                          }
+                        out1 &lt;&lt; std::endl;
+                      }
+                    out1 &lt;&lt; &quot;};\n&quot;;
+                  }
+
+                  out2 &lt;&lt; std::endl;
+                  
+                  last_char.chr = 0;
+                  last_char.x = 0;
+                  last_char.y = 0;
+                  last_char.w = 0;
+                  last_char.h = 0;
+                }
+
+              i += 1;
+            }
+
+          last_was_empty = true;
+        }
+    }
+
+  out2 &lt;&lt; &quot;};&quot; &lt;&lt; std::endl;
+
+  std::cout &lt;&lt; out1.str() &lt;&lt; std::endl;
+  std::cout &lt;&lt; &quot;const int &quot; &lt;&lt; fontname &lt;&lt; &quot;_glyphs_size = &quot; &lt;&lt; i &lt;&lt; &quot;;&quot; &lt;&lt; std::endl;
+  std::cout &lt;&lt; out2.str() &lt;&lt; std::endl;
+
+  //  std::cout &lt;&lt; out3.str() &lt;&lt; std::endl;
+
+  std::cout &lt;&lt; &quot;/* EOF */&quot; &lt;&lt; std::endl;
+}
+
+int main (int argc, char* argv[])
+{
+  if (argc &lt; 2)
+    {
+      std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; OP INFILE OUTFILE&quot; &lt;&lt; std::endl;
+      std::cout &lt;&lt; std::endl;
+      std::cout &lt;&lt; &quot; OP: findchars&quot; &lt;&lt; std::endl;
+      exit (EXIT_FAILURE);
+    }
+  else
+    {
+      if (strcmp(argv[1], &quot;findchars&quot;) == 0)
+        {
+          if (argc &lt; 5)
+            {
+              std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; findchars FILENAME CHARS FONTNAME&quot; &lt;&lt; std::endl;
+            }
+          else
+            {
+              Image image(argv[2]);
+              detect_characters(image, argv[3], argv[4]);
+              //image.write_image(&quot;/tmp/foo&quot;);
+            }
+        }
+      else
+        {
+          std::cout &lt;&lt; &quot;Unknown OP: &quot; &lt;&lt; argv[1] &lt;&lt; std::endl;
+        }
+    }
+    
+  if (0)
+    {
+      Image image (argv[1]);
+      std::cout &lt;&lt; image.get_width() &lt;&lt; &quot;x&quot; &lt;&lt; image.get_height() &lt;&lt; std::endl;
+      std::cout &lt;&lt; &quot;writing &quot; &lt;&lt; std::string(argv[2]) + &quot;_pal.bin&quot; &lt;&lt; std::endl;
+      std::cout &lt;&lt; &quot;writing &quot; &lt;&lt; std::string(argv[2]) + &quot;_img.bin&quot; &lt;&lt; std::endl;
+      image.write_palette16bit(std::string(argv[2]) + &quot;_pal.bin&quot;);
+      image.write_image(std::string(argv[2]) + &quot;_img.bin&quot;);
+    }
+}
+
+// EOF //


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000932.html">[Windstille-commit] r1280 - in trunk/windstille-nds/windstille:	data source
</A></li>
	<LI>Next message: <A HREF="000934.html">[Windstille-commit] r1282 - in trunk/windstille-nds/windstille:	source tools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#933">[ date ]</a>
              <a href="thread.html#933">[ thread ]</a>
              <a href="subject.html#933">[ subject ]</a>
              <a href="author.html#933">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/windstille-commit">More information about the Windstille-commit
mailing list</a><br>
</body></html>
