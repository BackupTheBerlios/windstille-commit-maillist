<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Windstille-commit] r1440 - trunk/windstille/src/scripting
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/windstille-commit/2007-June/index.html" >
   <LINK REL="made" HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r1440%20-%20trunk/windstille/src/scripting&In-Reply-To=%3C200706152046.l5FKka2s003825%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001091.html">
   <LINK REL="Next"  HREF="001093.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Windstille-commit] r1440 - trunk/windstille/src/scripting</H1>
    <B>grumbel at BerliOS</B> 
    <A HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r1440%20-%20trunk/windstille/src/scripting&In-Reply-To=%3C200706152046.l5FKka2s003825%40sheep.berlios.de%3E"
       TITLE="[Windstille-commit] r1440 - trunk/windstille/src/scripting">grumbel at mail.berlios.de
       </A><BR>
    <I>Fri Jun 15 22:46:36 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="001091.html">[Windstille-commit] r1439 - in trunk/windstille/src: . scripting
</A></li>
        <LI>Next message: <A HREF="001093.html">[Windstille-commit] r1441 - in trunk/windstille/src: . math	navigation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1092">[ date ]</a>
              <a href="thread.html#1092">[ thread ]</a>
              <a href="subject.html#1092">[ subject ]</a>
              <a href="author.html#1092">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: grumbel
Date: 2007-06-15 22:46:36 +0200 (Fri, 15 Jun 2007)
New Revision: 1440

Added:
   trunk/windstille/src/scripting/README
   trunk/windstille/src/scripting/util.cpp
   trunk/windstille/src/scripting/util.hpp
Log:
- reordered the scripting functions a bit

Added: trunk/windstille/src/scripting/README
===================================================================
--- trunk/windstille/src/scripting/README	2007-06-15 20:34:14 UTC (rev 1439)
+++ trunk/windstille/src/scripting/README	2007-06-15 20:46:36 UTC (rev 1440)
@@ -0,0 +1,29 @@
+  Scripting
+&#9600;&#9600;&#9600;&#9600;&#9600;&#9600;&#9600;&#9600;&#9600;&#9600;&#9600;&#9600;&#9600;
+
+Autogenerated
+=============
+
+- wrapper.?pp is automatically generated
+
+Util
+====
+
+- util.?pp - utility functions to convert squirrel expression
+  to string as well as print a stackstrace
+
+- squirrel_error.?pp converts a squirrel error into a C++ exception
+
+Interface
+=========
+
+- interface.?pp contains simple functions that can be accessed from
+  the squirrel console
+
+- game_objects.?pp contains wrapper classes around objects to make
+  them exportable to squirrel
+
+- wrapper.interface.hpp include files for wrappper.cpp
+ 
+
+# EOF #

Added: trunk/windstille/src/scripting/util.cpp
===================================================================
--- trunk/windstille/src/scripting/util.cpp	2007-06-15 20:34:14 UTC (rev 1439)
+++ trunk/windstille/src/scripting/util.cpp	2007-06-15 20:46:36 UTC (rev 1440)
@@ -0,0 +1,424 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  &gt; |__| |__|____/____/\___  &gt;
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2007 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;, 
+**                     Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include &lt;sstream&gt;
+#include &lt;memory&gt;
+
+#include &lt;assert.h&gt;
+#include &quot;lisp/lisp.hpp&quot;
+#include &quot;lisp/parser.hpp&quot;
+#include &quot;lisp/properties.hpp&quot;
+#include &quot;lisp/writer.hpp&quot;
+
+#include &quot;util.hpp&quot;
+
+namespace Scripting {
+
+std::string sq_to_lisp_string(std::string sq_str)
+{
+  for (unsigned i = 0; i != sq_str.size(); ++i) {
+    if (sq_str[i] == '_')
+      sq_str[i] = '-';
+  }
+  
+  return sq_str;
+}
+
+void sq_to_lisp(HSQUIRRELVM v, std::vector&lt;lisp::Lisp*&gt;&amp; entries)
+{
+  switch(sq_gettype(v, -1)) {
+    case OT_INTEGER: {
+      SQInteger val;
+      sq_getinteger(v, -1, &amp;val);
+      entries.push_back(new lisp::Lisp(static_cast&lt;int&gt;(val)));
+      break;
+    }
+    case OT_FLOAT: {
+      float val;
+      sq_getfloat(v, -1, &amp;val);
+      entries.push_back(new lisp::Lisp(val));
+      break;
+    }
+    case OT_STRING: {
+      const char* str;
+      sq_getstring(v, -1, &amp;str);      
+      entries.push_back(new lisp::Lisp(lisp::Lisp::TYPE_STRING, str));
+      break;
+    }                                                    
+    case OT_BOOL: {
+      SQBool boolean;
+      sq_getbool(v, -1, &amp;boolean);
+      entries.push_back(new lisp::Lisp((bool) boolean));
+      break;
+    }
+    case OT_ARRAY:
+    case OT_TABLE: {
+      table_to_lisp(v, -1, entries);
+      break;
+    }
+    default:
+      std::cerr &lt;&lt; &quot;Unsupported value type in table\n&quot;;
+      break;
+  }
+}
+
+void table_to_lisp(HSQUIRRELVM v, int table_idx, std::vector&lt;lisp::Lisp*&gt;&amp; entries)
+{
+  // offset because of sq_pushnull
+  if(table_idx &lt; 0)
+    table_idx--;
+
+  // iterate table
+  sq_pushnull(v);
+  while(SQ_SUCCEEDED(sq_next(v, table_idx))) {
+    // key is -2, value -1 now
+    if(sq_gettype(v, table_idx) == OT_TABLE) {
+      if(sq_gettype(v, -2) != OT_STRING) {
+        std::cerr &lt;&lt; &quot;Table contains a non string key\n&quot;;
+        continue;
+      }
+
+      const char* key;
+      sq_getstring(v, -2, &amp;key);
+      std::string lisp_key = sq_to_lisp_string(key);
+
+      std::vector&lt;lisp::Lisp*&gt; childs;
+      childs.push_back(new lisp::Lisp(lisp::Lisp::TYPE_SYMBOL, lisp_key));
+      sq_to_lisp(v, childs);
+      entries.push_back(new lisp::Lisp(childs));
+    } else {
+      sq_to_lisp(v, entries);
+    }
+    
+    // pop table key and value
+    sq_pop(v, 2);
+  }
+  // pop iterator
+  sq_pop(v, 1);
+}
+
+std::string squirrel2string(HSQUIRRELVM v, int i)
+{
+  std::ostringstream os;
+  switch(sq_gettype(v, i))
+    {
+    case OT_NULL:
+      os &lt;&lt; &quot;&lt;null&gt;&quot;;        
+      break;
+    case OT_BOOL: {
+      SQBool p;
+      sq_getbool(v, i, &amp;p);
+      if (p) 
+        os &lt;&lt; &quot;true&quot;;
+      else
+        os &lt;&lt; &quot;false&quot;;
+      break;
+    }
+    case OT_INTEGER: {
+      SQInteger val;
+      sq_getinteger(v, i, &amp;val);
+      os &lt;&lt; val;
+      break;
+    }
+    case OT_FLOAT: {
+      float val;
+      sq_getfloat(v, i, &amp;val);
+      os &lt;&lt; val;
+      break;
+    }
+    case OT_STRING: {
+      const char* val;
+      sq_getstring(v, i, &amp;val);
+      os &lt;&lt; &quot;\&quot;&quot; &lt;&lt; val &lt;&lt; &quot;\&quot;&quot;;
+      break;    
+    }
+    case OT_TABLE: {
+      bool first = true;
+      os &lt;&lt; &quot;{&quot;;
+      sq_pushnull(v);  //null iterator
+      while(SQ_SUCCEEDED(sq_next(v,i-1)))
+        {
+          if (!first) {
+            os &lt;&lt; &quot;, &quot;;
+          }
+          first = false;
+
+          //here -1 is the value and -2 is the key
+          os &lt;&lt; squirrel2string(v, -2) &lt;&lt; &quot; =&gt; &quot; 
+             &lt;&lt; squirrel2string(v, -1);
+                              
+          sq_pop(v,2); //pops key and val before the nex iteration
+        }
+      sq_pop(v, 1);
+      os &lt;&lt; &quot;}&quot;;
+      break;
+    }
+    case OT_ARRAY: {
+      bool first = true;
+      os &lt;&lt; &quot;[&quot;;
+      sq_pushnull(v);  //null iterator
+      while(SQ_SUCCEEDED(sq_next(v,i-1)))
+        {
+          if (!first) {
+            os &lt;&lt; &quot;, &quot;;
+          }
+          first = false;
+
+          //here -1 is the value and -2 is the key
+          // we ignore the key, since that is just the index in an array
+          os &lt;&lt; squirrel2string(v, -1);
+                              
+          sq_pop(v,2); //pops key and val before the nex iteration
+        }
+      sq_pop(v, 1);
+      os &lt;&lt; &quot;]&quot;;
+      break;
+    }
+    case OT_USERDATA:
+      os &lt;&lt; &quot;&lt;userdata&gt;&quot;;
+      break;
+    case OT_CLOSURE:        
+      os &lt;&lt; &quot;&lt;closure (function)&gt;&quot;;
+      break;
+    case OT_NATIVECLOSURE:
+      os &lt;&lt; &quot;&lt;native closure (C function)&gt;&quot;;
+      break;
+    case OT_GENERATOR:
+      os &lt;&lt; &quot;&lt;generator&gt;&quot;;
+      break;
+    case OT_USERPOINTER:
+      os &lt;&lt; &quot;userpointer&quot;;
+      break;
+    case OT_THREAD:
+      os &lt;&lt; &quot;&lt;thread&gt;&quot;;
+      break;
+    case OT_CLASS:
+      os &lt;&lt; &quot;&lt;class&gt;&quot;;
+      break;
+    case OT_INSTANCE:
+      os &lt;&lt; &quot;&lt;instance&gt;&quot;;
+      break;
+    default:
+      os &lt;&lt; &quot;&lt;unknown&gt;&quot;;
+      break;
+    }
+  return os.str();
+}
+
+void print_squirrel_stack(HSQUIRRELVM v)
+{
+    printf(&quot;--------------------------------------------------------------\n&quot;);
+    int count = sq_gettop(v);
+    for(int i = 1; i &lt;= count; ++i) {
+        printf(&quot;%d: &quot;,i);
+        switch(sq_gettype(v, i))
+        {
+            case OT_NULL:
+                printf(&quot;null&quot;);        
+                break;
+            case OT_INTEGER: {
+                SQInteger val;
+                sq_getinteger(v, i, &amp;val);
+                printf(&quot;integer (%d)&quot;, static_cast&lt;int&gt;(val));
+                break;
+            }
+            case OT_FLOAT: {
+                float val;
+                sq_getfloat(v, i, &amp;val);
+                printf(&quot;float (%f)&quot;, val);
+                break;
+            }
+            case OT_STRING: {
+                const char* val;
+                sq_getstring(v, i, &amp;val);
+                printf(&quot;string (%s)&quot;, val);
+                break;    
+            }
+            case OT_TABLE:
+                printf(&quot;table&quot;);
+                break;
+            case OT_ARRAY:
+                printf(&quot;array&quot;);
+                break;
+            case OT_USERDATA:
+                printf(&quot;userdata&quot;);
+                break;
+            case OT_CLOSURE:        
+                printf(&quot;closure(function)&quot;);    
+                break;
+            case OT_NATIVECLOSURE:
+                printf(&quot;native closure(C function)&quot;);
+                break;
+            case OT_GENERATOR:
+                printf(&quot;generator&quot;);
+                break;
+            case OT_USERPOINTER:
+                printf(&quot;userpointer&quot;);
+                break;
+            case OT_THREAD:
+                printf(&quot;thread&quot;);
+                break;
+            case OT_CLASS:
+                printf(&quot;class&quot;);
+                break;
+            case OT_INSTANCE:
+                printf(&quot;instance&quot;);
+                break;
+            default:
+                printf(&quot;unknown?!?&quot;);
+                break;
+        }
+        printf(&quot;\n&quot;);
+    }
+    printf(&quot;--------------------------------------------------------------\n&quot;);
+}
+
+void load_squirrel_table(HSQUIRRELVM v, int table_idx, const lisp::Lisp* lisp)
+{
+  using namespace lisp;
+  
+  Properties props(lisp);
+  PropertyIterator&lt;const lisp::Lisp*&gt; iter = props.get_iter();
+  while(iter.next()) {
+    sq_pushstring(v, iter.item().c_str(), iter.item().size());
+    switch((*iter)-&gt;get_type()) {
+      case lisp::Lisp::TYPE_LIST:
+        sq_newtable(v);
+        load_squirrel_table(v, sq_gettop(v), *iter);
+        break;
+      case lisp::Lisp::TYPE_INT:
+        sq_pushinteger(v, (*iter)-&gt;get_int());
+        break;
+      case lisp::Lisp::TYPE_FLOAT:
+        sq_pushfloat(v, (*iter)-&gt;get_float());
+        break;
+      case lisp::Lisp::TYPE_STRING:
+        sq_pushstring(v, (*iter)-&gt;get_string(), -1);
+        break;
+      case lisp::Lisp::TYPE_BOOL:
+        sq_pushbool(v, (*iter)-&gt;get_bool());
+        break;
+      case lisp::Lisp::TYPE_SYMBOL:
+        std::cerr &lt;&lt; &quot;Unexpected symbol in lisp file...&quot;;
+        sq_pushnull(v);
+        break;
+      default:
+        assert(false);
+        break;
+    }
+    if(table_idx &lt; 0) {
+      sq_createslot(v, table_idx - 2);
+    } else {
+      sq_createslot(v, table_idx);
+    }
+  }
+}
+
+void load_squirrel_table(HSQUIRRELVM v, int table_idx, const std::string&amp; file)
+{
+  using namespace lisp;
+  std::auto_ptr&lt;Lisp&gt; root (Parser::parse(file));
+
+  Properties rootp(root.get());
+  const lisp::Lisp* table = 0;
+  if(rootp.get(&quot;squirrel-state&quot;, table) == false)
+    throw std::runtime_error(&quot;Not a squirrel-state file&quot;);
+
+  load_squirrel_table(v, table_idx, table);
+}
+
+void save_squirrel_table(HSQUIRRELVM v, int table_idx, lisp::Writer&amp; writer)
+{
+  // offset because of sq_pushnull
+  if(table_idx &lt; 0)
+    table_idx--;
+  
+  //iterator table
+  sq_pushnull(v);
+  while(SQ_SUCCEEDED(sq_next(v, table_idx))) {
+    if(sq_gettype(v, -2) != OT_STRING) {
+      std::cerr &lt;&lt; &quot;Table contains non-string key\n&quot;;
+      continue;
+    }
+    const char* key;
+    sq_getstring(v, -2, &amp;key);
+
+    switch(sq_gettype(v, -1)) {
+      case OT_INTEGER: {
+        SQInteger val;
+        sq_getinteger(v, -1, &amp;val);
+        writer.write_int(key, val);
+        break;
+      }
+      case OT_FLOAT: {
+        float val;
+        sq_getfloat(v, -1, &amp;val);
+        writer.write_float(key, val);
+        break;
+      }
+      case OT_BOOL: {
+        SQBool val;
+        sq_getbool(v, -1, &amp;val);
+        writer.write_bool(key, val);
+        break;
+      }
+      case OT_STRING: {
+        const char* str;
+        sq_getstring(v, -1, &amp;str);
+        writer.write_string(key, str);
+        break;
+      }
+      case OT_TABLE: {
+        writer.start_list(key);
+        save_squirrel_table(v, -1, writer);
+        writer.end_list(key);
+        break;
+      }
+      case OT_CLOSURE:
+        break; // ignore
+      case OT_NATIVECLOSURE:
+        break;
+      default:
+        std::cerr &lt;&lt; &quot;Can't serialize key '&quot; &lt;&lt; key &lt;&lt; &quot;' in table.\n&quot;;
+        break;
+    }
+    sq_pop(v, 2);
+  }
+  sq_pop(v, 1);
+}
+
+void save_squirrel_table(HSQUIRRELVM v, int table_idx, const std::string&amp; file)
+{
+  lisp::Writer writer(file);
+
+  writer.start_list(&quot;squirrel-state&quot;);
+  save_squirrel_table(v, table_idx, writer);
+  writer.end_list(&quot;squirrel-state&quot;);
+}
+
+} // namespace Scripting
+
+/* EOF */


Property changes on: trunk/windstille/src/scripting/util.cpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Added: trunk/windstille/src/scripting/util.hpp
===================================================================
--- trunk/windstille/src/scripting/util.hpp	2007-06-15 20:34:14 UTC (rev 1439)
+++ trunk/windstille/src/scripting/util.hpp	2007-06-15 20:46:36 UTC (rev 1440)
@@ -0,0 +1,58 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  &gt; |__| |__|____/____/\___  &gt;
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2007 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_WINDSTILLE_SCRIPTING_UTIL_HPP
+#define HEADER_WINDSTILLE_SCRIPTING_UTIL_HPP
+
+#include &lt;squirrel.h&gt;
+#include &lt;string&gt;
+
+namespace lisp {
+class Writer;
+};
+
+namespace Scripting {
+
+// Squirrel to Lisp
+void        table_to_lisp(HSQUIRRELVM v, int table_idx, std::vector&lt;lisp::Lisp*&gt;&amp; entries);
+void        sq_to_lisp(HSQUIRRELVM v, std::vector&lt;lisp::Lisp*&gt;&amp; entries);
+std::string sq_to_lisp_string(std::string sq_str);
+std::string squirrel2string(HSQUIRRELVM v, int i);
+
+void print_squirrel_stack(HSQUIRRELVM v);
+
+
+// serialisation
+void save_squirrel_table(HSQUIRRELVM v, int table_idx, lisp::Writer&amp; writer);
+void load_squirrel_table(HSQUIRRELVM v, int table_idx, const lisp::Lisp* lisp);
+
+void save_squirrel_table(HSQUIRRELVM v, int table_idx, const std::string&amp; file);
+void load_squirrel_table(HSQUIRRELVM v, int table_idx, const std::string&amp; file);
+
+} // namespace Scripting
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/src/scripting/util.hpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001091.html">[Windstille-commit] r1439 - in trunk/windstille/src: . scripting
</A></li>
	<LI>Next message: <A HREF="001093.html">[Windstille-commit] r1441 - in trunk/windstille/src: . math	navigation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1092">[ date ]</a>
              <a href="thread.html#1092">[ thread ]</a>
              <a href="subject.html#1092">[ subject ]</a>
              <a href="author.html#1092">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/windstille-commit">More information about the Windstille-commit
mailing list</a><br>
</body></html>
