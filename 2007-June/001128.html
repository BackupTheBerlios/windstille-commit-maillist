<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Windstille-commit] r1476 - in trunk/windstille: . data/controller	src src/navigation src/particles src/scripting test/physics	tools/sdl-jstest
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/windstille-commit/2007-June/index.html" >
   <LINK REL="made" HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r1476%20-%20in%20trunk/windstille%3A%20.%20data/controller%0A%09src%20src/navigation%20src/particles%20src/scripting%20test/physics%0A%09tools/sdl-jstest&In-Reply-To=%3C200706200423.l5K4NF3h024350%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001127.html">
   <LINK REL="Next"  HREF="001129.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Windstille-commit] r1476 - in trunk/windstille: . data/controller	src src/navigation src/particles src/scripting test/physics	tools/sdl-jstest</H1>
    <B>grumbel at BerliOS</B> 
    <A HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r1476%20-%20in%20trunk/windstille%3A%20.%20data/controller%0A%09src%20src/navigation%20src/particles%20src/scripting%20test/physics%0A%09tools/sdl-jstest&In-Reply-To=%3C200706200423.l5K4NF3h024350%40sheep.berlios.de%3E"
       TITLE="[Windstille-commit] r1476 - in trunk/windstille: . data/controller	src src/navigation src/particles src/scripting test/physics	tools/sdl-jstest">grumbel at mail.berlios.de
       </A><BR>
    <I>Wed Jun 20 06:23:15 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="001127.html">[Windstille-commit] r1475 - in trunk/windstille: . src
</A></li>
        <LI>Next message: <A HREF="001129.html">[Windstille-commit] r1477 - in trunk/windstille: . data src	src/navigation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1128">[ date ]</a>
              <a href="thread.html#1128">[ thread ]</a>
              <a href="subject.html#1128">[ subject ]</a>
              <a href="author.html#1128">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: grumbel
Date: 2007-06-20 06:23:13 +0200 (Wed, 20 Jun 2007)
New Revision: 1476

Added:
   trunk/windstille/data/controller/dvorak.scm
   trunk/windstille/src/file_reader.cpp
   trunk/windstille/src/file_reader_impl.hpp
   trunk/windstille/src/sexpr_file_reader.cpp
   trunk/windstille/src/sexpr_file_reader.hpp
   trunk/windstille/tools/sdl-jstest/README
Modified:
   trunk/windstille/NEWS
   trunk/windstille/SConstruct
   trunk/windstille/TODO
   trunk/windstille/src/SConscript
   trunk/windstille/src/config.cpp
   trunk/windstille/src/file_reader.hpp
   trunk/windstille/src/navigation/navigation_graph.cpp
   trunk/windstille/src/navigation/navigation_graph.hpp
   trunk/windstille/src/particle_viewer.cpp
   trunk/windstille/src/particles/particle_system.cpp
   trunk/windstille/src/particles/surface_drawer.cpp
   trunk/windstille/src/scripting/interface.cpp
   trunk/windstille/src/sector.cpp
   trunk/windstille/src/sector.hpp
   trunk/windstille/src/tile_factory.cpp
   trunk/windstille/src/tile_factory.hpp
   trunk/windstille/src/windstille_main.cpp
   trunk/windstille/test/physics/
Log:
- switched from lisp::Properties to FileReader (easier to read and more flexible due to not being limited to a single file type)

Modified: trunk/windstille/NEWS
===================================================================
--- trunk/windstille/NEWS	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/NEWS	2007-06-20 04:23:13 UTC (rev 1476)
@@ -6,6 +6,7 @@
  - added arc drawing
  - added navigation graph
  - added geometry test
+ - added sdl-jstest application
 
 Windstille 0.3.0
 ================

Modified: trunk/windstille/SConstruct
===================================================================
--- trunk/windstille/SConstruct	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/SConstruct	2007-06-20 04:23:13 UTC (rev 1476)
@@ -171,6 +171,7 @@
 opts.Add('LIBPATH', 'Additional library paths')
 opts.Add('LIBS', 'Additional libraries')
 opts.Add('CCFLAGS', 'C Compiler flags')
+opts.Add('CXXFLAGS', 'C++ Compiler flags')
 opts.Add('LINKFLAGS', 'Linker Compiler flags')
 opts.Add('CC', 'C Compiler')
 opts.Add('CXX', 'C++ Compiler')  
@@ -178,6 +179,9 @@
 opts.Save('options.cache', conf_env)
 Help(opts.GenerateHelpText(conf_env))
 
+# FIXME: Giving multiple CCFLAGS doesn't work since they have to be
+# broken down to a list
+
 conf = Configure(conf_env, custom_tests = { 'Check32bit' : Check32bit,
                                             'CheckYacc'  : CheckYacc,
                                             'CheckLex'   : CheckLex})

Modified: trunk/windstille/TODO
===================================================================
--- trunk/windstille/TODO	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/TODO	2007-06-20 04:23:13 UTC (rev 1476)
@@ -25,6 +25,10 @@
 
 Misc:
 -----
+
+- rewrite the file reading/writing to look more like that in Pingus
+  (i.e. no toying around with evil pointers, weirdo iter objects,
+  etc. just FileReader)
 - polish/test scripting interface
 - create doll class
 - figure out how to do background animation (coroutines, multiple VM, etc.)

Added: trunk/windstille/data/controller/dvorak.scm
===================================================================
--- trunk/windstille/data/controller/dvorak.scm	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/data/controller/dvorak.scm	2007-06-20 04:23:13 UTC (rev 1476)
@@ -0,0 +1,29 @@
+;; -*- scheme -*-
+(windstille-controller
+ (x-axis   (keyboard-axis (minus &quot;left&quot;) (plus &quot;right&quot;)))
+ (y-axis   (keyboard-axis (minus &quot;up&quot;) (plus &quot;down&quot;)))
+  
+ (x2-axis  (keyboard-axis (minus &quot;[4]&quot;) (plus &quot;[6]&quot;))) 
+ (y2-axis  (keyboard-axis (minus &quot;[2]&quot;) (plus &quot;[8]&quot;)))
+
+ (view-center-button  (keyboard-button (key &quot;[5]&quot;)))
+
+ (primary-button      (keyboard-button (key &quot;o&quot;)))
+ (secondary-button    (keyboard-button (key &quot;a&quot;)))
+ (tertiary-button     (keyboard-button (key &quot;e&quot;)))
+
+ (pda-button          (keyboard-button (key &quot;,&quot;)))
+ (aim-button          (keyboard-button (key &quot;'&quot;)))
+ (pause-button        (keyboard-button (key &quot;p&quot;)))
+ (inventory-button    (keyboard-button (key &quot;.&quot;)))
+
+ ;; don't bind those, since they only make sense on analog gamepads
+ ;; with an additional dpad, on digital devices x-axs and y-axis
+ ;; already serve the same purpose
+ (menu-up-button)
+ (menu-down-button)
+ (menu-left-button)
+ (menu-right-button)
+ )
+
+;; EOF ;;

Modified: trunk/windstille/src/SConscript
===================================================================
--- trunk/windstille/src/SConscript	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/SConscript	2007-06-20 04:23:13 UTC (rev 1476)
@@ -57,6 +57,8 @@
 'elevator.cpp',
 'energy_bar.cpp',
 'entity.cpp',
+'file_reader.cpp',
+'sexpr_file_reader.cpp',
 'config.cpp',
 'game_object.cpp',
 'game_session.cpp',

Modified: trunk/windstille/src/config.cpp
===================================================================
--- trunk/windstille/src/config.cpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/config.cpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -30,10 +30,7 @@
 #include &lt;iostream&gt;
 #include &quot;config.hpp&quot;
 #include &quot;tinygettext/gettext.hpp&quot;
-#include &quot;lisp/lisp.hpp&quot;
-#include &quot;lisp/parser.hpp&quot;
-#include &quot;lisp/writer.hpp&quot;
-#include &quot;lisp/properties.hpp&quot;
+#include &quot;sexpr_file_reader.hpp&quot;
 #include &quot;command_line.hpp&quot;
 #include &quot;globals.hpp&quot;
 
@@ -57,7 +54,7 @@
   add(new ConfigValue&lt;std::string&gt;(&quot;levelfile&quot;,       _(&quot;Levelfile to be used at startup&quot;), false));
 
   // FIXME: There is no need to limit this to just two
-  add(new ConfigValue&lt;std::string&gt;(&quot;primary-controller-file&quot;, _(&quot;Controller Config file to load&quot;), true));
+  add(new ConfigValue&lt;std::string&gt;(&quot;primary-controller-file&quot;,   _(&quot;Controller Config file to load&quot;), true));
   add(new ConfigValue&lt;std::string&gt;(&quot;secondary-controller-file&quot;, _(&quot;Controller Config file to load&quot;), true));
 
   add(new ConfigValue&lt;std::string&gt;(&quot;screenshot-dir&quot;,  _(&quot;Directory where Screenshots are saved&quot;), false));
@@ -316,51 +313,47 @@
 void
 Config::load()
 {
-  using namespace lisp;
-  
   try {
-    std::auto_ptr&lt;Lisp&gt; root(lisp::Parser::parse(&quot;config&quot;));
-    Properties rootp(root.get());
-    
-    const Lisp* config_lisp = 0;
-    if(rootp.get(&quot;windstille-config&quot;, config_lisp) == false) {
+    SExprFileReader reader(&quot;config&quot;);
+
+    if(reader.get_name() != &quot;windstille-config&quot;) {
       std::cerr &lt;&lt; &quot;Warning: Config file is not a windstille-config file.\n&quot;;
       return;
     }
     
-    Properties props(config_lisp);
-    PropertyIterator&lt;const lisp::Lisp*&gt; iter = props.get_iter();
+    for(ConfigValues::iterator i = config_values.begin(); i != config_values.end(); ++i)
+      { // FIXME: all this dynamic_casting is overcomplicated crap
+        if (dynamic_cast&lt;ConfigValue&lt;int&gt;*&gt;(i-&gt;second))
+          {
+            int v;
+            if (reader.get(i-&gt;first.c_str(), v))
+              set_int(i-&gt;first, v);
+          }
+        else if (dynamic_cast&lt;ConfigValue&lt;bool&gt;*&gt;(i-&gt;second))
+          {
+            bool v;
+            if (reader.get(i-&gt;first.c_str(), v))
+              set_bool(i-&gt;first, v);
+          }
+        else if (dynamic_cast&lt;ConfigValue&lt;float&gt;*&gt;(i-&gt;second))
+          {
+            float v;
+            if (reader.get(i-&gt;first.c_str(), v))
+              set_float(i-&gt;first, v);
+          }
+        else if (dynamic_cast&lt;ConfigValue&lt;std::string&gt;*&gt;(i-&gt;second))
+          {
+            std::string v;
+            if (reader.get(i-&gt;first.c_str(), v))
+              set_string(i-&gt;first, v);
+          }
+        else 
+          {
+            std::cout &lt;&lt; &quot;Config: Unknown type for: &quot; &lt;&lt; i-&gt;first &lt;&lt; std::endl;
+          }
+      }
+    reader.print_unused_warnings(&quot;configfile&quot;);
 
-    while(iter.next()) {
-      // FIXME: this is a little hacky PropertyIterator should be a bit rewritten
-      lisp::Lisp* lisp = (*iter)-&gt;get_list_elem(1);
-      switch (lisp-&gt;get_type())
-        {
-        case Lisp::TYPE_BOOL:
-          set_bool(iter.item(), lisp-&gt;get_bool());
-          break;
-
-        case Lisp::TYPE_INT:
-          set_int(iter.item(), lisp-&gt;get_int());
-          break;
-
-        case Lisp::TYPE_FLOAT:
-          set_float(iter.item(), lisp-&gt;get_float());
-          break;
-
-        case Lisp::TYPE_STRING:
-          set_string(iter.item(), lisp-&gt;get_string());
-          break;
-
-        default:
-          std::cout &lt;&lt; &quot;Config: Unhandled type: &quot;;
-          lisp-&gt;print();
-          std::cout &lt;&lt; std::endl;
-        }
-    }
-
-    props.print_unused_warnings(&quot;configfile&quot;);
-
     // TODO read controller config
   } catch(std::exception&amp; e) {
     std::cerr &lt;&lt; &quot;Couldn't open config file: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;

Added: trunk/windstille/src/file_reader.cpp
===================================================================
--- trunk/windstille/src/file_reader.cpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/file_reader.cpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -0,0 +1,191 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include &quot;sexpr_file_reader.hpp&quot;
+#include &quot;lisp/parser.hpp&quot;
+#include &quot;lisp/lisp.hpp&quot;
+#include &quot;file_reader.hpp&quot;
+#include &quot;file_reader_impl.hpp&quot;
+
+FileReader::FileReader(SharedPtr&lt;FileReaderImpl&gt; impl_)
+  : impl(impl_)
+{
+}
+
+FileReader::FileReader()
+  : impl(0)
+{
+}
+
+std::string
+FileReader::get_name() const
+{
+  if (impl.get())
+    return impl-&gt;get_name();
+  else
+    return &quot;&quot;;
+}
+
+bool
+FileReader::read_int(const char* name, int&amp; value) const
+{
+  if (impl.get())
+    return impl-&gt;read_int(name, value);
+  else
+    return false;
+}
+
+bool
+FileReader::read_float (const char* name, float&amp; value) const
+{
+  if (impl.get())
+    return impl-&gt;read_float(name, value);
+  else
+    return false;
+}
+
+bool
+FileReader::read_bool  (const char* name, bool&amp; value) const
+{
+  if (impl.get())
+    return impl-&gt;read_bool(name, value);
+  else
+    return false;
+}
+
+bool
+FileReader::read_string(const char* name, std::string&amp; value) const
+{
+  if (impl.get())
+    return impl-&gt;read_string(name, value);
+  else
+    return false;
+}
+
+bool
+FileReader::read_vector3(const char* name, Vector3&amp; value) const
+{
+  if (impl.get())
+    return impl-&gt;read_vector3(name, value);
+  else
+    return false;
+}
+
+bool
+FileReader::read_color(const char* name, Color&amp; value) const
+{
+  if (impl.get())
+    return impl-&gt;read_color(name, value);
+  else
+    return false;
+}
+
+bool
+FileReader::read_size  (const char* name, Size&amp; value) const
+{
+  if (impl.get())
+    return impl-&gt;read_size(name, value);
+  else
+    return false;
+}
+
+bool
+FileReader::get(const char* name, std::vector&lt;int&gt;&amp; value) const
+{
+  if (impl.get())
+    return impl-&gt;get(name, value);
+  else
+    return false;
+}
+
+bool
+FileReader::get(const char* name, std::vector&lt;float&gt;&amp; value) const
+{
+  if (impl.get())
+    return impl-&gt;get(name, value);
+  else
+    return false;
+}
+
+bool
+FileReader::read_vector(const char* name, Vector&amp; value) const
+{
+  if (impl.get())
+    return impl-&gt;read_vector(name, value);
+  else
+    return false;
+}
+
+bool
+FileReader::read_section(const char* name, FileReader&amp; reader) const
+{
+  if (impl.get())
+    return impl-&gt;read_section(name, reader);
+  else
+    return false;
+}
+
+std::vector&lt;std::string&gt;
+FileReader::get_section_names() const
+{
+  if (impl.get())
+    return impl-&gt;get_section_names();
+  else
+    return std::vector&lt;std::string&gt;();
+}
+
+std::vector&lt;FileReader&gt;
+FileReader::get_sections() const
+{
+  if (impl.get())
+    return impl-&gt;get_sections();
+  else
+    return std::vector&lt;FileReader&gt;();
+}
+
+FileReader
+FileReader::read_section(const char* name)   const
+{
+  FileReader reader;
+  read_section(name, reader);
+  return reader;
+}
+
+FileReader
+FileReader::parse(const std::string&amp; filename)
+{
+  // FIXME: memory leak, somebody must delete the lisp::Lisp
+  lisp::Lisp* sexpr = lisp::Parser::parse(filename);
+  if (sexpr)
+    {
+      return SExprFileReader(sexpr-&gt;get_list_elem(0));
+    }
+  else
+    {
+      return FileReader();
+    }
+}
+
+void
+FileReader::print_unused_warnings(const std::string&amp; title)
+{
+  // unimplemented
+}
+
+/* EOF */


Property changes on: trunk/windstille/src/file_reader.cpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Modified: trunk/windstille/src/file_reader.hpp
===================================================================
--- trunk/windstille/src/file_reader.hpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/file_reader.hpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -1,36 +1,97 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  &gt; |__| |__|____/____/\___  &gt;
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
+//  $Id: file_reader.hxx,v 1.4 2003/10/18 23:17:27 grumbel Exp $
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
-#ifndef HEADER_FILE_READER_HPP
-#define HEADER_FILE_READER_HPP
+#ifndef HEADER_PINGUS_FILE_READER_HXX
+#define HEADER_PINGUS_FILE_READER_HXX
 
-#include &quot;lisp/properties.hpp&quot;
-#include &quot;lisp_getters.hpp&quot;
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &quot;sharedptr.hpp&quot;
 
-typedef lisp::Properties FileReader;
+class Size;
+class Color;
+class Vector;
+class Vector3;
 
+class ResDescriptor;
+class FileReaderImpl;
+
+/** Interface to read name/value pairs out of some kind of file or
+    structure */
+class FileReader
+{
+public:
+  FileReader(SharedPtr&lt;FileReaderImpl&gt; impl_);
+  FileReader();
+
+  /** Name of the current section, ie. in the case of
+      &lt;groundpiece&gt;&lt;pos&gt;...&lt;/groundpiece&gt; it would be 'groundpiece' */
+  std::string get_name() const;
+
+  bool read_int    (const char* name, int&amp;)           const;
+  bool read_float  (const char* name, float&amp;)         const;
+  bool read_bool   (const char* name, bool&amp;)          const;
+  bool read_string (const char* name, std::string&amp;)   const;
+  bool read_vector3(const char* name, Vector3&amp;)      const;
+  bool read_vector (const char* name, Vector&amp;)    const;
+  bool read_size   (const char* name, Size&amp;)          const;
+  bool read_color  (const char* name, Color&amp;)         const;
+  bool read_section(const char* name, FileReader&amp;)   const;
+  FileReader read_section(const char* name)   const;
+
+  template&lt;class E, class T&gt;
+  bool read_enum  (const char* name, E&amp; value, T enum2string) const
+  {
+    std::string str;
+    if (read_string(name, str))
+      {
+        value = enum2string(str);
+        return true;
+      }
+
+    return false;
+  }
+
+  bool get(const char* name, std::vector&lt;int&gt;&amp;   v) const;
+  bool get(const char* name, std::vector&lt;float&gt;&amp; v) const;
+
+  bool get(const char* name, FileReader&amp; v) { return read_section(name, v); }
+  bool get(const char* name, int&amp;   v) { return read_int(name, v); }
+  bool get(const char* name, float&amp; v) { return read_float(name, v); }
+  bool get(const char* name, bool&amp; v) { return read_bool(name, v); }
+  bool get(const char* name, std::string&amp; v) { return read_string(name, v); }
+  bool get(const char* name, Vector3&amp; v) { return read_vector3(name, v); }
+  bool get(const char* name, Vector&amp; v) { return read_vector(name, v); }
+  bool get(const char* name, Size&amp; v) { return read_size(name, v); }
+  bool get(const char* name, Color&amp; v) { return read_color(name, v); } 
+
+  std::vector&lt;std::string&gt; get_section_names() const;
+  std::vector&lt;FileReader&gt;  get_sections() const;
+
+  static FileReader parse(const std::string&amp; filename);
+
+  void print_unused_warnings(const std::string&amp; title);
+
+private:
+  SharedPtr&lt;FileReaderImpl&gt; impl;
+};
+
 #endif
 
 /* EOF */

Added: trunk/windstille/src/file_reader_impl.hpp
===================================================================
--- trunk/windstille/src/file_reader_impl.hpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/file_reader_impl.hpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -0,0 +1,62 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_FILE_READER_IMPL_HXX
+#define HEADER_FILE_READER_IMPL_HXX
+
+#include &lt;vector&gt;
+#include &lt;string&gt;
+
+class Size;
+class Color;
+class Vector;
+class Vector3;
+
+class FileReader;
+class ResDescriptor;
+
+/** */
+class FileReaderImpl
+{
+public:
+  FileReaderImpl() {}
+  virtual ~FileReaderImpl() {}
+
+  virtual std::string get_name()                           const =0;
+  virtual bool read_int   (const char* name, int&amp;)         const =0;
+  virtual bool read_float (const char* name, float&amp;)       const =0;
+  virtual bool read_bool  (const char* name, bool&amp;)        const =0;
+  virtual bool read_string(const char* name, std::string&amp;) const =0;
+  virtual bool read_vector3(const char* name, Vector3&amp;)    const =0;
+  virtual bool read_size  (const char* name, Size&amp;)        const =0;
+  virtual bool read_vector(const char* name, Vector&amp;)      const =0;
+  virtual bool read_color (const char* name, Color&amp;)       const =0;
+
+  virtual bool get(const char* name, std::vector&lt;int&gt;&amp;   v) const =0;
+  virtual bool get(const char* name, std::vector&lt;float&gt;&amp; v) const =0;
+
+  virtual bool read_section(const char* name, FileReader&amp;)   const =0;
+  virtual std::vector&lt;FileReader&gt; get_sections() const =0;
+  virtual std::vector&lt;std::string&gt; get_section_names() const =0;
+};
+
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/src/file_reader_impl.hpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Modified: trunk/windstille/src/navigation/navigation_graph.cpp
===================================================================
--- trunk/windstille/src/navigation/navigation_graph.cpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/navigation/navigation_graph.cpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -24,6 +24,7 @@
 */
 
 #include &lt;iostream&gt;
+#include &lt;iomanip&gt;
 #include &lt;map&gt;
 #include &lt;algorithm&gt;
 #include &quot;display/display.hpp&quot;
@@ -242,6 +243,12 @@
 }
 
 void
+NavigationGraph::load(FileReader&amp; reader)
+{
+  
+}
+
+void
 NavigationGraph::save(std::ostream&amp; out)
 {
   int id = 1;
@@ -250,22 +257,24 @@
   for(Nodes::iterator i = nodes.begin(); i != nodes.end(); ++i)
     ptr2id[*i] = id++;
 
+  std::ios_base::fmtflags old_flags = out.flags();
   out &lt;&lt; &quot;(navigation\n&quot;;
-
   out &lt;&lt; &quot;  (segments\n&quot;;
   for(Segments::iterator i = segments.begin(); i != segments.end(); ++i)  
     out &lt;&lt; &quot;    (segment &quot;
-        &lt;&lt; &quot;(node &quot; &lt;&lt; ptr2id[(*i)-&gt;get_node1()] &lt;&lt; &quot;) &quot;
-        &lt;&lt; &quot;(node &quot; &lt;&lt; ptr2id[(*i)-&gt;get_node2()] &lt;&lt; &quot;) &quot;
+        &lt;&lt; &quot;(node &quot; &lt;&lt; std::setw(3) &lt;&lt; ptr2id[(*i)-&gt;get_node1()] &lt;&lt; &quot;) &quot;
+        &lt;&lt; &quot;(node &quot; &lt;&lt; std::setw(3) &lt;&lt; ptr2id[(*i)-&gt;get_node2()] &lt;&lt; &quot;) &quot;
         &lt;&lt; &quot;(properties &quot; &lt;&lt; (*i)-&gt;get_properties() &lt;&lt; &quot;))\n&quot;;
   out &lt;&lt; &quot; )\n&quot;;
       
     out &lt;&lt; &quot;  (nodes\n&quot;; 
   for(Nodes::iterator i = nodes.begin(); i != nodes.end(); ++i)
-    out &lt;&lt; &quot;    (node (id &quot; &lt;&lt; ptr2id[*i] &lt;&lt; &quot;) (pos &quot; &lt;&lt; (*i)-&gt;get_pos().x &lt;&lt; &quot; &quot; &lt;&lt; (*i)-&gt;get_pos().y &lt;&lt; &quot;))\n&quot;;
+    out &lt;&lt; &quot;    (node (id &quot; &lt;&lt; std::setw(3) &lt;&lt; ptr2id[*i] &lt;&lt; &quot;) (pos &quot; 
+        &lt;&lt; std::setw(3) &lt;&lt; (*i)-&gt;get_pos().x &lt;&lt; &quot; &quot; &lt;&lt; (*i)-&gt;get_pos().y &lt;&lt; &quot;))\n&quot;;
   out &lt;&lt; &quot; )\n&quot;;
 
   out &lt;&lt; &quot;)\n&quot;;
+  out.flags(old_flags);
 }
 
 bool

Modified: trunk/windstille/src/navigation/navigation_graph.hpp
===================================================================
--- trunk/windstille/src/navigation/navigation_graph.hpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/navigation/navigation_graph.hpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -32,6 +32,7 @@
 #include &quot;math/line.hpp&quot;
 
 class Node;
+class FileReader;
 class Segment;
 class SegmentPosition;
 
@@ -113,6 +114,7 @@
   /** Draw the navigation graph, for debugging only */
   void draw();
 
+  void load(FileReader&amp; reader);
   void save(std::ostream&amp; out);
 
   bool valid(Segment* segment);

Modified: trunk/windstille/src/particle_viewer.cpp
===================================================================
--- trunk/windstille/src/particle_viewer.cpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/particle_viewer.cpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -25,8 +25,7 @@
 
 #include &quot;lisp/lisp.hpp&quot;
 #include &quot;lisp/parser.hpp&quot;
-#include &quot;lisp/properties.hpp&quot;
-#include &quot;file_reader.hpp&quot;
+#include &quot;sexpr_file_reader.hpp&quot;
 #include &quot;input/controller.hpp&quot;
 #include &quot;screen_manager.hpp&quot;
 #include &quot;gui/gui_manager.hpp&quot;
@@ -113,30 +112,24 @@
 ParticleViewer::load(const std::string&amp; filename)
 {
   std::cout &lt;&lt; &quot;ParticleViewer: loading &quot; &lt;&lt; filename &lt;&lt; std::endl;
-  using namespace lisp;
   
   for(Systems::iterator i = systems.begin(); i != systems.end(); ++i)
     delete *i;
   systems.clear();
   
-  std::auto_ptr&lt;Lisp&gt; root(Parser::parse(filename));
-  Properties rootp(root.get());
-
-  const Lisp* sector = 0;
-  if(!rootp.get(&quot;particle-systems&quot;, sector)) {
+  SExprFileReader root_reader(filename);
+  if(root_reader.get_name() != &quot;particle-systems&quot;) {
     std::ostringstream msg;
     msg &lt;&lt; &quot;'&quot; &lt;&lt; filename &lt;&lt; &quot;' is not a particle-system file&quot;;
     throw std::runtime_error(msg.str());
   }
-  rootp.print_unused_warnings(&quot;sector&quot;);
-  
-  Properties props(sector);
-  PropertyIterator&lt;const Lisp*&gt; iter = props.get_iter();
-  while(iter.next()) {
-    if (iter.item() == &quot;particle-system&quot;)
+
+  std::vector&lt;FileReader&gt; sections = root_reader.get_sections();
+  for(std::vector&lt;FileReader&gt;::iterator i = sections.begin(); i != sections.end(); ++i)
+    { 
+      if (i-&gt;get_name() == &quot;particle-system&quot;)
       {
-        FileReader reader(*iter);
-        systems.push_back(new ParticleSystem(reader));
+        systems.push_back(new ParticleSystem(*i));
 
         guis.push_back(new ParticleSystemGUI(tab, systems.back()));
         tab-&gt;pack(&quot;Testomap&quot;, guis.back()-&gt;get_component());

Modified: trunk/windstille/src/particles/particle_system.cpp
===================================================================
--- trunk/windstille/src/particles/particle_system.cpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/particles/particle_system.cpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -134,70 +134,82 @@
   }
 
   {
-    const lisp::Lisp* drawer_lisp = 0;
-    if (props.get(&quot;drawer&quot;, drawer_lisp))
+    FileReader drawer_reader;
+    if (props.get(&quot;drawer&quot;, drawer_reader))
       {
-        lisp::Properties drawer_props(drawer_lisp);
-        lisp::PropertyIterator&lt;const lisp::Lisp*&gt; iter = drawer_props.get_iter();
-        while(iter.next()) {
-          if (iter.item() == &quot;surface-drawer&quot;) 
-            {
-              lisp::Properties props(*iter);
-              set_drawer(new SurfaceDrawer(props));
-            } 
-          else if (iter.item() == &quot;spark-drawer&quot;) 
-            {
-              lisp::Properties props(*iter);
-              set_drawer(new SparkDrawer(props));
-            } 
-          else if (iter.item() == &quot;deform-drawer&quot;)
-            {
-              lisp::Properties props(*iter);
-              set_drawer(new DeformDrawer(props));
-            }
-          else 
-            {
-              std::cout &lt;&lt; &quot;Unknown drawer: &quot; &lt;&lt; iter.item() &lt;&lt; std::endl;
-            }
-        }
+        std::vector&lt;FileReader&gt; sections = drawer_reader.get_sections();
+
+        if (sections.size() &gt; 1)
+          std::cout &lt;&lt; &quot;ParticleSystem: Only one drawer allowed&quot; &lt;&lt; std::endl;
+        
+        if (sections.size() == 0)
+          std::cout &lt;&lt; &quot;ParticleSystem: You must specify a drawer&quot; &lt;&lt; std::endl;
+
+        if (sections.size() &gt;= 1)
+          {
+            FileReader&amp; reader  = sections.front();
+            if (reader.get_name() == &quot;surface-drawer&quot;) 
+              {
+                set_drawer(new SurfaceDrawer(reader));
+              } 
+            else if (reader.get_name() == &quot;spark-drawer&quot;) 
+              {
+                set_drawer(new SparkDrawer(reader));
+              } 
+            else if (reader.get_name() == &quot;deform-drawer&quot;)
+              {
+                set_drawer(new DeformDrawer(reader));
+              }
+            else 
+              {
+                std::cout &lt;&lt; &quot;Unknown drawer: &quot; &lt;&lt; reader.get_name() &lt;&lt; std::endl;
+              }
+          }
       }
   }
 
   {
-    const lisp::Lisp* distribution_lisp = 0;
-    if (props.get(&quot;distribution&quot;, distribution_lisp))
+    FileReader distribution_reader;
+    if (props.get(&quot;distribution&quot;, distribution_reader))
       {
-        lisp::Properties distribution_props(distribution_lisp);
-        lisp::PropertyIterator&lt;const lisp::Lisp*&gt; iter = distribution_props.get_iter();
-        if (iter.next()) {
-          lisp::Properties prop(*iter);
+        std::vector&lt;FileReader&gt; sections = distribution_reader.get_sections();
 
-          if (iter.item() == &quot;point-distribution&quot;) {
-            set_point_distribution();
-          } else if (iter.item() == &quot;line-distribution&quot;) {
-            float x1, y1, x2, y2;
-            prop.get(&quot;x1&quot;, x1);
-            prop.get(&quot;y1&quot;, y1);
-            prop.get(&quot;x2&quot;, x2);
-            prop.get(&quot;y2&quot;, y2);
+        if (sections.size() &gt; 1)
+          std::cout &lt;&lt; &quot;ParticleSystem: Only one distribution allowed&quot; &lt;&lt; std::endl;
+        
+        if (sections.size() == 0)
+          std::cout &lt;&lt; &quot;ParticleSystem: You must specify a distribution&quot; &lt;&lt; std::endl;
+
+        if (sections.size() &gt;= 1)
+          {
+            FileReader&amp; reader  = sections.front();
+
+            if (reader.get_name() == &quot;point-distribution&quot;) {
+              set_point_distribution();
+            } else if (reader.get_name() == &quot;line-distribution&quot;) {
+              float x1, y1, x2, y2;
+              reader.get(&quot;x1&quot;, x1);
+              reader.get(&quot;y1&quot;, y1);
+              reader.get(&quot;x2&quot;, x2);
+              reader.get(&quot;y2&quot;, y2);
           
-            set_line_distribution(x1, y1, x2, y2);
-          } else if (iter.item() == &quot;rect-distribution&quot;) {
-            Rectf rect;
-            prop.get(&quot;x1&quot;, rect.left);
-            prop.get(&quot;y1&quot;, rect.top);
-            prop.get(&quot;x2&quot;, rect.right);
-            prop.get(&quot;y2&quot;, rect.bottom);
+              set_line_distribution(x1, y1, x2, y2);
+            } else if (reader.get_name() == &quot;rect-distribution&quot;) {
+              Rectf rect;
+              reader.get(&quot;x1&quot;, rect.left);
+              reader.get(&quot;y1&quot;, rect.top);
+              reader.get(&quot;x2&quot;, rect.right);
+              reader.get(&quot;y2&quot;, rect.bottom);
           
-            set_rect_distribution(rect);
+              set_rect_distribution(rect);
 
-          } else {
-            std::cout &lt;&lt; &quot;Unknown distribution: &quot; &lt;&lt; iter.item() &lt;&lt; std::endl;
+            } else {
+              std::cout &lt;&lt; &quot;Unknown distribution: &quot; &lt;&lt; reader.get_name() &lt;&lt; std::endl;
+            }
           }
-        }
       }
   }
-
+  
   int p_count = 70;
   props.get(&quot;count&quot;, p_count);
   set_count(p_count);

Modified: trunk/windstille/src/particles/surface_drawer.cpp
===================================================================
--- trunk/windstille/src/particles/surface_drawer.cpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/particles/surface_drawer.cpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -31,7 +31,7 @@
 #include &quot;surface_drawer.hpp&quot;
 
 SurfaceDrawer::SurfaceDrawer(Surface surface_)
-  :surface(surface_)
+  : surface(surface_)
 {
   
 }

Modified: trunk/windstille/src/scripting/interface.cpp
===================================================================
--- trunk/windstille/src/scripting/interface.cpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/scripting/interface.cpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -37,6 +37,7 @@
 #include &quot;camera.hpp&quot;
 #include &quot;config.hpp&quot;
 #include &quot;pda.hpp&quot;
+#include &quot;sexpr_file_reader.hpp&quot;
 #include &quot;display/display.hpp&quot;
 #include &quot;controller_help_window.hpp&quot;
 
@@ -327,9 +328,10 @@
   std::vector&lt;lisp::Lisp*&gt; entries;
   entries.push_back(new Lisp(Lisp::TYPE_SYMBOL, objname));
   table_to_lisp(v, 3, entries);
-  std::auto_ptr&lt;Lisp&gt; lisp (new Lisp(entries));
+
   try {
-    Sector::current()-&gt;add_object(objname, lisp.get());
+    SExprFileReader reader(new Lisp(entries), true);
+    Sector::current()-&gt;add_object(reader);
   } catch(std::exception&amp; e) {
     std::cerr &lt;&lt; &quot;Error parsing object in spawn_object: &quot; &lt;&lt; e.what()
       &lt;&lt; &quot;\n&quot;;

Modified: trunk/windstille/src/sector.cpp
===================================================================
--- trunk/windstille/src/sector.cpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/sector.cpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -23,6 +23,7 @@
 #include &quot;lisp/properties.hpp&quot;
 #include &quot;lisp/parser.hpp&quot;
 #include &quot;lisp_getters.hpp&quot;
+#include &quot;sexpr_file_reader.hpp&quot;
 #include &quot;globals.hpp&quot;
 #include &quot;display/scene_context.hpp&quot;
 #include &quot;objects/background_gradient.hpp&quot;
@@ -107,92 +108,84 @@
   if (debug) std::cout &lt;&lt; &quot;Sector:parse_file '&quot; &lt;&lt; filename &lt;&lt; &quot;'&quot; &lt;&lt; std::endl;
   using namespace lisp;
   
-  std::auto_ptr&lt;Lisp&gt; root(Parser::parse(filename));
-  Properties rootp(root.get());
-
-  const Lisp* sector = 0;
-  if(!rootp.get(&quot;windstille-sector&quot;, sector)) {
+  SExprFileReader reader(filename);
+  if(reader.get_name() != &quot;windstille-sector&quot;) {
     std::ostringstream msg;
     msg &lt;&lt; &quot;'&quot; &lt;&lt; filename &lt;&lt; &quot;' is not a windstille-sector file&quot;;
     throw std::runtime_error(msg.str());
   }
-  rootp.print_unused_warnings(&quot;sector&quot;);
   
-  Properties props(sector);
-
   int version = 1;
-  if(!props.get(&quot;version&quot;, version))
+  if(!reader.get(&quot;version&quot;, version))
     std::cerr &lt;&lt; &quot;Warning no version specified in levelformat.\n&quot;;
   if(version &gt; 1)
     std::cerr &lt;&lt; &quot;Warning: format version is newer than game.\n&quot;;
 
-  props.get(&quot;name&quot;, name);
-  props.get(&quot;music&quot;, music);
-  props.get(&quot;init-script&quot;, init_script);
-  props.get(&quot;ambient-color&quot;, ambient_light);
+  reader.get(&quot;name&quot;,          name);
+  reader.get(&quot;music&quot;,         music);
+  reader.get(&quot;init-script&quot;,   init_script);
+  reader.get(&quot;ambient-color&quot;, ambient_light);
   
-  PropertyIterator&lt;const Lisp*&gt; iter;
-  const Lisp* objects = 0;
-  if(props.get(&quot;objects&quot;, objects) == false)
+  FileReader objects_reader;
+  if(reader.get(&quot;objects&quot;, objects_reader) == false)
     throw std::runtime_error(&quot;No objects specified&quot;);
-  Properties pobjects(objects);
-  iter = pobjects.get_iter();
-  while(iter.next()) {
-    add_object(iter.item(), *iter);
-  }
 
-  props.print_unused_warnings(&quot;sector&quot;);
+  std::vector&lt;FileReader&gt; objects_readers = objects_reader.get_sections();
+  for(std::vector&lt;FileReader&gt;::iterator i = objects_readers.begin(); i != objects_readers.end(); ++i)
+    {
+      add_object(*i);
+    }
+
+  reader.print_unused_warnings(&quot;sector&quot;);
   if (debug) std::cout &lt;&lt; &quot;Finished parsing&quot; &lt;&lt; std::endl;
 }
 
 void
-Sector::add_object(const std::string&amp; name, const lisp::Lisp* lisp)
+Sector::add_object(FileReader&amp; reader)
 {
-  lisp::Properties props(lisp);
-
-  if(name == &quot;tilemap&quot;) {
-    TileMap* tilemap = new TileMap(props);
+  if(reader.get_name() == &quot;tilemap&quot;) {
+    TileMap* tilemap = new TileMap(reader);
     add(tilemap);
     if (tilemap-&gt;get_name() == &quot;interactive&quot;)
       interactive_tilemap = tilemap;
     else if (tilemap-&gt;get_name() == &quot;interactivebackground&quot;)
       interactivebackground_tilemap = tilemap;
-  } else if(name == &quot;background&quot;) {
+  } else if(reader.get_name() == &quot;background&quot;) {
     // TODO
-  } else if (name == &quot;background-gradient&quot;) {
-    add(new BackgroundGradient(props));
-  } else if(name == &quot;trigger&quot;) {
-    add(new Trigger(props));
-  } else if(name == &quot;box&quot;) {
-    add(new Box(props));
-  } else if(name == &quot;shockwave&quot;) {
-    add(new Shockwave(props));
-  } else if(name == &quot;elevator&quot;) {
-    add(new Elevator(props));
-  } else if(name == &quot;character&quot;) {    
-    add(new Character(props));
-  } else if(name == &quot;spider-mine&quot;) {
-    add(new SpiderMine(props));
-  } else if(name == &quot;hedgehog&quot;) {
-    add(new Hedgehog(props));
-  } else if(name == &quot;test-object&quot;) {
-    add(new TestObject(props));
-  } else if (name == &quot;nightvision&quot;) {
-    add(new Nightvision(props));
-  } else if (name == &quot;particle-system&quot;) {
-    add(new ParticleSystem(props));
-  } else if(name == &quot;scriptable-object&quot;) {    
-    add(new ScriptableObject(props));
-  } else if (name == &quot;vrdummy&quot;) {
-    add(new VRDummy(props));
-  } else if (name == &quot;swarm&quot;) {
-    add(new Swarm(props));
-  } else if (name == &quot;laserpointer&quot;) {
+  } else if (reader.get_name() == &quot;background-gradient&quot;) {
+    add(new BackgroundGradient(reader));
+  } else if(reader.get_name() == &quot;trigger&quot;) {
+    add(new Trigger(reader));
+  } else if(reader.get_name() == &quot;box&quot;) {
+    add(new Box(reader));
+  } else if(reader.get_name() == &quot;shockwave&quot;) {
+    add(new Shockwave(reader));
+  } else if(reader.get_name() == &quot;elevator&quot;) {
+    add(new Elevator(reader));
+  } else if(reader.get_name() == &quot;character&quot;) {    
+    add(new Character(reader));
+  } else if(reader.get_name() == &quot;spider-mine&quot;) {
+    add(new SpiderMine(reader));
+  } else if(reader.get_name() == &quot;hedgehog&quot;) {
+    add(new Hedgehog(reader));
+  } else if(reader.get_name() == &quot;test-object&quot;) {
+    add(new TestObject(reader));
+  } else if (reader.get_name() == &quot;nightvision&quot;) {
+    add(new Nightvision(reader));
+  } else if (reader.get_name() == &quot;particle-system&quot;) {
+    add(new ParticleSystem(reader));
+  } else if(reader.get_name() == &quot;scriptable-object&quot;) {    
+    add(new ScriptableObject(reader));
+  } else if (reader.get_name() == &quot;vrdummy&quot;) {
+    add(new VRDummy(reader));
+  } else if (reader.get_name() == &quot;swarm&quot;) {
+    add(new Swarm(reader));
+  } else if (reader.get_name() == &quot;laserpointer&quot;) {
     add(new LaserPointer());
-  } else if (name == &quot;liquid&quot;) {
-    add(new Liquid(props));
+  } else if (reader.get_name() == &quot;liquid&quot;) {
+    add(new Liquid(reader));
   } else {
-    std::cout &lt;&lt; &quot;Skipping unknown Object: &quot; &lt;&lt; name &lt;&lt; &quot;\n&quot;;
+    std::cout &lt;&lt; &quot;Skipping unknown Object: &quot; &lt;&lt; reader.get_name() &lt;&lt; &quot;\n&quot;;
   }
 }
 

Modified: trunk/windstille/src/sector.hpp
===================================================================
--- trunk/windstille/src/sector.hpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/sector.hpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -22,9 +22,9 @@
 
 #include &lt;string&gt;
 #include &lt;vector&gt;
-#include &quot;lisp/lisp.hpp&quot;
 #include &quot;color.hpp&quot;
 
+class FileReader;
 class GameObject;
 class TileMap;
 class Player;
@@ -98,7 +98,7 @@
   Color get_ambient_light() const;
 
   void add(GameObject*);
-  void add_object(const std::string&amp; name, const lisp::Lisp* lisp);
+  void add_object(FileReader&amp; reader);
 
   CollisionEngine* get_collision_engine() const { return collision_engine; }
 

Added: trunk/windstille/src/sexpr_file_reader.cpp
===================================================================
--- trunk/windstille/src/sexpr_file_reader.cpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/sexpr_file_reader.cpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -0,0 +1,312 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  &gt; |__| |__|____/____/\___  &gt;
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include &lt;assert.h&gt;
+#include &quot;lisp/parser.hpp&quot;
+#include &quot;lisp/getters.hpp&quot;
+#include &quot;color.hpp&quot;
+#include &quot;math/size.hpp&quot;
+#include &quot;math/vector.hpp&quot;
+#include &quot;math/vector3.hpp&quot;
+#include &quot;file_reader_impl.hpp&quot;
+#include &quot;sexpr_file_reader.hpp&quot;
+
+class SExprFileReaderImpl: public FileReaderImpl
+{
+public:
+  bool delete_sexpr;
+  const lisp::Lisp* sexpr;
+
+  SExprFileReaderImpl(const lisp::Lisp* sexpr_, bool delete_sexpr_) 
+    : sexpr(sexpr_), 
+      delete_sexpr(delete_sexpr_)
+  {
+    assert(sexpr &amp;&amp; 
+           sexpr-&gt;get_type() == lisp::Lisp::TYPE_LIST &amp;&amp;
+           sexpr-&gt;get_list_size() &gt;= 1);
+    
+    // FIXME: I don't think this is good for anything
+    // for(size_t i = 1; i &lt; sexpr-&gt;get_list_size(); ++i)
+    // { // iterate over subsections
+    //  sexpr-&gt;get_list_elem(i);
+    // }
+  }
+
+  ~SExprFileReaderImpl()
+  {
+    if (delete_sexpr)
+      {
+        delete sexpr;
+      }
+  }
+
+  std::string get_name() const 
+  {
+    return sexpr-&gt;get_list_elem(0)-&gt;get_symbol();
+  }
+
+  bool read_int(const char* name, int&amp; v) const 
+  {
+    lisp::Lisp* item = get_subsection_item(name);
+    if (item &amp;&amp; item-&gt;get_type() == lisp::Lisp::TYPE_INT)
+      {
+        v = item-&gt;get_int();
+        return true;
+      }
+    return false;
+  }
+
+  bool read_float(const char* name, float&amp; v) const 
+  {
+    lisp::Lisp* item = get_subsection_item(name);
+    if (item)
+      {
+        if (item-&gt;get_type() == lisp::Lisp::TYPE_FLOAT)
+          {
+            v = item-&gt;get_float();
+            return true;
+          }
+        else if (item-&gt;get_type() == lisp::Lisp::TYPE_INT)
+          {
+            v = item-&gt;get_int();
+            return true;
+          }
+        else
+          {
+            return false;
+          }
+      }
+    return false;
+  }
+
+  bool read_bool  (const char* name, bool&amp; v) const 
+  {
+    lisp::Lisp* item = get_subsection_item(name);
+    if (item &amp;&amp; item-&gt;get_type() == lisp::Lisp::TYPE_BOOL)
+      {
+        v = item-&gt;get_bool();
+        return true;
+      }
+    return false;
+  }
+
+  bool read_string(const char* name, std::string&amp; v) const 
+  {
+    lisp::Lisp* sub = get_subsection(name);
+    if (sub)
+      {
+        v = &quot;&quot;;
+        for(size_t i = 1; i &lt; sub-&gt;get_list_size(); ++i)
+          {
+            lisp::Lisp* item = sub-&gt;get_list_elem(i);
+            if (item-&gt;get_type() == lisp::Lisp::TYPE_STRING)
+              {
+                v += item-&gt;get_string();
+              }
+            else if (item-&gt;get_type() == lisp::Lisp::TYPE_SYMBOL)
+              {
+                v += item-&gt;get_symbol();
+              }
+          }
+        return true;
+      }
+    return false;
+  }
+
+  bool read_vector3(const char* name, Vector3&amp; v) const
+  {
+    lisp::Lisp* sub = get_subsection(name);
+    if (sub &amp;&amp; sub-&gt;get_list_size() == 4)
+      {
+        lisp::get(sub-&gt;get_list_elem(1), v.x);
+        lisp::get(sub-&gt;get_list_elem(2), v.y);
+        lisp::get(sub-&gt;get_list_elem(3), v.z);
+        return true;
+      }    
+    return false;
+  }
+
+  bool read_size(const char* name, Size&amp; v) const
+  {
+    lisp::Lisp* sub = get_subsection(name);
+    if (sub &amp;&amp; sub-&gt;get_list_size() == 3)
+      {
+        v.width  = sub-&gt;get_list_elem(1)-&gt;get_int();
+        v.height = sub-&gt;get_list_elem(2)-&gt;get_int();
+        return true;
+      }    
+    return false;
+  }
+
+  bool read_vector(const char* name, Vector&amp; v) const
+  {
+    lisp::Lisp* sub = get_subsection(name);
+    if (sub &amp;&amp; sub-&gt;get_list_size() == 3)
+      {
+        lisp::get(sub-&gt;get_list_elem(1), v.x);
+        lisp::get(sub-&gt;get_list_elem(2), v.y);
+        return true;
+      }    
+    return false;
+  }
+
+  bool read_color (const char* name, Color&amp; v) const
+  {
+    lisp::Lisp* sub = get_subsection(name);
+    if (sub)
+      {
+        if (sub-&gt;get_list_size() == 5)
+          {
+            lisp::get(sub-&gt;get_list_elem(1), v.r);
+            lisp::get(sub-&gt;get_list_elem(2), v.g);
+            lisp::get(sub-&gt;get_list_elem(3), v.b);
+            lisp::get(sub-&gt;get_list_elem(4), v.a);
+            return true;
+          }
+        else if (sub-&gt;get_list_size() == 4)
+          {
+            lisp::get(sub-&gt;get_list_elem(1), v.r);
+            lisp::get(sub-&gt;get_list_elem(2), v.g);
+            lisp::get(sub-&gt;get_list_elem(3), v.b);
+            v.a = 1.0f;
+            return true;
+          }
+        else
+          {
+            return false;
+          }
+      }
+    return false;
+  }
+
+  bool get(const char* name, std::vector&lt;int&gt;&amp;   v) const
+  {
+    lisp::Lisp* sub = get_subsection(name);
+    if (sub)
+      return property_get(sub, v);
+    else 
+      return false;
+  }
+
+  bool get(const char* name, std::vector&lt;float&gt;&amp; v) const
+  {
+    lisp::Lisp* sub = get_subsection(name);
+    if (sub)
+      return property_get(sub, v);
+    else 
+      return false;
+  }
+
+  bool read_section(const char* name, FileReader&amp; v) const 
+  {
+    lisp::Lisp* cur = get_subsection(name);
+    if (cur)
+      {
+        v = SExprFileReader(cur);
+        return true;
+      }
+    return false;
+  }
+
+  std::vector&lt;FileReader&gt; get_sections() const 
+  {
+    std::vector&lt;FileReader&gt; lst;
+    for(size_t i = 1; i &lt; sexpr-&gt;get_list_size(); ++i)
+      { // iterate over subsections
+        lst.push_back(SExprFileReader(sexpr-&gt;get_list_elem(i)));
+      }
+    return lst;
+  }
+
+  std::vector&lt;std::string&gt; get_section_names() const 
+  {
+    std::vector&lt;std::string&gt; lst;
+
+    for(size_t i = 1; i &lt; sexpr-&gt;get_list_size(); ++i)
+      { // iterate over subsections
+        lisp::Lisp* sub = sexpr-&gt;get_list_elem(i);
+        lst.push_back(sub-&gt;get_list_elem(0)-&gt;get_symbol());
+      }
+
+    return lst;
+  }
+
+private:
+  lisp::Lisp* get_subsection_item(const char* name) const
+  {
+    lisp::Lisp* sub = get_subsection(name);
+    if (sub &amp;&amp; sub-&gt;get_list_size() == 2)
+      {
+        return sub-&gt;get_list_elem(1);
+      }
+    return 0;
+  }
+
+  lisp::Lisp* get_subsection(const char* name) const
+  {
+    for(size_t i = 1; i &lt; sexpr-&gt;get_list_size(); ++i)
+      { // iterate over subsections
+        lisp::Lisp* sub = sexpr-&gt;get_list_elem(i);
+        if (strcmp(sub-&gt;get_list_elem(0)-&gt;get_symbol(), name) == 0)
+          return sub;
+      }
+    return 0;
+  } 
+
+};
+
+SExprFileReader::SExprFileReader(const lisp::Lisp* sexpr, bool delete_sexpr)
+  : FileReader(SharedPtr&lt;FileReaderImpl&gt;(new SExprFileReaderImpl(sexpr, delete_sexpr)))
+{
+}
+
+static lisp::Lisp* read_lisp_file(const std::string&amp; filename)
+{
+  lisp::Lisp* sexpr = lisp::Parser::parse(filename);
+  if (!sexpr)
+    {
+      std::ostringstream msg;
+      msg &lt;&lt; &quot;'&quot; &lt;&lt; filename &lt;&lt; &quot;': file not found&quot;;
+      throw std::runtime_error(msg.str());
+    }
+  else if (sexpr &amp;&amp; sexpr-&gt;get_type() == lisp::Lisp::TYPE_LIST &amp;&amp; sexpr-&gt;get_list_size() &gt;= 1)
+    {
+      return sexpr-&gt;get_list_elem(0);
+    }
+  else
+    {
+      std::ostringstream msg;
+      msg &lt;&lt; &quot;'&quot; &lt;&lt; filename &lt;&lt; &quot;': not a valid sexpr file&quot;;
+      throw std::runtime_error(msg.str());
+    }
+}
+
+SExprFileReader::SExprFileReader(const std::string&amp; filename)
+  : FileReader(SharedPtr&lt;FileReaderImpl&gt;(new SExprFileReaderImpl(read_lisp_file(filename),
+                                                                 true)))
+{
+}
+
+/* EOF */


Property changes on: trunk/windstille/src/sexpr_file_reader.cpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Added: trunk/windstille/src/sexpr_file_reader.hpp
===================================================================
--- trunk/windstille/src/sexpr_file_reader.hpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/sexpr_file_reader.hpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -0,0 +1,43 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  &gt; |__| |__|____/____/\___  &gt;
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_SEXPR_FILE_READER_HPP
+#define HEADER_SEXPR_FILE_READER_HPP
+
+#include &quot;file_reader.hpp&quot;
+#include &quot;lisp/lisp.hpp&quot;
+
+/** */
+class SExprFileReader : public FileReader
+{
+private:
+public:
+  SExprFileReader(const lisp::Lisp* lisp, bool delete_sexpr = false);
+  SExprFileReader(const std::string&amp; filename);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/src/sexpr_file_reader.hpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Modified: trunk/windstille/src/tile_factory.cpp
===================================================================
--- trunk/windstille/src/tile_factory.cpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/tile_factory.cpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -30,9 +30,7 @@
 #include &quot;tile_packer.hpp&quot;
 #include &quot;tile_factory.hpp&quot;
 #include &quot;tile_description.hpp&quot;
-#include &quot;lisp/lisp.hpp&quot;
-#include &quot;lisp/parser.hpp&quot;
-#include &quot;lisp/properties.hpp&quot;
+#include &quot;sexpr_file_reader.hpp&quot;
 #include &quot;display/surface_manager.hpp&quot;
 #include &quot;display/texture.hpp&quot;
 #include &quot;physfs/physfs_sdl.hpp&quot;
@@ -64,29 +62,28 @@
 
 TileFactory::TileFactory (const std::string&amp; filename)
 {
-  using namespace lisp;
-
   packers.push_back(new TilePacker(1024, 1024));
   packers.push_back(new TilePacker(1024, 1024));
   color_packer     = 0;
 
-  std::auto_ptr&lt;Lisp&gt; root (Parser::parse(filename));
-  Properties rootp(root.get());
+  SExprFileReader reader(filename);
+  if(reader.get_name() != &quot;windstille-tiles&quot;)
+    {
+      std::ostringstream msg;
+      msg &lt;&lt; &quot;'&quot; &lt;&lt; filename &lt;&lt; &quot;' is not a windstille tiles file&quot;;
+      throw std::runtime_error(msg.str());
+    }
   
-  const lisp::Lisp* tiles_lisp = 0;
-  if(rootp.get(&quot;windstille-tiles&quot;, tiles_lisp) == false) {
-    std::ostringstream msg;
-    msg &lt;&lt; &quot;'&quot; &lt;&lt; filename &lt;&lt; &quot;' is not a windstille tiles file&quot;;
-    throw std::runtime_error(msg.str());
-  }
-  
-  Properties props(tiles_lisp);
-  PropertyIterator&lt;const lisp::Lisp*&gt; iter;
-  props.get_iter(&quot;tiles&quot;, iter);
-  while(iter.next()) {
-    parse_tiles(*iter);
-  }
-  props.print_unused_warnings(&quot;windstille-tiles&quot;);
+  std::vector&lt;FileReader&gt; sections = reader.get_sections();
+  for(std::vector&lt;FileReader&gt;::iterator i = sections.begin(); i != sections.end(); ++i)
+    {
+      if (i-&gt;get_name() == &quot;tiles&quot;) {
+        parse_tiles(*i);
+      } else if (i-&gt;get_name() == &quot;tilegroup&quot;) {
+        // ignore
+      }
+    }
+  reader.print_unused_warnings(&quot;TileFactory&quot;);
 }
 
 TileFactory::~TileFactory()
@@ -104,14 +101,10 @@
 }
 
 void
-TileFactory::parse_tiles(const lisp::Lisp* data)
+TileFactory::parse_tiles(FileReader&amp; reader)
 {
-  using namespace lisp;
-  assert(data);
+  descriptions.push_back(new TileDescription(reader));
 
-  lisp::Properties props(data);
-
-  descriptions.push_back(new TileDescription(props));
   TileDescription&amp; desc = *descriptions.back();
   
   if (0)

Modified: trunk/windstille/src/tile_factory.hpp
===================================================================
--- trunk/windstille/src/tile_factory.hpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/tile_factory.hpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -77,7 +77,7 @@
   static TileFactory* current() { return current_; }
 
 private:
-  void parse_tiles(const lisp::Lisp* data);
+  void parse_tiles(FileReader&amp; reader);
 };
 
 #endif

Modified: trunk/windstille/src/windstille_main.cpp
===================================================================
--- trunk/windstille/src/windstille_main.cpp	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/src/windstille_main.cpp	2007-06-20 04:23:13 UTC (rev 1476)
@@ -134,7 +134,6 @@
         std::string leveldir = dirname(config.get_string(&quot;levelfile&quot;));
         PHYSFS_addToSearchPath(leveldir.c_str(), true);
         levelfile = basename(config.get_string(&quot;levelfile&quot;));
-        std::cout &lt;&lt; &quot;XXX: &quot; &lt;&lt; leveldir &lt;&lt; std::endl;
       }
 
     if (sprite3dview)


Property changes on: trunk/windstille/test/physics
___________________________________________________________________
Name: svn:ignore
   - 
main
.sconsign

   + 
main
.sconsign
.sconsign.dblite


Added: trunk/windstille/tools/sdl-jstest/README
===================================================================
--- trunk/windstille/tools/sdl-jstest/README	2007-06-20 00:15:36 UTC (rev 1475)
+++ trunk/windstille/tools/sdl-jstest/README	2007-06-20 04:23:13 UTC (rev 1476)
@@ -0,0 +1,10 @@
+sdl-jstest
+==========
+
+sdl-jstest is a simple program that lets you find out how many
+joysticks SDL detected on your system, how many axes, buttons, hats
+and balls they have each. It also lets you test the joysticks by
+displaying the events they send or by displaying their current button,
+axis, hat or ball state.
+
+# EOF #


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001127.html">[Windstille-commit] r1475 - in trunk/windstille: . src
</A></li>
	<LI>Next message: <A HREF="001129.html">[Windstille-commit] r1477 - in trunk/windstille: . data src	src/navigation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1128">[ date ]</a>
              <a href="thread.html#1128">[ thread ]</a>
              <a href="subject.html#1128">[ subject ]</a>
              <a href="author.html#1128">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/windstille-commit">More information about the Windstille-commit
mailing list</a><br>
</body></html>
