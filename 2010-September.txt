From grumbel at mail.berlios.de  Thu Sep  2 14:59:38 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Thu,  2 Sep 2010 14:59:38 +0200
Subject: [Windstille-commit] r3348 - trunk/windstille/extra/slideshow
Message-ID: <20100902125938.E90824801A1@sheep.berlios.de>

Author: grumbel
Date: 2010-09-02 14:59:38 +0200 (Thu, 02 Sep 2010)
New Revision: 3348

Modified:
   trunk/windstille/extra/slideshow/slideshow.cpp
Log:
Use m_files, not argv


Modified: trunk/windstille/extra/slideshow/slideshow.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slideshow.cpp	2010-08-30 21:13:50 UTC (rev 3347)
+++ trunk/windstille/extra/slideshow/slideshow.cpp	2010-09-02 12:59:38 UTC (rev 3348)
@@ -202,9 +202,9 @@
 
               case SDLK_F5:
                 slide_show.clear();
-                for(int i = 1; i < argc; ++i)
+                for(size_t i = 0; i < m_files.size(); ++i)
                 {
-                  slide_show.load(argv[i], m_aspect_ratio);
+                  slide_show.load(m_files[i], m_aspect_ratio);
                 }
                 break;
 
@@ -296,11 +296,12 @@
       glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       slide_show.draw(time);
+      //SDL_GL_SwapBuffers();
 
       char out[1024];
       sprintf(out, "%s/%08d.jpg", m_output_dir.c_str(), frame_number);
       Display::save_screenshot(Pathname(out, Pathname::kSysPath));
-      std::cout << "Wrote: " << out << std::endl;
+      //std::cout << "Wrote: " << out << std::endl;
       frame_number += 1;
       Display::pop_framebuffer();
     }



From grumbel at mail.berlios.de  Fri Sep  3 00:01:54 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Fri,  3 Sep 2010 00:01:54 +0200
Subject: [Windstille-commit] r3349 - in trunk/windstille/extra/slideshow: .
	plugins
Message-ID: <20100902220154.DB829481019@sheep.berlios.de>

Author: grumbel
Date: 2010-09-03 00:01:54 +0200 (Fri, 03 Sep 2010)
New Revision: 3349

Added:
   trunk/windstille/extra/slideshow/plugins/
   trunk/windstille/extra/slideshow/plugins/file_jpeg_decompressor.cpp
   trunk/windstille/extra/slideshow/plugins/file_jpeg_decompressor.hpp
   trunk/windstille/extra/slideshow/plugins/jpeg.cpp
   trunk/windstille/extra/slideshow/plugins/jpeg.hpp
   trunk/windstille/extra/slideshow/plugins/jpeg_decompressor.cpp
   trunk/windstille/extra/slideshow/plugins/jpeg_decompressor.hpp
   trunk/windstille/extra/slideshow/plugins/jpeg_memory_dest.cpp
   trunk/windstille/extra/slideshow/plugins/jpeg_memory_dest.hpp
   trunk/windstille/extra/slideshow/plugins/jpeg_memory_src.cpp
   trunk/windstille/extra/slideshow/plugins/jpeg_memory_src.hpp
Log:
slideshow: added some JPEG reading code from Galapix

Added: trunk/windstille/extra/slideshow/plugins/file_jpeg_decompressor.cpp
===================================================================
--- trunk/windstille/extra/slideshow/plugins/file_jpeg_decompressor.cpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/plugins/file_jpeg_decompressor.cpp	2010-09-02 22:01:54 UTC (rev 3349)
@@ -0,0 +1,47 @@
+/*
+**  Galapix - an image viewer for large image collections
+**  Copyright (C) 2008 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "file_jpeg_decompressor.hpp"
+
+#include <sstream>
+#include <stdexcept>
+#include <string.h>
+#include <errno.h>
+
+FileJPEGDecompressor::FileJPEGDecompressor(const std::string& filename) :
+  m_filename(filename),
+  m_in(fopen(filename.c_str(), "rb"))
+{
+  if (!m_in)
+  {
+    std::ostringstream out;
+    out << "FileJPEGDecompressor(): " << filename << ": " << strerror(errno);
+    throw std::runtime_error(out.str());
+  }
+  else
+  {
+    jpeg_stdio_src(&m_cinfo, m_in);
+  }
+}
+
+FileJPEGDecompressor::~FileJPEGDecompressor()
+{
+  fclose(m_in);
+}
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/plugins/file_jpeg_decompressor.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/plugins/file_jpeg_decompressor.hpp
===================================================================
--- trunk/windstille/extra/slideshow/plugins/file_jpeg_decompressor.hpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/plugins/file_jpeg_decompressor.hpp	2010-09-02 22:01:54 UTC (rev 3349)
@@ -0,0 +1,44 @@
+/*
+**  Galapix - an image viewer for large image collections
+**  Copyright (C) 2008 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_GALAPIX_PLUGINS_FILE_JPEG_DECOMPRESSOR_HPP
+#define HEADER_GALAPIX_PLUGINS_FILE_JPEG_DECOMPRESSOR_HPP
+
+#include "jpeg_decompressor.hpp"
+
+#include <sstream>
+#include <stdio.h>
+
+class FileJPEGDecompressor : public JPEGDecompressor
+{
+private:
+  std::string m_filename;
+  FILE* m_in;
+
+public:
+  FileJPEGDecompressor(const std::string& filename);
+  ~FileJPEGDecompressor();
+
+private:
+  FileJPEGDecompressor(const FileJPEGDecompressor&);
+  FileJPEGDecompressor& operator=(const FileJPEGDecompressor&);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/plugins/file_jpeg_decompressor.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/plugins/jpeg.cpp
===================================================================
--- trunk/windstille/extra/slideshow/plugins/jpeg.cpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/plugins/jpeg.cpp	2010-09-02 22:01:54 UTC (rev 3349)
@@ -0,0 +1,47 @@
+/*
+**  Galapix - an image viewer for large image collections
+**  Copyright (C) 2008 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <iostream>
+#include <sstream>
+#include <boost/bind.hpp>
+#include <setjmp.h>
+
+#include "math/size.hpp"
+#include "file_jpeg_decompressor.hpp"
+#include "jpeg.hpp"
+#include "util/util.hpp"
+
+bool
+JPEG::filename_is_jpeg(const std::string& filename)
+{
+  // FIXME: Merge this with util/jpeg_software_surface_loader, maybe
+  // store the fileformat/SoftwareSurfaceLoader in the database intead
+  // of figuring out the format each time anew
+  return (has_suffix(filename, "jpg") ||
+          has_suffix(filename, "jpeg"));
+}
+
+Size
+JPEG::get_size(const std::string& filename)
+{
+  FileJPEGDecompressor loader(filename);
+  Size size = loader.read_size();
+  return size;
+}
+  
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/plugins/jpeg.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/plugins/jpeg.hpp
===================================================================
--- trunk/windstille/extra/slideshow/plugins/jpeg.hpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/plugins/jpeg.hpp	2010-09-02 22:01:54 UTC (rev 3349)
@@ -0,0 +1,38 @@
+/*
+**  Galapix - an image viewer for large image collections
+**  Copyright (C) 2008 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_GALAPIX_PLUGINS_JPEG_HPP
+#define HEADER_GALAPIX_PLUGINS_JPEG_HPP
+
+#include <string>
+#include <jpeglib.h>
+
+
+class JPEG
+{
+private:
+
+public:
+  static bool filename_is_jpeg(const std::string& filename);
+
+  static Size get_size(const std::string& filename);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/plugins/jpeg.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/plugins/jpeg_decompressor.cpp
===================================================================
--- trunk/windstille/extra/slideshow/plugins/jpeg_decompressor.cpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/plugins/jpeg_decompressor.cpp	2010-09-02 22:01:54 UTC (rev 3349)
@@ -0,0 +1,70 @@
+/*
+**  Galapix - an image viewer for large image collections
+**  Copyright (C) 2008 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "jpeg_decompressor.hpp"
+
+#include <sstream>
+#include <iostream>
+#include <stdexcept>
+
+void
+JPEGDecompressor::fatal_error_handler(j_common_ptr cinfo)
+{
+  longjmp(reinterpret_cast<ErrorMgr*>(cinfo->err)->setjmp_buffer, 1);
+}
+
+JPEGDecompressor::JPEGDecompressor() :
+  m_cinfo(),
+  m_err()
+{
+  jpeg_std_error(&m_err.pub);
+
+  m_err.pub.error_exit = &JPEGDecompressor::fatal_error_handler;
+
+  m_cinfo.err = &m_err.pub;
+
+  jpeg_create_decompress(&m_cinfo);
+}
+
+JPEGDecompressor::~JPEGDecompressor()
+{
+  jpeg_destroy_decompress(&m_cinfo);
+}
+
+Size
+JPEGDecompressor::read_size()
+{
+  if (setjmp(m_err.setjmp_buffer))
+  {
+    char buffer[JMSG_LENGTH_MAX];
+    (m_cinfo.err->format_message)(reinterpret_cast<jpeg_common_struct*>(&m_cinfo), buffer);
+
+    std::ostringstream out;
+    out << "JPEG::read_size(): " /*<< filename << ": "*/ << buffer;
+    throw std::runtime_error(out.str());
+  }
+  else
+  {
+    jpeg_read_header(&m_cinfo, /*require_image*/ FALSE);
+
+    return Size(m_cinfo.image_width,
+                m_cinfo.image_height);
+  }
+}
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/plugins/jpeg_decompressor.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/plugins/jpeg_decompressor.hpp
===================================================================
--- trunk/windstille/extra/slideshow/plugins/jpeg_decompressor.hpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/plugins/jpeg_decompressor.hpp	2010-09-02 22:01:54 UTC (rev 3349)
@@ -0,0 +1,59 @@
+/*
+**  Galapix - an image viewer for large image collections
+**  Copyright (C) 2008 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_GALAPIX_PLUGINS_JPEG_DECOMPRESSOR_HPP
+#define HEADER_GALAPIX_PLUGINS_JPEG_DECOMPRESSOR_HPP
+
+#include <stdio.h>
+#include <jpeglib.h>
+#include <setjmp.h>
+
+#include "math/size.hpp"
+
+class JPEGDecompressor
+{
+protected:
+  struct ErrorMgr 
+  {
+    struct jpeg_error_mgr pub;
+    jmp_buf setjmp_buffer;
+  };
+
+protected:
+  struct jpeg_decompress_struct  m_cinfo;
+  struct ErrorMgr m_err;
+
+protected:
+  JPEGDecompressor();
+
+public:
+  virtual ~JPEGDecompressor();
+  
+  Size read_size();
+
+private:
+  static void fatal_error_handler(j_common_ptr cinfo);
+  
+private:
+  JPEGDecompressor(const JPEGDecompressor&);
+  JPEGDecompressor& operator=(const JPEGDecompressor&);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/plugins/jpeg_decompressor.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/plugins/jpeg_memory_dest.cpp
===================================================================
--- trunk/windstille/extra/slideshow/plugins/jpeg_memory_dest.cpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/plugins/jpeg_memory_dest.cpp	2010-09-02 22:01:54 UTC (rev 3349)
@@ -0,0 +1,84 @@
+/*
+**  Galapix - an image viewer for large image collections
+**  Copyright (C) 2008 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "jpeg_memory_dest.hpp"
+
+#define OUTPUT_BUF_SIZE 4096
+
+struct jpeg_memory_destination_mgr 
+{
+  struct jpeg_destination_mgr pub;
+
+  JOCTET buffer[OUTPUT_BUF_SIZE];
+  std::vector<uint8_t>* data;
+};
+
+void jpeg_memory_init_destination(j_compress_ptr cinfo)
+{
+  struct jpeg_memory_destination_mgr* mgr = (struct jpeg_memory_destination_mgr*)cinfo->dest;
+
+  cinfo->dest->next_output_byte = mgr->buffer;
+  cinfo->dest->free_in_buffer   = OUTPUT_BUF_SIZE;
+}
+
+boolean jpeg_memory_empty_output_buffer(j_compress_ptr cinfo)
+{
+  struct jpeg_memory_destination_mgr* mgr = (struct jpeg_memory_destination_mgr*)cinfo->dest;
+  
+  // This function always gets OUTPUT_BUF_SIZE bytes,
+  // cinfo->dest->free_in_buffer *must* be ignored
+  for(size_t i = 0; i < OUTPUT_BUF_SIZE; ++i) 
+  { // FIXME: Little slow maybe?
+    mgr->data->push_back(mgr->buffer[i]);
+  }
+
+  cinfo->dest->next_output_byte = mgr->buffer;
+  cinfo->dest->free_in_buffer   = OUTPUT_BUF_SIZE;
+
+  return TRUE;
+}
+
+void jpeg_memory_term_destination(j_compress_ptr cinfo)
+{
+  struct jpeg_memory_destination_mgr* mgr = (struct jpeg_memory_destination_mgr*)cinfo->dest;
+  size_t datacount = OUTPUT_BUF_SIZE - cinfo->dest->free_in_buffer;
+
+  for(size_t i = 0; i < datacount; ++i)
+  { // FIXME: Little slow maybe?
+    mgr->data->push_back(mgr->buffer[i]);
+  }
+}
+
+void jpeg_memory_dest(j_compress_ptr cinfo, std::vector<uint8_t>* data)
+{
+  if (cinfo->dest == NULL) 
+  {     /* first time for this JPEG object? */
+    cinfo->dest = (struct jpeg_destination_mgr*)
+      (*cinfo->mem->alloc_small)((j_common_ptr) cinfo, JPOOL_PERMANENT,
+                                 sizeof(struct jpeg_memory_destination_mgr));
+  }
+
+  cinfo->dest->init_destination    = jpeg_memory_init_destination;
+  cinfo->dest->empty_output_buffer = jpeg_memory_empty_output_buffer;
+  cinfo->dest->term_destination    = jpeg_memory_term_destination;
+
+  struct jpeg_memory_destination_mgr* mgr = (struct jpeg_memory_destination_mgr*)cinfo->dest;
+  mgr->data = data;
+}
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/plugins/jpeg_memory_dest.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/plugins/jpeg_memory_dest.hpp
===================================================================
--- trunk/windstille/extra/slideshow/plugins/jpeg_memory_dest.hpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/plugins/jpeg_memory_dest.hpp	2010-09-02 22:01:54 UTC (rev 3349)
@@ -0,0 +1,31 @@
+/*
+**  Galapix - an image viewer for large image collections
+**  Copyright (C) 2008 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_GALAPIX_PLUGINS_JPEG_MEMORY_DEST_HPP
+#define HEADER_GALAPIX_PLUGINS_JPEG_MEMORY_DEST_HPP
+
+#include <vector>
+#include <stdint.h>
+#include <stdio.h>
+#include <jpeglib.h>
+
+void jpeg_memory_dest(j_compress_ptr cinfo, std::vector<uint8_t>* data);
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/plugins/jpeg_memory_dest.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/plugins/jpeg_memory_src.cpp
===================================================================
--- trunk/windstille/extra/slideshow/plugins/jpeg_memory_src.cpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/plugins/jpeg_memory_src.cpp	2010-09-02 22:01:54 UTC (rev 3349)
@@ -0,0 +1,97 @@
+/*
+**  Galapix - an image viewer for large image collections
+**  Copyright (C) 2008 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "jpeg_memory_src.hpp"
+
+#include <jerror.h>
+
+struct jpeg_memory_source_mgr {
+  struct jpeg_source_mgr pub;   /* public fields */
+
+  const uint8_t* data;
+  int      len;
+};
+
+void jpeg_memory_init_source(j_decompress_ptr cinfo)
+{
+  cinfo->src->next_input_byte = NULL;
+  cinfo->src->bytes_in_buffer = 0;
+}
+
+void jpeg_memory_term_source(j_decompress_ptr)
+{
+  // nothing to do destruct the source
+}
+
+boolean jpeg_memory_fill_input_buffer(j_decompress_ptr cinfo)
+{
+  if (cinfo->src->next_input_byte != NULL)
+  {
+    (cinfo)->err->msg_code = JERR_INPUT_EOF;
+    (*(cinfo)->err->error_exit)((j_common_ptr) (cinfo));
+    return FALSE;
+  }
+  else
+  {
+    struct jpeg_memory_source_mgr* mgr = (struct jpeg_memory_source_mgr*)(cinfo->src);
+  
+    cinfo->src->next_input_byte = mgr->data;
+    cinfo->src->bytes_in_buffer = mgr->len;
+
+    return TRUE;
+  }
+}
+
+void jpeg_memory_skip_input_data(j_decompress_ptr cinfo, long num_bytes)
+{
+  cinfo->src->next_input_byte = cinfo->src->next_input_byte + num_bytes;
+  cinfo->src->bytes_in_buffer = cinfo->src->bytes_in_buffer - num_bytes;
+
+  struct jpeg_memory_source_mgr* mgr = (struct jpeg_memory_source_mgr*)(cinfo->src);
+
+  if (cinfo->src->next_input_byte >= &mgr->data[mgr->len])
+  {
+    (cinfo)->err->msg_code = JERR_INPUT_EOF;
+    (*(cinfo)->err->error_exit)((j_common_ptr) (cinfo));
+  }
+}
+
+void jpeg_memory_src(j_decompress_ptr cinfo, const uint8_t* data, int len)
+{
+  if (cinfo->src == NULL) 
+  {
+    cinfo->src = (struct jpeg_source_mgr*)((*cinfo->mem->alloc_small)((j_common_ptr)cinfo, 
+                                                                      JPOOL_PERMANENT,
+                                                                      sizeof(struct jpeg_memory_source_mgr)));
+  }
+  
+  cinfo->src->init_source       = jpeg_memory_init_source;
+  cinfo->src->fill_input_buffer = jpeg_memory_fill_input_buffer;
+  cinfo->src->skip_input_data   = jpeg_memory_skip_input_data;
+  cinfo->src->resync_to_restart = jpeg_resync_to_restart; /* use default method */
+  cinfo->src->term_source       = jpeg_memory_term_source;
+
+  cinfo->src->bytes_in_buffer = 0; /* forces fill_input_buffer on first read */
+  cinfo->src->next_input_byte = NULL; /* until buffer loaded */
+
+  struct jpeg_memory_source_mgr* mgr = (struct jpeg_memory_source_mgr*)(cinfo->src);
+  mgr->data = data;
+  mgr->len  = len;
+}
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/plugins/jpeg_memory_src.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/plugins/jpeg_memory_src.hpp
===================================================================
--- trunk/windstille/extra/slideshow/plugins/jpeg_memory_src.hpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/plugins/jpeg_memory_src.hpp	2010-09-02 22:01:54 UTC (rev 3349)
@@ -0,0 +1,31 @@
+/*
+**  Galapix - an image viewer for large image collections
+**  Copyright (C) 2008 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_GALAPIX_PLUGINS_JPEG_MEMORY_SRC_HPP
+#define HEADER_GALAPIX_PLUGINS_JPEG_MEMORY_SRC_HPP
+
+#include <stdint.h>
+#include <stdio.h>
+#include <jpeglib.h>
+
+/** Setup IO handling so that a JPEG can be read from memory */
+void jpeg_memory_src(j_decompress_ptr cinfo, const uint8_t* data, int len);
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/plugins/jpeg_memory_src.hpp
___________________________________________________________________
Added: svn:eol-style
   + native



From grumbel at mail.berlios.de  Fri Sep  3 00:03:48 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Fri,  3 Sep 2010 00:03:48 +0200
Subject: [Windstille-commit] r3350 - trunk/windstille/extra/slideshow
Message-ID: <20100902220348.51D08481019@sheep.berlios.de>

Author: grumbel
Date: 2010-09-03 00:03:48 +0200 (Fri, 03 Sep 2010)
New Revision: 3350

Modified:
   trunk/windstille/extra/slideshow/slide_object.cpp
   trunk/windstille/extra/slideshow/slide_object.hpp
Log:
slideshow: added on-demand loading

Modified: trunk/windstille/extra/slideshow/slide_object.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_object.cpp	2010-09-02 22:01:54 UTC (rev 3349)
+++ trunk/windstille/extra/slideshow/slide_object.cpp	2010-09-02 22:03:48 UTC (rev 3350)
@@ -20,15 +20,19 @@
 
 #include <math.h>
 
+#include "plugins/jpeg.hpp"
 #include "display/surface_drawing_parameters.hpp"
 
 SlideObject::SlideObject(const Pathname& filename) :
-  m_surface(filename),
+  m_filename(filename),
+  m_size(0.0f, 0.0f),
+  m_surface(),
   m_begin(0.0f),
   m_path(),
   m_fade_in_time(0.0f),
   m_fade_out_time(0.0f)
 {  
+  m_size = JPEG::get_size(filename.get_sys_path());
 }
 
 void
@@ -46,6 +50,11 @@
 void
 SlideObject::draw(float relative_time)
 {
+  if (!m_surface)
+  {
+    m_surface = Surface(m_filename);
+  }
+
   SlidePathNode node = m_path.get(relative_time);
 
   // FIXME: hardcoded fade hack
@@ -87,6 +96,12 @@
   return m_begin;
 }
 
+float
+SlideObject::end() const
+{
+  return begin() + length();
+}
+
 void
 SlideObject::set_begin(float beg)
 {
@@ -96,13 +111,34 @@
 float
 SlideObject::get_width() const
 {
-  return m_surface.get_width();
+  return m_size.width;
 }
 
 float
 SlideObject::get_height() const
 {
-  return m_surface.get_height();
+  return m_size.height;
 }
 
+Pathname 
+SlideObject::get_filename() const
+{
+  return m_filename;
+}
+
+bool
+SlideObject::unload()
+{
+  if (m_surface)
+  {
+    m_surface = Surface();
+    std::cout << "Unloading: " << m_filename.get_sys_path() << std::endl;
+    return true;
+  }
+  else
+  {
+    return false;
+  }
+}
+
 /* EOF */

Modified: trunk/windstille/extra/slideshow/slide_object.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_object.hpp	2010-09-02 22:01:54 UTC (rev 3349)
+++ trunk/windstille/extra/slideshow/slide_object.hpp	2010-09-02 22:03:48 UTC (rev 3350)
@@ -28,6 +28,8 @@
 class SlideObject
 {
 private:
+  Pathname m_filename;
+  Sizef m_size;
   Surface m_surface;
   float m_begin;
   SlidePath m_path;
@@ -42,6 +44,8 @@
 
   float length() const;
   float begin() const;
+  float end() const;
+
   void set_begin(float beg);
   void set_fade_in(float f);
   void set_fade_out(float f);
@@ -51,6 +55,10 @@
   float get_width() const;
   float get_height() const;
 
+  Pathname get_filename() const;
+
+  bool unload();
+
 private:
   SlideObject(const SlideObject&);
   SlideObject& operator=(const SlideObject&);



From grumbel at mail.berlios.de  Fri Sep  3 00:04:16 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Fri,  3 Sep 2010 00:04:16 +0200
Subject: [Windstille-commit] r3351 - trunk/windstille/extra/slideshow
Message-ID: <20100902220416.1473B481019@sheep.berlios.de>

Author: grumbel
Date: 2010-09-03 00:04:15 +0200 (Fri, 03 Sep 2010)
New Revision: 3351

Modified:
   trunk/windstille/extra/slideshow/slide_builder.cpp
   trunk/windstille/extra/slideshow/slide_builder.hpp
Log:
slideshow: added pos given in percent

Modified: trunk/windstille/extra/slideshow/slide_builder.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.cpp	2010-09-02 22:03:48 UTC (rev 3350)
+++ trunk/windstille/extra/slideshow/slide_builder.cpp	2010-09-02 22:04:15 UTC (rev 3351)
@@ -32,6 +32,7 @@
 float
 NodePosX::get(const Sizef& scr, const Sizef& img, float zoom) const
 {
+  // FIXME: Warning img is already multiplied by zoom
   switch(m_type)
   {
     case kNodePosXLeft:
@@ -43,11 +44,17 @@
     case kNodePosXCenter:
       return scr.width/2;
 
-    case kNodePosXFloat:
+    case kNodePosXAbsFloat:
       {
         float x = m_value * zoom;
         return img.width/2.0f - x + scr.width/2.0f;
       }
+
+    case kNodePosXRelFloat:
+      {
+        float x = (m_value/100.0f) * img.width;
+        return img.width/2.0f - x + scr.width/2.0f;
+      }
   }
 
   assert(!"never reached");
@@ -56,6 +63,7 @@
 float
 NodePosY::get(const Sizef& scr, const Sizef& img, float zoom) const
 {
+  // FIXME: Warning img is already multiplied by zoom
   switch(m_type)
   {
     case kNodePosYTop:
@@ -67,11 +75,17 @@
     case kNodePosYCenter:
       return scr.height/2;
       
-    case kNodePosYFloat:
+    case kNodePosYAbsFloat:
       {
         float y = m_value * zoom;
         return img.height/2.0f - y + scr.height/2.0f;
       }
+      
+    case kNodePosYRelFloat:
+      {
+        float y = (m_value/100.0f) * img.height;
+        return img.height/2.0f - y + scr.height/2.0f;
+      }
   }
 
   assert(!"never reached");
@@ -135,7 +149,9 @@
   std::ifstream in(filename.c_str());
   if (!in)
   {
-    throw std::runtime_error(strerror(errno));
+    std::ostringstream str;
+    str << filename << ": " << strerror(errno);
+    throw std::runtime_error(str.str());
   }
   else
   {
@@ -153,7 +169,7 @@
 }
 
 void
-SlideBuilder::error(const std::string& str)
+SlideBuilder::error(const std::string& str) const
 {
   std::ostringstream out;
   out << m_context << ':' << m_line << ": error: " << str;
@@ -171,9 +187,7 @@
       m_line += 1;
       line = strip_comment(line);
 
-      boost::char_separator<char> sep(" \t");
-      boost::tokenizer<boost::char_separator<char> > tokens(line, sep);
-      std::vector<std::string> args(tokens.begin(), tokens.end());
+      std::vector<std::string> args = tokenize(line);
 
       if (args.empty())
       {
@@ -338,14 +352,22 @@
     }
     else if (args[1] == "prev")
     {
-      // reuse previous value      
+      // reuse previous value
     }
     else
     {
       //float x = boost::lexical_cast<float>(args[1]) * m_path_node.zoom;
       //m_path_node.pos.x = img_w/2.0f - x + scr_w/2.0f;
-
-      m_node.pos_x = NodePosX(NodePosX::kNodePosXFloat, boost::lexical_cast<float>(args[1]));
+      if (args[1][args[1].length()-1] == '%')
+      {
+        m_node.pos_x = NodePosX(NodePosX::kNodePosXRelFloat, 
+                                boost::lexical_cast<float>(args[1].substr(0, args[1].length()-1)));
+      }
+      else
+      {
+        m_node.pos_x = NodePosX(NodePosX::kNodePosXAbsFloat, 
+                                boost::lexical_cast<float>(args[1]));
+      }
     }
 
     if (args[2] == "top")
@@ -371,7 +393,16 @@
     {
       //float y = boost::lexical_cast<float>(args[2]) * m_path_node.zoom;
       //m_path_node.pos.y = img_h/2.0f - y + scr_h/2.0f;
-      m_node.pos_y = NodePosY(NodePosY::kNodePosYFloat, boost::lexical_cast<float>(args[2]));
+      if (args[2][args[2].length()-1] == '%')
+      {
+        m_node.pos_y = NodePosY(NodePosY::kNodePosYRelFloat, 
+                                boost::lexical_cast<float>(args[2].substr(0, args[2].length()-1)));
+      }
+      else
+      {
+        m_node.pos_y = NodePosY(NodePosY::kNodePosYAbsFloat, 
+                                boost::lexical_cast<float>(args[2]));
+      }
     }
 
     //std::cout << "  (pos " << m_path_node.pos.x << " " << m_path_node.pos.y << ")" << std::endl;
@@ -558,4 +589,62 @@
   }
 }
 
+std::vector<std::string>
+SlideBuilder::tokenize(const std::string& line) const
+{
+  if (true)
+  {
+    boost::char_separator<char> sep(" \t");
+    boost::tokenizer<boost::char_separator<char> > tokens(line, sep);
+    std::vector<std::string> lst(tokens.begin(), tokens.end());
+    return lst;
+  }
+  else
+  {
+    //enum { kWhitespace, kString } state;
+
+    std::vector<std::string> lst;  
+    std::ostringstream str;
+    std::string::const_iterator i = line.begin();
+
+    while(i != line.end())
+    {
+    
+      if (*i == ' ' || *i == '\t')
+      {
+      
+      }
+      else if (*i == '\\')
+      {
+        ++i;
+        if (i != line.end())
+        {
+          switch(*i)
+          {
+            case '\\': str << '\\'; break;
+            case '0': str << '\0'; break;
+            case 'a': str << '\a'; break;
+            case 'b': str << '\b'; break;
+            case 't': str << '\t'; break;
+            case 'r': str << '\r'; break;
+            case 'n': str << '\n'; break;
+            default: str << '\\' << *i; break;
+          }
+        }
+        else
+        {
+          error("couldn't tokenize line");
+        }
+      }
+      else
+      {
+      }
+
+      ++i;
+    }
+  
+    return lst;
+  }
+}
+
 /* EOF */

Modified: trunk/windstille/extra/slideshow/slide_builder.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.hpp	2010-09-02 22:03:48 UTC (rev 3350)
+++ trunk/windstille/extra/slideshow/slide_builder.hpp	2010-09-02 22:04:15 UTC (rev 3351)
@@ -37,7 +37,8 @@
     kNodePosXLeft,
     kNodePosXRight,
     kNodePosXCenter,
-    kNodePosXFloat
+    kNodePosXAbsFloat,
+    kNodePosXRelFloat
   };
   
 public:
@@ -66,7 +67,8 @@
     kNodePosYTop,
     kNodePosYBottom,
     kNodePosYCenter,
-    kNodePosYFloat
+    kNodePosYAbsFloat,
+    kNodePosYRelFloat
   };
   
 public:
@@ -168,7 +170,7 @@
   void load_from_stream(std::istream& stream);
 
 private:
-  void error(const std::string& str);
+  void error(const std::string& str) const;
 
   void handle_image(const std::vector<std::string>& args);
   void handle_pos(const std::vector<std::string>& args);
@@ -182,6 +184,8 @@
 
   void add_node();
 
+  std::vector<std::string> tokenize(const std::string& str) const;
+
 private:
   SlideBuilder(const SlideBuilder&);
   SlideBuilder& operator=(const SlideBuilder&);



From grumbel at mail.berlios.de  Fri Sep  3 00:05:00 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Fri,  3 Sep 2010 00:05:00 +0200
Subject: [Windstille-commit] r3352 - trunk/windstille/extra/slideshow
Message-ID: <20100902220500.85350481019@sheep.berlios.de>

Author: grumbel
Date: 2010-09-03 00:05:00 +0200 (Fri, 03 Sep 2010)
New Revision: 3352

Modified:
   trunk/windstille/extra/slideshow/slide_show.cpp
   trunk/windstille/extra/slideshow/slide_show.hpp
   trunk/windstille/extra/slideshow/slideshow.cpp
   trunk/windstille/extra/slideshow/slideshow.hpp
Log:
slideshow: unload unused surfaces, -S option to give the start frame for offline rendering

Modified: trunk/windstille/extra/slideshow/slide_show.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_show.cpp	2010-09-02 22:04:15 UTC (rev 3351)
+++ trunk/windstille/extra/slideshow/slide_show.cpp	2010-09-02 22:05:00 UTC (rev 3352)
@@ -18,6 +18,8 @@
 
 #include "slideshow/slide_show.hpp"
 
+#include "display/surface_manager.hpp"
+#include "display/texture_manager.hpp"
 #include "slideshow/slide_builder.hpp"
 
 SlideShow::SlideShow() :
@@ -27,8 +29,10 @@
 }
 
 void
-SlideShow::draw(float time)
+SlideShow::draw(float time, bool verbose)
 {
+  bool cleanup = false;
+
   for(std::vector<SlideObjectPtr>::iterator i = m_objects.begin(); i != m_objects.end(); ++i)
   {
     SlideObjectPtr& obj = *i;
@@ -41,9 +45,27 @@
       // active object
       float relative_time = time - obj->begin();
       //std::cout << time << " " << relative_time << std::endl;
+      if (verbose)
+      {
+        std::cout << obj->get_filename().get_sys_path() << std::endl;
+      }
+
       obj->draw(relative_time);
     }
+    else if (time < obj->begin()-60.0f || obj->end()+60.0f < time)
+    { // unload anything that 60 seconds away from the current time pos
+      if (obj->unload())
+      {
+        cleanup = true;
+      }
+    }
   }
+
+  if (cleanup)
+  {
+    SurfaceManager::current()->cleanup();
+    TextureManager::current()->cleanup();
+  }
 }
 
 void

Modified: trunk/windstille/extra/slideshow/slide_show.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_show.hpp	2010-09-02 22:04:15 UTC (rev 3351)
+++ trunk/windstille/extra/slideshow/slide_show.hpp	2010-09-02 22:05:00 UTC (rev 3352)
@@ -32,7 +32,7 @@
 public:
   SlideShow();
 
-  void draw(float time);
+  void draw(float time, bool verbose);
 
   bool done(float time) const;
 

Modified: trunk/windstille/extra/slideshow/slideshow.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slideshow.cpp	2010-09-02 22:04:15 UTC (rev 3351)
+++ trunk/windstille/extra/slideshow/slideshow.cpp	2010-09-02 22:05:00 UTC (rev 3352)
@@ -45,7 +45,8 @@
   m_output_dir(),
   m_fps(25.0f),
   m_edit_mode(false),
-  m_start_time(0.0f)
+  m_start_time(0.0f),
+  m_start_frame(-1)
 {
 }
 
@@ -83,6 +84,7 @@
   argp.add_option('F', "fps", "FPS", "Generate FPS frames per seconds");
   argp.add_option('o', "output", "DIR", "Write screenshots to DIR");
   argp.add_option('s', "start", "SEC", "Time where the playback should start");
+  argp.add_option('S', "frame", "FRAME", "Frame at which offline rendering should start");
   argp.add_option('h', "help", "", "Print help");
 
   argp.parse_args(argc, argv);
@@ -95,6 +97,10 @@
         m_fullscreen = true;
         break;
 
+      case 'S':
+        m_start_frame = boost::lexical_cast<int>(argp.get_argument());
+        break;
+
       case 'e':
         m_edit_mode = true;
         break;
@@ -173,10 +179,19 @@
   bool loop = true;
   bool pause = false;
 
+  int last_percent_complete = -1;
+
   int frame_number = 0;
   Uint32 last_ticks = SDL_GetTicks();
   float time = m_start_time;
   bool fast_forward = false;
+
+  if (m_start_frame != -1)
+  {
+    frame_number = m_start_frame;
+    time = static_cast<float>(frame_number) / m_fps;
+  }
+
   while(loop && (!slide_show.done(time) || m_edit_mode))
   {
     SDL_Event event;
@@ -281,7 +296,7 @@
       glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 
-      slide_show.draw(time);
+      slide_show.draw(time, m_edit_mode);
 
       SDL_GL_SwapBuffers();
 
@@ -295,7 +310,7 @@
       Display::push_framebuffer(framebuffer);
       glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-      slide_show.draw(time);
+      slide_show.draw(time, m_edit_mode);
       //SDL_GL_SwapBuffers();
 
       char out[1024];
@@ -304,6 +319,13 @@
       //std::cout << "Wrote: " << out << std::endl;
       frame_number += 1;
       Display::pop_framebuffer();
+
+      int percent = static_cast<int>(time / slide_show.length() * 100.0f);
+      if (percent != last_percent_complete)
+      {
+        std::cout << "Completed: " << percent << "% - " << frame_number << std::endl;
+        last_percent_complete = percent;
+      }
     }
 
     if (m_edit_mode)

Modified: trunk/windstille/extra/slideshow/slideshow.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slideshow.hpp	2010-09-02 22:04:15 UTC (rev 3351)
+++ trunk/windstille/extra/slideshow/slideshow.hpp	2010-09-02 22:05:00 UTC (rev 3352)
@@ -34,6 +34,7 @@
   float m_fps;
   bool m_edit_mode;
   float m_start_time;
+  int m_start_frame;
 
 public:
   App();



From grumbel at mail.berlios.de  Fri Sep  3 00:05:52 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Fri,  3 Sep 2010 00:05:52 +0200
Subject: [Windstille-commit] r3353 - trunk/windstille/src/display
Message-ID: <20100902220552.97A8D481019@sheep.berlios.de>

Author: grumbel
Date: 2010-09-03 00:05:52 +0200 (Fri, 03 Sep 2010)
New Revision: 3353

Modified:
   trunk/windstille/src/display/opengl_window.cpp
Log:
removed debug output

Modified: trunk/windstille/src/display/opengl_window.cpp
===================================================================
--- trunk/windstille/src/display/opengl_window.cpp	2010-09-02 22:05:00 UTC (rev 3352)
+++ trunk/windstille/src/display/opengl_window.cpp	2010-09-02 22:05:52 UTC (rev 3353)
@@ -79,7 +79,7 @@
     }
     else
     {
-      std::cout << "glewInit() successfull" << std::endl;
+      //std::cout << "glewInit() successfull" << std::endl;
 
       glViewport(0, 0, m_impl->m_window->w, m_impl->m_window->h);
       glMatrixMode(GL_PROJECTION);



From grumbel at mail.berlios.de  Fri Sep  3 00:06:33 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Fri,  3 Sep 2010 00:06:33 +0200
Subject: [Windstille-commit] r3354 - trunk/windstille/src/display
Message-ID: <20100902220633.D8A15481019@sheep.berlios.de>

Author: grumbel
Date: 2010-09-03 00:06:33 +0200 (Fri, 03 Sep 2010)
New Revision: 3354

Modified:
   trunk/windstille/src/display/surface_manager.cpp
   trunk/windstille/src/display/texture.cpp
   trunk/windstille/src/display/texture.hpp
   trunk/windstille/src/display/texture_manager.cpp
   trunk/windstille/src/display/texture_manager.hpp
Log:
some code for unloading textures and surfaces, doesn't properly work yet

Modified: trunk/windstille/src/display/surface_manager.cpp
===================================================================
--- trunk/windstille/src/display/surface_manager.cpp	2010-09-02 22:05:52 UTC (rev 3353)
+++ trunk/windstille/src/display/surface_manager.cpp	2010-09-02 22:06:33 UTC (rev 3354)
@@ -151,10 +151,12 @@
 void
 SurfaceManager::cleanup()
 {
+  std::cout << "SurfaceManager: size: " << surfaces.size() << std::endl;
   for(Surfaces::iterator i = surfaces.begin(); i != surfaces.end(); ++i)
   {
     if (i->second.use_count() == 1)
     {
+      std::cout << "SurfaceManager: erasing a surface" << std::endl;
       surfaces.erase(i);
     }
   }

Modified: trunk/windstille/src/display/texture.cpp
===================================================================
--- trunk/windstille/src/display/texture.cpp	2010-09-02 22:05:52 UTC (rev 3353)
+++ trunk/windstille/src/display/texture.cpp	2010-09-02 22:06:33 UTC (rev 3354)
@@ -292,5 +292,11 @@
 {
   return impl->target;
 }
+
+int
+Texture::use_count() const
+{
+  return impl.use_count();
+}
 
 /* EOF */

Modified: trunk/windstille/src/display/texture.hpp
===================================================================
--- trunk/windstille/src/display/texture.hpp	2010-09-02 22:05:52 UTC (rev 3353)
+++ trunk/windstille/src/display/texture.hpp	2010-09-02 22:06:33 UTC (rev 3354)
@@ -83,6 +83,8 @@
 
   SoftwareSurface get_software_surface() const;
 
+  int use_count() const;
+
   /** true if the Texture is valid and usable, false if not */
   operator bool() const;
 

Modified: trunk/windstille/src/display/texture_manager.cpp
===================================================================
--- trunk/windstille/src/display/texture_manager.cpp	2010-09-02 22:05:52 UTC (rev 3353)
+++ trunk/windstille/src/display/texture_manager.cpp	2010-09-02 22:06:33 UTC (rev 3354)
@@ -65,4 +65,19 @@
   }
 }
 
+void
+TextureManager::cleanup()
+{
+  std::cout << "TextureManager: size: " << textures.size() << std::endl;
+  for(Textures::iterator i = textures.begin(); i != textures.end(); ++i)
+  {
+    std::cout << "TextureManager: use count: " << i->second.use_count() << std::endl;
+    if (i->second.use_count() == 1)
+    {
+      std::cout << "TextureManager: erasing a texture" << std::endl;
+      textures.erase(i);
+    }
+  }
+}
+
 /* EOF */

Modified: trunk/windstille/src/display/texture_manager.hpp
===================================================================
--- trunk/windstille/src/display/texture_manager.hpp	2010-09-02 22:05:52 UTC (rev 3353)
+++ trunk/windstille/src/display/texture_manager.hpp	2010-09-02 22:06:33 UTC (rev 3354)
@@ -48,6 +48,8 @@
    */
   Texture get(const Pathname& filename);
 
+  void cleanup();
+
 private:
   typedef std::map<Pathname, Texture> Textures;
   Textures textures;



From grumbel at mail.berlios.de  Wed Sep  8 11:30:19 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed,  8 Sep 2010 11:30:19 +0200
Subject: [Windstille-commit] r3355 - trunk/windstille/src/display
Message-ID: <20100908093019.8A7EB48101F@sheep.berlios.de>

Author: grumbel
Date: 2010-09-08 11:30:19 +0200 (Wed, 08 Sep 2010)
New Revision: 3355

Modified:
   trunk/windstille/src/display/software_surface.cpp
Log:
Fixed memleak

Modified: trunk/windstille/src/display/software_surface.cpp
===================================================================
--- trunk/windstille/src/display/software_surface.cpp	2010-09-02 22:06:33 UTC (rev 3354)
+++ trunk/windstille/src/display/software_surface.cpp	2010-09-08 09:30:19 UTC (rev 3355)
@@ -73,6 +73,10 @@
 
 SoftwareSurface::~SoftwareSurface()
 {
+  if (impl)
+  {
+    SDL_FreeSurface(impl->surface);
+  }
 }
 
 int



From grumbel at mail.berlios.de  Wed Sep  8 11:32:15 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed,  8 Sep 2010 11:32:15 +0200
Subject: [Windstille-commit] r3356 - trunk/windstille/src/display
Message-ID: <20100908093215.CD3CE48101F@sheep.berlios.de>

Author: grumbel
Date: 2010-09-08 11:32:15 +0200 (Wed, 08 Sep 2010)
New Revision: 3356

Modified:
   trunk/windstille/src/display/display.cpp
   trunk/windstille/src/display/framebuffer.cpp
   trunk/windstille/src/display/framebuffer.hpp
   trunk/windstille/src/display/render_buffer.cpp
   trunk/windstille/src/display/render_buffer.hpp
Log:
Implemented anti-aliasing for the Framebuffer (currently breaks render-to-texture)

Modified: trunk/windstille/src/display/display.cpp
===================================================================
--- trunk/windstille/src/display/display.cpp	2010-09-08 09:30:19 UTC (rev 3355)
+++ trunk/windstille/src/display/display.cpp	2010-09-08 09:32:15 UTC (rev 3356)
@@ -32,6 +32,7 @@
 #include "math/quad.hpp"
 #include "math/line.hpp"
 #include "display/opengl_state.hpp"
+#include "display/assert_gl.hpp"
 
 Size              Display::aspect_size;
 std::vector<Rect> Display::cliprects;
@@ -480,6 +481,7 @@
   boost::scoped_array<GLbyte> pixels(new GLbyte[len]);
   glPixelStorei(GL_PACK_ALIGNMENT, 1);
   glReadPixels(0, 0, size.width, size.height, GL_RGB, GL_UNSIGNED_BYTE, pixels.get());
+  assert_gl("Display::save_screenshot()");
 
   if (false)
   { // PPM saving
@@ -527,7 +529,7 @@
       m_cinfo.in_color_space   = JCS_RGB;   /* colorspace of input image */
 
       jpeg_set_defaults(&m_cinfo);
-      //jpeg_set_quality(&m_cinfo, quality, TRUE /* limit to baseline-JPEG values */);
+      //jpeg_set_quality(&m_cinfo, 100, TRUE /* limit to baseline-JPEG values */);
  
       jpeg_start_compress(&m_cinfo, TRUE);
 
@@ -551,7 +553,7 @@
       fclose(m_out);
     }
   }
-  else 
+  else if (false)
   { // PNG saving
     FILE* fp = fopen(filename.get_sys_path().c_str(), "w");
 

Modified: trunk/windstille/src/display/framebuffer.cpp
===================================================================
--- trunk/windstille/src/display/framebuffer.cpp	2010-09-08 09:30:19 UTC (rev 3355)
+++ trunk/windstille/src/display/framebuffer.cpp	2010-09-08 09:32:15 UTC (rev 3356)
@@ -18,6 +18,7 @@
 
 #include <GL/glew.h>
 
+#include "math/size.hpp"
 #include "util/util.hpp"
 #include "display/render_buffer.hpp"
 #include "display/framebuffer.hpp"
@@ -27,14 +28,19 @@
 {
 public:
   GLuint  handle;
-  Texture texture;
+  Size size;
+  
+  //Texture texture;
+  RenderBuffer m_color_buffer;
   RenderBuffer m_depth_stencil_buffer;
   //RenderBuffer m_stencil_buffer;
 
-  FramebufferImpl(GLenum target, int width, int height)
-    : handle(0),
-      texture(target, width, height),
-      m_depth_stencil_buffer(GL_DEPTH24_STENCIL8_EXT, width, height)
+  FramebufferImpl(GLenum target, int width, int height, int multisample) : 
+    handle(0),
+    size(width, height),
+    //texture(target, width, height),
+    m_color_buffer(GL_RGB8, width, height, multisample), // FIXME: do we need RGBA or just RGB?!
+    m_depth_stencil_buffer(GL_DEPTH24_STENCIL8_EXT, width, height, multisample)
   {
     glGenFramebuffersEXT(1, &handle);
     assert_gl("FramebufferImpl::FramebufferImpl()");
@@ -43,13 +49,26 @@
     glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, handle);
 
     // bind texture and renderbuffers to the framebuffer
-    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
-                              texture.get_target(), texture.get_handle(), 0);  
-    glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, 
-                                 GL_RENDERBUFFER_EXT, m_depth_stencil_buffer.get_handle());
-    glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT, 
-                                 GL_RENDERBUFFER_EXT, m_depth_stencil_buffer.get_handle());
+    //glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, texture.get_target(), texture.get_handle(), 0);
+
+    glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,  GL_RENDERBUFFER_EXT, m_color_buffer.get_handle());
+    glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,   GL_RENDERBUFFER_EXT, m_depth_stencil_buffer.get_handle());
+    glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, m_depth_stencil_buffer.get_handle());
+
     assert_gl("FramebufferImpl::FramebufferImpl() - binding");
+
+
+    GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+    switch(status)
+    {
+      case GL_FRAMEBUFFER_COMPLETE_EXT:
+        std::cout << "Framebuffer ok" << std::endl;
+        break;
+
+      default:
+        std::cout << "Framebuffer status failure: " << status << std::endl;
+        break;
+    }
     glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
   }
 
@@ -64,8 +83,8 @@
 {
 }
 
-Framebuffer::Framebuffer(GLenum target, int width, int height) :
-  impl(new FramebufferImpl(target, width, height))
+Framebuffer::Framebuffer(GLenum target, int width, int height, int multisample) :
+  impl(new FramebufferImpl(target, width, height, multisample))
 {  
 }
 
@@ -77,19 +96,21 @@
 Texture
 Framebuffer::get_texture()
 {
-  return impl->texture;
+  assert(!"not implemented right now - Framebuffer::get_texture()");
+  return Texture();
+  //return impl->texture;
 }
 
 int
 Framebuffer::get_width()  const
 {
-  return impl->texture.get_width();
+  return impl->size.width;
 }
 
 int
 Framebuffer::get_height() const
 {
-  return impl->texture.get_height();
+  return impl->size.height;
 }
 
 GLuint

Modified: trunk/windstille/src/display/framebuffer.hpp
===================================================================
--- trunk/windstille/src/display/framebuffer.hpp	2010-09-08 09:30:19 UTC (rev 3355)
+++ trunk/windstille/src/display/framebuffer.hpp	2010-09-08 09:32:15 UTC (rev 3356)
@@ -27,7 +27,7 @@
 {
 public:
   Framebuffer();
-  Framebuffer(GLenum target, int width, int height);
+  Framebuffer(GLenum target, int width, int height, int multisample = 0);
   ~Framebuffer();
   
   int get_width()  const;

Modified: trunk/windstille/src/display/render_buffer.cpp
===================================================================
--- trunk/windstille/src/display/render_buffer.cpp	2010-09-08 09:30:19 UTC (rev 3355)
+++ trunk/windstille/src/display/render_buffer.cpp	2010-09-08 09:32:15 UTC (rev 3356)
@@ -17,6 +17,7 @@
 */
 
 #include <GL/glew.h>
+#include <iostream>
 
 #include "display/render_buffer.hpp"
 
@@ -25,14 +26,23 @@
 public:
   GLuint handle;
 
-  RenderBufferImpl(GLenum format, int width, int height)
-    : handle(0)
+  RenderBufferImpl(GLenum format, int width, int height, int multisample) :
+    handle(0)
   {
     glGenRenderbuffersEXT(1, &handle);
 
     glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, handle);
-    glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, format, width, height);
-    
+
+    if (multisample)
+    { 
+      // antialiasing
+      std::cout << "Antialised Renderbuffer" << std::endl;
+      glRenderbufferStorageMultisampleEXT(GL_RENDERBUFFER_EXT, multisample, format, width, height);
+    }
+    else
+    {
+      glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, format, width, height);
+    }      
     glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0);
   }
 
@@ -42,8 +52,8 @@
   }
 };
 
-RenderBuffer::RenderBuffer(GLenum format, int width, int height) :
-  impl(new RenderBufferImpl(format, width, height))
+RenderBuffer::RenderBuffer(GLenum format, int width, int height, int multisample) :
+  impl(new RenderBufferImpl(format, width, height, multisample))
 {
 }
 

Modified: trunk/windstille/src/display/render_buffer.hpp
===================================================================
--- trunk/windstille/src/display/render_buffer.hpp	2010-09-08 09:30:19 UTC (rev 3355)
+++ trunk/windstille/src/display/render_buffer.hpp	2010-09-08 09:32:15 UTC (rev 3356)
@@ -31,7 +31,7 @@
    * @param height Height of the Renderbuffer
    * @param format GL_DEPTH_COMPONENT24, GL_STENCIL_INDEX, ...
    */
-  RenderBuffer(GLenum format, int width, int height);
+  RenderBuffer(GLenum format, int width, int height, int multisample = 0);
   
   GLuint get_handle() const;
 



From grumbel at mail.berlios.de  Wed Sep  8 15:37:29 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed,  8 Sep 2010 15:37:29 +0200
Subject: [Windstille-commit] r3357 - trunk/windstille/extra/slideshow
Message-ID: <20100908133729.7764848101F@sheep.berlios.de>

Author: grumbel
Date: 2010-09-08 15:37:29 +0200 (Wed, 08 Sep 2010)
New Revision: 3357

Modified:
   trunk/windstille/extra/slideshow/slideshow.cpp
Log:
Use anti-aliasing for Framebuffer Object


Modified: trunk/windstille/extra/slideshow/slideshow.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slideshow.cpp	2010-09-08 09:32:15 UTC (rev 3356)
+++ trunk/windstille/extra/slideshow/slideshow.cpp	2010-09-08 13:37:29 UTC (rev 3357)
@@ -25,6 +25,7 @@
 #include <boost/lexical_cast.hpp>
 
 #include "util/command_line.hpp"
+#include "display/assert_gl.hpp"
 #include "display/opengl_window.hpp"
 #include "display/framebuffer.hpp"
 #include "display/surface_manager.hpp"
@@ -174,6 +175,7 @@
     slide_show.load(*i, m_aspect_ratio);
   }
  
+  Framebuffer framebuffer_multisample(GL_TEXTURE_2D, m_window_size.width, m_window_size.height, 8);
   Framebuffer framebuffer(GL_TEXTURE_2D, m_window_size.width, m_window_size.height);
 
   bool loop = true;
@@ -207,7 +209,7 @@
           break;
 
         case SDL_KEYDOWN:
-          if (event.key.state)
+          if (event.key.state && m_output_dir.empty()) // ignore keypresses for offline rendereing
           {    
             switch (event.key.keysym.sym)
             {
@@ -307,12 +309,27 @@
       time += 1.0f/m_fps;
       
       // rendering to output dir
-      Display::push_framebuffer(framebuffer);
+      Display::push_framebuffer(framebuffer_multisample);
+      assert_gl("aeuthnoethuth");
       glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+      assert_gl("clear");
       slide_show.draw(time, m_edit_mode);
+      assert_gl("draw");
       //SDL_GL_SwapBuffers();
+      Display::pop_framebuffer();
 
+      glBindFramebufferEXT(GL_READ_FRAMEBUFFER_EXT, framebuffer_multisample.get_handle());
+      glBindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, framebuffer.get_handle());
+
+      glBlitFramebufferEXT(0, 0, framebuffer_multisample.get_width(), framebuffer_multisample.get_height(), 
+                           0, 0, framebuffer.get_width(), framebuffer.get_height(),
+                           GL_COLOR_BUFFER_BIT, GL_LINEAR /*NEAREST*/);
+
+      glBindFramebufferEXT(GL_READ_FRAMEBUFFER_EXT, 0);
+      glBindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, 0);
+
+      Display::push_framebuffer(framebuffer);
       char out[1024];
       sprintf(out, "%s/%08d.jpg", m_output_dir.c_str(), frame_number);
       Display::save_screenshot(Pathname(out, Pathname::kSysPath));



From grumbel at mail.berlios.de  Tue Sep 14 00:08:13 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Tue, 14 Sep 2010 00:08:13 +0200
Subject: [Windstille-commit] r3358 - trunk/windstille/src/display
Message-ID: <20100913220813.C8F15481034@sheep.berlios.de>

Author: grumbel
Date: 2010-09-14 00:08:13 +0200 (Tue, 14 Sep 2010)
New Revision: 3358

Modified:
   trunk/windstille/src/display/surface_manager.cpp
   trunk/windstille/src/display/texture_manager.cpp
Log:
Disabled debug output


Modified: trunk/windstille/src/display/surface_manager.cpp
===================================================================
--- trunk/windstille/src/display/surface_manager.cpp	2010-09-08 13:37:29 UTC (rev 3357)
+++ trunk/windstille/src/display/surface_manager.cpp	2010-09-13 22:08:13 UTC (rev 3358)
@@ -151,12 +151,12 @@
 void
 SurfaceManager::cleanup()
 {
-  std::cout << "SurfaceManager: size: " << surfaces.size() << std::endl;
+  //std::cout << "SurfaceManager: size: " << surfaces.size() << std::endl;
   for(Surfaces::iterator i = surfaces.begin(); i != surfaces.end(); ++i)
   {
     if (i->second.use_count() == 1)
     {
-      std::cout << "SurfaceManager: erasing a surface" << std::endl;
+      //std::cout << "SurfaceManager: erasing a surface" << std::endl;
       surfaces.erase(i);
     }
   }

Modified: trunk/windstille/src/display/texture_manager.cpp
===================================================================
--- trunk/windstille/src/display/texture_manager.cpp	2010-09-08 13:37:29 UTC (rev 3357)
+++ trunk/windstille/src/display/texture_manager.cpp	2010-09-13 22:08:13 UTC (rev 3358)
@@ -68,13 +68,13 @@
 void
 TextureManager::cleanup()
 {
-  std::cout << "TextureManager: size: " << textures.size() << std::endl;
+  //std::cout << "TextureManager: size: " << textures.size() << std::endl;
   for(Textures::iterator i = textures.begin(); i != textures.end(); ++i)
   {
     std::cout << "TextureManager: use count: " << i->second.use_count() << std::endl;
     if (i->second.use_count() == 1)
     {
-      std::cout << "TextureManager: erasing a texture" << std::endl;
+      //std::cout << "TextureManager: erasing a texture" << std::endl;
       textures.erase(i);
     }
   }



From grumbel at mail.berlios.de  Tue Sep 14 00:09:39 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Tue, 14 Sep 2010 00:09:39 +0200
Subject: [Windstille-commit] r3359 - in trunk/windstille: extra/slideshow
	src/app src/display
Message-ID: <20100913220939.367B9481034@sheep.berlios.de>

Author: grumbel
Date: 2010-09-14 00:09:39 +0200 (Tue, 14 Sep 2010)
New Revision: 3359

Added:
   trunk/windstille/extra/slideshow/slide_parser.cpp
   trunk/windstille/extra/slideshow/slide_parser.hpp
Modified:
   trunk/windstille/extra/slideshow/slide_builder.cpp
   trunk/windstille/extra/slideshow/slide_builder.hpp
   trunk/windstille/extra/slideshow/slide_show.cpp
   trunk/windstille/extra/slideshow/slideshow.cpp
   trunk/windstille/src/app/windstille_main.cpp
   trunk/windstille/src/display/opengl_window.cpp
   trunk/windstille/src/display/opengl_window.hpp
Log:
Renamed SlideBuilder to SlideParser
Added configurable title to OpenGLWindow


Modified: trunk/windstille/extra/slideshow/slide_builder.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.cpp	2010-09-13 22:08:13 UTC (rev 3358)
+++ trunk/windstille/extra/slideshow/slide_builder.cpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -29,622 +29,5 @@
 
 #include "slideshow/slide_show.hpp"
 
-float
-NodePosX::get(const Sizef& scr, const Sizef& img, float zoom) const
-{
-  // FIXME: Warning img is already multiplied by zoom
-  switch(m_type)
-  {
-    case kNodePosXLeft:
-      return img.width/2.0f - scr.width/2.0f + scr.width/2.0f;
 
-    case kNodePosXRight:
-      return -img.width/2.0f + scr.width/2.0f + scr.width/2.0f;
-
-    case kNodePosXCenter:
-      return scr.width/2;
-
-    case kNodePosXAbsFloat:
-      {
-        float x = m_value * zoom;
-        return img.width/2.0f - x + scr.width/2.0f;
-      }
-
-    case kNodePosXRelFloat:
-      {
-        float x = (m_value/100.0f) * img.width;
-        return img.width/2.0f - x + scr.width/2.0f;
-      }
-  }
-
-  assert(!"never reached");
-}
-
-float
-NodePosY::get(const Sizef& scr, const Sizef& img, float zoom) const
-{
-  // FIXME: Warning img is already multiplied by zoom
-  switch(m_type)
-  {
-    case kNodePosYTop:
-      return img.height/2.0f - scr.height/2.0f + scr.height/2.0f;
-      
-    case kNodePosYBottom:
-      return -img.height/2.0f + scr.height/2.0f + scr.height/2.0f;
-
-    case kNodePosYCenter:
-      return scr.height/2;
-      
-    case kNodePosYAbsFloat:
-      {
-        float y = m_value * zoom;
-        return img.height/2.0f - y + scr.height/2.0f;
-      }
-      
-    case kNodePosYRelFloat:
-      {
-        float y = (m_value/100.0f) * img.height;
-        return img.height/2.0f - y + scr.height/2.0f;
-      }
-  }
-
-  assert(!"never reached");
-}
-
-float
-NodeZoom::get(const Sizef& scr, const Sizef& img) const
-{
-  switch(m_type)
-  {
-    case kNodeZoomFit:
-      return std::min(scr.width / img.width,
-                      scr.height / img.height);
-
-    case kNodeZoomFill:
-      return std::max(scr.width / img.width,
-                      scr.height / img.height);
-
-    case kNodeZoomWidth:
-      return scr.width / img.width;
-      
-    case kNodeZoomHeight:
-      return scr.height / img.height;
-      
-    case kNodeZoomOriginal:
-      return 1.0f;
-
-    case kNodeZoomFloat:
-      {
-        // 1.0f means "fit", so recalculate values relative to that
-        float fit = std::min(scr.width / img.width,
-                             scr.height / img.height);
-        return fit * m_value;
-      }
-  }
-
-  assert(!"never reached");
-}
-
-SlideBuilder::SlideBuilder(SlideShow& slideshow, const Sizef& screen_size) :
-  m_slideshow(slideshow),
-  m_screen_size(screen_size),
-  m_context(),
-  m_line(),
-  m_fade(0.0f),
-  m_state(kGlobal),
-  m_time(0.0f),
-  m_image(),
-  m_last_image(),
-  m_node_has_pos(false),
-  m_node_has_zoom(false),
-  //m_path_node(),
-  m_node(),
-  m_variables()
-{
-}
-
-void
-SlideBuilder::load_from_file(const std::string& filename)
-{
-  std::ifstream in(filename.c_str());
-  if (!in)
-  {
-    std::ostringstream str;
-    str << filename << ": " << strerror(errno);
-    throw std::runtime_error(str.str());
-  }
-  else
-  {
-    m_context = filename;
-    m_line = 0;
-    load_from_stream(in);
-  }
-}
-
-std::string
-strip_comment(const std::string& line)
-{
-  std::string::size_type p = line.find('#');
-  return line.substr(0, p);
-}
-
-void
-SlideBuilder::error(const std::string& str) const
-{
-  std::ostringstream out;
-  out << m_context << ':' << m_line << ": error: " << str;
-  throw std::runtime_error(out.str());
-}
-
-void
-SlideBuilder::load_from_stream(std::istream& stream)
-{
-  try 
-  {
-    std::string line;
-    while(std::getline(stream, line))
-    {
-      m_line += 1;
-      line = strip_comment(line);
-
-      std::vector<std::string> args = tokenize(line);
-
-      if (args.empty())
-      {
-        // empty line, skip it
-      }
-      else
-      {
-        if (false)
-        { // debug output
-          for(std::vector<std::string>::iterator i = args.begin(); i != args.end(); ++i)
-          {
-            std::cout << "(" << *i << ") ";
-          }
-          std::cout << std::endl;
-        }
-
-        // handle variable replacement
-        for(std::vector<std::string>::iterator i = args.begin(); i != args.end(); ++i)
-        {
-          if ((*i)[0] == '$')
-          {
-            Variables::iterator it = m_variables.find(i->substr(1));
-            if (it == m_variables.end())
-            {
-              error("unknown variable: " + *i);
-            }
-            else
-            {
-              *i = it->second;
-            }
-          }
-        }
-
-        if (args[0] == "image")
-        {
-          handle_image(args);
-        }
-        else if (args[0] == "set")
-        {
-          handle_set(args);
-        }
-        else if (args[0] == "zoom")
-        {
-          handle_zoom(args);
-        }
-        else if (args[0] == "pos")
-        {
-          handle_pos(args);
-        }
-        else if (args[0] == "duration")
-        {
-          handle_duration(args);
-        }
-        else if (args[0] == "fade")
-        {
-          handle_fade(args);
-        }
-        else if (args[0] == "end")
-        {
-          handle_end(args);
-        }
-        else if (args[0] == "breakpoint")
-        {
-          handle_breakpoint(args);
-        }
-        else if (args[0] == "include")
-        {
-          handle_include(args);
-        }
-        else
-        {
-          error("unknown tag '" + args[0] + "'");
-        }
-      }
-    }
-
-    if (m_state != kGlobal)
-    {
-      error("not in global scope at end of file");
-    }
-
-    std::cout << "Total time: " << m_time << std::endl;
-  }
-  catch(std::exception& err)
-  {
-    error(err.what());
-  }
-}
-
-void
-SlideBuilder::handle_image(const std::vector<std::string>& args)
-{
-  if (m_state != kGlobal)
-  {
-    error("image must be in global scope");
-  }
-  else if (args.size() != 2)
-  {
-    error("image requires one argument");
-  }
-  else
-  {
-    m_state = kImage;
-
-    // reset pan/zoom pos
-    m_node = Node();
-
-    std::cout << ";; time = " << m_time << std::endl;
-    std::cout << "(image \"" << args[1] << "\")" << std::endl;
-    m_image = SlideObjectPtr(new SlideObject(Pathname(args[1], Pathname::kSysPath)));
-
-    if (m_slideshow.size() != 0)
-    {
-      m_time -= m_fade;
-      m_image->set_begin(m_time);
-    }
-
-    m_image->set_fade_in(m_fade);
-    m_fade = 0.0f;
-  }
-}
-
-void
-SlideBuilder::handle_pos(const std::vector<std::string>& args)
-{
-  if (m_state != kImage)
-  {
-    error("pos must be in image scope");
-  }
-  else if (args.size() != 3)
-  {
-    error("pos requires two arguments");
-  }
-  else if (m_node_has_pos)
-  {
-    error("pos already given");
-  }
-  else
-  {
-    m_node_has_pos = true;
-
-    //float img_w = m_image->get_width()  * m_path_node.zoom;
-    //float img_h = m_image->get_height() * m_path_node.zoom;
-
-    //float scr_w = m_screen_size.width;
-    //float scr_h = m_screen_size.height;
-
-    if (args[1] == "left")
-    {
-      //m_path_node.pos.x = img_w/2.0f - scr_w/2.0f + scr_w/2.0f;
-      m_node.pos_x = NodePosX(NodePosX::kNodePosXLeft);
-    }
-    else if (args[1] == "right")
-    {
-      //m_path_node.pos.x = -img_w/2.0f + scr_w/2.0f + scr_w/2.0f;
-      m_node.pos_x = NodePosX(NodePosX::kNodePosXRight);
-    }
-    else if (args[1] == "center")
-    {
-      //m_path_node.pos.x = scr_w/2;
-      m_node.pos_x = NodePosX(NodePosX::kNodePosXCenter);
-    }
-    else if (args[1] == "prev")
-    {
-      // reuse previous value
-    }
-    else
-    {
-      //float x = boost::lexical_cast<float>(args[1]) * m_path_node.zoom;
-      //m_path_node.pos.x = img_w/2.0f - x + scr_w/2.0f;
-      if (args[1][args[1].length()-1] == '%')
-      {
-        m_node.pos_x = NodePosX(NodePosX::kNodePosXRelFloat, 
-                                boost::lexical_cast<float>(args[1].substr(0, args[1].length()-1)));
-      }
-      else
-      {
-        m_node.pos_x = NodePosX(NodePosX::kNodePosXAbsFloat, 
-                                boost::lexical_cast<float>(args[1]));
-      }
-    }
-
-    if (args[2] == "top")
-    {
-      //m_path_node.pos.y = img_h/2.0f - scr_h/2.0f + scr_h/2.0f;
-      m_node.pos_y = NodePosY(NodePosY::kNodePosYTop);
-    }
-    else if (args[2] == "bottom")
-    {
-      //m_path_node.pos.y = -img_h/2.0f + scr_h/2.0f + scr_h/2.0f;
-      m_node.pos_y = NodePosY(NodePosY::kNodePosYBottom);
-    }
-    else if (args[2] == "center")
-    {
-      //m_path_node.pos.y = scr_h/2;
-      m_node.pos_y = NodePosY(NodePosY::kNodePosYCenter);
-    }
-    else if (args[2] == "prev")
-    {
-      // reuse previous value
-    }
-    else
-    {
-      //float y = boost::lexical_cast<float>(args[2]) * m_path_node.zoom;
-      //m_path_node.pos.y = img_h/2.0f - y + scr_h/2.0f;
-      if (args[2][args[2].length()-1] == '%')
-      {
-        m_node.pos_y = NodePosY(NodePosY::kNodePosYRelFloat, 
-                                boost::lexical_cast<float>(args[2].substr(0, args[2].length()-1)));
-      }
-      else
-      {
-        m_node.pos_y = NodePosY(NodePosY::kNodePosYAbsFloat, 
-                                boost::lexical_cast<float>(args[2]));
-      }
-    }
-
-    //std::cout << "  (pos " << m_path_node.pos.x << " " << m_path_node.pos.y << ")" << std::endl;
-  }
-}
-
-void
-SlideBuilder::handle_zoom(const std::vector<std::string>& args)
-{
-  if (m_state != kImage)
-  {
-    error("zoom must be in image scope");
-  }
-  else if (args.size() != 2)
-  {
-    error("zoom requires one argument");
-  }
-  else if (m_node_has_zoom)
-  {
-    error("zoom already given");
-  }
-  else
-  {
-    if (args[1] == "fit")
-    {
-      //m_path_node.zoom = std::min(m_screen_size.width / m_image->get_width(),
-      //                            m_screen_size.height / m_image->get_height());
-      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomFit);
-    }
-    else if (args[1] == "fill")
-    {
-      //m_path_node.zoom = std::max(m_screen_size.width / m_image->get_width(),
-      //m_screen_size.height / m_image->get_height());
-      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomFill);
-    }
-    else if (args[1] == "width")
-    {
-      //m_path_node.zoom = m_screen_size.width / m_image->get_width();
-      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomWidth);
-    }
-    else if (args[1] == "height")
-    {
-      //m_path_node.zoom = m_screen_size.height / m_image->get_height();
-      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomHeight);
-    }
-    else if (args[1] == "original")
-    {
-      //m_path_node.zoom = 1.0f;
-      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomOriginal);
-    }
-    else if (args[1] == "prev")
-    {
-      // reuse previous value      
-    }
-    else
-    {
-      /*
-      m_path_node.zoom = boost::lexical_cast<float>(args[1]);
-      
-      // 1.0f means "fit", so recalculate values relative to that
-      float fit = std::min(m_screen_size.width / m_image->get_width(),
-                           m_screen_size.height / m_image->get_height());
-      m_path_node.zoom = fit * m_path_node.zoom;
-
-      std::cout << "  (zoom " << m_path_node.zoom << ")" << std::endl;
-      */
-      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomFloat, boost::lexical_cast<float>(args[1]));
-    }
-
-    m_node_has_zoom = true;
-  }
-}
- 
-void
-SlideBuilder::handle_duration(const std::vector<std::string>& args)
-{
-  if (m_state != kImage)
-  {
-    error("duration must be in image scope");
-  }
-  else if (args.size() != 2)
-  {
-    error("duration requires one argument");
-  }
-  else
-  {
-    float duration = boost::lexical_cast<float>(args[1]);
-
-    assert(m_image);
-    add_node();
-    m_image->get_path().add_edge(duration);
-    std::cout << "  (duration " << duration << ")" << std::endl;
-  }
-}
-
-void
-SlideBuilder::add_node()
-{
-  Sizef image_size(m_image->get_width(), m_image->get_height());
-  float zoom = m_node.zoom.get(m_screen_size, image_size);
-  Sizef image_size_zoom(zoom * m_image->get_width(), 
-                        zoom * m_image->get_height());
-  
-  //m_image->get_path().add_node(m_path_node.pos, m_path_node.zoom);
-  m_image->get_path().add_node(Vector2f(m_node.pos_x.get(m_screen_size, image_size_zoom, zoom),
-                                        m_node.pos_y.get(m_screen_size, image_size_zoom, zoom)),
-                               zoom);
-
-  m_node_has_zoom = false;
-  m_node_has_pos  = false;
-}
-
-void
-SlideBuilder::handle_fade(const std::vector<std::string>& args)
-{
-  if (m_state != kGlobal)
-  {
-    error("fade must be in global scope");
-  }
-  else if (args.size() != 2)
-  {
-    error("fade requires one argument");
-  }
-  else
-  {
-    m_fade = boost::lexical_cast<float>(args[1]);
-    std::cout << "(fade " << m_fade << ")" << std::endl;
-
-    if (m_last_image)
-    {
-      m_last_image->set_fade_out(m_fade);
-    }
-  }
-}
-
-void
-SlideBuilder::handle_end(const std::vector<std::string>& args)
-{
-  if (m_state != kImage)
-  {
-    error("end must be in image scope");
-  }
-  else if (args.size() != 1)
-  {
-    error("end requires no argument");
-  }
-  else
-  {
-    m_state = kGlobal;
-    
-    assert(m_image);
-    add_node();
-    m_image->get_path().finish();
-
-    m_time += m_image->length();
-    m_slideshow.add(m_image);
-    m_last_image = m_image;
-    std::cout << "(end)" << std::endl;
-  }
-}
-
-void
-SlideBuilder::handle_breakpoint(const std::vector<std::string>& args)
-{
-  std::cout << "breakpoint not implemented" << std::endl;
-}
-
-void
-SlideBuilder::handle_include(const std::vector<std::string>& args)
-{
-  std::cout << "include not implemented" << std::endl;
-}
-
-void
-SlideBuilder::handle_set(const std::vector<std::string>& args)
-{
-  if (args.size() != 3)
-  {
-    error("set requires exactly one argument");
-  }
-  else
-  {
-    m_variables[args[1]] = args[2];
-  }
-}
-
-std::vector<std::string>
-SlideBuilder::tokenize(const std::string& line) const
-{
-  if (true)
-  {
-    boost::char_separator<char> sep(" \t");
-    boost::tokenizer<boost::char_separator<char> > tokens(line, sep);
-    std::vector<std::string> lst(tokens.begin(), tokens.end());
-    return lst;
-  }
-  else
-  {
-    //enum { kWhitespace, kString } state;
-
-    std::vector<std::string> lst;  
-    std::ostringstream str;
-    std::string::const_iterator i = line.begin();
-
-    while(i != line.end())
-    {
-    
-      if (*i == ' ' || *i == '\t')
-      {
-      
-      }
-      else if (*i == '\\')
-      {
-        ++i;
-        if (i != line.end())
-        {
-          switch(*i)
-          {
-            case '\\': str << '\\'; break;
-            case '0': str << '\0'; break;
-            case 'a': str << '\a'; break;
-            case 'b': str << '\b'; break;
-            case 't': str << '\t'; break;
-            case 'r': str << '\r'; break;
-            case 'n': str << '\n'; break;
-            default: str << '\\' << *i; break;
-          }
-        }
-        else
-        {
-          error("couldn't tokenize line");
-        }
-      }
-      else
-      {
-      }
-
-      ++i;
-    }
-  
-    return lst;
-  }
-}
-
 /* EOF */

Modified: trunk/windstille/extra/slideshow/slide_builder.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.hpp	2010-09-13 22:08:13 UTC (rev 3358)
+++ trunk/windstille/extra/slideshow/slide_builder.hpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -28,165 +28,15 @@
 #include "slideshow/slide_path.hpp"
 
 class SlideShow;
-
-class NodePosX
-{
-public:
-  enum NodePosXType
-  {
-    kNodePosXLeft,
-    kNodePosXRight,
-    kNodePosXCenter,
-    kNodePosXAbsFloat,
-    kNodePosXRelFloat
-  };
-  
-public:
-  NodePosX() :
-    m_type(kNodePosXCenter),
-    m_value(0.0f)
-  {}
 
-  NodePosX(NodePosXType type, float value = 0.0f) :
-    m_type(type),
-    m_value(value)
-  {}
-
-  float get(const Sizef& screen_size, const Sizef& image_size, float zoom) const;
-
-private:
-  NodePosXType m_type;  
-  float m_value;
-};
-
-class NodePosY
-{
-public:
-  enum NodePosYType
-  {
-    kNodePosYTop,
-    kNodePosYBottom,
-    kNodePosYCenter,
-    kNodePosYAbsFloat,
-    kNodePosYRelFloat
-  };
-  
-public:
-  NodePosY() :
-    m_type(kNodePosYCenter),
-    m_value(0.0f)
-  {}
-
-  NodePosY(NodePosYType type, float value = 0.0f) :
-    m_type(type),
-    m_value(value)
-  {}
-
-  float get(const Sizef& screen_size, const Sizef& image_size, float zoom) const;
-
-private:
-  NodePosYType m_type;
-  float m_value;
-};
-
-class NodeZoom
-{
-public:
-  enum NodeZoomType
-  {
-    kNodeZoomOriginal,
-    kNodeZoomFit,
-    kNodeZoomFill,
-    kNodeZoomWidth,
-    kNodeZoomHeight,
-    kNodeZoomFloat
-  };
-
-public:
-  NodeZoom() :
-    m_type(kNodeZoomFit),
-    m_value(0.0f)
-  {}
-
-  NodeZoom(NodeZoomType type, float value = 1.0f) :
-    m_type(type),
-    m_value(value)
-  {}
-
-  float get(const Sizef& screen_size, const Sizef& image_size) const;
-
-private:
-  NodeZoomType m_type;
-  float m_value;
-};
-
-class Node
-{
-public:
-  NodeZoom zoom;
-  NodePosX pos_x;
-  NodePosY pos_y;
-
-  Node() :
-    zoom(),
-    pos_x(),
-    pos_y()
-  {}
-};
-
 class SlideBuilder
 {
 private:
-  SlideShow& m_slideshow;
-  Sizef m_screen_size;
 
-  std::string m_context;
-  int m_line;
-
-  enum State {
-    kGlobal,
-    kImage
-  };
-
-  float m_fade;
-
-  State m_state;
-  float m_time;
-  SlideObjectPtr m_image;
-  SlideObjectPtr m_last_image;
-
-  bool m_node_has_pos;
-  bool m_node_has_zoom;
-  //SlidePathNode m_path_node;
-  Node m_node;
-
-  typedef std::map<std::string, std::string> Variables;
-  Variables m_variables;
-
 public:
-  SlideBuilder(SlideShow& slideshow, const Sizef& screen_size);
+  SlideBuilder();
 
-  void load_from_file(const std::string& filename);
-  void load_from_stream(std::istream& stream);
-
 private:
-  void error(const std::string& str) const;
-
-  void handle_image(const std::vector<std::string>& args);
-  void handle_pos(const std::vector<std::string>& args);
-  void handle_zoom(const std::vector<std::string>& args);
-  void handle_duration(const std::vector<std::string>& args);
-  void handle_fade(const std::vector<std::string>& args);
-  void handle_end(const std::vector<std::string>& args);
-  void handle_breakpoint(const std::vector<std::string>& args);
-  void handle_include(const std::vector<std::string>& args);
-  void handle_set(const std::vector<std::string>& args);
-
-  void add_node();
-
-  std::vector<std::string> tokenize(const std::string& str) const;
-
-private:
   SlideBuilder(const SlideBuilder&);
   SlideBuilder& operator=(const SlideBuilder&);
 };

Added: trunk/windstille/extra/slideshow/slide_parser.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_parser.cpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/slide_parser.cpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -0,0 +1,650 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "slideshow/slide_parser.hpp"
+
+#include <boost/tokenizer.hpp>
+#include <boost/lexical_cast.hpp>
+#include <string.h>
+#include <errno.h>
+#include <fstream>
+#include <iostream>
+#include <stdexcept>
+#include <sstream>
+
+#include "slideshow/slide_show.hpp"
+
+float
+NodePosX::get(const Sizef& scr, const Sizef& img, float zoom) const
+{
+  // FIXME: Warning img is already multiplied by zoom
+  switch(m_type)
+  {
+    case kNodePosXLeft:
+      return img.width/2.0f - scr.width/2.0f + scr.width/2.0f;
+
+    case kNodePosXRight:
+      return -img.width/2.0f + scr.width/2.0f + scr.width/2.0f;
+
+    case kNodePosXCenter:
+      return scr.width/2;
+
+    case kNodePosXAbsFloat:
+      {
+        float x = m_value * zoom;
+        return img.width/2.0f - x + scr.width/2.0f;
+      }
+
+    case kNodePosXRelFloat:
+      {
+        float x = (m_value/100.0f) * img.width;
+        return img.width/2.0f - x + scr.width/2.0f;
+      }
+  }
+
+  assert(!"never reached");
+}
+
+float
+NodePosY::get(const Sizef& scr, const Sizef& img, float zoom) const
+{
+  // FIXME: Warning img is already multiplied by zoom
+  switch(m_type)
+  {
+    case kNodePosYTop:
+      return img.height/2.0f - scr.height/2.0f + scr.height/2.0f;
+      
+    case kNodePosYBottom:
+      return -img.height/2.0f + scr.height/2.0f + scr.height/2.0f;
+
+    case kNodePosYCenter:
+      return scr.height/2;
+      
+    case kNodePosYAbsFloat:
+      {
+        float y = m_value * zoom;
+        return img.height/2.0f - y + scr.height/2.0f;
+      }
+      
+    case kNodePosYRelFloat:
+      {
+        float y = (m_value/100.0f) * img.height;
+        return img.height/2.0f - y + scr.height/2.0f;
+      }
+  }
+
+  assert(!"never reached");
+}
+
+float
+NodeZoom::get(const Sizef& scr, const Sizef& img) const
+{
+  switch(m_type)
+  {
+    case kNodeZoomFit:
+      return std::min(scr.width / img.width,
+                      scr.height / img.height);
+
+    case kNodeZoomFill:
+      return std::max(scr.width / img.width,
+                      scr.height / img.height);
+
+    case kNodeZoomWidth:
+      return scr.width / img.width;
+      
+    case kNodeZoomHeight:
+      return scr.height / img.height;
+      
+    case kNodeZoomOriginal:
+      return 1.0f;
+
+    case kNodeZoomFloat:
+      {
+        // 1.0f means "fit", so recalculate values relative to that
+        float fit = std::min(scr.width / img.width,
+                             scr.height / img.height);
+        return fit * m_value;
+      }
+  }
+
+  assert(!"never reached");
+}
+
+SlideParser::SlideParser(SlideShow& slideshow, const Sizef& screen_size) :
+  m_slideshow(slideshow),
+  m_screen_size(screen_size),
+  m_context(),
+  m_line(),
+  m_fade(0.0f),
+  m_state(kGlobal),
+  m_time(0.0f),
+  m_image(),
+  m_last_image(),
+  m_node_has_pos(false),
+  m_node_has_zoom(false),
+  //m_path_node(),
+  m_node(),
+  m_variables()
+{
+}
+
+void
+SlideParser::load_from_file(const std::string& filename)
+{
+  std::ifstream in(filename.c_str());
+  if (!in)
+  {
+    std::ostringstream str;
+    str << filename << ": " << strerror(errno);
+    throw std::runtime_error(str.str());
+  }
+  else
+  {
+    m_context = filename;
+    m_line = 0;
+    load_from_stream(in);
+  }
+}
+
+std::string
+strip_comment(const std::string& line)
+{
+  std::string::size_type p = line.find('#');
+  return line.substr(0, p);
+}
+
+void
+SlideParser::error(const std::string& str) const
+{
+  std::ostringstream out;
+  out << m_context << ':' << m_line << ": error: " << str;
+  throw std::runtime_error(out.str());
+}
+
+void
+SlideParser::load_from_stream(std::istream& stream)
+{
+  try 
+  {
+    std::string line;
+    while(std::getline(stream, line))
+    {
+      m_line += 1;
+      line = strip_comment(line);
+
+      std::vector<std::string> args = tokenize(line);
+
+      if (args.empty())
+      {
+        // empty line, skip it
+      }
+      else
+      {
+        if (false)
+        { // debug output
+          for(std::vector<std::string>::iterator i = args.begin(); i != args.end(); ++i)
+          {
+            std::cout << "(" << *i << ") ";
+          }
+          std::cout << std::endl;
+        }
+
+        // handle variable replacement
+        for(std::vector<std::string>::iterator i = args.begin(); i != args.end(); ++i)
+        {
+          if ((*i)[0] == '$')
+          {
+            Variables::iterator it = m_variables.find(i->substr(1));
+            if (it == m_variables.end())
+            {
+              error("unknown variable: " + *i);
+            }
+            else
+            {
+              *i = it->second;
+            }
+          }
+        }
+
+        if (args[0] == "image")
+        {
+          handle_image(args);
+        }
+        else if (args[0] == "set")
+        {
+          handle_set(args);
+        }
+        else if (args[0] == "zoom")
+        {
+          handle_zoom(args);
+        }
+        else if (args[0] == "pos")
+        {
+          handle_pos(args);
+        }
+        else if (args[0] == "duration")
+        {
+          handle_duration(args);
+        }
+        else if (args[0] == "fade")
+        {
+          handle_fade(args);
+        }
+        else if (args[0] == "end")
+        {
+          handle_end(args);
+        }
+        else if (args[0] == "breakpoint")
+        {
+          handle_breakpoint(args);
+        }
+        else if (args[0] == "include")
+        {
+          handle_include(args);
+        }
+        else
+        {
+          error("unknown tag '" + args[0] + "'");
+        }
+      }
+    }
+
+    if (m_state != kGlobal)
+    {
+      error("not in global scope at end of file");
+    }
+
+    std::cout << "Total time: " << m_time << std::endl;
+  }
+  catch(std::exception& err)
+  {
+    error(err.what());
+  }
+}
+
+void
+SlideParser::handle_image(const std::vector<std::string>& args)
+{
+  if (m_state != kGlobal)
+  {
+    error("image must be in global scope");
+  }
+  else if (args.size() != 2)
+  {
+    error("image requires one argument");
+  }
+  else
+  {
+    m_state = kImage;
+
+    // reset pan/zoom pos
+    m_node = Node();
+
+    std::cout << ";; time = " << m_time << std::endl;
+    std::cout << "(image \"" << args[1] << "\")" << std::endl;
+    m_image = SlideObjectPtr(new SlideObject(Pathname(args[1], Pathname::kSysPath)));
+
+    if (m_slideshow.size() != 0)
+    {
+      m_time -= m_fade;
+      m_image->set_begin(m_time);
+    }
+
+    m_image->set_fade_in(m_fade);
+    m_fade = 0.0f;
+  }
+}
+
+void
+SlideParser::handle_pos(const std::vector<std::string>& args)
+{
+  if (m_state != kImage)
+  {
+    error("pos must be in image scope");
+  }
+  else if (args.size() != 3)
+  {
+    error("pos requires two arguments");
+  }
+  else if (m_node_has_pos)
+  {
+    error("pos already given");
+  }
+  else
+  {
+    m_node_has_pos = true;
+
+    //float img_w = m_image->get_width()  * m_path_node.zoom;
+    //float img_h = m_image->get_height() * m_path_node.zoom;
+
+    //float scr_w = m_screen_size.width;
+    //float scr_h = m_screen_size.height;
+
+    if (args[1] == "left")
+    {
+      //m_path_node.pos.x = img_w/2.0f - scr_w/2.0f + scr_w/2.0f;
+      m_node.pos_x = NodePosX(NodePosX::kNodePosXLeft);
+    }
+    else if (args[1] == "right")
+    {
+      //m_path_node.pos.x = -img_w/2.0f + scr_w/2.0f + scr_w/2.0f;
+      m_node.pos_x = NodePosX(NodePosX::kNodePosXRight);
+    }
+    else if (args[1] == "center")
+    {
+      //m_path_node.pos.x = scr_w/2;
+      m_node.pos_x = NodePosX(NodePosX::kNodePosXCenter);
+    }
+    else if (args[1] == "prev")
+    {
+      // reuse previous value
+    }
+    else
+    {
+      //float x = boost::lexical_cast<float>(args[1]) * m_path_node.zoom;
+      //m_path_node.pos.x = img_w/2.0f - x + scr_w/2.0f;
+      if (args[1][args[1].length()-1] == '%')
+      {
+        m_node.pos_x = NodePosX(NodePosX::kNodePosXRelFloat, 
+                                boost::lexical_cast<float>(args[1].substr(0, args[1].length()-1)));
+      }
+      else
+      {
+        m_node.pos_x = NodePosX(NodePosX::kNodePosXAbsFloat, 
+                                boost::lexical_cast<float>(args[1]));
+      }
+    }
+
+    if (args[2] == "top")
+    {
+      //m_path_node.pos.y = img_h/2.0f - scr_h/2.0f + scr_h/2.0f;
+      m_node.pos_y = NodePosY(NodePosY::kNodePosYTop);
+    }
+    else if (args[2] == "bottom")
+    {
+      //m_path_node.pos.y = -img_h/2.0f + scr_h/2.0f + scr_h/2.0f;
+      m_node.pos_y = NodePosY(NodePosY::kNodePosYBottom);
+    }
+    else if (args[2] == "center")
+    {
+      //m_path_node.pos.y = scr_h/2;
+      m_node.pos_y = NodePosY(NodePosY::kNodePosYCenter);
+    }
+    else if (args[2] == "prev")
+    {
+      // reuse previous value
+    }
+    else
+    {
+      //float y = boost::lexical_cast<float>(args[2]) * m_path_node.zoom;
+      //m_path_node.pos.y = img_h/2.0f - y + scr_h/2.0f;
+      if (args[2][args[2].length()-1] == '%')
+      {
+        m_node.pos_y = NodePosY(NodePosY::kNodePosYRelFloat, 
+                                boost::lexical_cast<float>(args[2].substr(0, args[2].length()-1)));
+      }
+      else
+      {
+        m_node.pos_y = NodePosY(NodePosY::kNodePosYAbsFloat, 
+                                boost::lexical_cast<float>(args[2]));
+      }
+    }
+
+    //std::cout << "  (pos " << m_path_node.pos.x << " " << m_path_node.pos.y << ")" << std::endl;
+  }
+}
+
+void
+SlideParser::handle_zoom(const std::vector<std::string>& args)
+{
+  if (m_state != kImage)
+  {
+    error("zoom must be in image scope");
+  }
+  else if (args.size() != 2)
+  {
+    error("zoom requires one argument");
+  }
+  else if (m_node_has_zoom)
+  {
+    error("zoom already given");
+  }
+  else
+  {
+    if (args[1] == "fit")
+    {
+      //m_path_node.zoom = std::min(m_screen_size.width / m_image->get_width(),
+      //                            m_screen_size.height / m_image->get_height());
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomFit);
+    }
+    else if (args[1] == "fill")
+    {
+      //m_path_node.zoom = std::max(m_screen_size.width / m_image->get_width(),
+      //m_screen_size.height / m_image->get_height());
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomFill);
+    }
+    else if (args[1] == "width")
+    {
+      //m_path_node.zoom = m_screen_size.width / m_image->get_width();
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomWidth);
+    }
+    else if (args[1] == "height")
+    {
+      //m_path_node.zoom = m_screen_size.height / m_image->get_height();
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomHeight);
+    }
+    else if (args[1] == "original")
+    {
+      //m_path_node.zoom = 1.0f;
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomOriginal);
+    }
+    else if (args[1] == "prev")
+    {
+      // reuse previous value      
+    }
+    else
+    {
+      /*
+      m_path_node.zoom = boost::lexical_cast<float>(args[1]);
+      
+      // 1.0f means "fit", so recalculate values relative to that
+      float fit = std::min(m_screen_size.width / m_image->get_width(),
+                           m_screen_size.height / m_image->get_height());
+      m_path_node.zoom = fit * m_path_node.zoom;
+
+      std::cout << "  (zoom " << m_path_node.zoom << ")" << std::endl;
+      */
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomFloat, boost::lexical_cast<float>(args[1]));
+    }
+
+    m_node_has_zoom = true;
+  }
+}
+ 
+void
+SlideParser::handle_duration(const std::vector<std::string>& args)
+{
+  if (m_state != kImage)
+  {
+    error("duration must be in image scope");
+  }
+  else if (args.size() != 2)
+  {
+    error("duration requires one argument");
+  }
+  else
+  {
+    float duration = boost::lexical_cast<float>(args[1]);
+
+    assert(m_image);
+    add_node();
+    m_image->get_path().add_edge(duration);
+    std::cout << "  (duration " << duration << ")" << std::endl;
+  }
+}
+
+void
+SlideParser::add_node()
+{
+  Sizef image_size(m_image->get_width(), m_image->get_height());
+  float zoom = m_node.zoom.get(m_screen_size, image_size);
+  Sizef image_size_zoom(zoom * m_image->get_width(), 
+                        zoom * m_image->get_height());
+  
+  //m_image->get_path().add_node(m_path_node.pos, m_path_node.zoom);
+  m_image->get_path().add_node(Vector2f(m_node.pos_x.get(m_screen_size, image_size_zoom, zoom),
+                                        m_node.pos_y.get(m_screen_size, image_size_zoom, zoom)),
+                               zoom);
+
+  m_node_has_zoom = false;
+  m_node_has_pos  = false;
+}
+
+void
+SlideParser::handle_fade(const std::vector<std::string>& args)
+{
+  if (m_state != kGlobal)
+  {
+    error("fade must be in global scope");
+  }
+  else if (args.size() != 2)
+  {
+    error("fade requires one argument");
+  }
+  else
+  {
+    m_fade = boost::lexical_cast<float>(args[1]);
+    std::cout << "(fade " << m_fade << ")" << std::endl;
+
+    if (m_last_image)
+    {
+      m_last_image->set_fade_out(m_fade);
+    }
+  }
+}
+
+void
+SlideParser::handle_end(const std::vector<std::string>& args)
+{
+  if (m_state != kImage)
+  {
+    error("end must be in image scope");
+  }
+  else if (args.size() != 1)
+  {
+    error("end requires no argument");
+  }
+  else
+  {
+    m_state = kGlobal;
+    
+    assert(m_image);
+    add_node();
+    m_image->get_path().finish();
+
+    m_time += m_image->length();
+    m_slideshow.add(m_image);
+    m_last_image = m_image;
+    std::cout << "(end)" << std::endl;
+  }
+}
+
+void
+SlideParser::handle_breakpoint(const std::vector<std::string>& args)
+{
+  std::cout << "breakpoint not implemented" << std::endl;
+}
+
+void
+SlideParser::handle_include(const std::vector<std::string>& args)
+{
+  std::cout << "include not implemented" << std::endl;
+}
+
+void
+SlideParser::handle_set(const std::vector<std::string>& args)
+{
+  if (args.size() != 3)
+  {
+    error("set requires exactly one argument");
+  }
+  else
+  {
+    m_variables[args[1]] = args[2];
+  }
+}
+
+std::vector<std::string>
+SlideParser::tokenize(const std::string& line) const
+{
+  if (true)
+  {
+    boost::char_separator<char> sep(" \t");
+    boost::tokenizer<boost::char_separator<char> > tokens(line, sep);
+    std::vector<std::string> lst(tokens.begin(), tokens.end());
+    return lst;
+  }
+  else
+  {
+    //enum { kWhitespace, kString } state;
+
+    std::vector<std::string> lst;  
+    std::ostringstream str;
+    std::string::const_iterator i = line.begin();
+
+    while(i != line.end())
+    {
+    
+      if (*i == ' ' || *i == '\t')
+      {
+      
+      }
+      else if (*i == '\\')
+      {
+        ++i;
+        if (i != line.end())
+        {
+          switch(*i)
+          {
+            case '\\': str << '\\'; break;
+            case '0': str << '\0'; break;
+            case 'a': str << '\a'; break;
+            case 'b': str << '\b'; break;
+            case 't': str << '\t'; break;
+            case 'r': str << '\r'; break;
+            case 'n': str << '\n'; break;
+            default: str << '\\' << *i; break;
+          }
+        }
+        else
+        {
+          error("couldn't tokenize line");
+        }
+      }
+      else
+      {
+      }
+
+      ++i;
+    }
+  
+    return lst;
+  }
+}
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/slide_parser.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/slide_parser.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_parser.hpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/slide_parser.hpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -0,0 +1,196 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_WINDSTILLE_EXTRA_SLIDESHOW_SLIDE_BUILDER_HPP
+#define HEADER_WINDSTILLE_EXTRA_SLIDESHOW_SLIDE_BUILDER_HPP
+
+#include <string>
+#include <vector>
+#include <map>
+
+#include "math/size.hpp"
+#include "slideshow/slide_object.hpp"
+#include "slideshow/slide_path.hpp"
+
+class SlideShow;
+
+class NodePosX
+{
+public:
+  enum NodePosXType
+  {
+    kNodePosXLeft,
+    kNodePosXRight,
+    kNodePosXCenter,
+    kNodePosXAbsFloat,
+    kNodePosXRelFloat
+  };
+  
+public:
+  NodePosX() :
+    m_type(kNodePosXCenter),
+    m_value(0.0f)
+  {}
+
+  NodePosX(NodePosXType type, float value = 0.0f) :
+    m_type(type),
+    m_value(value)
+  {}
+
+  float get(const Sizef& screen_size, const Sizef& image_size, float zoom) const;
+
+private:
+  NodePosXType m_type;  
+  float m_value;
+};
+
+class NodePosY
+{
+public:
+  enum NodePosYType
+  {
+    kNodePosYTop,
+    kNodePosYBottom,
+    kNodePosYCenter,
+    kNodePosYAbsFloat,
+    kNodePosYRelFloat
+  };
+  
+public:
+  NodePosY() :
+    m_type(kNodePosYCenter),
+    m_value(0.0f)
+  {}
+
+  NodePosY(NodePosYType type, float value = 0.0f) :
+    m_type(type),
+    m_value(value)
+  {}
+
+  float get(const Sizef& screen_size, const Sizef& image_size, float zoom) const;
+
+private:
+  NodePosYType m_type;
+  float m_value;
+};
+
+class NodeZoom
+{
+public:
+  enum NodeZoomType
+  {
+    kNodeZoomOriginal,
+    kNodeZoomFit,
+    kNodeZoomFill,
+    kNodeZoomWidth,
+    kNodeZoomHeight,
+    kNodeZoomFloat
+  };
+
+public:
+  NodeZoom() :
+    m_type(kNodeZoomFit),
+    m_value(0.0f)
+  {}
+
+  NodeZoom(NodeZoomType type, float value = 1.0f) :
+    m_type(type),
+    m_value(value)
+  {}
+
+  float get(const Sizef& screen_size, const Sizef& image_size) const;
+
+private:
+  NodeZoomType m_type;
+  float m_value;
+};
+
+class Node
+{
+public:
+  NodeZoom zoom;
+  NodePosX pos_x;
+  NodePosY pos_y;
+
+  Node() :
+    zoom(),
+    pos_x(),
+    pos_y()
+  {}
+};
+
+class SlideParser
+{
+private:
+  SlideShow& m_slideshow;
+  Sizef m_screen_size;
+
+  std::string m_context;
+  int m_line;
+
+  enum State {
+    kGlobal,
+    kImage
+  };
+
+  float m_fade;
+
+  State m_state;
+  float m_time;
+  SlideObjectPtr m_image;
+  SlideObjectPtr m_last_image;
+
+  bool m_node_has_pos;
+  bool m_node_has_zoom;
+  //SlidePathNode m_path_node;
+  Node m_node;
+
+  typedef std::map<std::string, std::string> Variables;
+  Variables m_variables;
+
+public:
+  SlideParser(SlideShow& slideshow, const Sizef& screen_size);
+
+  void load_from_file(const std::string& filename);
+  void load_from_stream(std::istream& stream);
+
+private:
+  void error(const std::string& str) const;
+
+  void handle_image(const std::vector<std::string>& args);
+  void handle_pos(const std::vector<std::string>& args);
+  void handle_zoom(const std::vector<std::string>& args);
+  void handle_duration(const std::vector<std::string>& args);
+  void handle_fade(const std::vector<std::string>& args);
+  void handle_end(const std::vector<std::string>& args);
+  void handle_breakpoint(const std::vector<std::string>& args);
+  void handle_include(const std::vector<std::string>& args);
+  void handle_set(const std::vector<std::string>& args);
+
+  void add_node();
+
+  std::vector<std::string> tokenize(const std::string& str) const;
+
+private:
+  SlideParser(const SlideParser&);
+  SlideParser& operator=(const SlideParser&);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/slide_parser.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: trunk/windstille/extra/slideshow/slide_show.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_show.cpp	2010-09-13 22:08:13 UTC (rev 3358)
+++ trunk/windstille/extra/slideshow/slide_show.cpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -20,7 +20,7 @@
 
 #include "display/surface_manager.hpp"
 #include "display/texture_manager.hpp"
-#include "slideshow/slide_builder.hpp"
+#include "slideshow/slide_parser.hpp"
 
 SlideShow::SlideShow() :
   m_objects(),
@@ -97,8 +97,8 @@
 void
 SlideShow::load(const std::string& filename, const Sizef& aspect)
 {
-  SlideBuilder slide_builder(*this, aspect);
-  slide_builder.load_from_file(filename);
+  SlideParser slide_parser(*this, aspect);
+  slide_parser.load_from_file(filename);
 }
 
 float

Modified: trunk/windstille/extra/slideshow/slideshow.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slideshow.cpp	2010-09-13 22:08:13 UTC (rev 3358)
+++ trunk/windstille/extra/slideshow/slideshow.cpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -39,8 +39,8 @@
 #include "slideshow/slide_builder.hpp"
 
 App::App() :
-  m_aspect_ratio(1280, 800),
-  m_window_size(1280, 800),
+  m_aspect_ratio(768, 576),
+  m_window_size(768, 576),
   m_fullscreen(false),
   m_files(),
   m_output_dir(),
@@ -106,6 +106,10 @@
         m_edit_mode = true;
         break;
 
+      case 'F':
+        m_fps = boost::lexical_cast<float>(argp.get_argument());
+        break;
+
       case 'g':
         if (sscanf(argp.get_argument().c_str(), "%dx%d", &m_window_size.width, &m_window_size.height) != 2)
         {
@@ -141,7 +145,7 @@
         break;
 
       default:
-        throw std::runtime_error("unhandled argument");
+        throw std::runtime_error("unhandled argument: " + argp.get_key());
     }
   }
 
@@ -160,7 +164,8 @@
   init_sdl();
       
   //std::cout << "OpenGLWindow" << std::endl;
-  OpenGLWindow window(m_window_size, // window size
+  OpenGLWindow window("Slideshow",
+                      m_window_size, // window size
                       m_aspect_ratio, // aspect ratio
                       m_fullscreen, // fullscreen
                       4); // anti-alias
@@ -253,6 +258,10 @@
                 time = slide_show.find_next(time);
                 break;
 
+              case SDLK_e:
+                m_edit_mode = !m_edit_mode;
+                break;
+
               case SDLK_f:
                 fast_forward = !fast_forward;
                 std::cout << fast_forward << std::endl;
@@ -302,7 +311,7 @@
 
       SDL_GL_SwapBuffers();
 
-      SDL_Delay(10);
+      SDL_Delay(30);
     }
     else
     {
@@ -350,6 +359,16 @@
       std::cout << "Time: " << time << std::endl;
     }
   }
+
+  
+  if (!loop)
+    std::cout << "Playback interrupted: " << std::endl;
+  else
+    std::cout << "Playback finished: " << std::endl;
+
+  std::cout << "  frame: " << frame_number << std::endl;
+  std::cout << "  time:  " << time << std::endl;
+
   return 0;
 }
 

Modified: trunk/windstille/src/app/windstille_main.cpp
===================================================================
--- trunk/windstille/src/app/windstille_main.cpp	2010-09-13 22:08:13 UTC (rev 3358)
+++ trunk/windstille/src/app/windstille_main.cpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -66,7 +66,8 @@
     config.parse_args(argc, argv);
 
     {
-      OpenGLWindow      window(Size(config.get_int("screen-width"), config.get_int("screen-height")),
+      OpenGLWindow      window("Windstille",
+                               Size(config.get_int("screen-width"), config.get_int("screen-height")),
                                Size(config.get_int("aspect-width"), config.get_int("aspect-height")),
                                config.get_bool("fullscreen"), config.get_int("anti-aliasing"));
       TTFFontManager    ttffont_manager;

Modified: trunk/windstille/src/display/opengl_window.cpp
===================================================================
--- trunk/windstille/src/display/opengl_window.cpp	2010-09-13 22:08:13 UTC (rev 3358)
+++ trunk/windstille/src/display/opengl_window.cpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -40,7 +40,8 @@
   {}
 };
 
-OpenGLWindow::OpenGLWindow(const Size& size, const Size& aspect, bool fullscreen, int anti_aliasing) :
+OpenGLWindow::OpenGLWindow(const std::string& title, 
+                           const Size& size, const Size& aspect, bool fullscreen, int anti_aliasing) :
   m_impl(new OpenGLWindowImpl)
 {
   m_impl->m_size = size;
@@ -58,7 +59,7 @@
     SDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, anti_aliasing ); // 0, 2, or 4 for number of samples
   }
   
-  SDL_WM_SetCaption("Windstille", "Windstille");
+  SDL_WM_SetCaption(title.c_str(), title.c_str());
   SDL_WM_SetIcon(IMG_Load(Pathname("icon.png").get_sys_path().c_str()), NULL);
 
   m_impl->m_window = SDL_SetVideoMode(size.width, size.height,

Modified: trunk/windstille/src/display/opengl_window.hpp
===================================================================
--- trunk/windstille/src/display/opengl_window.hpp	2010-09-13 22:08:13 UTC (rev 3358)
+++ trunk/windstille/src/display/opengl_window.hpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -29,7 +29,8 @@
 class OpenGLWindow : public Currenton<OpenGLWindow>
 {
 public:
-  OpenGLWindow(const Size& size, const Size& aspect, 
+  OpenGLWindow(const std::string& title, 
+               const Size& size, const Size& aspect, 
                bool fullscreen = false, int anti_aliasing = 0);
   ~OpenGLWindow();
 



From grumbel at mail.berlios.de  Tue Sep 21 22:27:45 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Tue, 21 Sep 2010 22:27:45 +0200
Subject: [Windstille-commit] r3360 - in trunk/windstille/src: display
	particles
Message-ID: <20100921202745.B096748082E@sheep.berlios.de>

Author: grumbel
Date: 2010-09-21 22:27:45 +0200 (Tue, 21 Sep 2010)
New Revision: 3360

Modified:
   trunk/windstille/src/display/display.cpp
   trunk/windstille/src/display/display.hpp
   trunk/windstille/src/display/framebuffer.cpp
   trunk/windstille/src/display/framebuffer.hpp
   trunk/windstille/src/display/framebuffer_compositor_impl.cpp
   trunk/windstille/src/display/framebuffer_compositor_impl.hpp
   trunk/windstille/src/display/render_buffer.hpp
   trunk/windstille/src/particles/deform_drawer.cpp
   trunk/windstille/src/particles/deform_drawer.hpp
Log:
Use FramebufferPtr instead of Framebuffer


Modified: trunk/windstille/src/display/display.cpp
===================================================================
--- trunk/windstille/src/display/display.cpp	2010-09-13 22:09:39 UTC (rev 3359)
+++ trunk/windstille/src/display/display.cpp	2010-09-21 20:27:45 UTC (rev 3360)
@@ -36,7 +36,7 @@
 
 Size              Display::aspect_size;
 std::vector<Rect> Display::cliprects;
-std::vector<Framebuffer> framebuffers;
+std::vector<FramebufferPtr> framebuffers;
 
 void
 Display::draw_line(const Line& line, const Color& color)
@@ -599,10 +599,10 @@
 }
 
 void
-Display::push_framebuffer(Framebuffer& framebuffer)
+Display::push_framebuffer(FramebufferPtr framebuffer)
 {
   framebuffers.push_back(framebuffer);
-  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, framebuffers.back().get_handle());
+  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, framebuffers.back()->get_handle());
 }
 
 void
@@ -614,7 +614,7 @@
   
   if (!framebuffers.empty())
   {
-    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, framebuffers.back().get_handle());
+    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, framebuffers.back()->get_handle());
   }
   else
   {
@@ -622,11 +622,11 @@
   }
 }
 
-Framebuffer
+FramebufferPtr
 Display::get_framebuffer()
 {
   if (framebuffers.empty())
-    return Framebuffer();
+    return FramebufferPtr();
   else
     return framebuffers.back();
 }

Modified: trunk/windstille/src/display/display.hpp
===================================================================
--- trunk/windstille/src/display/display.hpp	2010-09-13 22:09:39 UTC (rev 3359)
+++ trunk/windstille/src/display/display.hpp	2010-09-21 20:27:45 UTC (rev 3360)
@@ -71,9 +71,9 @@
   static void push_cliprect(const Rect& rect);
   static void pop_cliprect();
 
-  static void push_framebuffer(Framebuffer& framebuffer);
+  static void push_framebuffer(FramebufferPtr framebuffer);
   static void pop_framebuffer();
-  static Framebuffer get_framebuffer();
+  static FramebufferPtr get_framebuffer();
 
   static void save_screenshot(const Pathname& filename);
 };

Modified: trunk/windstille/src/display/framebuffer.cpp
===================================================================
--- trunk/windstille/src/display/framebuffer.cpp	2010-09-13 22:09:39 UTC (rev 3359)
+++ trunk/windstille/src/display/framebuffer.cpp	2010-09-21 20:27:45 UTC (rev 3360)
@@ -24,117 +24,129 @@
 #include "display/framebuffer.hpp"
 #include "display/assert_gl.hpp"
 
-class FramebufferImpl
+FramebufferPtr
+Framebuffer::create_with_texture(GLenum target, int width, int height, int multisample)
 {
-public:
-  GLuint  handle;
-  Size size;
-  
-  //Texture texture;
-  RenderBuffer m_color_buffer;
-  RenderBuffer m_depth_stencil_buffer;
-  //RenderBuffer m_stencil_buffer;
+  FramebufferPtr framebuffer(new Framebuffer);
+  framebuffer->create_with_texture_internal(target, width, height, multisample);
+  return framebuffer;
+}
 
-  FramebufferImpl(GLenum target, int width, int height, int multisample) : 
-    handle(0),
-    size(width, height),
-    //texture(target, width, height),
-    m_color_buffer(GL_RGB8, width, height, multisample), // FIXME: do we need RGBA or just RGB?!
-    m_depth_stencil_buffer(GL_DEPTH24_STENCIL8_EXT, width, height, multisample)
-  {
-    glGenFramebuffersEXT(1, &handle);
-    assert_gl("FramebufferImpl::FramebufferImpl()");
+FramebufferPtr
+Framebuffer::create(int width, int height, int multisample)
+{
+  FramebufferPtr framebuffer(new Framebuffer);
+  framebuffer->create_internal(GL_RGB8, width, height, multisample);
+  return framebuffer;
+}
 
-    // FIXME: Should use push/pop_framebuffer instead, but don't have pointer to Framebuffer here
-    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, handle);
-
-    // bind texture and renderbuffers to the framebuffer
-    //glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, texture.get_target(), texture.get_handle(), 0);
-
-    glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,  GL_RENDERBUFFER_EXT, m_color_buffer.get_handle());
-    glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,   GL_RENDERBUFFER_EXT, m_depth_stencil_buffer.get_handle());
-    glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, m_depth_stencil_buffer.get_handle());
-
-    assert_gl("FramebufferImpl::FramebufferImpl() - binding");
-
-
-    GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-    switch(status)
-    {
-      case GL_FRAMEBUFFER_COMPLETE_EXT:
-        std::cout << "Framebuffer ok" << std::endl;
-        break;
-
-      default:
-        std::cout << "Framebuffer status failure: " << status << std::endl;
-        break;
-    }
-    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
-  }
-
-  ~FramebufferImpl()
-  {
-    glDeleteFramebuffersEXT(1, &handle);
-  }
-};
+FramebufferPtr
+Framebuffer::create_hdr(int width, int height, int multisample)
+{
+  FramebufferPtr framebuffer(new Framebuffer);
+  framebuffer->create_internal(GL_RGBA16F, width, height, multisample);
+  return framebuffer;
+}
 
 Framebuffer::Framebuffer() :
-  impl()
+  m_handle(0),
+  m_size(),
+  m_texture(),
+  m_color_buffer(),
+  m_depth_stencil_buffer()
 {
+  glGenFramebuffersEXT(1, &m_handle);
+  assert_gl("Framebuffer::Framebuffer()");   
 }
 
-Framebuffer::Framebuffer(GLenum target, int width, int height, int multisample) :
-  impl(new FramebufferImpl(target, width, height, multisample))
-{  
-}
-
 Framebuffer::~Framebuffer()
 {
-  
+  glDeleteFramebuffersEXT(1, &m_handle);  
 }
 
 Texture
 Framebuffer::get_texture()
 {
-  assert(!"not implemented right now - Framebuffer::get_texture()");
-  return Texture();
-  //return impl->texture;
+  assert(m_texture);
+  return m_texture;
 }
 
 int
 Framebuffer::get_width()  const
 {
-  return impl->size.width;
+  return m_size.width;
 }
 
 int
 Framebuffer::get_height() const
 {
-  return impl->size.height;
+  return m_size.height;
 }
 
 GLuint
 Framebuffer::get_handle() const
 {
-  return impl->handle;
+  return m_handle;
 
 }
 
-Framebuffer::operator bool() const
+void
+Framebuffer::create_with_texture_internal(GLenum target, int width, int height, int multisample)
 {
-  return impl.get();
+  m_size = Size(width, height);
+  m_texture = Texture(target, width, height);
+  m_depth_stencil_buffer = RenderBuffer(GL_DEPTH24_STENCIL8_EXT, width, height, multisample);
+    
+  // FIXME: Should use push/pop_framebuffer instead, but don't have pointer to Framebuffer here
+  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, m_handle);
+
+  // bind texture and renderbuffers to the framebuffer
+  glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, m_texture.get_target(), m_texture.get_handle(), 0);
+  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,   GL_RENDERBUFFER_EXT, m_depth_stencil_buffer.get_handle());
+  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, m_depth_stencil_buffer.get_handle());
+
+  assert_gl("Framebuffer::Framebuffer() - binding");
+
+  check_completness();
+
+  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
 }
 
-bool
-Framebuffer::operator==(const Framebuffer& other) const
-{
-  return impl.get() == other.impl.get();
+void
+Framebuffer::create_internal(GLenum format, int width, int height, int multisample)
+{ 
+  m_size = Size(width, height);
+  m_color_buffer = RenderBuffer(format, width, height, multisample);
+  m_depth_stencil_buffer = RenderBuffer(GL_DEPTH24_STENCIL8_EXT, width, height, multisample);
+
+  // FIXME: Should use push/pop_framebuffer instead, but don't have pointer to Framebuffer here
+  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, m_handle);
+
+  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,  GL_RENDERBUFFER_EXT, m_color_buffer.get_handle());
+  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,   GL_RENDERBUFFER_EXT, m_depth_stencil_buffer.get_handle());
+  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, m_depth_stencil_buffer.get_handle());
+
+  assert_gl("Framebuffer::Framebuffer() - binding");
+
+  check_completness();
+
+  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);    
 }
 
-bool
-Framebuffer::operator!=(const Framebuffer& other) const
+void
+Framebuffer::check_completness()
 {
-  return impl.get() != other.impl.get();
+  GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+  switch(status)
+  {
+    case GL_FRAMEBUFFER_COMPLETE_EXT:
+      std::cout << "Framebuffer ok" << std::endl;
+      break;
+
+    default:
+      std::cout << "Framebuffer status failure: " << status << std::endl;
+      break;
+  }
 }
 
 /* EOF */

Modified: trunk/windstille/src/display/framebuffer.hpp
===================================================================
--- trunk/windstille/src/display/framebuffer.hpp	2010-09-13 22:09:39 UTC (rev 3359)
+++ trunk/windstille/src/display/framebuffer.hpp	2010-09-21 20:27:45 UTC (rev 3360)
@@ -19,33 +19,42 @@
 #ifndef HEADER_WINDSTILLE_DISPLAY_FRAMEBUFFER_HPP
 #define HEADER_WINDSTILLE_DISPLAY_FRAMEBUFFER_HPP
 
+#include "math/size.hpp"
 #include "display/texture.hpp"
+#include "display/render_buffer.hpp"
 
-class FramebufferImpl;
+class Framebuffer;
+typedef boost::shared_ptr<Framebuffer> FramebufferPtr;
 
 class Framebuffer
 {
 public:
-  Framebuffer();
-  Framebuffer(GLenum target, int width, int height, int multisample = 0);
+  static FramebufferPtr create_with_texture(GLenum target, int width, int height, int multisample = 0);
+  static FramebufferPtr create(int width, int height, int multisample = 0);
+  static FramebufferPtr create_hdr(int width, int height, int multisample = 0);
+
+public:  
   ~Framebuffer();
-  
+
   int get_width()  const;
   int get_height() const;
   Texture get_texture();
 
   GLuint get_handle() const;
 
-  /** 
-   * true if the Framebuffer is valid and usable, false if not 
-   */
-  operator bool() const;
+private:
+  Framebuffer();
+  void check_completness();
+  void create_internal(GLenum format, int width, int height, int multisample);
+  void create_with_texture_internal(GLenum target, int width, int height, int multisample);
 
-  bool operator==(const Framebuffer&) const;
-  bool operator!=(const Framebuffer&) const;
-
 private:
-  boost::shared_ptr<FramebufferImpl> impl;
+  GLuint m_handle;
+  Size   m_size;
+  
+  Texture m_texture;
+  RenderBuffer m_color_buffer;
+  RenderBuffer m_depth_stencil_buffer;
 };
 
 #endif

Modified: trunk/windstille/src/display/framebuffer_compositor_impl.cpp
===================================================================
--- trunk/windstille/src/display/framebuffer_compositor_impl.cpp	2010-09-13 22:09:39 UTC (rev 3359)
+++ trunk/windstille/src/display/framebuffer_compositor_impl.cpp	2010-09-21 20:27:45 UTC (rev 3360)
@@ -28,8 +28,8 @@
 
 FramebufferCompositorImpl::FramebufferCompositorImpl(const Size& window, const Size& viewport) :
   CompositorImpl(window, viewport),
-  m_screen  (GL_TEXTURE_2D, window.width, window.height),
-  m_lightmap(GL_TEXTURE_2D, window.width / LIGHTMAP_DIV, window.height / LIGHTMAP_DIV)
+  m_screen  (Framebuffer::create_with_texture(GL_TEXTURE_2D, window.width, window.height)),
+  m_lightmap(Framebuffer::create_with_texture(GL_TEXTURE_2D, window.width / LIGHTMAP_DIV, window.height / LIGHTMAP_DIV))
 {
 }
 
@@ -38,7 +38,7 @@
 {
   OpenGLState state;
 
-  state.bind_texture(m_lightmap.get_texture());
+  state.bind_texture(m_lightmap->get_texture());
       
   state.enable(GL_BLEND);
   state.set_blend_func(GL_DST_COLOR, GL_ZERO); // multiply the lightmap with the screen
@@ -150,7 +150,7 @@
     // Render the screen framebuffer to the actual screen 
     OpenGLState state;
 
-    state.bind_texture(m_screen.get_texture(), 0);
+    state.bind_texture(m_screen->get_texture(), 0);
 
     state.activate();
 

Modified: trunk/windstille/src/display/framebuffer_compositor_impl.hpp
===================================================================
--- trunk/windstille/src/display/framebuffer_compositor_impl.hpp	2010-09-13 22:09:39 UTC (rev 3359)
+++ trunk/windstille/src/display/framebuffer_compositor_impl.hpp	2010-09-21 20:27:45 UTC (rev 3360)
@@ -25,8 +25,8 @@
 class FramebufferCompositorImpl : public CompositorImpl
 {
 private:
-  Framebuffer m_screen;
-  Framebuffer m_lightmap;   
+  FramebufferPtr m_screen;
+  FramebufferPtr m_lightmap;   
 
 public:
   FramebufferCompositorImpl(const Size& window, const Size& viewport);

Modified: trunk/windstille/src/display/render_buffer.hpp
===================================================================
--- trunk/windstille/src/display/render_buffer.hpp	2010-09-13 22:09:39 UTC (rev 3359)
+++ trunk/windstille/src/display/render_buffer.hpp	2010-09-21 20:27:45 UTC (rev 3360)
@@ -22,10 +22,17 @@
 #include <boost/shared_ptr.hpp>
 
 class RenderBufferImpl;
+class RenderBuffer;
 
+typedef boost::shared_ptr<RenderBufferImpl> RenderBufferPtr;
+
 class RenderBuffer
 {
 public:
+  RenderBuffer()  :
+    impl()
+  {}
+
   /**
    * @param width  Width of the Renderbuffer
    * @param height Height of the Renderbuffer

Modified: trunk/windstille/src/particles/deform_drawer.cpp
===================================================================
--- trunk/windstille/src/particles/deform_drawer.cpp	2010-09-13 22:09:39 UTC (rev 3359)
+++ trunk/windstille/src/particles/deform_drawer.cpp	2010-09-21 20:27:45 UTC (rev 3360)
@@ -28,13 +28,13 @@
 class DeformDrawerRequest : public Drawable
 {
 public:
-  Framebuffer&      framebuffer;
+  FramebufferPtr    framebuffer;
   Surface&          surface;
   ParticleSystem&   psys;
   ShaderProgram&    shader_program;
 
   DeformDrawerRequest(const Vector2f& pos_, float z_pos_,  const Matrix& modelview_,
-                      Framebuffer& framebuffer_, Surface& surface_, ParticleSystem& psys_,
+                      FramebufferPtr framebuffer_, Surface& surface_, ParticleSystem& psys_,
                       ShaderProgram& shader_program_)
     : Drawable(pos_, z_pos_, modelview_),
       framebuffer(framebuffer_), surface(surface_), psys(psys_), 
@@ -164,10 +164,10 @@
   bool needs_prepare() { return true; }
 };
 
-DeformDrawer::DeformDrawer(FileReader& /*props*/)
-  : framebuffer(GL_TEXTURE_2D, 800, 600),
-    surface(Pathname("images/particles/deform2.png")),
-    shader_program()
+DeformDrawer::DeformDrawer(FileReader& /*props*/) :
+  framebuffer(Framebuffer::create_with_texture(GL_TEXTURE_2D, 800, 600)),
+  surface(Pathname("images/particles/deform2.png")),
+  shader_program()
 {
   shader_program.attach(ShaderObject(GL_FRAGMENT_SHADER, "data/shader/particledeform.frag"));
   shader_program.link();

Modified: trunk/windstille/src/particles/deform_drawer.hpp
===================================================================
--- trunk/windstille/src/particles/deform_drawer.hpp	2010-09-13 22:09:39 UTC (rev 3359)
+++ trunk/windstille/src/particles/deform_drawer.hpp	2010-09-21 20:27:45 UTC (rev 3360)
@@ -38,7 +38,7 @@
 class DeformDrawer : public Drawer
 {
 private:
-  Framebuffer    framebuffer;
+  FramebufferPtr framebuffer;
   Surface        surface;
   ShaderProgram  shader_program;
 



From grumbel at mail.berlios.de  Tue Sep 21 22:41:46 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Tue, 21 Sep 2010 22:41:46 +0200
Subject: [Windstille-commit] r3361 - trunk/windstille/src/display
Message-ID: <20100921204146.61D7A48082E@sheep.berlios.de>

Author: grumbel
Date: 2010-09-21 22:41:46 +0200 (Tue, 21 Sep 2010)
New Revision: 3361

Modified:
   trunk/windstille/src/display/framebuffer.cpp
   trunk/windstille/src/display/framebuffer.hpp
   trunk/windstille/src/display/render_buffer.cpp
   trunk/windstille/src/display/render_buffer.hpp
Log:
Use RenderbufferPtr instead of Renderbuffer


Modified: trunk/windstille/src/display/framebuffer.cpp
===================================================================
--- trunk/windstille/src/display/framebuffer.cpp	2010-09-21 20:27:45 UTC (rev 3360)
+++ trunk/windstille/src/display/framebuffer.cpp	2010-09-21 20:41:46 UTC (rev 3361)
@@ -95,15 +95,15 @@
 {
   m_size = Size(width, height);
   m_texture = Texture(target, width, height);
-  m_depth_stencil_buffer = RenderBuffer(GL_DEPTH24_STENCIL8_EXT, width, height, multisample);
+  m_depth_stencil_buffer = Renderbuffer::create(GL_DEPTH24_STENCIL8_EXT, width, height, multisample);
     
   // FIXME: Should use push/pop_framebuffer instead, but don't have pointer to Framebuffer here
   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, m_handle);
 
   // bind texture and renderbuffers to the framebuffer
   glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, m_texture.get_target(), m_texture.get_handle(), 0);
-  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,   GL_RENDERBUFFER_EXT, m_depth_stencil_buffer.get_handle());
-  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, m_depth_stencil_buffer.get_handle());
+  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,   GL_RENDERBUFFER_EXT, m_depth_stencil_buffer->get_handle());
+  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, m_depth_stencil_buffer->get_handle());
 
   assert_gl("Framebuffer::Framebuffer() - binding");
 
@@ -116,15 +116,15 @@
 Framebuffer::create_internal(GLenum format, int width, int height, int multisample)
 { 
   m_size = Size(width, height);
-  m_color_buffer = RenderBuffer(format, width, height, multisample);
-  m_depth_stencil_buffer = RenderBuffer(GL_DEPTH24_STENCIL8_EXT, width, height, multisample);
+  m_color_buffer = Renderbuffer::create(format, width, height, multisample);
+  m_depth_stencil_buffer = Renderbuffer::create(GL_DEPTH24_STENCIL8_EXT, width, height, multisample);
 
   // FIXME: Should use push/pop_framebuffer instead, but don't have pointer to Framebuffer here
   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, m_handle);
 
-  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,  GL_RENDERBUFFER_EXT, m_color_buffer.get_handle());
-  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,   GL_RENDERBUFFER_EXT, m_depth_stencil_buffer.get_handle());
-  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, m_depth_stencil_buffer.get_handle());
+  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,  GL_RENDERBUFFER_EXT, m_color_buffer->get_handle());
+  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,   GL_RENDERBUFFER_EXT, m_depth_stencil_buffer->get_handle());
+  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, m_depth_stencil_buffer->get_handle());
 
   assert_gl("Framebuffer::Framebuffer() - binding");
 

Modified: trunk/windstille/src/display/framebuffer.hpp
===================================================================
--- trunk/windstille/src/display/framebuffer.hpp	2010-09-21 20:27:45 UTC (rev 3360)
+++ trunk/windstille/src/display/framebuffer.hpp	2010-09-21 20:41:46 UTC (rev 3361)
@@ -53,8 +53,8 @@
   Size   m_size;
   
   Texture m_texture;
-  RenderBuffer m_color_buffer;
-  RenderBuffer m_depth_stencil_buffer;
+  RenderbufferPtr m_color_buffer;
+  RenderbufferPtr m_depth_stencil_buffer;
 };
 
 #endif

Modified: trunk/windstille/src/display/render_buffer.cpp
===================================================================
--- trunk/windstille/src/display/render_buffer.cpp	2010-09-21 20:27:45 UTC (rev 3360)
+++ trunk/windstille/src/display/render_buffer.cpp	2010-09-21 20:41:46 UTC (rev 3361)
@@ -21,46 +21,41 @@
 
 #include "display/render_buffer.hpp"
 
-class RenderBufferImpl
+RenderbufferPtr
+Renderbuffer::create(GLenum format, int width, int height, int multisample)
 {
-public:
-  GLuint handle;
+  return RenderbufferPtr(new Renderbuffer(format, width, height, multisample));
+}
 
-  RenderBufferImpl(GLenum format, int width, int height, int multisample) :
-    handle(0)
-  {
-    glGenRenderbuffersEXT(1, &handle);
+Renderbuffer::Renderbuffer(GLenum format, int width, int height, int multisample) :
+  m_handle(0)
+{
+  glGenRenderbuffersEXT(1, &m_handle);
 
-    glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, handle);
+  glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, m_handle);
 
-    if (multisample)
-    { 
-      // antialiasing
-      std::cout << "Antialised Renderbuffer" << std::endl;
-      glRenderbufferStorageMultisampleEXT(GL_RENDERBUFFER_EXT, multisample, format, width, height);
-    }
-    else
-    {
-      glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, format, width, height);
-    }      
-    glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0);
+  if (multisample)
+  { 
+    // antialiasing
+    std::cout << "Antialised Renderbuffer" << std::endl;
+    glRenderbufferStorageMultisampleEXT(GL_RENDERBUFFER_EXT, multisample, format, width, height);
   }
-
-  ~RenderBufferImpl()
+  else
   {
-    glDeleteRenderbuffersEXT(1, &handle);
-  }
-};
+    glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, format, width, height);
+  }      
+  glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0); 
+}
 
-RenderBuffer::RenderBuffer(GLenum format, int width, int height, int multisample) :
-  impl(new RenderBufferImpl(format, width, height, multisample))
+Renderbuffer::~Renderbuffer()
 {
+  glDeleteRenderbuffersEXT(1, &m_handle);
 }
 
 GLuint
-RenderBuffer::get_handle() const
+Renderbuffer::get_handle() const
 {
-  return impl->handle;
+  return m_handle;
 }
 
 /* EOF */

Modified: trunk/windstille/src/display/render_buffer.hpp
===================================================================
--- trunk/windstille/src/display/render_buffer.hpp	2010-09-21 20:27:45 UTC (rev 3360)
+++ trunk/windstille/src/display/render_buffer.hpp	2010-09-21 20:41:46 UTC (rev 3361)
@@ -21,29 +21,29 @@
 
 #include <boost/shared_ptr.hpp>
 
-class RenderBufferImpl;
-class RenderBuffer;
+class Renderbuffer;
+typedef boost::shared_ptr<Renderbuffer> RenderbufferPtr;
 
-typedef boost::shared_ptr<RenderBufferImpl> RenderBufferPtr;
-
-class RenderBuffer
+class Renderbuffer
 {
 public:
-  RenderBuffer()  :
-    impl()
-  {}
+  static RenderbufferPtr create(GLenum format, int width, int height, int multisample = 0);
 
+public:
+  ~Renderbuffer();
+  
+  GLuint get_handle() const;
+
+private:
   /**
    * @param width  Width of the Renderbuffer
    * @param height Height of the Renderbuffer
    * @param format GL_DEPTH_COMPONENT24, GL_STENCIL_INDEX, ...
    */
-  RenderBuffer(GLenum format, int width, int height, int multisample = 0);
-  
-  GLuint get_handle() const;
+  Renderbuffer(GLenum format, int width, int height, int multisample = 0);
 
 private:
-  boost::shared_ptr<RenderBufferImpl> impl;
+  GLuint m_handle;
 };
 
 #endif



From grumbel at mail.berlios.de  Tue Sep 21 22:45:19 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Tue, 21 Sep 2010 22:45:19 +0200
Subject: [Windstille-commit] r3362 - trunk/windstille/src/display
Message-ID: <20100921204519.321AB48082E@sheep.berlios.de>

Author: grumbel
Date: 2010-09-21 22:45:18 +0200 (Tue, 21 Sep 2010)
New Revision: 3362

Added:
   trunk/windstille/src/display/renderbuffer.cpp
   trunk/windstille/src/display/renderbuffer.hpp
Removed:
   trunk/windstille/src/display/render_buffer.cpp
   trunk/windstille/src/display/render_buffer.hpp
Modified:
   trunk/windstille/src/display/framebuffer.cpp
   trunk/windstille/src/display/framebuffer.hpp
Log:
Rename render_buffer.?pp to renderbuffer.?pp


Modified: trunk/windstille/src/display/framebuffer.cpp
===================================================================
--- trunk/windstille/src/display/framebuffer.cpp	2010-09-21 20:41:46 UTC (rev 3361)
+++ trunk/windstille/src/display/framebuffer.cpp	2010-09-21 20:45:18 UTC (rev 3362)
@@ -20,7 +20,7 @@
 
 #include "math/size.hpp"
 #include "util/util.hpp"
-#include "display/render_buffer.hpp"
+#include "display/renderbuffer.hpp"
 #include "display/framebuffer.hpp"
 #include "display/assert_gl.hpp"
 

Modified: trunk/windstille/src/display/framebuffer.hpp
===================================================================
--- trunk/windstille/src/display/framebuffer.hpp	2010-09-21 20:41:46 UTC (rev 3361)
+++ trunk/windstille/src/display/framebuffer.hpp	2010-09-21 20:45:18 UTC (rev 3362)
@@ -21,7 +21,7 @@
 
 #include "math/size.hpp"
 #include "display/texture.hpp"
-#include "display/render_buffer.hpp"
+#include "display/renderbuffer.hpp"
 
 class Framebuffer;
 typedef boost::shared_ptr<Framebuffer> FramebufferPtr;

Deleted: trunk/windstille/src/display/render_buffer.cpp
===================================================================
--- trunk/windstille/src/display/render_buffer.cpp	2010-09-21 20:41:46 UTC (rev 3361)
+++ trunk/windstille/src/display/render_buffer.cpp	2010-09-21 20:45:18 UTC (rev 3362)
@@ -1,61 +0,0 @@
-/*
-**  Windstille - A Sci-Fi Action-Adventure Game
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software: you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation, either version 3 of the License, or
-**  (at your option) any later version.
-**  
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**  
-**  You should have received a copy of the GNU General Public License
-**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <GL/glew.h>
-#include <iostream>
-
-#include "display/render_buffer.hpp"
-
-RenderbufferPtr
-Renderbuffer::create(GLenum format, int width, int height, int multisample)
-{
-  return RenderbufferPtr(new Renderbuffer(format, width, height, multisample));
-}
-
-Renderbuffer::Renderbuffer(GLenum format, int width, int height, int multisample) :
-  m_handle(0)
-{
-  glGenRenderbuffersEXT(1, &m_handle);
-
-  glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, m_handle);
-
-  if (multisample)
-  { 
-    // antialiasing
-    std::cout << "Antialised Renderbuffer" << std::endl;
-    glRenderbufferStorageMultisampleEXT(GL_RENDERBUFFER_EXT, multisample, format, width, height);
-  }
-  else
-  {
-    glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, format, width, height);
-  }      
-  glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0); 
-}
-
-Renderbuffer::~Renderbuffer()
-{
-  glDeleteRenderbuffersEXT(1, &m_handle);
-}
-
-GLuint
-Renderbuffer::get_handle() const
-{
-  return m_handle;
-}
-
-/* EOF */

Deleted: trunk/windstille/src/display/render_buffer.hpp
===================================================================
--- trunk/windstille/src/display/render_buffer.hpp	2010-09-21 20:41:46 UTC (rev 3361)
+++ trunk/windstille/src/display/render_buffer.hpp	2010-09-21 20:45:18 UTC (rev 3362)
@@ -1,51 +0,0 @@
-/*
-**  Windstille - A Sci-Fi Action-Adventure Game
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software: you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation, either version 3 of the License, or
-**  (at your option) any later version.
-**  
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**  
-**  You should have received a copy of the GNU General Public License
-**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef HEADER_WINDSTILLE_DISPLAY_RENDER_BUFFER_HPP
-#define HEADER_WINDSTILLE_DISPLAY_RENDER_BUFFER_HPP
-
-#include <boost/shared_ptr.hpp>
-
-class Renderbuffer;
-typedef boost::shared_ptr<Renderbuffer> RenderbufferPtr;
-
-class Renderbuffer
-{
-public:
-  static RenderbufferPtr create(GLenum format, int width, int height, int multisample = 0);
-
-public:
-  ~Renderbuffer();
-  
-  GLuint get_handle() const;
-
-private:
-  /**
-   * @param width  Width of the Renderbuffer
-   * @param height Height of the Renderbuffer
-   * @param format GL_DEPTH_COMPONENT24, GL_STENCIL_INDEX, ...
-   */
-  Renderbuffer(GLenum format, int width, int height, int multisample = 0);
-
-private:
-  GLuint m_handle;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/windstille/src/display/renderbuffer.cpp (from rev 3361, trunk/windstille/src/display/render_buffer.cpp)
===================================================================
--- trunk/windstille/src/display/renderbuffer.cpp	                        (rev 0)
+++ trunk/windstille/src/display/renderbuffer.cpp	2010-09-21 20:45:18 UTC (rev 3362)
@@ -0,0 +1,61 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**  
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**  
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <GL/glew.h>
+#include <iostream>
+
+#include "display/renderbuffer.hpp"
+
+RenderbufferPtr
+Renderbuffer::create(GLenum format, int width, int height, int multisample)
+{
+  return RenderbufferPtr(new Renderbuffer(format, width, height, multisample));
+}
+
+Renderbuffer::Renderbuffer(GLenum format, int width, int height, int multisample) :
+  m_handle(0)
+{
+  glGenRenderbuffersEXT(1, &m_handle);
+
+  glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, m_handle);
+
+  if (multisample)
+  { 
+    // antialiasing
+    std::cout << "Antialised Renderbuffer" << std::endl;
+    glRenderbufferStorageMultisampleEXT(GL_RENDERBUFFER_EXT, multisample, format, width, height);
+  }
+  else
+  {
+    glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, format, width, height);
+  }      
+  glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0); 
+}
+
+Renderbuffer::~Renderbuffer()
+{
+  glDeleteRenderbuffersEXT(1, &m_handle);
+}
+
+GLuint
+Renderbuffer::get_handle() const
+{
+  return m_handle;
+}
+
+/* EOF */

Copied: trunk/windstille/src/display/renderbuffer.hpp (from rev 3361, trunk/windstille/src/display/render_buffer.hpp)
===================================================================
--- trunk/windstille/src/display/renderbuffer.hpp	                        (rev 0)
+++ trunk/windstille/src/display/renderbuffer.hpp	2010-09-21 20:45:18 UTC (rev 3362)
@@ -0,0 +1,51 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**  
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**  
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_WINDSTILLE_DISPLAY_RENDER_BUFFER_HPP
+#define HEADER_WINDSTILLE_DISPLAY_RENDER_BUFFER_HPP
+
+#include <boost/shared_ptr.hpp>
+
+class Renderbuffer;
+typedef boost::shared_ptr<Renderbuffer> RenderbufferPtr;
+
+class Renderbuffer
+{
+public:
+  static RenderbufferPtr create(GLenum format, int width, int height, int multisample = 0);
+
+public:
+  ~Renderbuffer();
+  
+  GLuint get_handle() const;
+
+private:
+  /**
+   * @param width  Width of the Renderbuffer
+   * @param height Height of the Renderbuffer
+   * @param format GL_DEPTH_COMPONENT24, GL_STENCIL_INDEX, ...
+   */
+  Renderbuffer(GLenum format, int width, int height, int multisample = 0);
+
+private:
+  GLuint m_handle;
+};
+
+#endif
+
+/* EOF */



From grumbel at mail.berlios.de  Tue Sep 21 23:54:03 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Tue, 21 Sep 2010 23:54:03 +0200
Subject: [Windstille-commit] r3363 - in trunk/windstille/src: armature
	display font gui objects particles scenegraph screen sprite3d tile
Message-ID: <20100921215403.44983480AC8@sheep.berlios.de>

Author: grumbel
Date: 2010-09-21 23:54:02 +0200 (Tue, 21 Sep 2010)
New Revision: 3363

Modified:
   trunk/windstille/src/armature/mesh.hpp
   trunk/windstille/src/display/drawing_context.cpp
   trunk/windstille/src/display/drawing_context.hpp
   trunk/windstille/src/display/framebuffer.cpp
   trunk/windstille/src/display/framebuffer.hpp
   trunk/windstille/src/display/opengl_state.cpp
   trunk/windstille/src/display/opengl_state.hpp
   trunk/windstille/src/display/surface.cpp
   trunk/windstille/src/display/surface.hpp
   trunk/windstille/src/display/surface_manager.cpp
   trunk/windstille/src/display/surface_manager.hpp
   trunk/windstille/src/display/texture.cpp
   trunk/windstille/src/display/texture.hpp
   trunk/windstille/src/display/texture_manager.cpp
   trunk/windstille/src/display/texture_manager.hpp
   trunk/windstille/src/display/texture_packer.cpp
   trunk/windstille/src/display/texture_packer.hpp
   trunk/windstille/src/font/ttf_font.cpp
   trunk/windstille/src/font/ttf_font.hpp
   trunk/windstille/src/gui/automap.cpp
   trunk/windstille/src/objects/laser_pointer.cpp
   trunk/windstille/src/objects/laser_pointer.hpp
   trunk/windstille/src/objects/liquid.cpp
   trunk/windstille/src/objects/liquid.hpp
   trunk/windstille/src/objects/nightvision.cpp
   trunk/windstille/src/objects/nightvision.hpp
   trunk/windstille/src/objects/shockwave.cpp
   trunk/windstille/src/objects/shockwave.hpp
   trunk/windstille/src/particles/deform_drawer.cpp
   trunk/windstille/src/scenegraph/fill_screen_pattern_drawable.hpp
   trunk/windstille/src/scenegraph/shockwave_drawable.hpp
   trunk/windstille/src/scenegraph/vertex_array_drawable.cpp
   trunk/windstille/src/scenegraph/vertex_array_drawable.hpp
   trunk/windstille/src/screen/particle_viewer.cpp
   trunk/windstille/src/sprite3d/data.hpp
   trunk/windstille/src/tile/tile.hpp
   trunk/windstille/src/tile/tile_packer.cpp
   trunk/windstille/src/tile/tile_packer.hpp
Log:
Replaced Texture with TexturePtr


Modified: trunk/windstille/src/armature/mesh.hpp
===================================================================
--- trunk/windstille/src/armature/mesh.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/armature/mesh.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -85,7 +85,7 @@
   typedef std::vector<Vertex> Vertices;
   Vertices vertices_;
 
-  Texture texture;
+  TexturePtr texture;
 
   GLenum blend_sfactor;
   GLenum blend_dfactor;

Modified: trunk/windstille/src/display/drawing_context.cpp
===================================================================
--- trunk/windstille/src/display/drawing_context.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/drawing_context.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -146,7 +146,7 @@
 }
 
 void
-DrawingContext::fill_pattern(const Texture& pattern, const Vector2f& offset)
+DrawingContext::fill_pattern(TexturePtr pattern, const Vector2f& offset)
 {
   draw(new FillScreenPatternDrawable(pattern, offset));
 }

Modified: trunk/windstille/src/display/drawing_context.hpp
===================================================================
--- trunk/windstille/src/display/drawing_context.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/drawing_context.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -22,8 +22,8 @@
 #include <vector>
 
 #include "scenegraph/drawable.hpp"
+#include "display/texture.hpp"
 
-class Texture;
 class Surface;
 class SurfaceDrawingParameters;
 class DrawingParameters;
@@ -63,7 +63,7 @@
       queue */
   void fill_screen(const Color& color);
 
-  void fill_pattern(const Texture& pattern, const Vector2f& offset);
+  void fill_pattern(TexturePtr pattern, const Vector2f& offset);
 
   void draw_line(const Line& line, const Color& color, float z_pos = 0);
   void draw_line(const Vector2f& pos1, const Vector2f& pos2, const Color& color, float z_pos = 0);

Modified: trunk/windstille/src/display/framebuffer.cpp
===================================================================
--- trunk/windstille/src/display/framebuffer.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/framebuffer.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -64,7 +64,7 @@
   glDeleteFramebuffersEXT(1, &m_handle);  
 }
 
-Texture
+TexturePtr
 Framebuffer::get_texture()
 {
   assert(m_texture);
@@ -94,14 +94,14 @@
 Framebuffer::create_with_texture_internal(GLenum target, int width, int height, int multisample)
 {
   m_size = Size(width, height);
-  m_texture = Texture(target, width, height);
+  m_texture = Texture::create(target, width, height);
   m_depth_stencil_buffer = Renderbuffer::create(GL_DEPTH24_STENCIL8_EXT, width, height, multisample);
     
   // FIXME: Should use push/pop_framebuffer instead, but don't have pointer to Framebuffer here
   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, m_handle);
 
   // bind texture and renderbuffers to the framebuffer
-  glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, m_texture.get_target(), m_texture.get_handle(), 0);
+  glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, m_texture->get_target(), m_texture->get_handle(), 0);
   glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,   GL_RENDERBUFFER_EXT, m_depth_stencil_buffer->get_handle());
   glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, m_depth_stencil_buffer->get_handle());
 

Modified: trunk/windstille/src/display/framebuffer.hpp
===================================================================
--- trunk/windstille/src/display/framebuffer.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/framebuffer.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -38,7 +38,7 @@
 
   int get_width()  const;
   int get_height() const;
-  Texture get_texture();
+  TexturePtr get_texture();
 
   GLuint get_handle() const;
 
@@ -52,7 +52,7 @@
   GLuint m_handle;
   Size   m_size;
   
-  Texture m_texture;
+  TexturePtr m_texture;
   RenderbufferPtr m_color_buffer;
   RenderbufferPtr m_depth_stencil_buffer;
 };

Modified: trunk/windstille/src/display/opengl_state.cpp
===================================================================
--- trunk/windstille/src/display/opengl_state.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/opengl_state.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -33,7 +33,7 @@
       somebody forget the final activate() call */
   bool was_activated;
 
-  Texture     texture[MAX_TEXTURE_UNITS];
+  TexturePtr texture[MAX_TEXTURE_UNITS];
 
   Color color;
 
@@ -46,13 +46,13 @@
   /** glEnableClientState/glDisableClientState */
   std::map<GLenum, bool> client_state;
 
-  OpenGLStateImpl()
-    : was_activated(false),
-      color(),
-      blend_sfactor(GL_SRC_ALPHA),
-      blend_dfactor(GL_ONE_MINUS_SRC_ALPHA),
-      state(),
-      client_state()
+  OpenGLStateImpl() :
+    was_activated(false),
+    color(),
+    blend_sfactor(GL_SRC_ALPHA),
+    blend_dfactor(GL_ONE_MINUS_SRC_ALPHA),
+    state(),
+    client_state()
   {}
 };
 
@@ -115,7 +115,7 @@
 }
 
 void
-OpenGLState::bind_texture(const Texture& texture, int unit)
+OpenGLState::bind_texture(TexturePtr texture, int unit)
 {
   assert(unit >= 0 && unit < MAX_TEXTURE_UNITS);
   impl->texture[unit] = texture;
@@ -282,10 +282,10 @@
       {
         global_state->impl->texture[i] = impl->texture[i];
 
-        switch (impl->texture[i].get_target())
+        switch (impl->texture[i]->get_target())
         {                 
           case GL_TEXTURE_2D:
-            glBindTexture(GL_TEXTURE_2D, impl->texture[i].get_handle());
+            glBindTexture(GL_TEXTURE_2D, impl->texture[i]->get_handle());
             glEnable(GL_TEXTURE_2D);
             break;
                   
@@ -350,9 +350,9 @@
     GLint texture_handle;
     glActiveTexture(GL_TEXTURE0);
     glGetIntegerv(GL_TEXTURE_2D_BINDING_EXT, &texture_handle);
-    if (impl->texture[0] && static_cast<GLuint>(texture_handle) != impl->texture[0].get_handle())
+    if (impl->texture[0] && static_cast<GLuint>(texture_handle) != impl->texture[0]->get_handle())
     {
-      std::cout << "OpenGLState: texture handle is out of sync: " << impl->texture[0].get_handle() << std::endl;
+      std::cout << "OpenGLState: texture handle is out of sync: " << impl->texture[0]->get_handle() << std::endl;
     }
   }
   assert_gl("OpenGLState::verify");

Modified: trunk/windstille/src/display/opengl_state.hpp
===================================================================
--- trunk/windstille/src/display/opengl_state.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/opengl_state.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -22,8 +22,9 @@
 #include <GL/glew.h>
 #include <boost/scoped_ptr.hpp>
 
+#include "display/texture.hpp"
+
 class Framebuffer;
-class Texture;
 class Color;
 class OpenGLStateImpl;
 
@@ -71,7 +72,7 @@
    * Binds the given \a texture to the given texture \a unit and
    * enables texturing via glEnable(GL_TEXTURE2D) for the unit.
    */
-  void bind_texture(const Texture& texture, int unit = 0);
+  void bind_texture(TexturePtr texture, int unit = 0);
 
   void set_blend_func(GLenum sfactor, GLenum dfactor);
 

Modified: trunk/windstille/src/display/surface.cpp
===================================================================
--- trunk/windstille/src/display/surface.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/surface.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -29,7 +29,7 @@
   /**
    * Texture on which the surface is located
    */
-  Texture texture;
+  TexturePtr texture;
 
   /** 
    * uv coordinates of the Surface in [0,1] range
@@ -41,10 +41,10 @@
    */
   Sizef size;
 
-  SurfaceImpl()
-    : texture(),
-      uv(),
-      size()
+  SurfaceImpl() :
+    texture(),
+    uv(),
+    size()
   {}
 };
 
@@ -65,13 +65,13 @@
 {
   impl->size  = Size(width, height);
 
-  impl->texture = Texture(GL_TEXTURE_2D, width, height);
+  impl->texture = Texture::create(GL_TEXTURE_2D, width, height);
   impl->uv      = Rectf(0.0f, 0.0f,
-                        impl->size.width  / static_cast<float>(impl->texture.get_width()),
-                        impl->size.height / static_cast<float>(impl->texture.get_height()));
+                        impl->size.width  / static_cast<float>(impl->texture->get_width()),
+                        impl->size.height / static_cast<float>(impl->texture->get_height()));
 }
 
-Surface::Surface(Texture texture, const Rectf& uv, const Sizef& size) :
+Surface::Surface(TexturePtr texture, const Rectf& uv, const Sizef& size) :
   impl(new SurfaceImpl())
 {
   impl->texture = texture;
@@ -95,7 +95,7 @@
   return impl->size.height; 
 }
 
-Texture
+TexturePtr
 Surface::get_texture() const
 {
   return impl->texture;

Modified: trunk/windstille/src/display/surface.hpp
===================================================================
--- trunk/windstille/src/display/surface.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/surface.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -44,14 +44,14 @@
    * @param width  Width of the surface on the screen
    * @param height Height of the surface on the screen
    */
-  Surface(Texture texture, const Rectf& uv, const Sizef& size);
+  Surface(TexturePtr texture, const Rectf& uv, const Sizef& size);
   Surface(int width, int height);
   ~Surface();
   
   float get_width()  const;
   float get_height() const;
   
-  Texture get_texture() const;
+  TexturePtr get_texture() const;
 
   /** Returns texture coordinates for the Surface rectangle */
   Rectf get_uv() const;

Modified: trunk/windstille/src/display/surface_manager.cpp
===================================================================
--- trunk/windstille/src/display/surface_manager.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/surface_manager.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -68,7 +68,7 @@
     {
       float maxu = 0.0f;
       float maxv = 0.0f;
-      Texture texture;
+      TexturePtr texture;
 
       try
       {
@@ -98,7 +98,7 @@
   SoftwareSurface image(filename);
   float maxu, maxv;
 
-  Texture texture;
+  TexturePtr texture;
 
   try
   {                                                                       
@@ -128,7 +128,7 @@
   }
 }
 
-Texture
+TexturePtr
 SurfaceManager::create_texture(const SoftwareSurface& image,
                                float* maxu, float* maxv)
 {
@@ -140,7 +140,7 @@
 
   image.blit(convert, 0, 0);
 
-  Texture texture = Texture(convert);
+  TexturePtr texture = Texture::create(convert);
   
   *maxu = static_cast<float>(image.get_width())  / static_cast<float>(texture_w);
   *maxv = static_cast<float>(image.get_height()) / static_cast<float>(texture_h);

Modified: trunk/windstille/src/display/surface_manager.hpp
===================================================================
--- trunk/windstille/src/display/surface_manager.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/surface_manager.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -56,8 +56,8 @@
   void load_grid(const Pathname& filename,
                  std::vector<Surface>& surfaces, int width, int height);
 
-  Texture create_texture(const SoftwareSurface& image,
-                         float* maxu, float* maxv);
+  TexturePtr create_texture(const SoftwareSurface& image,
+                            float* maxu, float* maxv);
 
   /** Removes all cached Sprites that are no longer in use */
   void cleanup();

Modified: trunk/windstille/src/display/texture.cpp
===================================================================
--- trunk/windstille/src/display/texture.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/texture.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -28,51 +28,49 @@
 #include "display/texture_manager.hpp"
 #include "display/assert_gl.hpp"
 
-class TextureImpl
+static inline bool is_power_of_2(int v)
 {
-public:
-  GLenum target;
-  GLuint handle;
-  int    width;
-  int    height;
-
-  TextureImpl()
-    : target(0),
-      handle(0),
-      width(0),
-      height(0)
-  {
-    glGenTextures(1, &handle);
-    assert_gl("creating texture handle."); 
-  }
-
-  ~TextureImpl()
-  {
-    glDeleteTextures(1, &handle);
-  }
-};
+  return (v & (v-1)) == 0;
+}
 
-Texture::Texture() :
-  impl()
+TexturePtr
+Texture::create(const Pathname& filename)
 {
+  return TextureManager::current()->get(filename);
 }
 
-Texture::Texture(const Pathname& filename) :
-  impl()
+TexturePtr
+Texture::create(const SoftwareSurface& image, GLint format)
 {
-  *this = TextureManager::current()->get(filename);
+  return TexturePtr(new Texture(image, format));
 }
+  
+TexturePtr
+Texture::create(GLenum target, int width, int height, GLint format)
+{
+  return TexturePtr(new Texture(target, width, height, format));
+}
+
+Texture::Texture() :
+  m_target(0),
+  m_handle(0),
+  m_width(0),
+  m_height(0)
+{
+  glGenTextures(1, &m_handle);
+  assert_gl("Texture::Texture()"); 
+}
 
 Texture::Texture(GLenum target, int width, int height, GLint format) :
-  impl(new TextureImpl())
+  m_target(target),
+  m_handle(0),
+  m_width(width),
+  m_height(height)
 {
-  impl->target = target;
-  impl->width  = width;
-  impl->height = height;
+  glGenTextures(1, &m_handle);
+  assert_gl("Texture::Texture()"); 
 
-  OpenGLState state;
-  state.bind_texture(*this);
-  state.activate();
+  glBindTexture(GL_TEXTURE_2D, m_handle);
 
   glTexImage2D(target, 0, format, width, height, 0, GL_RGBA,
                GL_UNSIGNED_BYTE, 0);
@@ -84,17 +82,14 @@
   glTexParameteri(target, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
 }
 
-static inline bool is_power_of_2(int v)
-{
-  return (v & (v-1)) == 0;
-}
-
 Texture::Texture(const SoftwareSurface& image, GLint glformat) :
-  impl(new TextureImpl())
+  m_target(GL_TEXTURE_2D),
+  m_handle(0),
+  m_width(image.get_width()),
+  m_height(image.get_height())
 {
-  impl->target = GL_TEXTURE_2D;
-  impl->width  = image.get_width();
-  impl->height = image.get_height();
+  glGenTextures(1, &m_handle);
+  assert_gl("Texture::Texture()"); 
 
   // Should be ok with OpenGL2.0
   //if(!is_power_of_2(image.get_width()) || !is_power_of_2(image.get_height()))
@@ -131,25 +126,23 @@
       throw std::runtime_error("Texture: Image format not supported");
     }
 
-    OpenGLState state;
-    state.bind_texture(*this);
-    state.activate();
+    glBindTexture(GL_TEXTURE_2D, m_handle);
 
     glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
     glPixelStorei(GL_UNPACK_ROW_LENGTH, image.get_pitch() / image.get_bytes_per_pixel());
 
     if (0)
     { // no mipmapping
-      glTexImage2D(impl->target, 0, glformat,
+      glTexImage2D(m_target, 0, glformat,
                    image.get_width(), image.get_height(), 0, sdl_format,
                    GL_UNSIGNED_BYTE, image.get_pixels());
         
-      glTexParameteri(impl->target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-      glTexParameteri(impl->target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri(m_target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexParameteri(m_target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
     }
     else
     { // use mipmapping
-      gluBuild2DMipmaps(impl->target, glformat,
+      gluBuild2DMipmaps(m_target, glformat,
                         image.get_width(), image.get_height(), sdl_format,
                         GL_UNSIGNED_BYTE, image.get_pixels());
         
@@ -159,9 +152,9 @@
 
     assert_gl("creating texture");
 
-    glTexParameteri(impl->target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-    glTexParameteri(impl->target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-    glTexParameteri(impl->target, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
+    glTexParameteri(m_target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameteri(m_target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    glTexParameteri(m_target, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
 
     assert_gl("setting texture parameters");
   } 
@@ -173,24 +166,25 @@
 
 Texture::~Texture()
 {
+  glDeleteTextures(1, &m_handle);
 }
 
 int
 Texture::get_width() const
 {
-  return impl->width;
+  return m_width;
 }
 
 int
 Texture::get_height() const
 {
-  return impl->height;
+  return m_height;
 }
 
 GLuint
 Texture::get_handle() const
 {
-  return impl->handle;
+  return m_handle;
 }
 
 void
@@ -211,16 +205,14 @@
     throw std::runtime_error("Texture: Image format not supported");
   }
 
-  OpenGLState state;
-  state.bind_texture(*this);
-  state.activate();
+  glBindTexture(GL_TEXTURE_2D, m_handle);
 
   // FIXME: Add some checks here to make sure image has the right format 
   glPixelStorei(GL_UNPACK_ALIGNMENT, 4); // FIXME: Does SDL always use 4?
   glPixelStorei(GL_UNPACK_ROW_LENGTH,
                 image.get_pitch() / image.get_bytes_per_pixel());
 
-  glTexSubImage2D(impl->target, 0, x, y,
+  glTexSubImage2D(m_target, 0, x, y,
                   srcrect.get_width(), srcrect.get_height(), sdl_format, GL_UNSIGNED_BYTE,
                   static_cast<uint8_t*>(image.get_pixels())
                   + srcrect.top  * image.get_pitch()
@@ -236,67 +228,38 @@
 void
 Texture::set_wrap(GLenum mode)
 {
-  OpenGLState state;
-  state.bind_texture(*this);
-  state.activate();
+  glBindTexture(GL_TEXTURE_2D, m_handle);
 
-  glTexParameteri(impl->target, GL_TEXTURE_WRAP_S, mode);
-  glTexParameteri(impl->target, GL_TEXTURE_WRAP_T, mode);
-  glTexParameteri(impl->target, GL_TEXTURE_WRAP_R, mode); // FIXME: only good for 3d textures?!
+  glTexParameteri(m_target, GL_TEXTURE_WRAP_S, mode);
+  glTexParameteri(m_target, GL_TEXTURE_WRAP_T, mode);
+  glTexParameteri(m_target, GL_TEXTURE_WRAP_R, mode); // FIXME: only good for 3d textures?!
 }
 
 void
 Texture::set_filter(GLenum mode)
 {
-  OpenGLState state;
-  state.bind_texture(*this);
-  state.activate();
+  glBindTexture(GL_TEXTURE_2D, m_handle);
 
-  glTexParameteri(impl->target, GL_TEXTURE_MIN_FILTER, mode);
-  glTexParameteri(impl->target, GL_TEXTURE_MAG_FILTER, mode);
+  glTexParameteri(m_target, GL_TEXTURE_MIN_FILTER, mode);
+  glTexParameteri(m_target, GL_TEXTURE_MAG_FILTER, mode);
 }
 
 SoftwareSurface
 Texture::get_software_surface() const
 {
-  OpenGLState state;
-  state.bind_texture(*this);
-  state.activate();
+  glBindTexture(GL_TEXTURE_2D, m_handle);
 
-  SoftwareSurface surface(impl->width, impl->height);
+  SoftwareSurface surface(m_width, m_height);
 
   glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_UNSIGNED_BYTE, surface.get_pixels());
 
   return surface;
 }
 
-Texture::operator bool() const
-{
-  return impl.get();
-}
-
-bool
-Texture::operator==(const Texture& other) const
-{
-  return impl.get() == other.impl.get();
-}
-
-bool
-Texture::operator!=(const Texture& other) const
-{
-  return impl.get() != other.impl.get();
-}
-
 GLenum
 Texture::get_target() const
 {
-  return impl->target;
+  return m_target;
 }
-
-int
-Texture::use_count() const
-{
-  return impl.use_count();
-}
 
 /* EOF */

Modified: trunk/windstille/src/display/texture.hpp
===================================================================
--- trunk/windstille/src/display/texture.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/texture.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -31,32 +31,34 @@
 class TextureImpl;
 class Rect;
 
+class Texture;
+typedef boost::shared_ptr<Texture> TexturePtr;
+
 class Texture
 {
 public:
-  /** Create a empty and invalid Texture object (similar to a
-      NULL-pointer) */
-  explicit Texture();
-
   /** Load a texture from file */
-  explicit Texture(const Pathname& filename);
+  static TexturePtr create(const Pathname& filename);
 
   /**
    * Upload an SoftwareSurface onto an OpenGL texture. The surface must have power
    * of 2 dimensions
    * */
-  explicit Texture(const SoftwareSurface& image, GLint format = GL_RGBA);
-
+  static TexturePtr create(const SoftwareSurface& image, GLint format = GL_RGBA);
+  
   /** 
    * Create an empty Texture with the given dimensions
    */
-  explicit Texture(GLenum target, int width, int height, GLint format = GL_RGBA);
+  static TexturePtr create(GLenum target, int width, int height, GLint format = GL_RGBA);
+  
+private:
+  Texture();
+  Texture(const SoftwareSurface& image, GLint format = GL_RGBA);
+  Texture(GLenum target, int width, int height, GLint format = GL_RGBA);
 
+public:
   ~Texture();
 
-  bool operator==(const Texture&) const;
-  bool operator!=(const Texture&) const;
-
   int get_width() const;
   int get_height() const;
 
@@ -83,13 +85,11 @@
 
   SoftwareSurface get_software_surface() const;
 
-  int use_count() const;
-
-  /** true if the Texture is valid and usable, false if not */
-  operator bool() const;
-
 private:
-  boost::shared_ptr<TextureImpl> impl;
+  GLenum m_target;
+  GLuint m_handle;
+  int    m_width;
+  int    m_height;
 };
 
 #endif

Modified: trunk/windstille/src/display/texture_manager.cpp
===================================================================
--- trunk/windstille/src/display/texture_manager.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/texture_manager.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -38,7 +38,7 @@
 #endif
 }
 
-Texture
+TexturePtr
 TextureManager::get(const Pathname& filename)
 {
   Textures::iterator i = textures.find(filename);
@@ -51,7 +51,7 @@
     try 
     {
       SoftwareSurface image(filename);
-      Texture texture(image);
+      TexturePtr texture = Texture::create(image);
 
       textures.insert(std::make_pair(filename, texture));
 

Modified: trunk/windstille/src/display/texture_manager.hpp
===================================================================
--- trunk/windstille/src/display/texture_manager.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/texture_manager.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -24,11 +24,10 @@
 #include <GL/glew.h>
 #include <GL/gl.h>
 
+#include "display/texture.hpp"
 #include "util/currenton.hpp"
 #include "util/pathname.hpp"
 
-class Texture;
-
 /**
  * This class manages a map of image files to OpenGL textures.
  */
@@ -46,12 +45,12 @@
    * SurfaceManager for images with other dimensions.
    * Note: Texture is a refcounted class, store it with Ref<Texture>
    */
-  Texture get(const Pathname& filename);
+  TexturePtr get(const Pathname& filename);
 
   void cleanup();
 
 private:
-  typedef std::map<Pathname, Texture> Textures;
+  typedef std::map<Pathname, TexturePtr> Textures;
   Textures textures;
 };
 

Modified: trunk/windstille/src/display/texture_packer.cpp
===================================================================
--- trunk/windstille/src/display/texture_packer.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/texture_packer.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -33,11 +33,11 @@
   boost::scoped_ptr<TextureSpace> right;
 
 public:
-  TextureSpace(const Rect& rect_)
-    : rect(rect_),
-      used(false),
-      left(),
-      right()
+  TextureSpace(const Rect& rect_) :
+    rect(rect_),
+    used(false),
+    left(),
+    right()
   {}
 
   ~TextureSpace()
@@ -87,12 +87,12 @@
 class TexturePackerTexture
 {
 private:
-  Texture        texture;
+  TexturePtr     texture;
   TextureSpace   space;
 
 public:
   TexturePackerTexture(const Size& size)
-    : texture(GL_TEXTURE_2D, size.width, size.height),
+    : texture(Texture::create(GL_TEXTURE_2D, size.width, size.height)),
       space(Rect(Point(0, 0), size))
   {
   }
@@ -100,9 +100,9 @@
   ~TexturePackerTexture()
   {}
 
-  Texture get_texture() const { return texture; }
+  TexturePtr get_texture() const { return texture; }
 
-  bool allocate(const Size& size, Rect& out_rect, Texture& out_texture)
+  bool allocate(const Size& size, Rect& out_rect, TexturePtr& out_texture)
   {
     if (space.allocate(size, out_rect))
     {
@@ -134,18 +134,18 @@
 }
   
 bool
-TexturePacker::allocate(const Size& size, Rect& rect, Texture& texture)
+TexturePacker::allocate(const Size& size, Rect& rect, TexturePtr& out_texture)
 {
   for(Textures::iterator i = textures.begin(); i != textures.end(); ++i)
   {
-    if ((*i)->allocate(size, rect, texture))
+    if ((*i)->allocate(size, rect, out_texture))
     {
       return true;
     }
   }
 
   textures.push_back(new TexturePackerTexture(texture_size));
-  return textures.back()->allocate(size, rect, texture);
+  return textures.back()->allocate(size, rect, out_texture);
 }
 
 Surface
@@ -156,7 +156,7 @@
 
   Size    size(surface.get_width()+2, surface.get_height()+2);
   Rect    rect;
-  Texture texture;
+  TexturePtr texture;
 
   if (!allocate(size, rect, texture))
   {
@@ -167,36 +167,36 @@
     // duplicate border pixel
 
     // top
-    texture.put(surface, Rect(Point(0, 0), Size(surface.get_width(), 1)), 
+    texture->put(surface, Rect(Point(0, 0), Size(surface.get_width(), 1)), 
                 rect.left+1, rect.top);
     // bottom
-    texture.put(surface, Rect(Point(0, surface.get_height()-1), Size(surface.get_width(), 1)), 
+    texture->put(surface, Rect(Point(0, surface.get_height()-1), Size(surface.get_width(), 1)), 
                 rect.left+1, rect.bottom-1);
     // left
-    texture.put(surface, Rect(Point(0, 0), Size(1, surface.get_height())), 
+    texture->put(surface, Rect(Point(0, 0), Size(1, surface.get_height())), 
                 rect.left, rect.top+1);
     // right
-    texture.put(surface, Rect(Point(surface.get_width()-1, 0), Size(1, surface.get_height())),
+    texture->put(surface, Rect(Point(surface.get_width()-1, 0), Size(1, surface.get_height())),
                 rect.right-1, rect.top+1);
 
     // duplicate corner pixels
-    texture.put(surface, Rect(Point(0, 0), Size(1, 1)), 
+    texture->put(surface, Rect(Point(0, 0), Size(1, 1)), 
                 rect.left, rect.top);     
-    texture.put(surface, Rect(Point(surface.get_width()-1, 0), Size(1, 1)), 
+    texture->put(surface, Rect(Point(surface.get_width()-1, 0), Size(1, 1)), 
                 rect.right-1, rect.top);
-    texture.put(surface, Rect(Point(surface.get_width()-1, surface.get_height()-1), Size(1, 1)), 
+    texture->put(surface, Rect(Point(surface.get_width()-1, surface.get_height()-1), Size(1, 1)), 
                 rect.right-1, rect.bottom-1);
-    texture.put(surface, Rect(Point(0, surface.get_height()-1), Size(1, 1)),
+    texture->put(surface, Rect(Point(0, surface.get_height()-1), Size(1, 1)),
                 rect.left, rect.bottom-1);
 
     // draw the main surface
-    texture.put(surface, rect.left+1, rect.top+1);
+    texture->put(surface, rect.left+1, rect.top+1);
 
     return Surface(texture,
-                   Rectf(static_cast<float>(rect.left+1)   / static_cast<float>(texture.get_width()),
-                         static_cast<float>(rect.top+1)    / static_cast<float>(texture.get_height()),
-                         static_cast<float>(rect.right-1)  / static_cast<float>(texture.get_width()), 
-                         static_cast<float>(rect.bottom-1) / static_cast<float>(texture.get_height())),
+                   Rectf(static_cast<float>(rect.left+1)   / static_cast<float>(texture->get_width()),
+                         static_cast<float>(rect.top+1)    / static_cast<float>(texture->get_height()),
+                         static_cast<float>(rect.right-1)  / static_cast<float>(texture->get_width()), 
+                         static_cast<float>(rect.bottom-1) / static_cast<float>(texture->get_height())),
                    Sizef(static_cast<float>(surface.get_width()), static_cast<float>(surface.get_height())));
   }
 }
@@ -206,8 +206,8 @@
 {
   for(Textures::const_iterator i = textures.begin(); i != textures.end(); ++i)
   {
-    Texture texture = (*i)->get_texture();
-    SoftwareSurface surface = texture.get_software_surface();
+    TexturePtr texture = (*i)->get_texture();
+    SoftwareSurface surface = texture->get_software_surface();
 
     char filename[1024];
     sprintf(filename, "/tmp/texture_packer%04d.png", int(i - textures.begin()));

Modified: trunk/windstille/src/display/texture_packer.hpp
===================================================================
--- trunk/windstille/src/display/texture_packer.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/display/texture_packer.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -42,7 +42,7 @@
   ~TexturePacker();
   
   Surface upload(const SoftwareSurface& surface);
-  bool    allocate(const Size& size, Rect& rect, Texture& texture);
+  bool    allocate(const Size& size, Rect& rect, TexturePtr& out_texture);
   
   void save_all_as_png() const;
 

Modified: trunk/windstille/src/font/ttf_font.cpp
===================================================================
--- trunk/windstille/src/font/ttf_font.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/font/ttf_font.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -52,12 +52,12 @@
   int size;
 
   /** OpenGL Texture which holds all the characters */
-  Texture texture;
+  TexturePtr texture;
 
-  TTFFontImpl()
-    : characters(),
-      size(0),
-      texture()
+  TTFFontImpl() :
+    characters(),
+    size(0),
+    texture()
   {}
 };
 
@@ -149,7 +149,7 @@
   }
   FT_Done_Face(face);
 
-  impl->texture = Texture(pixelbuffer);
+  impl->texture = Texture::create(pixelbuffer);
 }
 
 TTFFont::~TTFFont()
@@ -225,7 +225,7 @@
   return width;
 }
 
-Texture
+TexturePtr
 TTFFont::get_texture() const
 {
   return impl->texture;

Modified: trunk/windstille/src/font/ttf_font.hpp
===================================================================
--- trunk/windstille/src/font/ttf_font.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/font/ttf_font.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -73,7 +73,7 @@
       FontEffoct */
   int get_size() const;
 
-  Texture get_texture() const;
+  TexturePtr get_texture() const;
 
   const TTFCharacter& get_character(int c) const;
   void draw(const Vector2f& pos, const std::string& str, const Color& color = Color(1.0f, 1.0f, 1.0f));

Modified: trunk/windstille/src/gui/automap.cpp
===================================================================
--- trunk/windstille/src/gui/automap.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/gui/automap.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -67,8 +67,8 @@
     }
 
   surface = Surface(tilemap->get_width(), tilemap->get_height());
-  surface.get_texture().set_filter(GL_NEAREST);
-  surface.get_texture().put(image, 0, 0);
+  surface.get_texture()->set_filter(GL_NEAREST);
+  surface.get_texture()->put(image, 0, 0);
 }
 
 Automap::~Automap()

Modified: trunk/windstille/src/objects/laser_pointer.cpp
===================================================================
--- trunk/windstille/src/objects/laser_pointer.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/objects/laser_pointer.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -29,12 +29,12 @@
   progress(),
   angle()
 {
-  noise = Texture(Pathname("images/noise2.png"));
+  noise = Texture::create(Pathname("images/noise2.png"));
   laserpointer = Sprite(Pathname("images/laserpointer.sprite"));
   laserpointer_light = Sprite(Pathname("images/laserpointer_light.sprite"));
   laserpointer_light.set_blend_func(GL_SRC_ALPHA, GL_ONE);
-  noise.set_wrap(GL_REPEAT);
-  noise.set_filter(GL_LINEAR);
+  noise->set_wrap(GL_REPEAT);
+  noise->set_filter(GL_LINEAR);
   
   progress = 0.0f;
   angle = 0.0f;

Modified: trunk/windstille/src/objects/laser_pointer.hpp
===================================================================
--- trunk/windstille/src/objects/laser_pointer.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/objects/laser_pointer.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -27,7 +27,7 @@
 class LaserPointer : public GameObject
 {
 private:
-  Texture noise;
+  TexturePtr noise;
   Sprite  laserpointer;
   Sprite  laserpointer_light;
   float   progress;

Modified: trunk/windstille/src/objects/liquid.cpp
===================================================================
--- trunk/windstille/src/objects/liquid.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/objects/liquid.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -56,8 +56,8 @@
   for(int i = 50; i < 70 && i < int(heightfield1->size()); ++i)
     (*heightfield1)[i] += 0.0025f;
 
-  texture = Texture(Pathname("images/textures/water.png"));
-  texture.set_wrap(GL_REPEAT);
+  texture = Texture::create(Pathname("images/textures/water.png"));
+  texture->set_wrap(GL_REPEAT);
   
   m_water_top.reset(new VertexArrayDrawable(Vector2f(pos.x, pos.y), 10000,
                                             Matrix::identity())); //sc.light().get_modelview()));

Modified: trunk/windstille/src/objects/liquid.hpp
===================================================================
--- trunk/windstille/src/objects/liquid.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/objects/liquid.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -28,7 +28,7 @@
 class Liquid : public Entity
 {
 private:
-  Texture texture;
+  TexturePtr texture;
   float t;
 
   std::vector<float> heightfield_store1;

Modified: trunk/windstille/src/objects/nightvision.cpp
===================================================================
--- trunk/windstille/src/objects/nightvision.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/objects/nightvision.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -24,11 +24,11 @@
 
 Nightvision::Nightvision(const FileReader& props) :
   nightvision(Pathname("images/nightvision.sprite")),
-  noise(Pathname("images/noise.png"))
+  noise(Texture::create(Pathname("images/noise.png")))
 {
   name = "nightvision";
-  noise.set_wrap(GL_REPEAT);
-  noise.set_filter(GL_LINEAR);
+  noise->set_wrap(GL_REPEAT);
+  noise->set_filter(GL_LINEAR);
 }
 
 Nightvision::~Nightvision()

Modified: trunk/windstille/src/objects/nightvision.hpp
===================================================================
--- trunk/windstille/src/objects/nightvision.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/objects/nightvision.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -28,7 +28,7 @@
 {
 private:
   Sprite  nightvision;
-  Texture noise;
+  TexturePtr noise;
 
 public:
   Nightvision(const FileReader& props);

Modified: trunk/windstille/src/objects/shockwave.cpp
===================================================================
--- trunk/windstille/src/objects/shockwave.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/objects/shockwave.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -24,7 +24,7 @@
 
 Shockwave::Shockwave(const FileReader& props) :
   pos(),
-  noise(Pathname("images/noise3.png")),
+  noise(Texture::create(Pathname("images/noise3.png"))),
   shader_program(),
   radius()
 {
@@ -32,8 +32,8 @@
   
   radius = 100.0f;
 
-  noise.set_wrap(GL_REPEAT);
-  noise.set_filter(GL_LINEAR);
+  noise->set_wrap(GL_REPEAT);
+  noise->set_filter(GL_LINEAR);
 
   shader_program.attach(ShaderObject(GL_FRAGMENT_SHADER, "data/shader/shockwave2.frag"));
   shader_program.link();

Modified: trunk/windstille/src/objects/shockwave.hpp
===================================================================
--- trunk/windstille/src/objects/shockwave.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/objects/shockwave.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -27,7 +27,7 @@
 {
 private:
   Vector2f        pos;
-  Texture       noise;
+  TexturePtr noise;
   ShaderProgram shader_program;
   float radius;
 

Modified: trunk/windstille/src/particles/deform_drawer.cpp
===================================================================
--- trunk/windstille/src/particles/deform_drawer.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/particles/deform_drawer.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -140,7 +140,7 @@
     glPopMatrix();
   }
 
-  void prepare(const Texture& screen_texture) 
+  void prepare(TexturePtr screen_texture) 
   {
     OpenGLState state;
     state.bind_texture(screen_texture);

Modified: trunk/windstille/src/scenegraph/fill_screen_pattern_drawable.hpp
===================================================================
--- trunk/windstille/src/scenegraph/fill_screen_pattern_drawable.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/scenegraph/fill_screen_pattern_drawable.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -20,19 +20,20 @@
 #define HEADER_WINDSTILLE_SCENEGRAPH_FILL_SCREEN_PATTERN_DRAWABLE_HPP
 
 #include "display/opengl_state.hpp"
+#include "display/texture.hpp"
 #include "scenegraph/drawable.hpp"
 
 class FillScreenPatternDrawable : public Drawable
 {
 private:
-  Texture  m_texture;
+  TexturePtr m_texture;
   Vector2f m_offset;
 
 public:
-  FillScreenPatternDrawable(const Texture& texture, const Vector2f& offset)
-    : Drawable(Vector2f(0, 0), -1000.0f), 
-      m_texture(texture),
-      m_offset(offset)
+  FillScreenPatternDrawable(TexturePtr texture, const Vector2f& offset) :
+    Drawable(Vector2f(0, 0), -1000.0f),
+    m_texture(texture),
+    m_offset(offset)
   {}
 
   virtual ~FillScreenPatternDrawable() {}
@@ -50,14 +51,14 @@
     state.bind_texture(m_texture);
     state.activate();
 
-    float u = static_cast<float>(Display::get_width())  / static_cast<float>(m_texture.get_width());
-    float v = static_cast<float>(Display::get_height()) / static_cast<float>(m_texture.get_height());
+    float u = static_cast<float>(Display::get_width())  / static_cast<float>(m_texture->get_width());
+    float v = static_cast<float>(Display::get_height()) / static_cast<float>(m_texture->get_height());
 
-    float u_start = -m_offset.x / static_cast<float>(m_texture.get_width());
-    float v_start = -m_offset.y / static_cast<float>(m_texture.get_height());
+    float u_start = -m_offset.x / static_cast<float>(m_texture->get_width());
+    float v_start = -m_offset.y / static_cast<float>(m_texture->get_height());
 
-    u -= m_offset.x / static_cast<float>(m_texture.get_width());
-    v -= m_offset.y / static_cast<float>(m_texture.get_height());
+    u -= m_offset.x / static_cast<float>(m_texture->get_width());
+    v -= m_offset.y / static_cast<float>(m_texture->get_height());
 
     glPushMatrix();
     glLoadIdentity();

Modified: trunk/windstille/src/scenegraph/shockwave_drawable.hpp
===================================================================
--- trunk/windstille/src/scenegraph/shockwave_drawable.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/scenegraph/shockwave_drawable.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -24,19 +24,19 @@
 class ShockwaveDrawable : public Drawable
 {
 public:
-  Texture       noise;
+  TexturePtr noise;
   ShaderProgram shader_program;
   float radius;
 
   ShockwaveDrawable(const Vector2f& pos_, 
-                    const Texture&       noise_,
+                    TexturePtr      noise_,
                     const ShaderProgram& shader_program_,
                     float r,
-                    const Matrix& modelview_) 
-    : Drawable(pos_, 500.0f, modelview_),
-      noise(noise_),
-      shader_program(shader_program_),
-      radius(r)
+                    const Matrix& modelview_) :
+    Drawable(pos_, 500.0f, modelview_), 
+    noise(noise_),
+    shader_program(shader_program_),
+    radius(r)
   {
   }
 

Modified: trunk/windstille/src/scenegraph/vertex_array_drawable.cpp
===================================================================
--- trunk/windstille/src/scenegraph/vertex_array_drawable.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/scenegraph/vertex_array_drawable.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -20,15 +20,15 @@
 #include "scenegraph/vertex_array_drawable.hpp"
 
 VertexArrayDrawable::VertexArrayDrawable(const Vector2f& pos_, float z_pos_, 
-                                         const Matrix& modelview_)
-  : Drawable(pos_, z_pos_, modelview_),
-    mode(GL_QUADS),
-    blend_sfactor(GL_SRC_ALPHA),
-    blend_dfactor(GL_ONE_MINUS_SRC_ALPHA),
-    texture(),
-    colors(),
-    texcoords(),
-    vertices()
+                                         const Matrix& modelview_) :
+  Drawable(pos_, z_pos_, modelview_),
+  mode(GL_QUADS),
+  blend_sfactor(GL_SRC_ALPHA),
+  blend_dfactor(GL_ONE_MINUS_SRC_ALPHA),
+  texture(),
+  colors(),
+  texcoords(),
+  vertices()
 {
 }
 
@@ -173,7 +173,7 @@
 }
 
 void
-VertexArrayDrawable::set_texture(Texture texture_)
+VertexArrayDrawable::set_texture(TexturePtr texture_)
 {
   texture = texture_;
 }

Modified: trunk/windstille/src/scenegraph/vertex_array_drawable.hpp
===================================================================
--- trunk/windstille/src/scenegraph/vertex_array_drawable.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/scenegraph/vertex_array_drawable.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -32,7 +32,7 @@
   GLenum blend_sfactor;
   GLenum blend_dfactor;
 
-  Texture texture;
+  TexturePtr texture;
   std::vector<unsigned char> colors;
   std::vector<float> texcoords;
   std::vector<float> vertices;
@@ -61,7 +61,7 @@
   void clear();
 
   void set_mode(GLenum mode_);
-  void set_texture(Texture texture);
+  void set_texture(TexturePtr texture);
   void set_blend_func(GLenum sfactor, GLenum dfactor);
 };
 

Modified: trunk/windstille/src/screen/particle_viewer.cpp
===================================================================
--- trunk/windstille/src/screen/particle_viewer.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/screen/particle_viewer.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -76,8 +76,8 @@
 
   {
     // Build the SceneGraph
-    Texture pattern_texture(Pathname("images/greychess.png"));
-    pattern_texture.set_wrap(GL_REPEAT);
+    TexturePtr pattern_texture = Texture::create(Pathname("images/greychess.png"));
+    pattern_texture->set_wrap(GL_REPEAT);
 
     m_background_drawable.reset(new FillScreenPatternDrawable(pattern_texture, Vector2f()));
     m_color_fill_drawable.reset(new FillScreenDrawable(Color(0.4f, 0.4f, 0.4f)));

Modified: trunk/windstille/src/sprite3d/data.hpp
===================================================================
--- trunk/windstille/src/sprite3d/data.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/sprite3d/data.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -68,7 +68,7 @@
  */
 struct Mesh
 {
-  Texture   texture;
+  TexturePtr   texture;
 
   uint16_t  vertex_count;
   uint16_t  triangle_count;

Modified: trunk/windstille/src/tile/tile.hpp
===================================================================
--- trunk/windstille/src/tile/tile.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/tile/tile.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -52,7 +52,7 @@
    */
   int     packer;
   Rectf   uv;
-  Texture texture;
+  TexturePtr texture;
 
   /** bitmap that holds the collision attributes for this tile */
   unsigned int colmap;

Modified: trunk/windstille/src/tile/tile_packer.cpp
===================================================================
--- trunk/windstille/src/tile/tile_packer.cpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/tile/tile_packer.cpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -32,7 +32,7 @@
   int x_pos;
   int y_pos;
 
-  Texture texture;
+  TexturePtr texture;
 
   int width;
   int height;
@@ -55,7 +55,7 @@
   impl->width  = width;
   impl->height = height;
 
-  impl->texture = Texture(GL_TEXTURE_2D, width, height);
+  impl->texture = Texture::create(GL_TEXTURE_2D, width, height);
         
   assert_gl("setting TilePacker texture parameters"); 
 }
@@ -90,7 +90,7 @@
 
   generate_border(convert, 1, 1, TILE_RESOLUTION, TILE_RESOLUTION);
 
-  impl->texture.put(convert, impl->x_pos, impl->y_pos);
+  impl->texture->put(convert, impl->x_pos, impl->y_pos);
   
   assert_gl("updating tilepacker texture");
 
@@ -118,7 +118,7 @@
   return (impl->y_pos + TILE_RESOLUTION + 2 > impl->height);
 }
 
-Texture
+TexturePtr
 TilePacker::get_texture() const
 {
   return impl->texture;

Modified: trunk/windstille/src/tile/tile_packer.hpp
===================================================================
--- trunk/windstille/src/tile/tile_packer.hpp	2010-09-21 20:45:18 UTC (rev 3362)
+++ trunk/windstille/src/tile/tile_packer.hpp	2010-09-21 21:54:02 UTC (rev 3363)
@@ -47,7 +47,7 @@
   /** Return true if the PixelBuffer is full */
   bool is_full() const;
 
-  Texture get_texture() const;
+  TexturePtr get_texture() const;
 
 private:
   boost::scoped_ptr<TilePackerImpl> impl;



From grumbel at mail.berlios.de  Wed Sep 22 12:16:27 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed, 22 Sep 2010 12:16:27 +0200
Subject: [Windstille-commit] r3364 - in trunk/windstille/src: display gui
	objects particles scenegraph sprite2d
Message-ID: <20100922101627.25BBD480F56@sheep.berlios.de>

Author: grumbel
Date: 2010-09-22 12:16:26 +0200 (Wed, 22 Sep 2010)
New Revision: 3364

Modified:
   trunk/windstille/src/display/basic_compositor_impl.cpp
   trunk/windstille/src/display/basic_compositor_impl.hpp
   trunk/windstille/src/display/drawing_context.cpp
   trunk/windstille/src/display/drawing_context.hpp
   trunk/windstille/src/display/surface.cpp
   trunk/windstille/src/display/surface.hpp
   trunk/windstille/src/display/surface_manager.cpp
   trunk/windstille/src/display/surface_manager.hpp
   trunk/windstille/src/display/texture_packer.cpp
   trunk/windstille/src/display/texture_packer.hpp
   trunk/windstille/src/gui/automap.cpp
   trunk/windstille/src/gui/automap.hpp
   trunk/windstille/src/objects/decal.cpp
   trunk/windstille/src/particles/deform_drawer.cpp
   trunk/windstille/src/particles/deform_drawer.hpp
   trunk/windstille/src/particles/surface_drawer.cpp
   trunk/windstille/src/particles/surface_drawer.hpp
   trunk/windstille/src/scenegraph/control_drawable.hpp
   trunk/windstille/src/scenegraph/surface_drawable.hpp
   trunk/windstille/src/scenegraph/surface_quad_drawable.hpp
   trunk/windstille/src/sprite2d/data.cpp
   trunk/windstille/src/sprite2d/data.hpp
   trunk/windstille/src/sprite2d/sprite.cpp
   trunk/windstille/src/sprite2d/sprite.hpp
Log:
Replaced Surface with SurfacePtr


Modified: trunk/windstille/src/display/basic_compositor_impl.cpp
===================================================================
--- trunk/windstille/src/display/basic_compositor_impl.cpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/display/basic_compositor_impl.cpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -30,8 +30,8 @@
 
 BasicCompositorImpl::BasicCompositorImpl(const Size& window, const Size& viewport) :
   CompositorImpl(window, viewport),
-  m_lightmap(m_window.width  / LIGHTMAP_DIV,
-             m_window.height / LIGHTMAP_DIV)
+  m_lightmap(Surface::create(m_window.width  / LIGHTMAP_DIV,
+                             m_window.height / LIGHTMAP_DIV))
 {
 }
 
@@ -39,10 +39,10 @@
 BasicCompositorImpl::render(SceneContext& sc, SceneGraph* sg, const GraphicContextState& gc_state)
 {
   // Resize Lightmap, only needed in the editor, FIXME: move this into a 'set_size()' call
-  if (m_lightmap.get_width()  != m_window.width /LIGHTMAP_DIV ||
-      m_lightmap.get_height() != m_window.height/LIGHTMAP_DIV)
+  if (m_lightmap->get_width()  != m_window.width /LIGHTMAP_DIV ||
+      m_lightmap->get_height() != m_window.height/LIGHTMAP_DIV)
   {
-    m_lightmap = Surface(m_window.width / LIGHTMAP_DIV, m_window.height / LIGHTMAP_DIV);
+    m_lightmap = Surface::create(m_window.width / LIGHTMAP_DIV, m_window.height / LIGHTMAP_DIV);
   }
 
   if (sc.get_render_mask() & SceneContext::LIGHTMAPSCREEN)
@@ -68,16 +68,16 @@
     { // Copy lightmap to a texture
       OpenGLState state;
         
-      state.bind_texture(m_lightmap.get_texture());
+      state.bind_texture(m_lightmap->get_texture());
       state.activate();
 
       glCopyTexSubImage2D(GL_TEXTURE_2D, 
                           0,    // mipmap level
                           0, 0, // xoffset, yoffset
                           0, // x
-                          m_window.height - static_cast<GLsizei>(m_lightmap.get_height()), // y (OpenGL is upside down)
-                          static_cast<GLsizei>(m_lightmap.get_width()), 
-                          static_cast<GLsizei>(m_lightmap.get_height()));
+                          m_window.height - static_cast<GLsizei>(m_lightmap->get_height()), // y (OpenGL is upside down)
+                          static_cast<GLsizei>(m_lightmap->get_width()), 
+                          static_cast<GLsizei>(m_lightmap->get_height()));
     }
   }
 
@@ -102,7 +102,7 @@
   { // Renders the lightmap to the screen     
     OpenGLState state;
 
-    state.bind_texture(m_lightmap.get_texture());
+    state.bind_texture(m_lightmap->get_texture());
 
     state.enable(GL_BLEND);
     state.set_blend_func(GL_DST_COLOR, GL_ZERO);

Modified: trunk/windstille/src/display/basic_compositor_impl.hpp
===================================================================
--- trunk/windstille/src/display/basic_compositor_impl.hpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/display/basic_compositor_impl.hpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -25,7 +25,7 @@
 class BasicCompositorImpl : public CompositorImpl
 {
 private:
-  Surface m_lightmap;
+  SurfacePtr m_lightmap;
 
 public:
   BasicCompositorImpl(const Size& window, const Size& viewport);

Modified: trunk/windstille/src/display/drawing_context.cpp
===================================================================
--- trunk/windstille/src/display/drawing_context.cpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/display/drawing_context.cpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -99,7 +99,7 @@
 }
 
 void
-DrawingContext::draw(const Surface surface, const Vector2f& pos, const Quad& quad,
+DrawingContext::draw(SurfacePtr surface, const Vector2f& pos, const Quad& quad,
                      const DrawingParameters& params, float z_pos)
 {
   draw(new SurfaceQuadDrawable(surface, pos, quad, params, z_pos,
@@ -107,20 +107,20 @@
 }
 
 void
-DrawingContext::draw(const Surface surface, const SurfaceDrawingParameters& params, float z_pos)
+DrawingContext::draw(SurfacePtr surface, const SurfaceDrawingParameters& params, float z_pos)
 {
   draw(new SurfaceDrawable(surface, params, z_pos,
                            modelview_stack.back()));
 }
 
 void
-DrawingContext::draw(const Surface surface, const Vector2f& pos, float z, float alpha)
+DrawingContext::draw(SurfacePtr surface, const Vector2f& pos, float z, float alpha)
 {
   draw(surface, pos.x, pos.y, z, alpha);
 }
 
 void
-DrawingContext::draw(Surface surface, float x, float y, float z, float )
+DrawingContext::draw(SurfacePtr surface, float x, float y, float z, float )
 {
   draw(new SurfaceDrawable(surface,
                            SurfaceDrawingParameters().set_pos(Vector2f(x, y)),
@@ -134,7 +134,7 @@
 }
 
 void
-DrawingContext::draw_control(const Surface surface, const Vector2f& pos, float angle, float z_pos)
+DrawingContext::draw_control(SurfacePtr surface, const Vector2f& pos, float angle, float z_pos)
 {
   draw(new ControlDrawable(surface, pos, angle, z_pos, modelview_stack.back()));
 }

Modified: trunk/windstille/src/display/drawing_context.hpp
===================================================================
--- trunk/windstille/src/display/drawing_context.hpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/display/drawing_context.hpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -23,6 +23,7 @@
 
 #include "scenegraph/drawable.hpp"
 #include "display/texture.hpp"
+#include "display/surface.hpp"
 
 class Surface;
 class SurfaceDrawingParameters;
@@ -78,12 +79,12 @@
   void draw(Drawable* request);
   void draw(const Sprite&   sprite,  const Vector2f& pos, float z = 0);
   void draw(const std::string& text,    float x, float y, float z = 0);
-  void draw(const Surface surface, const Vector2f& pos, float z = 0, float alpha = 0);
-  void draw(const Surface surface, float x, float y, float z = 0, float alpha = 0);
-  void draw(const Surface surface, const SurfaceDrawingParameters& params, float z_pos = 0);
-  void draw(const Surface surface, const Vector2f& pos, const Quad& quad,
+  void draw(SurfacePtr surface, const Vector2f& pos, float z = 0, float alpha = 0);
+  void draw(SurfacePtr surface, float x, float y, float z = 0, float alpha = 0);
+  void draw(SurfacePtr surface, const SurfaceDrawingParameters& params, float z_pos = 0);
+  void draw(SurfacePtr surface, const Vector2f& pos, const Quad& quad,
             const DrawingParameters& params, float z_pos = 0);
-  void draw_control(const Surface surface, const Vector2f& pos, float angle, float z_pos = 0);
+  void draw_control(SurfacePtr surface, const Vector2f& pos, float angle, float z_pos = 0);
   /*} */
   
   /** Translate the drawing context */

Modified: trunk/windstille/src/display/surface.cpp
===================================================================
--- trunk/windstille/src/display/surface.cpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/display/surface.cpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -23,60 +23,45 @@
 #include "display/surface_drawing_parameters.hpp"
 #include "display/surface_manager.hpp"
 
-class SurfaceImpl
+SurfacePtr
+Surface::create(const Pathname& filename)
 {
-public:
-  /**
-   * Texture on which the surface is located
-   */
-  TexturePtr texture;
+  return SurfaceManager::current()->get(filename);
+}
 
-  /** 
-   * uv coordinates of the Surface in [0,1] range
-   */
-  Rectf   uv;
-
-  /**
-   * The size of the Surface in pixels
-   */
-  Sizef size;
-
-  SurfaceImpl() :
-    texture(),
-    uv(),
-    size()
-  {}
-};
-
-Surface::Surface() :
-  impl()
+SurfacePtr
+Surface::create(TexturePtr texture, const Rectf& uv, const Sizef& size)
 {
+  return SurfacePtr(new Surface(texture, uv, size));
 }
 
-Surface::Surface(const Pathname& filename) :
-  impl()
+SurfacePtr
+Surface::create(int width, int height)
 {
-  // FIXME: a bit ugly, should move some of the surface_manager code over here
-  *this = SurfaceManager::current()->get(filename);
+  return SurfacePtr(new Surface(width, height));
 }
-
+
 Surface::Surface(int width, int height) :
-  impl(new SurfaceImpl())
+  m_texture(),
+  m_uv(),
+  m_size()
 {
-  impl->size  = Size(width, height);
+  m_size  = Size(width, height);
 
-  impl->texture = Texture::create(GL_TEXTURE_2D, width, height);
-  impl->uv      = Rectf(0.0f, 0.0f,
-                        impl->size.width  / static_cast<float>(impl->texture->get_width()),
-                        impl->size.height / static_cast<float>(impl->texture->get_height()));
+  m_texture = Texture::create(GL_TEXTURE_2D, width, height);
+  m_uv      = Rectf(0.0f, 0.0f,
+                    m_size.width  / static_cast<float>(m_texture->get_width()),
+                    m_size.height / static_cast<float>(m_texture->get_height()));
 }
 
 Surface::Surface(TexturePtr texture, const Rectf& uv, const Sizef& size) :
-  impl(new SurfaceImpl())
+  m_texture(),
+  m_uv(),
+  m_size()
 {
-  impl->texture = texture;
-  impl->uv      = uv;
-  impl->size    = size;
+  m_texture = texture;
+  m_uv      = uv;
+  m_size    = size;
 }
 
 Surface::~Surface()
@@ -86,54 +71,49 @@
 float
 Surface::get_width()  const
 {
-  return impl->size.width;
+  return m_size.width;
 }
 
 float
 Surface::get_height() const
 { 
-  return impl->size.height; 
+  return m_size.height; 
 }
 
 TexturePtr
 Surface::get_texture() const
 {
-  return impl->texture;
+  return m_texture;
 }
 
 Rectf
 Surface::get_uv() const
 {
-  return impl->uv;
+  return m_uv;
 }
 
-Surface::operator bool() const
-{
-  return impl.get() != 0;
-}
-
 void
 Surface::draw(const Vector2f& pos) const
 {
   OpenGLState state;
   state.enable(GL_BLEND);
   state.set_blend_func(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-  state.bind_texture(impl->texture);
+  state.bind_texture(m_texture);
   state.activate();
 
   glBegin(GL_QUADS);
 
-  glTexCoord2f(impl->uv.left, impl->uv.top);
+  glTexCoord2f(m_uv.left, m_uv.top);
   glVertex2f(pos.x, pos.y);
 
-  glTexCoord2f(impl->uv.right, impl->uv.top);
-  glVertex2f(pos.x + impl->size.width, pos.y);
+  glTexCoord2f(m_uv.right, m_uv.top);
+  glVertex2f(pos.x + m_size.width, pos.y);
 
-  glTexCoord2f(impl->uv.right, impl->uv.bottom);
-  glVertex2f(pos.x + impl->size.width, pos.y + impl->size.height);
+  glTexCoord2f(m_uv.right, m_uv.bottom);
+  glVertex2f(pos.x + m_size.width, pos.y + m_size.height);
 
-  glTexCoord2f(impl->uv.left, impl->uv.bottom);
-  glVertex2f(pos.x, pos.y + impl->size.height);
+  glTexCoord2f(m_uv.left, m_uv.bottom);
+  glVertex2f(pos.x, pos.y + m_size.height);
 
   glEnd();
 }
@@ -144,13 +124,13 @@
   OpenGLState state;
   state.enable(GL_BLEND);
   state.set_blend_func(params.blendfunc_src, params.blendfunc_dst);
-  state.bind_texture(impl->texture);
+  state.bind_texture(m_texture);
   state.color(params.color);
   state.activate();
 
   glBegin(GL_QUADS);
 
-  Rectf uv = impl->uv;
+  Rectf uv = m_uv;
 
   if (params.hflip)
     std::swap(uv.left, uv.right);
@@ -160,8 +140,8 @@
 
   Quad quad(params.pos.x, 
             params.pos.y,
-            params.pos.x + impl->size.width  * params.scale.x, 
-            params.pos.y + impl->size.height * params.scale.y);
+            params.pos.x + m_size.width  * params.scale.x, 
+            params.pos.y + m_size.height * params.scale.y);
 
   quad.rotate(params.angle);
   

Modified: trunk/windstille/src/display/surface.hpp
===================================================================
--- trunk/windstille/src/display/surface.hpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/display/surface.hpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -23,7 +23,8 @@
 #include "display/texture.hpp"
 
 class SurfaceDrawingParameters;
-class SurfaceImpl;
+class Surface;
+typedef boost::shared_ptr<Surface> SurfacePtr;
 
 /**
  * Surface class. This class basically holds a reference to an opengl texture
@@ -34,8 +35,7 @@
 class Surface
 {
 public:
-  Surface();
-  explicit Surface(const Pathname& filename);
+  static SurfacePtr create(const Pathname& filename);
   
   /** 
    * Create a new Surface object from a Texture
@@ -44,10 +44,16 @@
    * @param width  Width of the surface on the screen
    * @param height Height of the surface on the screen
    */
+  static SurfacePtr create(TexturePtr texture, const Rectf& uv, const Sizef& size);
+  static SurfacePtr create(int width, int height);
+
+private:
   Surface(TexturePtr texture, const Rectf& uv, const Sizef& size);
   Surface(int width, int height);
+  
+public:
   ~Surface();
-  
+
   float get_width()  const;
   float get_height() const;
   
@@ -59,13 +65,21 @@
   void draw(const Vector2f& pos) const;
   void draw(const SurfaceDrawingParameters& params) const;
 
-  /** true if the Texture is valid and usable, false if not */
-  operator bool() const;
+private:
+  /**
+   * Texture on which the surface is located
+   */
+  TexturePtr m_texture;
 
-  long use_count() const { return impl.use_count(); }
+  /** 
+   * uv coordinates of the Surface in [0,1] range
+   */
+  Rectf m_uv;
 
-private:
-  boost::shared_ptr<SurfaceImpl> impl;
+  /**
+   * The size of the Surface in pixels
+   */
+  Sizef m_size;
 };
 
 #endif

Modified: trunk/windstille/src/display/surface_manager.cpp
===================================================================
--- trunk/windstille/src/display/surface_manager.cpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/display/surface_manager.cpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -45,7 +45,7 @@
 #endif
 }
 
-Surface
+SurfacePtr
 SurfaceManager::get(const Pathname& filename)
 {
   Surfaces::iterator i = surfaces.find(filename);
@@ -60,7 +60,7 @@
 
     if (texture_packer)
     {
-      Surface result = texture_packer->upload(software_surface);
+      SurfacePtr result = texture_packer->upload(software_surface);
       surfaces.insert(std::make_pair(filename, result));
       return result;              
     }
@@ -81,9 +81,9 @@
         throw std::runtime_error(msg.str());
       }
         
-      Surface result(texture, Rectf(0.0f, 0.0f, maxu, maxv),
-                     Sizef(static_cast<float>(software_surface.get_width()),
-                           static_cast<float>(software_surface.get_height())));
+      SurfacePtr result = Surface::create(texture, Rectf(0.0f, 0.0f, maxu, maxv),
+                                          Sizef(static_cast<float>(software_surface.get_width()),
+                                                static_cast<float>(software_surface.get_height())));
       surfaces.insert(std::make_pair(filename, result));
       return result;
     }
@@ -92,7 +92,7 @@
 
 void
 SurfaceManager::load_grid(const Pathname& filename,
-                          std::vector<Surface>& out_surfaces,
+                          std::vector<SurfacePtr>& out_surfaces,
                           int width, int height)
 {
   SoftwareSurface image(filename);
@@ -120,10 +120,10 @@
       float s_max_u = (maxu * (static_cast<float>(x + width)))  / static_cast<float>(image.get_width());
       float s_max_v = (maxv * (static_cast<float>(x + height))) / static_cast<float>(image.get_height());
 
-      out_surfaces.push_back(Surface(texture, 
-                                     Rectf(s_min_u, s_min_v, s_max_u, s_max_v), 
-                                     Sizef(static_cast<float>(width),
-                                           static_cast<float>(height))));
+      out_surfaces.push_back(Surface::create(texture, 
+                                             Rectf(s_min_u, s_min_v, s_max_u, s_max_v), 
+                                             Sizef(static_cast<float>(width),
+                                                   static_cast<float>(height))));
     }
   }
 }

Modified: trunk/windstille/src/display/surface_manager.hpp
===================================================================
--- trunk/windstille/src/display/surface_manager.hpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/display/surface_manager.hpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -27,8 +27,8 @@
 #include "util/pathname.hpp"
 #include "util/currenton.hpp"
 #include "display/texture.hpp"
+#include "display/surface.hpp"
 
-class Surface;
 class TexturePacker;
 
 /**
@@ -39,7 +39,7 @@
 private:
   boost::scoped_ptr<TexturePacker> texture_packer;
   
-  typedef std::map<Pathname, Surface> Surfaces;
+  typedef std::map<Pathname, SurfacePtr> Surfaces;
   Surfaces surfaces;
 
 public:
@@ -47,14 +47,14 @@
   ~SurfaceManager();
 
   /** returns a surface containing the image specified with filename */
-  Surface get(const Pathname& filename);
+  SurfacePtr get(const Pathname& filename);
 
   /**
    * Loads an image and splits it into several Surfaces sized width and height.
    * The created surfaces will be added to the surfaces vector.
    */
   void load_grid(const Pathname& filename,
-                 std::vector<Surface>& surfaces, int width, int height);
+                 std::vector<SurfacePtr>& surfaces, int width, int height);
 
   TexturePtr create_texture(const SoftwareSurface& image,
                             float* maxu, float* maxv);

Modified: trunk/windstille/src/display/texture_packer.cpp
===================================================================
--- trunk/windstille/src/display/texture_packer.cpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/display/texture_packer.cpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -148,7 +148,7 @@
   return textures.back()->allocate(size, rect, out_texture);
 }
 
-Surface
+SurfacePtr
 TexturePacker::upload(const SoftwareSurface& surface)
 {
   // Add a 1px border around surfaces to avoid blending artifacts
@@ -168,36 +168,36 @@
 
     // top
     texture->put(surface, Rect(Point(0, 0), Size(surface.get_width(), 1)), 
-                rect.left+1, rect.top);
+                 rect.left+1, rect.top);
     // bottom
     texture->put(surface, Rect(Point(0, surface.get_height()-1), Size(surface.get_width(), 1)), 
-                rect.left+1, rect.bottom-1);
+                 rect.left+1, rect.bottom-1);
     // left
     texture->put(surface, Rect(Point(0, 0), Size(1, surface.get_height())), 
-                rect.left, rect.top+1);
+                 rect.left, rect.top+1);
     // right
     texture->put(surface, Rect(Point(surface.get_width()-1, 0), Size(1, surface.get_height())),
-                rect.right-1, rect.top+1);
+                 rect.right-1, rect.top+1);
 
     // duplicate corner pixels
     texture->put(surface, Rect(Point(0, 0), Size(1, 1)), 
-                rect.left, rect.top);     
+                 rect.left, rect.top);     
     texture->put(surface, Rect(Point(surface.get_width()-1, 0), Size(1, 1)), 
-                rect.right-1, rect.top);
+                 rect.right-1, rect.top);
     texture->put(surface, Rect(Point(surface.get_width()-1, surface.get_height()-1), Size(1, 1)), 
-                rect.right-1, rect.bottom-1);
+                 rect.right-1, rect.bottom-1);
     texture->put(surface, Rect(Point(0, surface.get_height()-1), Size(1, 1)),
-                rect.left, rect.bottom-1);
+                 rect.left, rect.bottom-1);
 
     // draw the main surface
     texture->put(surface, rect.left+1, rect.top+1);
 
-    return Surface(texture,
-                   Rectf(static_cast<float>(rect.left+1)   / static_cast<float>(texture->get_width()),
-                         static_cast<float>(rect.top+1)    / static_cast<float>(texture->get_height()),
-                         static_cast<float>(rect.right-1)  / static_cast<float>(texture->get_width()), 
-                         static_cast<float>(rect.bottom-1) / static_cast<float>(texture->get_height())),
-                   Sizef(static_cast<float>(surface.get_width()), static_cast<float>(surface.get_height())));
+    return Surface::create(texture,
+                           Rectf(static_cast<float>(rect.left+1)   / static_cast<float>(texture->get_width()),
+                                 static_cast<float>(rect.top+1)    / static_cast<float>(texture->get_height()),
+                                 static_cast<float>(rect.right-1)  / static_cast<float>(texture->get_width()), 
+                                 static_cast<float>(rect.bottom-1) / static_cast<float>(texture->get_height())),
+                           Sizef(static_cast<float>(surface.get_width()), static_cast<float>(surface.get_height())));
   }
 }
 

Modified: trunk/windstille/src/display/texture_packer.hpp
===================================================================
--- trunk/windstille/src/display/texture_packer.hpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/display/texture_packer.hpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -41,8 +41,8 @@
   TexturePacker(const Size& texture_size);
   ~TexturePacker();
   
-  Surface upload(const SoftwareSurface& surface);
-  bool    allocate(const Size& size, Rect& rect, TexturePtr& out_texture);
+  SurfacePtr upload(const SoftwareSurface& surface);
+  bool allocate(const Size& size, Rect& rect, TexturePtr& out_texture);
   
   void save_all_as_png() const;
 

Modified: trunk/windstille/src/gui/automap.cpp
===================================================================
--- trunk/windstille/src/gui/automap.cpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/gui/automap.cpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -26,20 +26,20 @@
 
 namespace gui {
 
-Automap::Automap(Component* parent_)
-  : Component(parent_),
-    surface(),
-    pos(),
-    zoom()
+Automap::Automap(Component* parent_) :
+  Component(parent_),
+  surface(),
+  pos(),
+  zoom()
 {
   assert(0);
 }
 
-Automap::Automap(const Rectf& rect_, Component* parent_)
-  : Component(rect_, parent_),
-    surface(),
-    pos(0.0f, 0.0f),
-    zoom(6.0f)
+Automap::Automap(const Rectf& rect_, Component* parent_) :
+  Component(rect_, parent_),
+  surface(),
+  pos(0.0f, 0.0f),
+  zoom(6.0f)
 {
   TileMap* tilemap = Sector::current()->get_tilemap();
 
@@ -66,9 +66,9 @@
       }
     }
 
-  surface = Surface(tilemap->get_width(), tilemap->get_height());
-  surface.get_texture()->set_filter(GL_NEAREST);
-  surface.get_texture()->put(image, 0, 0);
+  surface = Surface::create(tilemap->get_width(), tilemap->get_height());
+  surface->get_texture()->set_filter(GL_NEAREST);
+  surface->get_texture()->put(image, 0, 0);
 }
 
 Automap::~Automap()
@@ -79,10 +79,10 @@
 Automap::draw()
 {
   Display::push_cliprect(Rect(get_screen_rect()));
-  surface.draw(SurfaceDrawingParameters()
-               .set_pos(Vector2f(rect.left, rect.top) + pos)
-               .set_color(Color(1.0f, 1.0f, 1.0f, is_active() ? 0.8f : 0.5f))
-               .set_scale(zoom));
+  surface->draw(SurfaceDrawingParameters()
+                .set_pos(Vector2f(rect.left, rect.top) + pos)
+                .set_color(Color(1.0f, 1.0f, 1.0f, is_active() ? 0.8f : 0.5f))
+                .set_scale(zoom));
   Display::pop_cliprect();
 }
 

Modified: trunk/windstille/src/gui/automap.hpp
===================================================================
--- trunk/windstille/src/gui/automap.hpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/gui/automap.hpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -28,7 +28,7 @@
 class Automap : public Component
 {
 private:
-  Surface surface;
+  SurfacePtr surface;
   Vector2f  pos;
   float   zoom;
 

Modified: trunk/windstille/src/objects/decal.cpp
===================================================================
--- trunk/windstille/src/objects/decal.cpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/objects/decal.cpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -45,7 +45,7 @@
   reader.get("vflip", vflip);
   reader.get("hflip", hflip);
 
-  Surface surface = Surface(Pathname(path));
+  SurfacePtr surface = Surface::create(Pathname(path));
 
   SurfaceDrawingParameters params;
 
@@ -57,8 +57,8 @@
     case 2: params.set_blend_func(GL_SRC_ALPHA, GL_ONE); break;
   }
 
-  Vector2f center_offset(-surface.get_width() /2,
-                         -surface.get_height()/2);
+  Vector2f center_offset(-surface->get_width() /2,
+                         -surface->get_height()/2);
 
   center_offset.x *= scale.x;
   center_offset.y *= scale.y;
@@ -113,8 +113,8 @@
   { // FIXME: Not going to work with double parenting
     pos += decal->pos;
 
-    Vector2f center_offset(-drawable->get_surface().get_width() /2,
-                           -drawable->get_surface().get_height()/2);
+    Vector2f center_offset(-drawable->get_surface()->get_width() /2,
+                           -drawable->get_surface()->get_height()/2);
 
     center_offset.x *= drawable->get_params().scale.x;
     center_offset.y *= drawable->get_params().scale.y;

Modified: trunk/windstille/src/particles/deform_drawer.cpp
===================================================================
--- trunk/windstille/src/particles/deform_drawer.cpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/particles/deform_drawer.cpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -29,16 +29,16 @@
 {
 public:
   FramebufferPtr    framebuffer;
-  Surface&          surface;
+  SurfacePtr        surface;
   ParticleSystem&   psys;
   ShaderProgram&    shader_program;
 
   DeformDrawerRequest(const Vector2f& pos_, float z_pos_,  const Matrix& modelview_,
-                      FramebufferPtr framebuffer_, Surface& surface_, ParticleSystem& psys_,
-                      ShaderProgram& shader_program_)
-    : Drawable(pos_, z_pos_, modelview_),
-      framebuffer(framebuffer_), surface(surface_), psys(psys_), 
-      shader_program(shader_program_)
+                      FramebufferPtr framebuffer_, SurfacePtr surface_, ParticleSystem& psys_,
+                      ShaderProgram& shader_program_) :
+    Drawable(pos_, z_pos_, modelview_),
+    framebuffer(framebuffer_), surface(surface_), psys(psys_), 
+    shader_program(shader_program_)
   {}
   
   virtual ~DeformDrawerRequest() {}
@@ -89,7 +89,7 @@
     
     OpenGLState state;
     
-    state.bind_texture(surface.get_texture());
+    state.bind_texture(surface->get_texture());
     state.set_blend_func(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
     state.enable(GL_BLEND);
     state.activate();    
@@ -109,8 +109,8 @@
         float scale  = psys.get_size_start() + 
           psys.get_progress(i->t) * (psys.get_size_stop() - psys.get_size_start());
           
-        float width  = surface.get_width()  * scale;
-        float height = surface.get_height() * scale;
+        float width  = surface->get_width()  * scale;
+        float height = surface->get_height() * scale;
               
         // rotate
         float x_rot = width/2;
@@ -166,7 +166,7 @@
 
 DeformDrawer::DeformDrawer(FileReader& /*props*/) :
   framebuffer(Framebuffer::create_with_texture(GL_TEXTURE_2D, 800, 600)),
-  surface(Pathname("images/particles/deform2.png")),
+  surface(Surface::create(Pathname("images/particles/deform2.png"))),
   shader_program()
 {
   shader_program.attach(ShaderObject(GL_FRAGMENT_SHADER, "data/shader/particledeform.frag"));

Modified: trunk/windstille/src/particles/deform_drawer.hpp
===================================================================
--- trunk/windstille/src/particles/deform_drawer.hpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/particles/deform_drawer.hpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -39,7 +39,7 @@
 {
 private:
   FramebufferPtr framebuffer;
-  Surface        surface;
+  SurfacePtr     surface;
   ShaderProgram  shader_program;
 
 public:

Modified: trunk/windstille/src/particles/surface_drawer.cpp
===================================================================
--- trunk/windstille/src/particles/surface_drawer.cpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/particles/surface_drawer.cpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -23,10 +23,10 @@
 #include "display/drawing_context.hpp"
 #include "particles/surface_drawer.hpp"
 
-SurfaceDrawer::SurfaceDrawer(Surface surface_)
-  : surface(surface_),
-    blendfunc_src(),
-    blendfunc_dest()
+SurfaceDrawer::SurfaceDrawer(SurfacePtr surface_) :
+  surface(surface_),
+  blendfunc_src(),
+  blendfunc_dest()
 {
 }
 
@@ -93,7 +93,7 @@
 }
   
 void
-SurfaceDrawer::set_texture(Surface surface_)
+SurfaceDrawer::set_texture(SurfacePtr surface_)
 {
   surface = surface_;
 }
@@ -112,7 +112,7 @@
   buffer->set_pos(Vector2f(psys.get_x_pos(), psys.get_y_pos()));
 
   buffer->set_mode(GL_QUADS);
-  buffer->set_texture(surface.get_texture());
+  buffer->set_texture(surface->get_texture());
   buffer->set_blend_func(blendfunc_src, blendfunc_dest);
 
   for(ParticleSystem::const_iterator i = psys.begin(); i != psys.end(); ++i)
@@ -129,8 +129,8 @@
       float scale  = psys.get_size_start() + 
         psys.get_progress(i->t) * (psys.get_size_stop() - psys.get_size_start());
           
-      float width  = surface.get_width()  * scale;
-      float height = surface.get_height() * scale;
+      float width  = surface->get_width()  * scale;
+      float height = surface->get_height() * scale;
               
       // rotate
       float x_rot = width/2;
@@ -144,7 +144,7 @@
         y_rot = (width/2) * s + (height/2) * c;
       }
 
-      buffer->add_texcoords(surface.get_uv());
+      buffer->add_texcoords(surface->get_uv());
 
       buffer->color(color);
       buffer->vertex(i->x - x_rot, i->y - y_rot);

Modified: trunk/windstille/src/particles/surface_drawer.hpp
===================================================================
--- trunk/windstille/src/particles/surface_drawer.hpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/particles/surface_drawer.hpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -27,17 +27,17 @@
 class SurfaceDrawer : public Drawer
 {
 private:
-  Surface surface;
+  SurfacePtr surface;
   GLenum blendfunc_src;
   GLenum blendfunc_dest;
   boost::shared_ptr<VertexArrayDrawable> buffer;
   
 public:
   SurfaceDrawer(FileReader& props);
-  SurfaceDrawer(Surface surface);
+  SurfaceDrawer(SurfacePtr surface);
   virtual ~SurfaceDrawer();
   
-  void set_texture(Surface surface);
+  void set_texture(SurfacePtr surface);
   void set_blendfuncs(GLenum blendfunc_src, GLenum blendfunc_dst);
 
   void draw(const ParticleSystem& psys) const;

Modified: trunk/windstille/src/scenegraph/control_drawable.hpp
===================================================================
--- trunk/windstille/src/scenegraph/control_drawable.hpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/scenegraph/control_drawable.hpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -22,11 +22,11 @@
 class ControlDrawable : public Drawable
 {
 private:
-  Surface surface;
+  SurfacePtr surface;
   float angle;
 
 public:
-  ControlDrawable(Surface surface_, const Vector2f& pos_, float angle_, float z_pos_,
+  ControlDrawable(SurfacePtr surface_, const Vector2f& pos_, float angle_, float z_pos_,
                   const Matrix& modelview_)
     : Drawable(pos_, z_pos_, modelview_), 
       surface(surface_), 
@@ -46,10 +46,10 @@
 
     Vector3 p = modelview.multiply(Vector3(pos.x, pos.y, 0.0f));
 
-    surface.draw(SurfaceDrawingParameters()
+    surface->draw(SurfaceDrawingParameters()
                  .set_angle(angle)
-                 .set_pos(Vector2f(p.x - surface.get_width()/2,
-                                   p.y - surface.get_height()/2)));
+                 .set_pos(Vector2f(p.x - surface->get_width()/2,
+                                   p.y - surface->get_height()/2)));
 
     glPopMatrix();
   }

Modified: trunk/windstille/src/scenegraph/surface_drawable.hpp
===================================================================
--- trunk/windstille/src/scenegraph/surface_drawable.hpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/scenegraph/surface_drawable.hpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -25,11 +25,11 @@
 class SurfaceDrawable : public Drawable
 {
 private:
-  Surface surface;
+  SurfacePtr surface;
   SurfaceDrawingParameters params;
 
 public:
-  SurfaceDrawable(Surface surface_, const SurfaceDrawingParameters& params_,
+  SurfaceDrawable(SurfacePtr surface_, const SurfaceDrawingParameters& params_,
                   float z_pos_,
                   const Matrix& modelview_)
     : Drawable(pos, z_pos_, modelview_), 
@@ -40,7 +40,7 @@
   virtual ~SurfaceDrawable()
   {}
   
-  Surface get_surface() const { return surface; }
+  SurfacePtr get_surface() const { return surface; }
   SurfaceDrawingParameters& get_params() { return params; }
 
   void render(unsigned int mask)
@@ -48,7 +48,7 @@
     glPushMatrix();
     glMultMatrixf(modelview.matrix);
 
-    surface.draw(params);
+    surface->draw(params);
 
     glPopMatrix();
   }

Modified: trunk/windstille/src/scenegraph/surface_quad_drawable.hpp
===================================================================
--- trunk/windstille/src/scenegraph/surface_quad_drawable.hpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/scenegraph/surface_quad_drawable.hpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -27,12 +27,12 @@
 class SurfaceQuadDrawable : public Drawable
 {
 private:
-  Surface m_surface;
+  SurfacePtr m_surface;
   Quad m_quad;
   DrawingParameters m_params;
 
 public:
-  SurfaceQuadDrawable(Surface surface, const Vector2f& pos_, const Quad& quad, 
+  SurfaceQuadDrawable(SurfacePtr surface, const Vector2f& pos_, const Quad& quad, 
                       const DrawingParameters& params, float z_pos_,
                       const Matrix& modelview_)
     : Drawable(pos_, z_pos_, modelview_),
@@ -49,7 +49,7 @@
     OpenGLState state;
     state.enable(GL_BLEND);
     state.set_blend_func(m_params.blendfunc_src, m_params.blendfunc_dst);
-    state.bind_texture(m_surface.get_texture());
+    state.bind_texture(m_surface->get_texture());
     state.activate();
 
     glPushMatrix();
@@ -57,16 +57,16 @@
 
     glBegin(GL_QUADS);
     {
-      glTexCoord2f(m_surface.get_uv().left, m_surface.get_uv().top);
+      glTexCoord2f(m_surface->get_uv().left, m_surface->get_uv().top);
       glVertex2f(pos.x + m_quad.p1.x, pos.y + m_quad.p1.y);
     
-      glTexCoord2f(m_surface.get_uv().right, m_surface.get_uv().top);
+      glTexCoord2f(m_surface->get_uv().right, m_surface->get_uv().top);
       glVertex2f(pos.x + m_quad.p2.x, pos.y + m_quad.p2.y);
 
-      glTexCoord2f(m_surface.get_uv().right, m_surface.get_uv().bottom);
+      glTexCoord2f(m_surface->get_uv().right, m_surface->get_uv().bottom);
       glVertex2f(pos.x + m_quad.p3.x, pos.y + m_quad.p3.y);
 
-      glTexCoord2f(m_surface.get_uv().left, m_surface.get_uv().bottom);
+      glTexCoord2f(m_surface->get_uv().left, m_surface->get_uv().bottom);
       glVertex2f(pos.x + m_quad.p4.x, pos.y + m_quad.p4.y);
     }
     glEnd();

Modified: trunk/windstille/src/sprite2d/data.cpp
===================================================================
--- trunk/windstille/src/sprite2d/data.cpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/sprite2d/data.cpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -49,7 +49,7 @@
       action->speed  = 1.0;
       action->scale  = 1.0f;
       action->offset = Vector2f(0, 0);
-      action->surfaces.push_back(Surface(pathname));
+      action->surfaces.push_back(Surface::create(pathname));
       actions.push_back(action.release());
     }
     else
@@ -72,7 +72,7 @@
       action->speed  = 1.0;
       action->scale  = 1.0f;
       action->offset = Vector2f(0, 0);
-      action->surfaces.push_back(Surface(pngfile));
+      action->surfaces.push_back(Surface::create(pngfile));
       actions.push_back(action.release());
     }
     else

Modified: trunk/windstille/src/sprite2d/data.hpp
===================================================================
--- trunk/windstille/src/sprite2d/data.hpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/sprite2d/data.hpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -28,7 +28,7 @@
 
 struct SpriteAction
 {
-  typedef std::vector<Surface> Surfaces;
+  typedef std::vector<SurfacePtr> Surfaces;
 
   std::string name;
   float       speed;

Modified: trunk/windstille/src/sprite2d/sprite.cpp
===================================================================
--- trunk/windstille/src/sprite2d/sprite.cpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/sprite2d/sprite.cpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -225,7 +225,7 @@
   return color.a;
 }
 
-Surface
+SurfacePtr
 Sprite::get_current_surface() const
 {
   return current_action->surfaces[ static_cast<int> (frame) ];
@@ -240,8 +240,8 @@
 void
 Sprite::draw(const Vector2f& pos) const
 {
-  Surface surface = current_action->surfaces[ static_cast<int> (frame) ];
-  surface.draw(SurfaceDrawingParameters()
+  SurfacePtr surface = current_action->surfaces[ static_cast<int> (frame) ];
+  surface->draw(SurfaceDrawingParameters()
                .set_pos(pos + (current_action->offset * scale))
                .set_blend_func(blend_sfactor, blend_dfactor)
                .set_scale(scale)
@@ -299,13 +299,13 @@
 float
 Sprite::get_width() const
 {
-  return current_action->surfaces[ static_cast<int>(frame) ].get_width();
+  return current_action->surfaces[ static_cast<int>(frame) ]->get_width();
 }
 
 float
 Sprite::get_height() const
 {
-  return current_action->surfaces[ static_cast<int>(frame) ].get_height();
+  return current_action->surfaces[ static_cast<int>(frame) ]->get_height();
 }
 
 /* EOF */

Modified: trunk/windstille/src/sprite2d/sprite.hpp
===================================================================
--- trunk/windstille/src/sprite2d/sprite.hpp	2010-09-21 21:54:02 UTC (rev 3363)
+++ trunk/windstille/src/sprite2d/sprite.hpp	2010-09-22 10:16:26 UTC (rev 3364)
@@ -92,7 +92,7 @@
   void  set_scale(float s);
   float get_scale() const;
 
-  Surface get_current_surface() const;
+  SurfacePtr get_current_surface() const;
 
   Vector2f get_offset() const;
 



From grumbel at mail.berlios.de  Wed Sep 22 12:46:51 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed, 22 Sep 2010 12:46:51 +0200
Subject: [Windstille-commit] r3365 - in trunk/windstille/src: display font
	gui tile
Message-ID: <20100922104651.AF28E480F5C@sheep.berlios.de>

Author: grumbel
Date: 2010-09-22 12:46:51 +0200 (Wed, 22 Sep 2010)
New Revision: 3365

Modified:
   trunk/windstille/src/display/blitter.cpp
   trunk/windstille/src/display/blitter.hpp
   trunk/windstille/src/display/software_surface.cpp
   trunk/windstille/src/display/software_surface.hpp
   trunk/windstille/src/display/surface.hpp
   trunk/windstille/src/display/surface_manager.cpp
   trunk/windstille/src/display/surface_manager.hpp
   trunk/windstille/src/display/texture.cpp
   trunk/windstille/src/display/texture.hpp
   trunk/windstille/src/display/texture_manager.cpp
   trunk/windstille/src/display/texture_packer.cpp
   trunk/windstille/src/display/texture_packer.hpp
   trunk/windstille/src/font/border_font_effect.cpp
   trunk/windstille/src/font/border_font_effect.hpp
   trunk/windstille/src/font/font_effect.hpp
   trunk/windstille/src/font/no_font_effect.cpp
   trunk/windstille/src/font/no_font_effect.hpp
   trunk/windstille/src/font/ttf_font.cpp
   trunk/windstille/src/gui/automap.cpp
   trunk/windstille/src/tile/tile_description.cpp
   trunk/windstille/src/tile/tile_factory.cpp
   trunk/windstille/src/tile/tile_factory.hpp
   trunk/windstille/src/tile/tile_packer.cpp
   trunk/windstille/src/tile/tile_packer.hpp
Log:
Replaced SoftwareSurface with SoftwareSurfacePtr


Modified: trunk/windstille/src/display/blitter.cpp
===================================================================
--- trunk/windstille/src/display/blitter.cpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/display/blitter.cpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -24,13 +24,13 @@
 
 #include "display/software_surface.hpp"
 
-void generate_border(const SoftwareSurface& surface,
+void generate_border(SoftwareSurfacePtr surface,
                      int x_pos, int y_pos, int width, int height)
 {
-  assert(surface.get_bits_per_pixel() == 32);
+  assert(surface->get_bits_per_pixel() == 32);
  
-  uint8_t* data = static_cast<uint8_t*>(surface.get_pixels());
-  int pitch = surface.get_pitch();
+  uint8_t* data = static_cast<uint8_t*>(surface->get_pixels());
+  int pitch = surface->get_pitch();
 
   // duplicate the top line
   memcpy(data + (y_pos-1)*pitch + 4*x_pos, 

Modified: trunk/windstille/src/display/blitter.hpp
===================================================================
--- trunk/windstille/src/display/blitter.hpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/display/blitter.hpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -18,7 +18,7 @@
 #ifndef HEADER_WINDSTILLE_DISPLAY_BLITTER_HPP
 #define HEADER_WINDSTILLE_DISPLAY_BLITTER_HPP
 
-class SoftwareSurface;
+#include "display/software_surface.hpp"
 
 /** Duplicate all the edge pixel of the given rectangle to the outside
     of the rectangle, thus creating a border around the given
@@ -30,7 +30,7 @@
     X 4 5 6 X  / 4 4 5 6 6
     X X X X X    4 4 5 6 6
 */
-void generate_border(const SoftwareSurface& surface, int x_pos, int y_pos, int width, int height);
+void generate_border(SoftwareSurfacePtr surface, int x_pos, int y_pos, int width, int height);
 
 #endif
 

Modified: trunk/windstille/src/display/software_surface.cpp
===================================================================
--- trunk/windstille/src/display/software_surface.cpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/display/software_surface.cpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -26,18 +26,24 @@
 #include "math/rect.hpp"
 #include "display/software_surface.hpp"
 
-class SoftwareSurfaceImpl
+SoftwareSurfacePtr
+SoftwareSurface::create(const Pathname& filename)
 {
-public:
-  SDL_Surface* surface;
-};
+  return SoftwareSurfacePtr(new SoftwareSurface(filename));
+}
+
+SoftwareSurfacePtr
+SoftwareSurface::create(int width, int height, Format format)
+{
+  return SoftwareSurfacePtr(new SoftwareSurface(width, height, format));
+}
 
 SoftwareSurface::SoftwareSurface(const Pathname& filename) :
-  impl(new SoftwareSurfaceImpl())
+  m_surface(0)
 {
-  impl->surface = IMG_Load(filename.get_sys_path().c_str());
+  m_surface = IMG_Load(filename.get_sys_path().c_str());
 
-  if (!impl->surface)
+  if (!m_surface)
   {
     std::ostringstream str;
     str << "SoftwareSurface: Couldn't load: " << filename << std::endl;
@@ -45,101 +51,98 @@
   }
   else
   {
-    SDL_SetAlpha(impl->surface, 0, 0);
+    SDL_SetAlpha(m_surface, 0, 0);
 
-    assert(!SDL_MUSTLOCK(impl->surface));
+    assert(!SDL_MUSTLOCK(m_surface));
   }
 }
 
 SoftwareSurface::SoftwareSurface(int width, int height, Format format) :
-  impl(new SoftwareSurfaceImpl())
+  m_surface(0)
 {
   assert(format == RGBA);
 
 #if SDL_BYTEORDER == SDL_BIG_ENDIAN
-  impl->surface = SDL_CreateRGBSurface(SDL_SWSURFACE,
+  m_surface = SDL_CreateRGBSurface(SDL_SWSURFACE,
                                        width, height, 32,
                                        0xff000000, 0x00ff0000, 0x0000ff00, 0x000000ff);
 #else
-  impl->surface = SDL_CreateRGBSurface(SDL_SWSURFACE,
+  m_surface = SDL_CreateRGBSurface(SDL_SWSURFACE,
                                        width, height, 32,
                                        0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000);
 #endif
 
-  SDL_SetAlpha(impl->surface, 0, 0);
+  SDL_SetAlpha(m_surface, 0, 0);
 
-  assert(!SDL_MUSTLOCK(impl->surface));
+  assert(!SDL_MUSTLOCK(m_surface));
 }
 
 SoftwareSurface::~SoftwareSurface()
 {
-  if (impl)
-  {
-    SDL_FreeSurface(impl->surface);
-  }
+  SDL_FreeSurface(m_surface);
 }
 
 int
 SoftwareSurface::get_bytes_per_pixel() const
 {
-  return impl->surface->format->BytesPerPixel;
+  return m_surface->format->BytesPerPixel;
 }
 
 int
 SoftwareSurface::get_bits_per_pixel() const
 {
-  return impl->surface->format->BitsPerPixel;
+  return m_surface->format->BitsPerPixel;
 }
 
 int
 SoftwareSurface::get_width() const
 {
-  return impl->surface->w;
+  return m_surface->w;
 }
 
 int
 SoftwareSurface::get_height() const
 {
-  return impl->surface->h;
+  return m_surface->h;
 }
 
 Size
 SoftwareSurface::get_size() const
 {
-  return Size(impl->surface->w, 
-              impl->surface->h);
+  return Size(m_surface->w, 
+              m_surface->h);
 }
 
 int
 SoftwareSurface::get_pitch() const
 {
-  return impl->surface->pitch;
+  return m_surface->pitch;
 }
 
 void*
 SoftwareSurface::get_pixels() const
 {
-  return impl->surface->pixels;
+  return m_surface->pixels;
 }
 
 SDL_Surface*
 SoftwareSurface::get_surface() const
 {
-  return impl->surface;
+  return m_surface;
 }
 
 void
-SoftwareSurface::blit(SoftwareSurface& dst, int x, int y) const
+SoftwareSurface::blit(SoftwareSurfacePtr dst, int x, int y) const
 {
   SDL_Rect dst_rect; 
   dst_rect.x = static_cast<Sint16>(x);
   dst_rect.y = static_cast<Sint16>(y);
 
-  SDL_BlitSurface(impl->surface, 0, dst.impl->surface, &dst_rect);
+  SDL_BlitSurface(m_surface, 0, dst->m_surface, &dst_rect);
 }
 
 void
-SoftwareSurface::blit(const Rect& src_rect_, SoftwareSurface& dst, int x, int y) const
+SoftwareSurface::blit(const Rect& src_rect_, SoftwareSurfacePtr dst, int x, int y) const
 {
   SDL_Rect src_rect;
   src_rect.x = static_cast<Sint16>(src_rect_.left);
@@ -151,20 +154,20 @@
   dst_rect.x = static_cast<Sint16>(x);
   dst_rect.y = static_cast<Sint16>(y);
   
-  SDL_BlitSurface(impl->surface, &src_rect, dst.impl->surface, &dst_rect);
+  SDL_BlitSurface(m_surface, &src_rect, dst->m_surface, &dst_rect);
 }
 
 bool
 SoftwareSurface::is_at(int x, int y) const
 {
-  if (x >= 0 && x < impl->surface->w &&
-      y >= 0 && y < impl->surface->h)
+  if (x >= 0 && x < m_surface->w &&
+      y >= 0 && y < m_surface->h)
   {
     if (get_bits_per_pixel() == 32)
     {
-      uint8_t* pixels = static_cast<uint8_t*>(impl->surface->pixels);
+      uint8_t* pixels = static_cast<uint8_t*>(m_surface->pixels);
           
-      return pixels[y * impl->surface->pitch + x*4 + 3] > 128;
+      return pixels[y * m_surface->pitch + x*4 + 3] > 128;
     }
     else
     {

Modified: trunk/windstille/src/display/software_surface.hpp
===================================================================
--- trunk/windstille/src/display/software_surface.hpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/display/software_surface.hpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -28,7 +28,8 @@
 
 
 class Rect;
-class SoftwareSurfaceImpl;
+class SoftwareSurface;
+typedef boost::shared_ptr<SoftwareSurface> SoftwareSurfacePtr;
 
 class SoftwareSurface
 {
@@ -38,9 +39,15 @@
     RGBA
   };
 
-  SoftwareSurface() : impl() {}
+public:
+  static SoftwareSurfacePtr create(const Pathname& filename);
+  static SoftwareSurfacePtr create(int width, int height, Format format = RGBA);
+
+private:
   explicit SoftwareSurface(const Pathname& filename);
   SoftwareSurface(int width, int height, Format format = RGBA);
+
+public:
   ~SoftwareSurface();
 
   int   get_bytes_per_pixel() const;
@@ -51,8 +58,8 @@
   Size  get_size() const;
   void* get_pixels() const;
 
-  void blit(SoftwareSurface& dst, int x, int y) const;
-  void blit(const Rect& src_rect, SoftwareSurface& dst, int x, int y) const;
+  void blit(SoftwareSurfacePtr dst, int x, int y) const;
+  void blit(const Rect& src_rect, SoftwareSurfacePtr dst, int x, int y) const;
 
   void save_png(const std::string& filename) const;
 
@@ -60,10 +67,12 @@
 
   bool is_at(int x, int y) const;
 
-  operator bool() { return impl; }
+private:
+  SDL_Surface* m_surface;
 
 private:
-  boost::shared_ptr<SoftwareSurfaceImpl> impl;
+  SoftwareSurface(const SoftwareSurface&);
+  SoftwareSurface& operator=(const SoftwareSurface&);
 };
 
 #endif

Modified: trunk/windstille/src/display/surface.hpp
===================================================================
--- trunk/windstille/src/display/surface.hpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/display/surface.hpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -19,8 +19,9 @@
 #ifndef HEADER_WINDSTILLE_DISPLAY_SURFACE_HPP
 #define HEADER_WINDSTILLE_DISPLAY_SURFACE_HPP
 
+#include "display/texture.hpp"
 #include "math/rect.hpp"
-#include "display/texture.hpp"
+#include "util/pathname.hpp"
 
 class SurfaceDrawingParameters;
 class Surface;

Modified: trunk/windstille/src/display/surface_manager.cpp
===================================================================
--- trunk/windstille/src/display/surface_manager.cpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/display/surface_manager.cpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -56,7 +56,7 @@
   }
   else
   {
-    SoftwareSurface software_surface(filename);
+    SoftwareSurfacePtr software_surface = SoftwareSurface::create(filename);
 
     if (texture_packer)
     {
@@ -82,8 +82,8 @@
       }
         
       SurfacePtr result = Surface::create(texture, Rectf(0.0f, 0.0f, maxu, maxv),
-                                          Sizef(static_cast<float>(software_surface.get_width()),
-                                                static_cast<float>(software_surface.get_height())));
+                                          Sizef(static_cast<float>(software_surface->get_width()),
+                                                static_cast<float>(software_surface->get_height())));
       surfaces.insert(std::make_pair(filename, result));
       return result;
     }
@@ -95,7 +95,7 @@
                           std::vector<SurfacePtr>& out_surfaces,
                           int width, int height)
 {
-  SoftwareSurface image(filename);
+  SoftwareSurfacePtr image = SoftwareSurface::create(filename);
   float maxu, maxv;
 
   TexturePtr texture;
@@ -104,21 +104,21 @@
   {                                                                       
     texture = create_texture(image, &maxu, &maxv);
   }
-  catch(std::exception& e)
+  catch(const std::exception& e)
   {
     std::ostringstream msg;
     msg << "Couldn't create texture for '" << filename << "': " << e.what();
     throw std::runtime_error(msg.str());                                      
   }
 
-  for(int y = 0; y <= image.get_height() - height + 1; y += height)
+  for(int y = 0; y <= image->get_height() - height + 1; y += height)
   {
-    for(int x = 0; x <= image.get_width() - width + 1; x += width)
+    for(int x = 0; x <= image->get_width() - width + 1; x += width)
     {
-      float s_min_u = maxu * static_cast<float>(x) / static_cast<float>(image.get_width());
-      float s_min_v = maxv * static_cast<float>(x) / static_cast<float>(image.get_height());
-      float s_max_u = (maxu * (static_cast<float>(x + width)))  / static_cast<float>(image.get_width());
-      float s_max_v = (maxv * (static_cast<float>(x + height))) / static_cast<float>(image.get_height());
+      float s_min_u = maxu * static_cast<float>(x) / static_cast<float>(image->get_width());
+      float s_min_v = maxv * static_cast<float>(x) / static_cast<float>(image->get_height());
+      float s_max_u = (maxu * (static_cast<float>(x + width)))  / static_cast<float>(image->get_width());
+      float s_max_v = (maxv * (static_cast<float>(x + height))) / static_cast<float>(image->get_height());
 
       out_surfaces.push_back(Surface::create(texture, 
                                              Rectf(s_min_u, s_min_v, s_max_u, s_max_v), 
@@ -129,21 +129,21 @@
 }
 
 TexturePtr
-SurfaceManager::create_texture(const SoftwareSurface& image,
+SurfaceManager::create_texture(SoftwareSurfacePtr image,
                                float* maxu, float* maxv)
 {
   // OpenGL2.0 should be fine with non-power-of-two
-  int texture_w = image.get_width();  //math::round_to_power_of_two(image.get_width());
-  int texture_h = image.get_height(); //math::round_to_power_of_two(image.get_height());
+  int texture_w = image->get_width();  //math::round_to_power_of_two(image->get_width());
+  int texture_h = image->get_height(); //math::round_to_power_of_two(image->get_height());
 
-  SoftwareSurface convert(texture_w, texture_h);
+  SoftwareSurfacePtr convert = SoftwareSurface::create(texture_w, texture_h);
 
-  image.blit(convert, 0, 0);
+  image->blit(convert, 0, 0);
 
   TexturePtr texture = Texture::create(convert);
   
-  *maxu = static_cast<float>(image.get_width())  / static_cast<float>(texture_w);
-  *maxv = static_cast<float>(image.get_height()) / static_cast<float>(texture_h);
+  *maxu = static_cast<float>(image->get_width())  / static_cast<float>(texture_w);
+  *maxv = static_cast<float>(image->get_height()) / static_cast<float>(texture_h);
 
   return texture;
 }

Modified: trunk/windstille/src/display/surface_manager.hpp
===================================================================
--- trunk/windstille/src/display/surface_manager.hpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/display/surface_manager.hpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -56,7 +56,7 @@
   void load_grid(const Pathname& filename,
                  std::vector<SurfacePtr>& surfaces, int width, int height);
 
-  TexturePtr create_texture(const SoftwareSurface& image,
+  TexturePtr create_texture(SoftwareSurfacePtr image,
                             float* maxu, float* maxv);
 
   /** Removes all cached Sprites that are no longer in use */

Modified: trunk/windstille/src/display/texture.cpp
===================================================================
--- trunk/windstille/src/display/texture.cpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/display/texture.cpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -40,7 +40,7 @@
 }
 
 TexturePtr
-Texture::create(const SoftwareSurface& image, GLint format)
+Texture::create(SoftwareSurfacePtr image, GLint format)
 {
   return TexturePtr(new Texture(image, format));
 }
@@ -82,20 +82,20 @@
   glTexParameteri(target, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
 }
 
-Texture::Texture(const SoftwareSurface& image, GLint glformat) :
+Texture::Texture(SoftwareSurfacePtr image, GLint glformat) :
   m_target(GL_TEXTURE_2D),
   m_handle(0),
-  m_width(image.get_width()),
-  m_height(image.get_height())
+  m_width(image->get_width()),
+  m_height(image->get_height())
 {
   glGenTextures(1, &m_handle);
   assert_gl("Texture::Texture()"); 
 
   // Should be ok with OpenGL2.0
-  //if(!is_power_of_2(image.get_width()) || !is_power_of_2(image.get_height()))
+  //if(!is_power_of_2(image->get_width()) || !is_power_of_2(image->get_height()))
   //throw std::runtime_error("image has no power of 2 size");
 
-  if (image.get_bits_per_pixel() != 24 && image.get_bits_per_pixel() != 32)
+  if (image->get_bits_per_pixel() != 24 && image->get_bits_per_pixel() != 32)
     throw std::runtime_error("image has not 24 or 32 bit color depth");
 
   // FIXME: User SDL_ConvertSurface to bring images in the right format
@@ -106,18 +106,18 @@
     GLint maxt;
     glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxt);
 
-    if(image.get_width() > maxt || image.get_height() > maxt)
+    if(image->get_width() > maxt || image->get_height() > maxt)
     {
       throw std::runtime_error("Texture size not supported");
     }
 
     GLint sdl_format;
 
-    if (image.get_bytes_per_pixel() == 3)
+    if (image->get_bytes_per_pixel() == 3)
     {
       sdl_format = GL_RGB;
     }
-    else if (image.get_bytes_per_pixel() == 4)
+    else if (image->get_bytes_per_pixel() == 4)
     {
       sdl_format = GL_RGBA;
     }
@@ -129,13 +129,13 @@
     glBindTexture(GL_TEXTURE_2D, m_handle);
 
     glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, image.get_pitch() / image.get_bytes_per_pixel());
+    glPixelStorei(GL_UNPACK_ROW_LENGTH, image->get_pitch() / image->get_bytes_per_pixel());
 
     if (0)
     { // no mipmapping
       glTexImage2D(m_target, 0, glformat,
-                   image.get_width(), image.get_height(), 0, sdl_format,
-                   GL_UNSIGNED_BYTE, image.get_pixels());
+                   image->get_width(), image->get_height(), 0, sdl_format,
+                   GL_UNSIGNED_BYTE, image->get_pixels());
         
       glTexParameteri(m_target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
       glTexParameteri(m_target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
@@ -143,8 +143,8 @@
     else
     { // use mipmapping
       gluBuild2DMipmaps(m_target, glformat,
-                        image.get_width(), image.get_height(), sdl_format,
-                        GL_UNSIGNED_BYTE, image.get_pixels());
+                        image->get_width(), image->get_height(), sdl_format,
+                        GL_UNSIGNED_BYTE, image->get_pixels());
         
       glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
       glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
@@ -188,15 +188,15 @@
 }
 
 void
-Texture::put(const SoftwareSurface& image, const Rect& srcrect, int x, int y)
+Texture::put(SoftwareSurfacePtr image, const Rect& srcrect, int x, int y)
 {
   GLint sdl_format;
 
-  if (image.get_bytes_per_pixel() == 3)
+  if (image->get_bytes_per_pixel() == 3)
   {
     sdl_format = GL_RGB;
   }
-  else if (image.get_bytes_per_pixel() == 4)
+  else if (image->get_bytes_per_pixel() == 4)
   {
     sdl_format = GL_RGBA;
   }
@@ -210,19 +210,19 @@
   // FIXME: Add some checks here to make sure image has the right format 
   glPixelStorei(GL_UNPACK_ALIGNMENT, 4); // FIXME: Does SDL always use 4?
   glPixelStorei(GL_UNPACK_ROW_LENGTH,
-                image.get_pitch() / image.get_bytes_per_pixel());
+                image->get_pitch() / image->get_bytes_per_pixel());
 
   glTexSubImage2D(m_target, 0, x, y,
                   srcrect.get_width(), srcrect.get_height(), sdl_format, GL_UNSIGNED_BYTE,
-                  static_cast<uint8_t*>(image.get_pixels())
-                  + srcrect.top  * image.get_pitch()
-                  + srcrect.left * image.get_bytes_per_pixel());
+                  static_cast<uint8_t*>(image->get_pixels())
+                  + srcrect.top  * image->get_pitch()
+                  + srcrect.left * image->get_bytes_per_pixel());
 }
 
 void
-Texture::put(const SoftwareSurface& image, int x, int y)
+Texture::put(SoftwareSurfacePtr image, int x, int y)
 {
-  put(image, Rect(0, 0, image.get_width(), image.get_height()), x, y);
+  put(image, Rect(0, 0, image->get_width(), image->get_height()), x, y);
 }
 
 void
@@ -244,14 +244,14 @@
   glTexParameteri(m_target, GL_TEXTURE_MAG_FILTER, mode);
 }
 
-SoftwareSurface
+SoftwareSurfacePtr
 Texture::get_software_surface() const
 {
   glBindTexture(GL_TEXTURE_2D, m_handle);
 
-  SoftwareSurface surface(m_width, m_height);
+  SoftwareSurfacePtr surface = SoftwareSurface::create(m_width, m_height);
 
-  glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_UNSIGNED_BYTE, surface.get_pixels());
+  glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_UNSIGNED_BYTE, surface->get_pixels());
 
   return surface;
 }

Modified: trunk/windstille/src/display/texture.hpp
===================================================================
--- trunk/windstille/src/display/texture.hpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/display/texture.hpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -25,6 +25,7 @@
 #include <GL/gl.h>
 #include <boost/shared_ptr.hpp>
 
+#include "display/software_surface.hpp"
 #include "util/pathname.hpp"
 
 class SoftwareSurface;
@@ -44,7 +45,7 @@
    * Upload an SoftwareSurface onto an OpenGL texture. The surface must have power
    * of 2 dimensions
    * */
-  static TexturePtr create(const SoftwareSurface& image, GLint format = GL_RGBA);
+  static TexturePtr create(SoftwareSurfacePtr image, GLint format = GL_RGBA);
   
   /** 
    * Create an empty Texture with the given dimensions
@@ -53,7 +54,7 @@
   
 private:
   Texture();
-  Texture(const SoftwareSurface& image, GLint format = GL_RGBA);
+  Texture(SoftwareSurfacePtr image, GLint format = GL_RGBA);
   Texture(GLenum target, int width, int height, GLint format = GL_RGBA);
 
 public:
@@ -70,11 +71,11 @@
   void set_filter(GLenum mode);
 
   /** Uploads the given image to the given coordinates */
-  void put(const SoftwareSurface& image, int x, int y);
+  void put(SoftwareSurfacePtr image, int x, int y);
   
   /** Uploads the given subsection \a srcrect of \a image to the given
       coordinates */
-  void put(const SoftwareSurface& image, const Rect& srcrect, int x, int y);
+  void put(SoftwareSurfacePtr image, const Rect& srcrect, int x, int y);
 
   GLuint get_handle() const;
   
@@ -83,7 +84,7 @@
    */ 
   GLenum get_target() const;
 
-  SoftwareSurface get_software_surface() const;
+  SoftwareSurfacePtr get_software_surface() const;
 
 private:
   GLenum m_target;

Modified: trunk/windstille/src/display/texture_manager.cpp
===================================================================
--- trunk/windstille/src/display/texture_manager.cpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/display/texture_manager.cpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -50,7 +50,7 @@
   {
     try 
     {
-      SoftwareSurface image(filename);
+      SoftwareSurfacePtr image = SoftwareSurface::create(filename);
       TexturePtr texture = Texture::create(image);
 
       textures.insert(std::make_pair(filename, texture));

Modified: trunk/windstille/src/display/texture_packer.cpp
===================================================================
--- trunk/windstille/src/display/texture_packer.cpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/display/texture_packer.cpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -149,12 +149,12 @@
 }
 
 SurfacePtr
-TexturePacker::upload(const SoftwareSurface& surface)
+TexturePacker::upload(SoftwareSurfacePtr surface)
 {
   // Add a 1px border around surfaces to avoid blending artifacts
   //SoftwareSurface surface = in_surface.add_1px_border();
 
-  Size    size(surface.get_width()+2, surface.get_height()+2);
+  Size    size(surface->get_width()+2, surface->get_height()+2);
   Rect    rect;
   TexturePtr texture;
 
@@ -167,26 +167,26 @@
     // duplicate border pixel
 
     // top
-    texture->put(surface, Rect(Point(0, 0), Size(surface.get_width(), 1)), 
+    texture->put(surface, Rect(Point(0, 0), Size(surface->get_width(), 1)), 
                  rect.left+1, rect.top);
     // bottom
-    texture->put(surface, Rect(Point(0, surface.get_height()-1), Size(surface.get_width(), 1)), 
+    texture->put(surface, Rect(Point(0, surface->get_height()-1), Size(surface->get_width(), 1)), 
                  rect.left+1, rect.bottom-1);
     // left
-    texture->put(surface, Rect(Point(0, 0), Size(1, surface.get_height())), 
+    texture->put(surface, Rect(Point(0, 0), Size(1, surface->get_height())), 
                  rect.left, rect.top+1);
     // right
-    texture->put(surface, Rect(Point(surface.get_width()-1, 0), Size(1, surface.get_height())),
+    texture->put(surface, Rect(Point(surface->get_width()-1, 0), Size(1, surface->get_height())),
                  rect.right-1, rect.top+1);
 
     // duplicate corner pixels
     texture->put(surface, Rect(Point(0, 0), Size(1, 1)), 
                  rect.left, rect.top);     
-    texture->put(surface, Rect(Point(surface.get_width()-1, 0), Size(1, 1)), 
+    texture->put(surface, Rect(Point(surface->get_width()-1, 0), Size(1, 1)), 
                  rect.right-1, rect.top);
-    texture->put(surface, Rect(Point(surface.get_width()-1, surface.get_height()-1), Size(1, 1)), 
+    texture->put(surface, Rect(Point(surface->get_width()-1, surface->get_height()-1), Size(1, 1)), 
                  rect.right-1, rect.bottom-1);
-    texture->put(surface, Rect(Point(0, surface.get_height()-1), Size(1, 1)),
+    texture->put(surface, Rect(Point(0, surface->get_height()-1), Size(1, 1)),
                  rect.left, rect.bottom-1);
 
     // draw the main surface
@@ -197,7 +197,7 @@
                                  static_cast<float>(rect.top+1)    / static_cast<float>(texture->get_height()),
                                  static_cast<float>(rect.right-1)  / static_cast<float>(texture->get_width()), 
                                  static_cast<float>(rect.bottom-1) / static_cast<float>(texture->get_height())),
-                           Sizef(static_cast<float>(surface.get_width()), static_cast<float>(surface.get_height())));
+                           Sizef(static_cast<float>(surface->get_width()), static_cast<float>(surface->get_height())));
   }
 }
 
@@ -207,12 +207,12 @@
   for(Textures::const_iterator i = textures.begin(); i != textures.end(); ++i)
   {
     TexturePtr texture = (*i)->get_texture();
-    SoftwareSurface surface = texture->get_software_surface();
+    SoftwareSurfacePtr surface = texture->get_software_surface();
 
     char filename[1024];
     sprintf(filename, "/tmp/texture_packer%04d.png", int(i - textures.begin()));
     std::cout << "Saving: " << filename << std::endl;
-    surface.save_png(filename);
+    surface->save_png(filename);
   }
 }
 

Modified: trunk/windstille/src/display/texture_packer.hpp
===================================================================
--- trunk/windstille/src/display/texture_packer.hpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/display/texture_packer.hpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -41,7 +41,7 @@
   TexturePacker(const Size& texture_size);
   ~TexturePacker();
   
-  SurfacePtr upload(const SoftwareSurface& surface);
+  SurfacePtr upload(SoftwareSurfacePtr surface);
   bool allocate(const Size& size, Rect& rect, TexturePtr& out_texture);
   
   void save_all_as_png() const;

Modified: trunk/windstille/src/font/border_font_effect.cpp
===================================================================
--- trunk/windstille/src/font/border_font_effect.cpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/font/border_font_effect.cpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -62,7 +62,7 @@
 }
 
 void
-BorderFontEffect::blit(const SoftwareSurface& target, const FT_Bitmap& brush, int x_pos, int y_pos) const
+BorderFontEffect::blit(SoftwareSurfacePtr target, const FT_Bitmap& brush, int x_pos, int y_pos) const
 {
   x_pos += size;
   y_pos += size;
@@ -70,12 +70,12 @@
   int start_x = std::max(0, -x_pos);
   int start_y = std::max(0, -y_pos);
   
-  int end_x = std::min(brush.width, target.get_width()  - x_pos);
-  int end_y = std::min(brush.rows,  target.get_height() - y_pos);
+  int end_x = std::min(brush.width, target->get_width()  - x_pos);
+  int end_y = std::min(brush.rows,  target->get_height() - y_pos);
 
-  unsigned char* target_buf = static_cast<unsigned char*>(target.get_pixels());
+  unsigned char* target_buf = static_cast<unsigned char*>(target->get_pixels());
 
-  int target_pitch = target.get_pitch();
+  int target_pitch = target->get_pitch();
 
   uint8_t red   = 0;
   uint8_t blue  = 0;

Modified: trunk/windstille/src/font/border_font_effect.hpp
===================================================================
--- trunk/windstille/src/font/border_font_effect.hpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/font/border_font_effect.hpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -45,7 +45,7 @@
   int get_x_offset(int orig_glyph_offset) const;
   int get_y_offset(int orig_glyph_offset) const;
   
-  void blit(const SoftwareSurface& target, const FT_Bitmap& brush, int x_pos, int y_pos) const;
+  void blit(SoftwareSurfacePtr target, const FT_Bitmap& brush, int x_pos, int y_pos) const;
 
   /* disabled for g++-4.2 compatibilty
      private:

Modified: trunk/windstille/src/font/font_effect.hpp
===================================================================
--- trunk/windstille/src/font/font_effect.hpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/font/font_effect.hpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -22,9 +22,9 @@
 #include <ft2build.h>
 #include FT_FREETYPE_H
 #include FT_GLYPH_H
+
+#include "display/software_surface.hpp"
 
-class SoftwareSurface;
-
 /** 
  *  The FontEffect class manages the blitting from a glyph bitmap to
  *  the SDL_Surface, it allows to apply different kinds of effects to
@@ -46,7 +46,7 @@
   virtual int get_x_offset(int orig_glyph_offset) const =0;
   virtual int get_y_offset(int orig_glyph_offset) const =0;
   
-  virtual void blit(const SoftwareSurface& target, const FT_Bitmap& brush, int x_pos, int y_pos) const =0;
+  virtual void blit(SoftwareSurfacePtr target, const FT_Bitmap& brush, int x_pos, int y_pos) const =0;
 
   /* disabled for g++-4.2 compatibilty
      private:

Modified: trunk/windstille/src/font/no_font_effect.cpp
===================================================================
--- trunk/windstille/src/font/no_font_effect.cpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/font/no_font_effect.cpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -20,17 +20,17 @@
 #include "font/no_font_effect.hpp"
 
 void
-NoFontEffect::blit(const SoftwareSurface& target, const FT_Bitmap& brush, int x_pos, int y_pos) const
+NoFontEffect::blit(SoftwareSurfacePtr target, const FT_Bitmap& brush, int x_pos, int y_pos) const
 {
   int start_x = std::max(0, -x_pos);
   int start_y = std::max(0, -y_pos);
   
-  int end_x = std::min(brush.width, target.get_width()  - x_pos);
-  int end_y = std::min(brush.rows,  target.get_height() - y_pos);
+  int end_x = std::min(brush.width, target->get_width()  - x_pos);
+  int end_y = std::min(brush.rows,  target->get_height() - y_pos);
 
-  unsigned char* target_buf = static_cast<unsigned char*>(target.get_pixels());
+  unsigned char* target_buf = static_cast<unsigned char*>(target->get_pixels());
 
-  int target_pitch = target.get_pitch();
+  int target_pitch = target->get_pitch();
 
   for (int y = start_y; y < end_y; ++y)
     for (int x = start_x; x < end_x; ++x)

Modified: trunk/windstille/src/font/no_font_effect.hpp
===================================================================
--- trunk/windstille/src/font/no_font_effect.hpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/font/no_font_effect.hpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -36,7 +36,7 @@
   int get_x_offset(int orig_glyph_offset) const { return orig_glyph_offset; }
   int get_y_offset(int orig_glyph_offset) const { return orig_glyph_offset; }
   
-  void blit(const SoftwareSurface& target, const FT_Bitmap& brush, int x_pos, int y_pos) const;
+  void blit(SoftwareSurfacePtr target, const FT_Bitmap& brush, int x_pos, int y_pos) const;
   
   /* disabled for g++-4.2 compatibilty
      private:

Modified: trunk/windstille/src/font/ttf_font.cpp
===================================================================
--- trunk/windstille/src/font/ttf_font.cpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/font/ttf_font.cpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -89,7 +89,7 @@
   FT_Select_Charmap(face,  FT_ENCODING_UNICODE);
 
   // FIXME: should calculate texture size, based on font size
-  SoftwareSurface pixelbuffer(1024, 1024);
+  SoftwareSurfacePtr pixelbuffer = SoftwareSurface::create(1024, 1024);
   
   int x_pos = 1;
   int y_pos = 1;
@@ -127,23 +127,23 @@
                      effect.get_y_offset(-face->glyph->bitmap_top)),
                Size(glyph_width, glyph_height));
 
-      Rectf uv(static_cast<float>(x_pos) / static_cast<float>(pixelbuffer.get_width()),
-               static_cast<float>(y_pos) / static_cast<float>(pixelbuffer.get_height()),
-               static_cast<float>(x_pos + glyph_width)/static_cast<float>(pixelbuffer.get_width()),
-               static_cast<float>(y_pos + glyph_height)/static_cast<float>(pixelbuffer.get_height()));
+      Rectf uv(static_cast<float>(x_pos) / static_cast<float>(pixelbuffer->get_width()),
+               static_cast<float>(y_pos) / static_cast<float>(pixelbuffer->get_height()),
+               static_cast<float>(x_pos + glyph_width)/static_cast<float>(pixelbuffer->get_width()),
+               static_cast<float>(y_pos + glyph_height)/static_cast<float>(pixelbuffer->get_height()));
       
       impl->characters.push_back(TTFCharacter(pos, uv,
                                               face->glyph->advance.x >> 6));
 
       // we leave a one pixel border around the letters which we fill with generate_border
       x_pos += glyph_width + 2;
-      if (x_pos + max_glyph_height + 2 > pixelbuffer.get_width()) // FIXME: should use glyph_width of the next glyph instead of max_glyph_height
+      if (x_pos + max_glyph_height + 2 > pixelbuffer->get_width()) // FIXME: should use glyph_width of the next glyph instead of max_glyph_height
       {
         y_pos += max_glyph_height + 2;
         x_pos = 1;
       }
 
-      if (y_pos + max_glyph_height + 2 > pixelbuffer.get_height())
+      if (y_pos + max_glyph_height + 2 > pixelbuffer->get_height())
         throw std::runtime_error("Font Texture to small");
     }
   }

Modified: trunk/windstille/src/gui/automap.cpp
===================================================================
--- trunk/windstille/src/gui/automap.cpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/gui/automap.cpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -43,26 +43,26 @@
 {
   TileMap* tilemap = Sector::current()->get_tilemap();
 
-  SoftwareSurface image(tilemap->get_width(), tilemap->get_height());
+  SoftwareSurfacePtr image = SoftwareSurface::create(tilemap->get_width(), tilemap->get_height());
   
-  unsigned char* buffer = static_cast<unsigned char*>(image.get_pixels());
+  unsigned char* buffer = static_cast<unsigned char*>(image->get_pixels());
 
-  for(int y = 0; y < image.get_height(); ++y)
-    for(int x = 0; x < image.get_width(); ++x)
+  for(int y = 0; y < image->get_height(); ++y)
+    for(int x = 0; x < image->get_width(); ++x)
     {
       if (tilemap->get_pixel(x, y))
       {
-        buffer[image.get_pitch() * y + 4*x + 0] = 255;
-        buffer[image.get_pitch() * y + 4*x + 1] = 255;
-        buffer[image.get_pitch() * y + 4*x + 2] = 255;
-        buffer[image.get_pitch() * y + 4*x + 3] = 255;
+        buffer[image->get_pitch() * y + 4*x + 0] = 255;
+        buffer[image->get_pitch() * y + 4*x + 1] = 255;
+        buffer[image->get_pitch() * y + 4*x + 2] = 255;
+        buffer[image->get_pitch() * y + 4*x + 3] = 255;
       }
       else
       {
-        buffer[image.get_pitch() * y + 4*x + 0] = 0;
-        buffer[image.get_pitch() * y + 4*x + 1] = 0;
-        buffer[image.get_pitch() * y + 4*x + 2] = 0;
-        buffer[image.get_pitch() * y + 4*x + 3] = 255;
+        buffer[image->get_pitch() * y + 4*x + 0] = 0;
+        buffer[image->get_pitch() * y + 4*x + 1] = 0;
+        buffer[image->get_pitch() * y + 4*x + 2] = 0;
+        buffer[image->get_pitch() * y + 4*x + 3] = 255;
       }
     }
 

Modified: trunk/windstille/src/tile/tile_description.cpp
===================================================================
--- trunk/windstille/src/tile/tile_description.cpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/tile/tile_description.cpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -45,7 +45,7 @@
 TileDescription::load(TileFactory* factory)
 {  
   // FIXM: SoftwareSurface image(Pathname(filename)); doesn't work, as its handled as function declaration!?
-  SoftwareSurface image = SoftwareSurface(Pathname(filename));
+  SoftwareSurfacePtr image = SoftwareSurface::create(Pathname(filename));
 
   int num_tiles = width * height; //(image->w/TILE_RESOLUTION) * (image->h/TILE_RESOLUTION);
   if (int(colmap.size()) != num_tiles)

Modified: trunk/windstille/src/tile/tile_factory.cpp
===================================================================
--- trunk/windstille/src/tile/tile_factory.cpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/tile/tile_factory.cpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -27,14 +27,14 @@
 #include "display/software_surface.hpp"
 
 /** Check if the given region of the given image is fully transparent */
-bool surface_empty(const SoftwareSurface& image, int sx, int sy, int w, int h)
+bool surface_empty(SoftwareSurfacePtr image, int sx, int sy, int w, int h)
 { 
-  unsigned char* data = static_cast<unsigned char*>(image.get_pixels());
+  unsigned char* data = static_cast<unsigned char*>(image->get_pixels());
   
   for(int y = sy; y < sy + h; ++y)
     for(int x = sx; x < sx + w; ++x)
     {
-      if (data[y * image.get_pitch() + 4*x + 3] != 0)
+      if (data[y * image->get_pitch() + 4*x + 3] != 0)
       { 
         return false;
       }
@@ -117,7 +117,7 @@
 }
 
 void
-TileFactory::pack(int id, int colmap, const SoftwareSurface& image, const Rect& rect)
+TileFactory::pack(int id, int colmap, SoftwareSurfacePtr image, const Rect& rect)
 {
   if(id < int(tiles.size())
      && tiles[id] != 0

Modified: trunk/windstille/src/tile/tile_factory.hpp
===================================================================
--- trunk/windstille/src/tile/tile_factory.hpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/tile/tile_factory.hpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -22,6 +22,7 @@
 #include <map>
 #include <string>
 
+#include "display/software_surface.hpp"
 #include "tile/tile_description.hpp"
 #include "util/currenton.hpp"
 
@@ -63,7 +64,7 @@
   /** 
    * Adds a surface to the TileFactory
    */
-  void pack(int id, int colmap, const SoftwareSurface& image, const Rect& rect);
+  void pack(int id, int colmap, SoftwareSurfacePtr image, const Rect& rect);
 
 private:
   void parse_tiles(FileReader& reader);

Modified: trunk/windstille/src/tile/tile_packer.cpp
===================================================================
--- trunk/windstille/src/tile/tile_packer.cpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/tile/tile_packer.cpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -67,12 +67,12 @@
 /** Pack a tile and return the position where it is placed in the
     pixel buffer */
 Rectf
-TilePacker::pack(const SoftwareSurface& image, int x, int y, int w, int h)
+TilePacker::pack(SoftwareSurfacePtr image, int x, int y, int w, int h)
 {
   assert(w == TILE_RESOLUTION && h == TILE_RESOLUTION);
   assert(!is_full());
 
-  SoftwareSurface convert(w+2, h+2);
+  SoftwareSurfacePtr convert = SoftwareSurface::create(w+2, h+2);
 
   SDL_Rect source_rect;
   source_rect.x = static_cast<Sint16>(x);
@@ -86,7 +86,7 @@
   dest_rect.w = static_cast<Sint16>(w);
   dest_rect.h = static_cast<Sint16>(h);
 
-  SDL_BlitSurface(image.get_surface(), &source_rect, convert.get_surface(), &dest_rect);
+  SDL_BlitSurface(image->get_surface(), &source_rect, convert->get_surface(), &dest_rect);
 
   generate_border(convert, 1, 1, TILE_RESOLUTION, TILE_RESOLUTION);
 

Modified: trunk/windstille/src/tile/tile_packer.hpp
===================================================================
--- trunk/windstille/src/tile/tile_packer.hpp	2010-09-22 10:16:26 UTC (rev 3364)
+++ trunk/windstille/src/tile/tile_packer.hpp	2010-09-22 10:46:51 UTC (rev 3365)
@@ -42,7 +42,7 @@
 
   /** Pack a tile and return the position where it is placed in the
       pixel buffer */
-  Rectf pack(const SoftwareSurface& image, int x, int y, int w, int h);
+  Rectf pack(SoftwareSurfacePtr image, int x, int y, int w, int h);
 
   /** Return true if the PixelBuffer is full */
   bool is_full() const;



From grumbel at mail.berlios.de  Wed Sep 22 13:34:40 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Wed, 22 Sep 2010 13:34:40 +0200
Subject: [Windstille-commit] r3366 - trunk/windstille/src/display
Message-ID: <20100922113440.95BDA480F56@sheep.berlios.de>

Author: grumbel
Date: 2010-09-22 13:34:40 +0200 (Wed, 22 Sep 2010)
New Revision: 3366

Modified:
   trunk/windstille/src/display/shader_object.cpp
   trunk/windstille/src/display/shader_object.hpp
   trunk/windstille/src/display/shader_program.cpp
   trunk/windstille/src/display/shader_program.hpp
Log:
Replaced ShaderObject with ShaderObjectPtr, same for ShaderProgram


Modified: trunk/windstille/src/display/shader_object.cpp
===================================================================
--- trunk/windstille/src/display/shader_object.cpp	2010-09-22 10:46:51 UTC (rev 3365)
+++ trunk/windstille/src/display/shader_object.cpp	2010-09-22 11:34:40 UTC (rev 3366)
@@ -51,25 +51,17 @@
   return str;
 }
 
-class ShaderObjectImpl
+ShaderObjectPtr
+ShaderObject::create(GLenum type, const std::string& filename)
 {
-public:
-  GLuint handle;
-
-  ShaderObjectImpl(GLenum type)
-    : handle(glCreateShader(type))
-  {
-  }
-
-  ~ShaderObjectImpl()
-  {
-    glDeleteShader(handle);
-  }
-};
+  return ShaderObjectPtr(new ShaderObject(type, filename));
+}
 
 ShaderObject::ShaderObject(GLenum type, const std::string& filename) :
-  impl(new ShaderObjectImpl(type))
+  m_handle(0)
 {
+  m_handle = glCreateShader(type);
+
   load(filename);
   compile();
   print_log();
@@ -77,13 +69,14 @@
 
 ShaderObject::~ShaderObject()
 {
+  glDeleteShader(m_handle);
 }
 
 void
 ShaderObject::load(const std::string& filename)
 {
   GLchar* buf = load_file(filename.c_str());
-  glShaderSource(impl->handle, 1, const_cast<const GLchar**>(&buf), NULL);
+  glShaderSource(m_handle, 1, const_cast<const GLchar**>(&buf), NULL);
   assert_gl("load_source");
 
   std::cout << "Source:\n" << buf << std::endl;
@@ -93,13 +86,13 @@
 GLuint 
 ShaderObject::get_handle() const
 {
-  return impl->handle;
+  return m_handle;
 }
 
 void
 ShaderObject::compile()
 {
-  glCompileShader(impl->handle);
+  glCompileShader(m_handle);
 }
 
 void
@@ -110,7 +103,7 @@
   GLchar* infoLog;
 
   assert_gl("print_log1");
-  glGetShaderiv(impl->handle, GL_INFO_LOG_LENGTH, &infologLength);
+  glGetShaderiv(m_handle, GL_INFO_LOG_LENGTH, &infologLength);
   assert_gl("print_log2");
 
   if (infologLength > 0)
@@ -121,7 +114,7 @@
       printf("ERROR: Could not allocate InfoLog buffer\n");
       exit(1);
     }
-    glGetShaderInfoLog(impl->handle, infologLength, &charsWritten, infoLog);
+    glGetShaderInfoLog(m_handle, infologLength, &charsWritten, infoLog);
     printf("InfoLog:\n%s\n\n", infoLog);
     free(infoLog);
   }

Modified: trunk/windstille/src/display/shader_object.hpp
===================================================================
--- trunk/windstille/src/display/shader_object.hpp	2010-09-22 10:46:51 UTC (rev 3365)
+++ trunk/windstille/src/display/shader_object.hpp	2010-09-22 11:34:40 UTC (rev 3366)
@@ -23,13 +23,19 @@
 #include <GL/gl.h>
 #include <string>
 #include <boost/shared_ptr.hpp>
-
-class ShaderObjectImpl;
-
+
+class ShaderObject;
+typedef boost::shared_ptr<ShaderObject> ShaderObjectPtr;
+
 class ShaderObject
 {
 public:
+  static ShaderObjectPtr create(GLenum type, const std::string& filename);
+
+private:
   ShaderObject(GLenum type, const std::string& filename);
+
+public:
   ~ShaderObject();
 
   GLuint get_handle() const;
@@ -38,9 +44,9 @@
   void print_log();
 
 private:
-  boost::shared_ptr<ShaderObjectImpl> impl;
+  GLuint m_handle;
 };
-
+
 #endif
 
 /* EOF */

Modified: trunk/windstille/src/display/shader_program.cpp
===================================================================
--- trunk/windstille/src/display/shader_program.cpp	2010-09-22 10:46:51 UTC (rev 3365)
+++ trunk/windstille/src/display/shader_program.cpp	2010-09-22 11:34:40 UTC (rev 3366)
@@ -22,39 +22,33 @@
 #include "display/assert_gl.hpp"
 #include "display/shader_program.hpp"
 
-class ShaderProgramImpl
+ShaderProgramPtr
+ShaderProgram::create()
 {
-public:
-  GLuint handle;
-
-  ShaderProgramImpl() 
-    : handle(glCreateProgram())
-  {}
-
-  ~ShaderProgramImpl() {
-    glDeleteProgram(handle);
-  }
-};
-
+  return ShaderProgramPtr(new ShaderProgram());
+}
+
 ShaderProgram::ShaderProgram() :
-  impl(new ShaderProgramImpl())
+ m_handle(0)
 {
+  m_handle = glCreateProgram();
 }
 
 ShaderProgram::~ShaderProgram()
 {
+  glDeleteProgram(m_handle);
 }
 
 void
-ShaderProgram::attach(const ShaderObject& obj)
+ShaderProgram::attach(ShaderObjectPtr obj)
 {
-  glAttachShader(impl->handle, obj.get_handle());
+  glAttachShader(m_handle, obj->get_handle());
 }
 
 void
 ShaderProgram::link()
 {
-  glLinkProgram(impl->handle);
+  glLinkProgram(m_handle);
 }
 
 GLint
@@ -62,7 +56,7 @@
 {
   GLint loc;
 
-  loc = glGetUniformLocation(impl->handle, name);
+  loc = glGetUniformLocation(m_handle, name);
 
   if (loc == -1)
     std::cout << "No such uniform named \"%s\"\n" << name << std::endl;
@@ -75,13 +69,13 @@
 GLuint 
 ShaderProgram::get_handle() const
 {
-  return impl->handle;
+  return m_handle;
 }
 
 void
 ShaderProgram::set_uniform1f(const char* name, GLfloat v0)
 {
-  GLint location = glGetUniformLocation(impl->handle, name);
+  GLint location = glGetUniformLocation(m_handle, name);
   if (location == -1)
     std::cout << "No such uniform named \"" << name << "\"" << std::endl;
   else
@@ -91,7 +85,7 @@
 void
 ShaderProgram::set_uniform2f(const char* name, GLfloat v0, GLfloat v1)
 {
-  GLint location = glGetUniformLocation(impl->handle, name);
+  GLint location = glGetUniformLocation(m_handle, name);
   if (location == -1)
     std::cout << "No such uniform named \"" << name << "\"" << std::endl;
   else
@@ -101,7 +95,7 @@
 void
 ShaderProgram::set_uniform3f(const char* name, GLfloat v0, GLfloat v1, GLfloat v2)
 {
-  GLint location = glGetUniformLocation(impl->handle, name);
+  GLint location = glGetUniformLocation(m_handle, name);
   if (location == -1)
     std::cout << "No such uniform named \"" << name << "\"" << std::endl;
   else
@@ -111,7 +105,7 @@
 void
 ShaderProgram::set_uniform4f(const char* name, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
 {
-  GLint location = glGetUniformLocation(impl->handle, name);
+  GLint location = glGetUniformLocation(m_handle, name);
   if (location == -1)
     std::cout << "No such uniform named \"" << name << "\"" << std::endl;
   else
@@ -121,7 +115,7 @@
 void
 ShaderProgram::set_uniform1i(const char* name, GLint v0)
 {
-  GLint location = glGetUniformLocation(impl->handle, name);
+  GLint location = glGetUniformLocation(m_handle, name);
   if (location == -1)
     std::cout << "No such uniform named \"" << name << "\"" << std::endl;
   else
@@ -131,7 +125,7 @@
 void
 ShaderProgram::set_uniform2i(const char* name, GLint v0, GLint v1)
 {
-  GLint location = glGetUniformLocation(impl->handle, name);
+  GLint location = glGetUniformLocation(m_handle, name);
   if (location == -1)
     std::cout << "No such uniform named \"" << name << "\"" << std::endl;
   else
@@ -141,7 +135,7 @@
 void
 ShaderProgram::set_uniform3i(const char* name, GLint v0, GLint v1, GLint v2)
 {
-  GLint location = glGetUniformLocation(impl->handle, name);
+  GLint location = glGetUniformLocation(m_handle, name);
   if (location == -1)
     std::cout << "No such uniform named \"" << name << "\"" << std::endl;
   else
@@ -151,7 +145,7 @@
 void
 ShaderProgram::set_uniform4i(const char* name, GLint v0, GLint v1, GLint v2, GLint v3)
 {
-  GLint location = glGetUniformLocation(impl->handle, name);
+  GLint location = glGetUniformLocation(m_handle, name);
   if (location == -1)
     std::cout << "No such uniform named \"" << name << "\"" << std::endl;
   else

Modified: trunk/windstille/src/display/shader_program.hpp
===================================================================
--- trunk/windstille/src/display/shader_program.hpp	2010-09-22 10:46:51 UTC (rev 3365)
+++ trunk/windstille/src/display/shader_program.hpp	2010-09-22 11:34:40 UTC (rev 3366)
@@ -23,18 +23,24 @@
 #include <GL/gl.h>
 #include <boost/shared_ptr.hpp>
 
-class ShaderProgramImpl;
+#include "display/shader_object.hpp"
+
 class ShaderObject;
+class ShaderProgram;
+typedef boost::shared_ptr<ShaderProgram> ShaderProgramPtr;
 
-/** */
 class ShaderProgram
 {
+public:
+  static ShaderProgramPtr create(); 
+
 private:
+  ShaderProgram();
+
 public:
-  ShaderProgram();
   ~ShaderProgram();
 
-  void attach(const ShaderObject& obj);
+  void attach(ShaderObjectPtr obj);
   void link();
 
   GLint get_uniform_location(const char* name);
@@ -53,7 +59,7 @@
   void set_uniform4i(const char* name, GLint v0, GLint v1, GLint v2, GLint v3);
 
 private:
-  boost::shared_ptr<ShaderProgramImpl> impl;
+  GLuint m_handle;
 };
 
 #endif



