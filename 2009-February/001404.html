<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Windstille-commit] r2407 - in trunk: . blender windstille/tools
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/windstille-commit/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r2407%20-%20in%20trunk%3A%20.%20blender%20windstille/tools&In-Reply-To=%3C200902051742.n15HgqK1022375%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001403.html">
   <LINK REL="Next"  HREF="001405.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Windstille-commit] r2407 - in trunk: . blender windstille/tools</H1>
    <B>grumbel at BerliOS</B> 
    <A HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r2407%20-%20in%20trunk%3A%20.%20blender%20windstille/tools&In-Reply-To=%3C200902051742.n15HgqK1022375%40sheep.berlios.de%3E"
       TITLE="[Windstille-commit] r2407 - in trunk: . blender windstille/tools">grumbel at mail.berlios.de
       </A><BR>
    <I>Thu Feb  5 18:42:52 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001403.html">[Windstille-commit] r2406 - in trunk/windstille: . test
</A></li>
        <LI>Next message: <A HREF="001405.html">[Windstille-commit] r2408 - in trunk: . blender-thumbnail scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1404">[ date ]</a>
              <a href="thread.html#1404">[ thread ]</a>
              <a href="subject.html#1404">[ subject ]</a>
              <a href="author.html#1404">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: grumbel
Date: 2009-02-05 18:42:50 +0100 (Thu, 05 Feb 2009)
New Revision: 2407

Added:
   trunk/blender/
   trunk/blender/bone_export.py
   trunk/blender/bone_test.blend
   trunk/blender/ipo_export.py
   trunk/blender/mesh_export.py
   trunk/blender/model_test.blend
   trunk/blender/pose_export.py
   trunk/blender/windstille_export.py
Removed:
   trunk/windstille/tools/bone_export.py
   trunk/windstille/tools/bone_test.blend
   trunk/windstille/tools/ipo_export.py
   trunk/windstille/tools/mesh_export.py
   trunk/windstille/tools/model_test.blend
   trunk/windstille/tools/pose_export.py
   trunk/windstille/tools/windstille_export.py
Log:
Moved some more tools out of windstille/ tree

Copied: trunk/blender/bone_export.py (from rev 2405, trunk/windstille/tools/bone_export.py)


Property changes on: trunk/blender/bone_export.py
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/blender/bone_test.blend (from rev 2405, trunk/windstille/tools/bone_test.blend)


Property changes on: trunk/blender/bone_test.blend
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream
Name: svn:mergeinfo
   + 

Copied: trunk/blender/ipo_export.py (from rev 2405, trunk/windstille/tools/ipo_export.py)


Property changes on: trunk/blender/ipo_export.py
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/blender/mesh_export.py (from rev 2405, trunk/windstille/tools/mesh_export.py)


Property changes on: trunk/blender/mesh_export.py
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/blender/model_test.blend (from rev 2405, trunk/windstille/tools/model_test.blend)


Property changes on: trunk/blender/model_test.blend
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream
Name: svn:mergeinfo
   + 

Copied: trunk/blender/pose_export.py (from rev 2405, trunk/windstille/tools/pose_export.py)


Property changes on: trunk/blender/pose_export.py
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/blender/windstille_export.py (from rev 2405, trunk/windstille/tools/windstille_export.py)


Property changes on: trunk/blender/windstille_export.py
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: trunk/windstille/tools/bone_export.py
===================================================================
--- trunk/windstille/tools/bone_export.py	2009-02-05 17:35:39 UTC (rev 2406)
+++ trunk/windstille/tools/bone_export.py	2009-02-05 17:42:50 UTC (rev 2407)
@@ -1,81 +0,0 @@
-import Blender
-from Blender import *
-
-arms = Blender.Armature.Get()
-
-def vec2str(vec):
-    return &quot;%f %f %f&quot; % (vec.x,vec.y,vec.z)
-
-def euler2str(euler):
-    return &quot;%f %f %f&quot; % (euler.x, euler.y, euler.z)
-
-def quat2str(quat):
-    return &quot;%f %f %f %f&quot; % (quat.w, quat.x, quat.y, quat.z)
-
-def matrix2str(indent, m):
-        return          (&quot;%9f %9f %9f %9f\n&quot; % (m[0][0], m[0][1], m[0][2], 0)) + \
-               indent + (&quot;%9f %9f %9f %9f\n&quot; % (m[1][0], m[1][1], m[1][2], 0)) + \
-               indent + (&quot;%9f %9f %9f %9f\n&quot; % (m[2][0], m[2][1], m[2][2], 0)) + \
-               indent + (&quot;%9f %9f %9f %9f&quot;   % (      0,       0,       0, 1))
-
-def list2str(lst):
-    str = &quot;&quot;
-    for i in lst:
-        str += &quot; \&quot;%s\&quot;&quot; % i
-    return str
-
-def export_armature(out, armature):
-    out.write(&quot;;; -*- scheme -*-\n&quot;)
-    out.write(&quot;(armature\n&quot;)
-    out.write(&quot;  (name \&quot;%s\&quot;)\n&quot; % armature.name)
-    out.write(&quot;  (bones\n&quot;)
-
-    for bone in armature.bones.values():
-        if bone.name[:3] == &quot;IK_&quot;: # ignore helper bones
-            out.write(&quot;    ;; ignoring bone: %s\n&quot; % bone.name)
-            out.write(&quot;\n&quot;)
-        else:
-            if bone.parent:
-                out.write(&quot;    (bone\n&quot;)
-            else:
-                out.write(&quot;    (bone ;; a root bone\n&quot;)
-
-            out.write(&quot;      (name      \&quot;%s\&quot;)\n&quot; % bone.name)
-
-            out.write(&quot;      (children %s)\n&quot; % list2str(map(lambda b: b.name, bone.children)))
-
-            # If a bone lacks parent its head is in armature space,
-            # else in local bonespace
-            if bone.parent:
-                out.write(&quot;      (parent    \&quot;%s\&quot;)\n&quot; % bone.parent.name)
-                out.write(&quot;      (head      %s)\n&quot; % (vec2str(bone.head['BONESPACE']),))
-            else:
-                out.write(&quot;      (parent )\n&quot;)
-                out.write(&quot;      (head      %s)\n&quot; % (vec2str(bone.head['ARMATURESPACE'])))
-
-            out.write(&quot;      (length    %s)\n&quot; % (bone.length))
-            out.write(&quot;      (matrix   %s)\n&quot; % matrix2str(&quot; &quot;*16, bone.matrix['BONESPACE']))
-            out.write(&quot;      (quat      %s)\n&quot; % quat2str(bone.matrix['BONESPACE'].toQuat()))
-            out.write(&quot;      (euler     %s)\n&quot; % euler2str(bone.matrix['BONESPACE'].toEuler()))
-            # out.write(&quot;###  BoneSpace:&quot;
-            # out.write(bone.matrix['BONESPACE']
-            # print
-            # out.write(&quot;  ArmatureSpace:&quot;
-            #  out.write(bone.matrix['ARMATURESPACE']
-            out.write(&quot;     )\n\n&quot;)
-    out.write(&quot;  ) ;; bones\n&quot;)
-    out.write(&quot; ) ;; armature\n&quot;)
-
-print &quot;Windstille Bone Exporter:&quot;
-for armature in arms.values():
-    filename = &quot;/tmp/bone-%s.scm&quot; % armature.name
-    out = file(filename, &quot;w&quot;)
-    print &quot;  - exporting to '%s'...&quot; % filename,
-    export_armature(out, armature)
-    out.close()
-    print &quot;done&quot;
-print
-
-Draw.PupMenu(&quot;Export ok&quot;)
-
-# EOF #

Deleted: trunk/windstille/tools/bone_test.blend
===================================================================
(Binary files differ)

Deleted: trunk/windstille/tools/ipo_export.py
===================================================================
--- trunk/windstille/tools/ipo_export.py	2009-02-05 17:35:39 UTC (rev 2406)
+++ trunk/windstille/tools/ipo_export.py	2009-02-05 17:42:50 UTC (rev 2407)
@@ -1,35 +0,0 @@
-import Blender
-import Blender.Armature
-from Blender import Ipo
-
-def vec2str(vec):
-    return &quot;%f %f %f&quot; % (vec.x,vec.y,vec.z)
-
-def export_action(out, action):
-    out.write(&quot;;; -*- scheme -*-\n&quot;)
-    out.write(&quot;(action\n&quot;)
-    out.write(&quot;  (name \&quot;%s\&quot;)\n&quot; % action.getName())
-    out.write(&quot;  (bones\n&quot;)
-    for ipo in action.getAllChannelIpos().values():
-        out.write(&quot;    (bone\n&quot;)
-        out.write(&quot;      (name \&quot;%s\&quot;)\n&quot; % ipo.getName())
-        for (v, k) in [('quatw', Ipo.PO_QUATW), ('quatx', Ipo.PO_QUATX),
-                       ('quaty', Ipo.PO_QUATY), ('quatz', Ipo.PO_QUATZ)]:
-            if ipo[k]:
-                out.write(&quot;      (%s &quot; % v)
-                for point in ipo[k].bezierPoints:
-                    for v in point.vec:
-                        out.write(&quot;%f %f %f&quot; % (v[0], v[1], v[2]))
-                out.write(&quot;)\n&quot;)                    
-        out.write(&quot;     ) ;; bone \n&quot;)
-    out.write(&quot;   ) ;; bones \n&quot;)
-    out.write(&quot; ) ;; action\n&quot;)    
-
-for action in Blender.Armature.NLA.GetActions().values():
-    out = file(&quot;/tmp/action-%s.scm&quot; % action.getName(), &quot;w&quot;)
-    export_action(out, action)
-    out.close
-
-Draw.PupMenu(&quot;Export ok&quot;)
-
-# EOF #

Deleted: trunk/windstille/tools/mesh_export.py
===================================================================
--- trunk/windstille/tools/mesh_export.py	2009-02-05 17:35:39 UTC (rev 2406)
+++ trunk/windstille/tools/mesh_export.py	2009-02-05 17:42:50 UTC (rev 2407)
@@ -1,268 +0,0 @@
-import Blender
-from Blender import *
-
-class MeshData:
-    &quot;&quot;&quot;Data structure that holds a list of faces&quot;&quot;&quot;
-
-    def __init__(self, texture_filename):
-        # Filename of the used texture
-        self.texture_filename = texture_filename
-
-        # [FaceData, ...]
-        self.faces    = []
-
-        # [VerticeData, ...]
-        self.vertices = []
-
-        # { orig_index : [VerticeData, ...], ... }
-        self.vertmap = {}
-
-        # { (bonename, weight) : VertexGroup, ...}
-        self.groups = {}
-
-    def add(self, face):
-        self.faces.append(face)
-        
-        for vert in face.verts:
-            if not self.vertmap.has_key(vert.orig_idx):
-                self.vertmap[vert.orig_idx] = []
-            self.vertmap[vert.orig_idx].append(vert)
-
-    def add_influences(self, orig_idx, influences):
-        &quot;&quot;&quot;influences -&gt; [(bonename, weight), ...]&quot;&quot;&quot;
-        if not self.vertmap.has_key(orig_idx):
-            pass # this is normal due to MeshData not being a complete
-                 # Blender mesh when multiple textures are in play
-                 
-        else:
-            # orig_idx is part of this mesh
-            for v in self.vertmap[orig_idx]:
-                # print v.orig_idx
-                v.influences = influences
-            
-            for (bone,weight) in influences:
-                key = (bone, weight)
-                if not self.groups.has_key(key):
-                    self.groups[key] = VertexGroup(bone, weight)
-                self.groups[key].add(self.vertmap[orig_idx])
-
-    def finalize(self):
-        &quot;&quot;&quot;Reorders vertex indexes and merge vertexes which have the
-        same UV coordinates, thus bringing the MeshData into a stage
-        where it is ready to be written out to file&quot;&quot;&quot;
-
-        # Generate a list of uniq vertices
-        uniq_vertices = {}
-        for face in self.faces:
-            for vert in face.verts:
-                uniq_vertices[vert.key()] = vert
-
-        # Merge duplicate vertices
-        for face in self.faces:
-            for i in xrange(0, len(face.verts)):
-                face.verts[i] = uniq_vertices[face.verts[i].key()]
-
-        for group in self.groups.values():
-            for i in xrange(0, len(group.vertices)):
-                group.vertices[i] = uniq_vertices[group.vertices[i].key()]
-
-        # Generate new index numbering
-        self.vertices = uniq_vertices.values()
-        for i, vert in enumerate(self.vertices):
-            vert.index = i
-
-        ## Remove '//' infront of the filename that Blender inserts there
-        self.texture_filename = self.texture_filename[2:]
-      
-class FaceData:
-    def __init__(self, verts):
-        self.verts   = verts
-
-class VertexData:
-    def __init__(self, orig_idx, co, uv, normal):
-        self.orig_idx   = orig_idx
-        self.co         = co
-        self.uv         = uv
-        self.normal     = normal
-        self.index      = -1
-        self.influences = []
-
-    def key(self):
-        &quot;&quot;&quot;Return something that can be used as a key to compare if two vertices are equal&quot;&quot;&quot;
-        return (self.co[0], self.co[1], self.co[2],
-                self.normal[0], self.normal[1], self.normal[2],
-                self.uv[0], self.uv[1])
-    
-
-class VertexGroup:
-    def __init__(self, bone, weight):
-        self.bone     = bone
-        self.weight   = weight
-        self.vertices = [] # [VertexData,...]
-
-    def add(self, v):
-        self.vertices.extend(v)
-
-class WindstilleModel:
-    &quot;&quot;&quot;WindstilleMesh is used to collect data vertex and face data
-    from Blender internals and convert it to a form usable by
-    OpenGL/Windstille&quot;&quot;&quot;  
-
-    def __init__(self):
-        # dictionary of { &quot;texture_filename.png&quot; : MeshData, ... } 
-        self.mesh_data   = {}
-
-    def add(self, blender_mesh):
-        &quot;&quot;&quot;Convert Blender data structures into something that is used by
-        this export script&quot;&quot;&quot;
-        
-        # Convert blender meshes to MeshData
-        for face in blender_mesh.faces:
-            if face.image:
-                texture_filename = face.image.filename
-            else:
-                texture_filename = &quot;//404.png&quot;
-            
-            if not self.mesh_data.has_key(texture_filename):
-                mesh = self.mesh_data[texture_filename] = MeshData(texture_filename)
-            else:
-                mesh = self.mesh_data[texture_filename]
-
-            if face.uv == []:
-                raise &quot;Face doesn't have UV&quot;
-
-            verts = []
-            for i in [0, 1, 2]:
-                verts.append(VertexData(face.v[i].index,
-                                        [face.v[i].co[0], face.v[i].co[1], face.v[i].co[2]],
-                                        [face.uv[i][0], 1.0 - face.uv[i][1]],
-                                        [face.v[i].no[1], face.v[i].no[1], face.v[i].no[2]]))
-            mesh.add(FaceData(verts))
-
-            # Write out another triangle in case we have a quad
-            if len(face.v) == 4:
-                verts = []
-                for i in [0, 2, 3]:
-                    verts.append(VertexData(face.v[i].index,
-                                            [face.v[i].co[0], face.v[i].co[1], face.v[i].co[2]],
-                                            [face.uv[i][0], 1.0 - face.uv[i][1]],
-                                            [face.v[i].no[0], face.v[i].no[1], face.v[i].no[2]]))
-                mesh.add(FaceData(verts))
-
-        for mesh in self.mesh_data.values():
-            for vert in blender_mesh.verts:
-                #if blender_mesh.getVertexInfluences(vert.index) == []:
-                #    print &quot;No influences on&quot;, vert.index, &quot;this sounds like a bug&quot;
-                #else:
-                #    print vert.index, &quot;Ok&quot;
-                mesh.add_influences(vert.index, blender_mesh.getVertexInfluences(vert.index))
-
-
-    def finalize(self):
-        for (texture, mesh) in self.mesh_data.iteritems():
-            mesh.finalize()
-
-    def write(self, out):
-        out.write(&quot;;; -*- scheme -*-\n&quot;)
-        out.write(&quot;(windstille-model\n&quot;)
-        out.write(&quot;  (name \&quot;\&quot;)\n&quot;)
-    
-        for mesh in self.mesh_data.values():
-            out.write(&quot;  (mesh\n&quot;)
-            out.write(&quot;    (name \&quot;\&quot;)\n&quot;)
-            out.write(&quot;    (texture \&quot;%s\&quot;)\n\n&quot; % mesh.texture_filename)
-            out.write(&quot;    (vertices\n&quot;)
-            for v in mesh.vertices:
-                out.write(&quot;      %10f %10f %10f ;; %d was %d\n&quot; % (v.co[0], v.co[1], v.co[2],
-                                                                   v.index, v.orig_idx))
-            out.write(&quot;     ) ;; vertices\n\n&quot;)
-
-            out.write(&quot;    (normals\n&quot;) 
-            for vert in mesh.vertices:
-                out.write(&quot;      %9f %9f %9f\n&quot; % (vert.normal[0],
-                                              vert.normal[1],
-                                              vert.normal[2]))
-            out.write(&quot;     ) ;; normals\n\n&quot;)
-
-            out.write(&quot;    (texcoords\n&quot;)
-            for vert in mesh.vertices:
-                out.write(&quot;      %f %f\n&quot; % (vert.uv[0], vert.uv[1]))
-            out.write(&quot;     ) ;; texcoords\n\n&quot;)
-
-            out.write(&quot;    (triangles\n&quot;)
-            for face in mesh.faces:
-                out.write(&quot;      %d %d %d\n&quot; % (face.verts[0].index,
-                                                face.verts[1].index,
-                                                face.verts[2].index))
-            out.write(&quot;     ) ;; triangles\n\n&quot;)
-
-            out.write(&quot;    (groups\n&quot;)
-            for group in mesh.groups.values():
-                out.write(&quot;      (group\n&quot;)
-                out.write(&quot;        (bone    \&quot;%s\&quot;)\n&quot; % group.bone)
-                out.write(&quot;        (weight   %f)\n&quot; % group.weight)
-                out.write(&quot;        (vertices&quot;)
-                for v in set(map(lambda v: v.index, group.vertices)):
-                    out.write(&quot; %d&quot; % v) 
-                out.write(&quot;)\n&quot;)
-                out.write(&quot;       )\n&quot;)
-            out.write(&quot;     ) ;; groups\n\n&quot;)
-             
-#             out.write(&quot;    (influences\n&quot;)
-#             for vert in mesh.vertices:
-#                 if vert.influences != []:
-#                     out.write(&quot;      (vertex\n&quot;)
-#                     out.write(&quot;        (index %d)\n&quot; % vert.index)
-#                     out.write(&quot;        (influeces&quot;)
-#                     for (bone, weight) in vert.influences:
-#                         out.write(&quot;\n          (influence (weight %f) (bone \&quot;%s\&quot;))&quot; % (weight, bone))
-#                     out.write(&quot;))\n&quot;)
-#             out.write(&quot;     ) ;; influencs\n\n&quot;)
-            
-            out.write(&quot;   ) ;; mesh\n\n&quot;)
-        out.write(&quot; ) ;; windstille-model\n&quot;)
-        out.write(&quot;\n;; EOF ;;\n&quot;)
-
-    def print_stats(self):
-        &quot;&quot;&quot;Print some stats, vertex count, face count and such&quot;&quot;&quot;
-        print &quot;+====================================================================&quot;
-        print &quot;| WindstilleSprite&quot;
-        print &quot;+====================================================================&quot;
-        print &quot;| Model:&quot; 
-        for i, mesh in enumerate(self.mesh_data.values()):
-            print &quot;|   Mesh:        %d/%d&quot; % (i+1, len(self.mesh_data))
-            print &quot;|     Texture:  &quot;, mesh.texture_filename
-            print &quot;|     Faces:    &quot;, len(mesh.faces)
-            print &quot;|     Vertices: &quot;, len(mesh.vertices)
-            print &quot;|&quot;
-        print &quot;+====================================================================&quot;
-
-
-def export(filename):
-    model = WindstilleModel()
-
-    layers = Blender.Scene.getCurrent().Layers
-
-    for obj in Blender.Object.Get():
-        mesh = obj.getData()
-        if (type(mesh) is not Blender.Types.NMeshType) or not mesh.faces:
-            pass # ignore anything that isn't a mesh
-        elif (obj.Layers &amp; layers) == 0:
-            print &quot;Skipping \&quot;%s\&quot; because it is on an inactive layer&quot; % obj.getName()
-        else:
-            model.add(mesh)
-
-    model.finalize()
-
-    file = open(filename, &quot;w&quot;)
-
-    model.write(file)
-    file.close()
-
-    model.print_stats()
-
-export(&quot;/tmp/mesh.scm&quot;)
-
-Draw.PupMenu(&quot;Export ok&quot;)
-
-# EOF #

Deleted: trunk/windstille/tools/model_test.blend
===================================================================
(Binary files differ)

Deleted: trunk/windstille/tools/pose_export.py
===================================================================
--- trunk/windstille/tools/pose_export.py	2009-02-05 17:35:39 UTC (rev 2406)
+++ trunk/windstille/tools/pose_export.py	2009-02-05 17:42:50 UTC (rev 2407)
@@ -1,46 +0,0 @@
-import Blender
-from Blender import *
-
-def is_identity(quat):
-    return quat.w == 1.0 and quat.x == 0.0 and quat.y == 0.0 and quat.z == 0.0
-
-def is_null_loc(loc):
-    return loc.x == 0 and loc.y == 0 and loc.z == 0
-
-def export_pose(out, obj):
-    pose = obj.getPose()
-
-    out.write(&quot;;; -*- scheme -*-\n&quot;)
-    out.write(&quot;(pose\n&quot;)
-    out.write(&quot;  (name \&quot;%s\&quot;)\n&quot; % obj.getName())
-    out.write(&quot;  (bones\n&quot;)
-    for bone in pose.bones.values():
-        if bone.name[:3] == &quot;IK_&quot;:
-            out.write(&quot;    ;; ignoring '%s', IK control bone\n&quot; % bone.name)
-        elif is_identity(bone.quat) and is_null_loc(bone.loc):
-            out.write(&quot;    ;; ignoring '%s', neutral position\n&quot; % bone.name)        
-        else: 
-            out.write(&quot;    (bone\n&quot;)
-            out.write(&quot;      (name \&quot;%s\&quot;)\n&quot; % bone.name)
-            out.write(&quot;      (loc %f %f %f)\n&quot; %
-                      (bone.loc.x, bone.loc.y, bone.loc.z))
-            out.write(&quot;      (quat %f %f %f %f))\n&quot; % 
-                      (bone.quat.w, bone.quat.x, bone.quat.y, bone.quat.z))
-    out.write(&quot;   ) ;; bones\n&quot;)
-    out.write(&quot; ) ;; pose\n&quot;)
-    out.write(&quot;\n;; EOF ;;\n&quot;)
-
-print &quot;Windstille Pose Exporter:&quot;
-for frame in xrange(1, 20):
-    Blender.Set(&quot;curframe&quot;, frame)
-    for obj in Blender.Object.Get():
-        if obj.type == &quot;Armature&quot;:
-            filename = &quot;/tmp/pose-%s-frame%03d.scm&quot; % (obj.getName(), frame)
-            out = file(filename, &quot;w&quot;)
-            export_pose(out, obj)
-            out.close()
-            print &quot;Wrote:&quot;, filename
-
-Draw.PupMenu(&quot;Export ok&quot;)
-
-# EOF #

Deleted: trunk/windstille/tools/windstille_export.py
===================================================================
--- trunk/windstille/tools/windstille_export.py	2009-02-05 17:35:39 UTC (rev 2406)
+++ trunk/windstille/tools/windstille_export.py	2009-02-05 17:42:50 UTC (rev 2407)
@@ -1,612 +0,0 @@
-#!BPY
-
-&quot;&quot;&quot;
-Name: 'Windstille Exporter'
-Blender: 233
-Group: 'Export'
-Tip: 'Export meshes/actions to windstille format'
-&quot;&quot;&quot;
-
-##  $Id: windstille_main.hxx,v 1.4 2003/11/07 13:00:39 grumbel Exp $
-## 
-##  Windstille - A Jump'n Shoot Game
-##  Copyright (C) 2005 Matthias Braun &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">matze at braunis.de</A>&gt;,
-##                     Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
-##
-##  This program is free software; you can redistribute it and/or
-##  modify it under the terms of the GNU General Public License
-##  as published by the Free Software Foundation; either version 2
-##  of the License, or (at your option) any later version.
-##
-##  This program is distributed in the hope that it will be useful,
-##  but WITHOUT ANY WARRANTY; without even the implied warranty of
-##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-##  GNU General Public License for more details.
-## 
-##  You should have received a copy of the GNU General Public License
-##  along with this program; if not, write to the Free Software
-##  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-# Simple Python script that shows how to export animations from
-# Blender
-# Put this script in your $HOME/.blender/scripts directory.
-#
-# See windstille/docs/models.txt for more details
-
-### TODO ###
-# - add handling of meshes with armatures, but without actions
-# - change the code to use some more MathUtil instead of its own quaternion/matrix code 
-############
-
-import string
-import struct, shlex, os.path, math
-import Blender
-from Blender import NMesh
-from Blender import Window
-
-# SAMPLEFRAMES, only export every nth frame of the animation
-DEFAULT_SAMPLERATE = 5
-# ZOOM, is multiplied with all vertex coordinates
-ZOOM = 32.0
-DEFAULT_SPEED = 1.0
-SPEED_MULTIPLIER = 9.8
-# DO NOT change this
-FORMAT_VERSION = 2
-
-def progress(percent, str):
-#    print &quot;%3.2f%% - %s&quot; % (percent*100, str)
-    Window.DrawProgressBar(percent, str)
-
-### Some math helper functions ###
-def matrix2quaternion(m):
-  tr = 1.0 + m[0][0] + m[1][1] + m[2][2]
-  if tr &gt; .00001:
-    s = math.sqrt(tr)
-    w = s / 2.0
-    s = 0.5 / s
-    x = (m[1][2] - m[2][1]) * s
-    y = (m[2][0] - m[0][2]) * s
-    z = (m[0][1] - m[1][0]) * s
-  elif m[0][0] &gt; m[1][1] and m[0][0] &gt; m[2][2]:
-    s = math.sqrt(1.0 + m[0][0] - m[1][1] - m[2][2])
-    x = s / 2.0
-    s = 0.5 / s
-    y = (m[0][1] + m[1][0]) * s
-    z = (m[2][0] + m[0][2]) * s
-    w = (m[1][2] - m[2][1]) * s
-  elif m[1][1] &gt; m[2][2]:
-    s = math.sqrt(1.0 + m[1][1] - m[0][0] - m[2][2])
-    y = s / 2.0
-    s = 0.5 / s
-    x = (m[0][1] + m[1][0]) * s
-    z = (m[1][2] + m[2][1]) * s
-    w = (m[2][0] - m[0][2]) * s
-  else:
-    s = math.sqrt(1.0 + m[2][2] - m[0][0] - m[1][1])
-    z = s / 2.0
-    s = 0.5 / s
-    x = (m[2][0] + m[0][2]) * s
-    y = (m[1][2] + m[2][1]) * s
-    w = (m[0][1] - m[1][0]) * s
-
-  return quaternion_normalize([w, x, y, z])
-
-def quaternion_normalize(q):
-  l = math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3])
-  return q[0] / l, q[1] / l, q[2] / l, q[3] / l
-
-def quaternion_to_axisangle(q):
-  cos_a = q[0]
-  angle = math.acos(cos_a) * 2.0
-  sin_a = math.sqrt(1.0 - cos_a * cos_a)
-  if(sin_a &lt; .0005 or sin_a &gt; .0005): sin_a = 1
-  return angle, q[1]/sin_a, q[2]/sin_a, q[3]/sin_a
-
-def get_text(textname):
-  &quot;&quot;&quot;Little shortcut function to return the content of
-  Blender.Text.get(textname) as a single string and do a little error
-  handling in addition&quot;&quot;&quot;
-  try:
-    textobj = Blender.Text.Get(textname)
-  except Exception, err:
-    print &quot;WARNING: &quot;, err
-    return &quot;&quot;
-  else:
-    return string.join(textobj.asLines(), &quot;\n&quot;)
-
-### Data Structures to hold the Mesh ###
-class MeshData:
-  def __init__(self, texture_filename):
-    # Filename of the used texture
-    self.texture_filename = texture_filename
-
-    # [FaceData, ...]
-    self.faces            = []
-
-    self.vertices         = []
-
-  def merge(self, mesh):
-      &quot;&quot;&quot;Merges a mesh with self&quot;&quot;&quot;
-      if self.texture_filename != mesh.texture_filename:
-          raise Exception, &quot;Error: MeshData:merge: meshes can only be merged if they have the same texture&quot;
-      elif self.vertices != []:
-          raise Exception, &quot;Error: MeshData:merge: Must merge the meshes before finalization&quot;
-      else:
-          self.faces += mesh.faces
-
-  def finalize(self):
-      &quot;&quot;&quot;Reorders vertex indexes and merge vertexes which have the
-      same UV coordinates, thus bringing the MeshData into a stage
-      where it is ready to be written out to file&quot;&quot;&quot;
-
-      # Merge vertices with the same UV
-      vertices = {}
-      for face in self.faces:
-          for vert in face.verts:
-              key = (vert.uv[0], vert.uv[1])
-              vertices[key] = vert
-
-      print &quot;Vertices: &quot;, len(vertices)
-
-      # FIXME: This might not work with vertices that have the same
-      # uv, but different positions
-      for face in self.faces:
-          for vi in range(0, len(face.verts)):
-              key = (face.verts[vi].uv[0], face.verts[vi].uv[1])
-              face.verts[vi] = vertices[key]
-
-      self.vertices = vertices.values()
-
-      # Sort the vertices by object to allow faster export in collect_frame_data()
-      self.vertices.sort(lambda x, y: cmp(x.object.getName(), y.object.getName()))
-      
-      # Generate new index numbering
-      for i, vert in enumerate(self.vertices):
-          vert.new_index = i
-
-      ## Remove '//' infront of the filename that Blender inserts there
-      self.texture_filename = self.texture_filename[2:]
-      
-class FaceData:
-    def __init__(self, verts, normal):
-        self.verts   = verts
-        self.normal  = normal
-
-class VertexData:
-    def __init__(self, object, index, uv, normal):
-        self.object    = object
-        self.index     = index
-        self.uv        = uv
-        self.normal    = normal
-        self.new_index = -1
-
-class AttachmentPointData:
-    &quot;&quot;&quot;Data for an attachment point, its location and its rotation&quot;&quot;&quot;
-    def __init__(self, loc, quat):
-        self.loc  = loc
-        self.quat = quat
-
-class FrameData:
-    &quot;&quot;&quot; Data used for a single frame in an action &quot;&quot;&quot;
-    def __init__(self, vertex_locs, attachment_points):
-        # Format: [[[x,y,z], ...], [[x,y,z],  ...], ...] (one list for each Mesh)
-        self.vertex_locs        = vertex_locs
-
-        # [AttachmentPointData, ...]
-        self.attachment_points = attachment_points
-
-class ActionConfig:
-    &quot;&quot;&quot;ActionConfig handles the properties of a single
-    action, ie. when it starts, when it stops, its speed, how many
-    spamles should be taken, etc.&quot;&quot;&quot;
-
-    def __init__(self, first_frame, last_frame, speed, samplerate, markers):
-        self.first_frame = first_frame
-        self.last_frame  = last_frame
-        self.speed       = speed
-        self.samplerate  = samplerate
-        self.markers     = markers
-        self.numframes   = last_frame - first_frame + 1
-
-    def __str__(self):
-        return &quot;Frames: %3i - %3i, speed: %3.2f, Samplerate: %3d&quot; % (self.first_frame, self.last_frame,
-                                                                         self.speed, self.samplerate)
-
-    # config entry (first_frame, last_frame, speed, samplerate, markers[])
-    #  a marker is (name, frame)
-    def parse(text):     
-        def expect_string():
-            res = lex.get_token()
-            if res == lex.eof:
-                raise Exception, &quot;Expected string, got EOF&quot;
-            return res
-
-        def expect_int():
-            res = lex.get_token()
-            if res == lex.eof:
-                raise Exception, &quot;Expected in, got EOF&quot;
-            return int(res)
-
-        def expect_float():
-            res = lex.get_token()
-            if res == lex.eof:
-                raise Exception, &quot;Expected float, got EOF&quot;
-            return float(res)
-
-        def expect_dash():
-            res = lex.get_token()
-            if res == lex.eof:
-                raise Exception, &quot;Expected '-', got EOF&quot;
-            elif res != &quot;-&quot;:
-                raise Exception, &quot;Expected '-', got '%s'&quot; % res
-
-        lex = shlex.shlex(text)
-        lex.wordchars += &quot;.&quot;
-
-        actionconfig = {}
-        while True:
-            token = lex.get_token()
-            if token == lex.eof:
-                break
-            lex.push_token(token)
-            action_name = expect_string()
-            first_frame = expect_int()
-            expect_dash()
-            last_frame = expect_int()
-
-            token = lex.get_token()
-            if token == &quot;speed&quot;:
-                speed = expect_float()
-            else:
-                lex.push_token(token)
-                speed = DEFAULT_SPEED
-
-            token = lex.get_token()
-            if token == &quot;samplerate&quot;:
-                samplerate = expect_int()
-            else:
-                lex.push_token(token)
-                samplerate = DEFAULT_SAMPLERATE
-
-            token = lex.get_token()
-            markers = []
-            while token == &quot;marker&quot;:
-                marker_name = expect_string()
-                marker_frame = expect_int()
-                markers.append( (marker_name, marker_frame) )
-                token = lex.get_token()
-            lex.push_token(token)
-
-            actionconfig[action_name] = ActionConfig(first_frame, last_frame, speed, samplerate, markers)
-
-        return actionconfig
-    parse = staticmethod(parse)
-
-class ActionData:
-  def __init__(self, name, config, frame_data):
-    # name as string
-    self.name       = name
-
-    # ActionConfig
-    self.config     = config
-
-    # FrameData (filled out later in the WindstilleExporter)
-    self.frame_data = frame_data
-
-### end: Data Structures to hold the Mesh ###
-
-class WindstilleSprite:
-  ########################################################
-  def __init__(self):
-      &quot;&quot;&quot; Create a WindstilleSprite from the current scene&quot;&quot;&quot;
-      ### References to Blender internals
-      # List of Blender mesh objects that should get exported (everything on
-      # seperate layer is ignored)
-      self.mesh_objects    = []
-
-      # Blender armature object
-      self.armature_object = None
-
-      # Blender attachment objects, ie. Empties
-      self.attachment_objects = []
-
-      # Name of the actions as string
-      self.actions = []
-
-      # { actionname : ActionConfig, ... }
-      self.actionconfigs = {}
-      
-      ### Converted Data
-      # List of mesh_data, ie. data we collected and converted ourself from Blender
-      self.mesh_data   = []
-            
-      # Used to store animation data (vertex position and such)
-      self.action_data = []
-
-      ### Start collecting data
-      # Collect Action Config
-      self.collect_actionconfig()
-      # Fill out Blender internal references
-      self.collect_data()
-      # Data for all Meshes
-      self.collect_object_data()
-      # Collect data for the Actions and Animations
-      self.collect_animation_data()
-
-  def collect_actionconfig(self):
-      try:
-          self.actionconfigs = ActionConfig.parse(get_text(&quot;actionconfig&quot;))
-      except Exception, message:
-          raise Exception, &quot;Error: Parse Error in actionconfig:&quot; + str(message)
-      
-  def collect_data(self):
-      &quot;&quot;&quot;Convert Blender data structures into something that is used by
-      this export script&quot;&quot;&quot;
-
-      scene  = Blender.Scene.GetCurrent()
-      layers = scene.Layers
-
-      # compose list of meshs to export
-      for obj in Blender.Object.Get():
-          data = obj.getData()
-          if (type(data) is not Blender.Types.NMeshType) or not data.faces:
-              pass # ignore anything that isn't a mesh
-          elif (obj.Layers &amp; layers) == 0:
-              print &quot;Skipping \&quot;%s\&quot; because it is on different layer&quot; % obj.getName()
-          else:
-              texture = data.faces[0].image
-              self.mesh_objects.append(obj)
-
-      # search for armature object
-      armatures = [obj for obj in Blender.Object.Get() if obj.getType() == &quot;Armature&quot;]
-      if len(armatures) &gt; 1:
-          raise Exception, &quot;Need to have at most 1 armature in the scene&quot;
-      elif len(armatures) == 0:
-          self.armature_object = None
-      else:
-          self.armature_object = armatures[0]
-
-      # compose list of objects for attachment points
-      self.attachment_objects += [obj for obj in Blender.Object.Get() 
-                                  if (obj.getType() == 'Empty' and obj.getName().startswith(&quot;A:&quot;))]
-
-      # compose list of actions to export
-      if not self.armature_object:
-          self.actions.append(&quot;Default&quot;)
-      else:
-          for action in Blender.Armature.NLA.GetActions().iteritems():
-              self.actions.append(action[1])
-        
-  ### END: def collect_data()
-
-  def collect_animation_data(self):
-      for index, action in enumerate(self.actions):
-          progress(float(index)/len(self.actions)*0.5, &quot;Collecting Action %s&quot; % (action.name))
-          
-          action.setActive(self.armature_object)
-
-          # find/autodetect config
-          if self.actionconfigs.has_key(action.getName()):
-              actioncfg = self.actionconfigs[action.getName()]
-          else:
-              print &quot;Error: No config for action '%s' defined.&quot; % action.getName()
-              actioncfg = ActionConfig(1, 1, DEFAULT_SPEED, DEFAULT_SAMPLERATE, [])
-
-          frame_data = []
-          for frame in range(actioncfg.first_frame, actioncfg.last_frame+1, actioncfg.samplerate):
-              #progress((index + (float(frame)/(actioncfg.last_frame+1 - actioncfg.first_frame)))
-              #         /len(self.actions)*0.5,
-              #         &quot;Collecting Action %s&quot; % (action.name))
-              Blender.Set(&quot;curframe&quot;, int(frame))
-              frame_data.append(self.collect_frame_data())
-
-          self.action_data.append(ActionData(action.getName(), actioncfg, frame_data))
-
-  def collect_object_data(self):
-    self.mesh_data = {}
-    for obj in self.mesh_objects:
-      ### Convert mesh_objects to MeshData and merge all meshes with
-      ### the same texture
-      for (texture, mesh) in self.collect_mesh_data(obj).iteritems():
-        if self.mesh_data.has_key(texture):
-          self.mesh_data[texture].merge(mesh)
-        else:
-          self.mesh_data[texture] = mesh
-    self.mesh_data = self.mesh_data.values()
-
-    # Optimize the meshs by merging meshes and vertices
-    for mesh in self.mesh_data:
-      mesh.finalize()
-
-  def collect_mesh_data(self, obj): # returns { texture_filename : MeshData, ...}
-      &quot;&quot;&quot;
-      Returns mesh_data as dict with format:
-      key: texture_filename
-      val: MeshData
-      &quot;&quot;&quot;
-      mesh_data = {}
-
-      for face in obj.getData().faces:
-          if face.image:
-              texture_filename = face.image.filename
-          else:
-              texture_filename = &quot;//404.png&quot;
-
-          if not mesh_data.has_key(texture_filename):
-              mesh_data[texture_filename] = MeshData(texture_filename)
-
-          faces = []
-          for v in [0, 1, 2]:
-              faces.append(VertexData(obj, face.v[v].index,
-                                      [face.uv[v][0], 1.0-face.uv[v][1]],
-                                      [face.normal[1], -face.normal[2], -face.normal[0]]))
-          mesh_data[texture_filename].faces.append(FaceData(faces,
-                                                            [face.normal[1], -face.normal[2], -face.normal[0]]))
-
-          # Write out another triangle in case we have a quad: index, u, v
-          faces = []
-          if len(face.v) == 4:
-              for v in [0, 2, 3]:
-                  faces.append(VertexData(obj, face.v[v].index,
-                                          [face.uv[v][0], 1.0-face.uv[v][1]],
-                                          [face.normal[1], -face.normal[2], -face.normal[0]]))
-              mesh_data[texture_filename].faces.append(FaceData(faces,
-                                                                [face.normal[1], -face.normal[2], -face.normal[0]]))
-
-      return mesh_data
-
-  def collect_frame_data(self):
-      &quot;&quot;&quot;
-      Collect all data for the given object in a single frame, frame
-      has to be selected outside of this function.
-      Format:
-      [[[vertex_pos_x, vertex_pos_y, vertex_pos_z], ...],
-      [[attachment_pos_x, attachment_pos_y, attachment_pos_z,
-      attachment_quat1, attachment_quat2, attachment_quat3, attachment_quat4], ...]]
-       &quot;&quot;&quot;
-      # FIXME: This is by far the slowest function of all, optimizing might help
-      meshs = []
-      attachment_points = []
-
-      obj = None
-
-      # no triangles here (those are global), just vertexes (those are local)
-      for mesh_data in self.mesh_data:
-          vertex_positions = []
-          for vertex in mesh_data.vertices:
-              if obj != vertex.object:
-                  obj  = vertex.object
-                  data = Blender.NMesh.GetRawFromObject(obj.getName())
-                  m    = obj.getMatrix()
-
-              # location: action/frame/mesh/vertices
-              v = data.verts[vertex.index]
-              vertex_positions.append([+(m[0][1]*v[0] + m[1][1]*v[1] + m[2][1]*v[2] + m[3][1]) * ZOOM,
-                                       -(m[0][2]*v[0] + m[1][2]*v[1] + m[2][2]*v[2] + m[3][2]) * ZOOM,
-                                       -(m[0][0]*v[0] + m[1][0]*v[1] + m[2][0]*v[2] + m[3][0]) * ZOOM])
-          meshs.append(vertex_positions)
-
-      # attachment points
-      for obj in self.attachment_objects:
-          m    = obj.matrixWorld
-          loc  = (m[3][0] * ZOOM, m[3][1] * ZOOM, m[3][2] * ZOOM)
-          quat = matrix2quaternion(m)      
-          attachment_points.append(AttachmentPointData([loc[1], -loc[2], -loc[0]],
-                                                       [quat[0], quat[2], quat[3], quat[1]]))
-
-      return FrameData(meshs, attachment_points)
-
-  def write(self, out):
-      &quot;&quot;&quot;This is a new version of write_file(), instead of using blender
-      internals, it uses the collected data&quot;&quot;&quot;
-
-      ### Write magic, version and counts for mesh, attachment_points and actions
-      out.write(struct.pack(&quot;=4sHHHH&quot;, &quot;W3DS&quot;,
-                            FORMAT_VERSION, \
-                            len(self.mesh_data),
-                            len(self.attachment_objects),
-                            len(self.action_data)))
-
-      ### Mesh Header:
-      for mesh in self.mesh_data:
-          out.write(struct.pack(&quot;=64sHH&quot;,
-                                mesh.texture_filename,
-                                len(mesh.faces),
-                                len(mesh.vertices)))
-          ### Mesh Data:
-          ## Vertex indices of triangles
-          for face in mesh.faces:
-              out.write(struct.pack(&quot;=HHH&quot;,
-                                    face.verts[0].new_index,
-                                    face.verts[1].new_index,
-                                    face.verts[2].new_index))
-
-          ## Normal
-          for face in mesh.faces:
-              out.write(struct.pack(&quot;=fff&quot;, face.normal[0], face.normal[1], face.normal[2]))
-
-          ## UV Coordinates
-          for vert in mesh.vertices:
-            out.write(struct.pack(&quot;=ff&quot;, vert.uv[0], vert.uv[1]))
-
-      ### Attachment points
-      for obj in self.attachment_objects:
-          out.write(struct.pack(&quot;=64s&quot;, obj.getName()[2:]))
-
-      ## Action Header
-      for index, action in enumerate(self.action_data):
-          progress(0.5 + float(index)/len(self.action_data) * 0.5,
-                   &quot;Writing Action %s&quot; % (action.name))
-
-          out.write(struct.pack(&quot;=64sfHH&quot;,
-                                action.name, 
-                                action.config.speed * SPEED_MULTIPLIER,
-                                len(action.config.markers),
-                                len(action.frame_data)))
-          
-          ## Marker
-          for (marker_name, marker_frame) in action.config.markers:
-              out.write(struct.pack(&quot;=64sH&quot;,
-                                    marker_name, 
-                                    (marker_frame - action.config.first_frame) / action.config.samplerate))
-
-          ## Action Data
-          for frame in action.frame_data:
-              ### Vertex positions
-              for mesh in frame.vertex_locs:
-                  for vert in mesh:
-                      out.write(struct.pack(&quot;=fff&quot;, vert[0], vert[1], vert[2]))
-              ### Attachment Points
-              for at in frame.attachment_points:
-                  out.write(struct.pack(&quot;=fffffff&quot;,
-                                        at.loc[0],  at.loc[1],  at.loc[2],
-                                        at.quat[0], at.quat[1], at.quat[2], at.quat[3]))
-    ### DONE ###
-
-  def print_stats(self):
-      &quot;&quot;&quot;Print some stats, vertex count, face count and such&quot;&quot;&quot;
-      print &quot;+====================================================================&quot;
-      print &quot;| WindstilleSprite&quot;
-      print &quot;+====================================================================&quot;
-      print &quot;| Mesh Count:     &quot;, len(self.mesh_data)
-      print &quot;| Mesh Objects:   &quot;, self.mesh_objects
-      print &quot;| Actions:        &quot;, self.actions
-      print &quot;| AttachmentObjs: &quot;, self.attachment_objects
-      print &quot;| Meshs: &quot;
-      for mesh in self.mesh_data:
-          print &quot;|   Mesh:       &quot;, mesh
-          print &quot;|     Texture:  &quot;, mesh.texture_filename
-          print &quot;|     Faces:    &quot;, len(mesh.faces)
-          print &quot;|     Vertices: &quot;, len(mesh.vertices)
-          print &quot;|&quot;
-      print &quot;| Actions: &quot;
-      for action in self.action_data:
-          print &quot;|   Name:        &quot;, action.name
-          print &quot;|   Config:      &quot;, action.config
-          print &quot;|   Frames:      &quot;, len(action.frame_data)
-          print &quot;|   Vertices:    &quot;, [len(x) for x in action.frame_data[0].vertex_locs]
-          print &quot;|   Attachments: &quot;, len(action.frame_data[0].attachment_points)
-          print &quot;|&quot;
-      print &quot;+====================================================================&quot;
-    
-def export(filename):
-    data = WindstilleSprite()
-
-    file = open(filename, &quot;wb&quot;)
-    data.write(file)
-    file.close()
-
-    data.print_stats()
-
-def fs_callback(filename):
-    print &quot;=== Exporting: %s ===&quot; % (filename)
-    export(filename)
-    Window.DrawProgressBar(1.0, &quot;Finished writing %s&quot; % (filename)) 
-    print &quot;=== Windstille Exporter done, wrote %s ===&quot; % (filename)
-
-defaultname = Blender.Get(&quot;filename&quot;)
-if defaultname.endswith(&quot;.blend&quot;):
-    defaultname = defaultname[0:len(defaultname) - len(&quot;.blend&quot;)] + &quot;.wsprite&quot;
-Window.FileSelector(fs_callback, &quot;Windstille Export&quot;, defaultname)
-
-# EOF #


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001403.html">[Windstille-commit] r2406 - in trunk/windstille: . test
</A></li>
	<LI>Next message: <A HREF="001405.html">[Windstille-commit] r2408 - in trunk: . blender-thumbnail scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1404">[ date ]</a>
              <a href="thread.html#1404">[ thread ]</a>
              <a href="subject.html#1404">[ subject ]</a>
              <a href="author.html#1404">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/windstille-commit">More information about the Windstille-commit
mailing list</a><br>
</body></html>
