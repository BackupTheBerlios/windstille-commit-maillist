<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Windstille-commit] r2412 - in tags/windstille-0.3.0/tools: .	miniswig
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/windstille-commit/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r2412%20-%20in%20tags/windstille-0.3.0/tools%3A%20.%0A%09miniswig&In-Reply-To=%3C200902052009.n15K9DOc028740%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001408.html">
   <LINK REL="Next"  HREF="001410.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Windstille-commit] r2412 - in tags/windstille-0.3.0/tools: .	miniswig</H1>
    <B>grumbel at BerliOS</B> 
    <A HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r2412%20-%20in%20tags/windstille-0.3.0/tools%3A%20.%0A%09miniswig&In-Reply-To=%3C200902052009.n15K9DOc028740%40sheep.berlios.de%3E"
       TITLE="[Windstille-commit] r2412 - in tags/windstille-0.3.0/tools: .	miniswig">grumbel at mail.berlios.de
       </A><BR>
    <I>Thu Feb  5 21:09:13 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001408.html">[Windstille-commit] r2411 - tags
</A></li>
        <LI>Next message: <A HREF="001410.html">[Windstille-commit] r2413 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1409">[ date ]</a>
              <a href="thread.html#1409">[ thread ]</a>
              <a href="subject.html#1409">[ subject ]</a>
              <a href="author.html#1409">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: grumbel
Date: 2009-02-05 21:09:13 +0100 (Thu, 05 Feb 2009)
New Revision: 2412

Added:
   tags/windstille-0.3.0/tools/miniswig/
   tags/windstille-0.3.0/tools/miniswig/Jamfile
   tags/windstille-0.3.0/tools/miniswig/create_docu.cpp
   tags/windstille-0.3.0/tools/miniswig/create_docu.hpp
   tags/windstille-0.3.0/tools/miniswig/create_wrapper.cpp
   tags/windstille-0.3.0/tools/miniswig/create_wrapper.hpp
   tags/windstille-0.3.0/tools/miniswig/globals.hpp
   tags/windstille-0.3.0/tools/miniswig/lexer.ll
   tags/windstille-0.3.0/tools/miniswig/main.cpp
   tags/windstille-0.3.0/tools/miniswig/parser.yy
   tags/windstille-0.3.0/tools/miniswig/tree.cpp
   tags/windstille-0.3.0/tools/miniswig/tree.hpp
   tags/windstille-0.3.0/tools/miniswig/xmlwriter.cpp
   tags/windstille-0.3.0/tools/miniswig/xmlwriter.hpp
Modified:
   tags/windstille-0.3.0/tools/
Log:
Added miniswig from windstille-0.3.0 source tarball, since svn:externals isn't much good with tags


Property changes on: tags/windstille-0.3.0/tools
___________________________________________________________________
Name: svn:externals
   - miniswig <A HREF="svn://svn.berlios.de/supertux/trunk/supertux/tools/miniswig">svn://svn.berlios.de/supertux/trunk/supertux/tools/miniswig</A>

   + 


Added: tags/windstille-0.3.0/tools/miniswig/Jamfile
===================================================================
--- tags/windstille-0.3.0/tools/miniswig/Jamfile	2009-02-05 20:06:07 UTC (rev 2411)
+++ tags/windstille-0.3.0/tools/miniswig/Jamfile	2009-02-05 20:09:13 UTC (rev 2412)
@@ -0,0 +1,22 @@
+SubDir TOP tools miniswig ;
+
+if $(LEX) &amp;&amp; $(LEX) != &quot;:&quot; &amp;&amp; $(BISON) {
+  
+    # hack because SDL does nasty -Dmain=SDL_main on windows
+    old_CXXFLAGS = $(CXXFLAGS) ;
+    CXXFLAGS = [ Filter $(CXXFLAGS) : -Dmain=SDL_main ] ;
+  
+    sources = [ Filter [ Wildcard *.yy *.ll *.cpp ] : parser.cpp lexer.cpp ] ;
+    MINISWIG = [ Application miniswig : $(sources) : noinstall ] ;
+    C++Flags miniswig : -Wno-unused ;
+    IncludeDir miniswig : . ;
+    ExternalLibs miniswig : LEX ;
+
+    CXXFLAGS = $(old_CXXFLAGS) ;
+
+# we gotta run bison before flex
+    lexer_cpp = [ SearchSource lexer.cpp ] ;
+    lexer_o = [ LocateTarget $(lexer_cpp:S=.o) ] ;
+    Depends lexer_o : [ LocateTarget parser.cpp : $(SUBDIR) ] ;
+}
+

Added: tags/windstille-0.3.0/tools/miniswig/create_docu.cpp
===================================================================
--- tags/windstille-0.3.0/tools/miniswig/create_docu.cpp	2009-02-05 20:06:07 UTC (rev 2411)
+++ tags/windstille-0.3.0/tools/miniswig/create_docu.cpp	2009-02-05 20:09:13 UTC (rev 2412)
@@ -0,0 +1,112 @@
+#include &lt;config.h&gt;
+
+#include &quot;tree.hpp&quot;
+#include &lt;iostream&gt;
+#include &lt;sstream&gt;
+#include &lt;stdexcept&gt;
+#include &quot;create_docu.hpp&quot;
+#include &quot;globals.hpp&quot;
+
+void
+DocuCreator::create_docu(Namespace* ns)
+{
+    std::string fromfile = original_file != &quot;&quot; ? original_file : inputfile;
+
+    writer.openTag(&quot;documentation&quot;);
+    writer.openTag(&quot;namespace&quot;);
+    writer.writeAttribute(&quot;name&quot;, ns-&gt;name);
+
+    for(std::vector&lt;AtomicType*&gt;::iterator i = ns-&gt;types.begin();
+            i != ns-&gt;types.end(); ++i) {
+        AtomicType* type = *i;
+        Class* _class = dynamic_cast&lt;Class*&gt; (type);
+        if(_class != 0)
+            create_class_docu(_class);
+    }
+    for(std::vector&lt;Function*&gt;::iterator i = ns-&gt;functions.begin();
+            i != ns-&gt;functions.end(); ++i) {
+        create_function_docu(0, *i);
+    }
+
+    writer.closeTag(&quot;namespace&quot;);
+    writer.closeTag(&quot;documentation&quot;);
+}
+
+void
+DocuCreator::create_class_docu(Class* _class)
+{
+    writer.openTag(&quot;class&quot;);
+    writer.writeAttribute(&quot;name&quot;, _class-&gt;name);
+
+    if(_class-&gt;docu_comment != &quot;&quot;) {
+        writer.writeTag(&quot;documentation&quot;);
+        writer.write(_class-&gt;docu_comment);
+    }
+
+    for(std::vector&lt;ClassMember*&gt;::iterator i = _class-&gt;members.begin();
+            i != _class-&gt;members.end(); ++i) {
+        ClassMember* member = *i;
+        if(member-&gt;visibility != ClassMember::PUBLIC)
+            continue;
+        Function* function = dynamic_cast&lt;Function*&gt; (member);
+        if(!function)
+            continue;
+        if(function-&gt;type != Function::FUNCTION)
+            continue;
+        create_function_docu(_class, function);
+    }
+
+    writer.closeTag(&quot;class&quot;);
+}
+
+void
+DocuCreator::create_function_docu(Class* _class, Function* function)
+{
+    writer.openTag(&quot;function&quot;);
+
+    writer.writeAttribute(&quot;return_type&quot;,
+            get_type(function-&gt;return_type));
+    writer.writeAttribute(&quot;name&quot;, function-&gt;name);
+
+    if(function-&gt;docu_comment != &quot;&quot;) {
+        writer.writeTag(&quot;documentation&quot;);
+        writer.write(function-&gt;docu_comment);
+    }
+
+    for(std::vector&lt;Parameter&gt;::iterator p = function-&gt;parameters.begin();
+            p != function-&gt;parameters.end(); ++p) {
+        if(p == function-&gt;parameters.begin()
+                &amp;&amp; p-&gt;type.atomic_type == HSQUIRRELVMType::instance())
+            continue;
+
+        writer.writeTag(&quot;param&quot;);
+        writer.writeAttribute(&quot;type&quot;, get_type(p-&gt;type));
+        writer.writeAttribute(&quot;name&quot;, p-&gt;name);
+    }
+
+    writer.closeTag(&quot;function&quot;);
+}
+
+std::string
+DocuCreator::get_type(const Type&amp; type)
+{
+    if(type.ref &gt; 0 &amp;&amp; type.atomic_type != StringType::instance())
+        throw std::runtime_error(&quot;References not handled yet&quot;);
+    if(type.pointer &gt; 0)
+        throw std::runtime_error(&quot;Pointers not handled yet&quot;);
+    if(type.atomic_type == &amp;BasicType::VOID) {
+        return &quot;void&quot;;
+    } else if(type.atomic_type == &amp;BasicType::INT) {
+        return &quot;int&quot;;
+    } else if(type.atomic_type == &amp;BasicType::FLOAT) {
+        return &quot;float&quot;;
+    } else if(type.atomic_type == &amp;BasicType::BOOL) {
+        return &quot;bool&quot;;
+    } else if(type.atomic_type == StringType::instance()) {
+        return &quot;string&quot;;
+    }
+
+    std::ostringstream msg;
+    msg &lt;&lt; &quot;Type '&quot; &lt;&lt; type.atomic_type-&gt;name &lt;&lt; &quot;' not supported yet.&quot;;
+    throw std::runtime_error(msg.str());
+}


Property changes on: tags/windstille-0.3.0/tools/miniswig/create_docu.cpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Added: tags/windstille-0.3.0/tools/miniswig/create_docu.hpp
===================================================================
--- tags/windstille-0.3.0/tools/miniswig/create_docu.hpp	2009-02-05 20:06:07 UTC (rev 2411)
+++ tags/windstille-0.3.0/tools/miniswig/create_docu.hpp	2009-02-05 20:09:13 UTC (rev 2412)
@@ -0,0 +1,26 @@
+#ifndef __CREATE_DOCU_H__
+#define __CREATE_DOCU_H__
+
+#include &quot;tree.hpp&quot;
+#include &quot;xmlwriter.hpp&quot;
+
+class DocuCreator
+{
+public:
+    const char* ind;
+    std::ostream&amp; out;
+    XmlWriter writer;
+
+    DocuCreator(std::ostream&amp; _out = std::cout)
+        : out(_out), writer(out)
+    {
+        ind = &quot;  &quot;;
+    }
+
+    void create_docu(Namespace* ns);
+    void create_class_docu(Class* _class);
+    void create_function_docu(Class* _class, Function* function);
+    std::string get_type(const Type&amp; type);
+};
+
+#endif


Property changes on: tags/windstille-0.3.0/tools/miniswig/create_docu.hpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Added: tags/windstille-0.3.0/tools/miniswig/create_wrapper.cpp
===================================================================
--- tags/windstille-0.3.0/tools/miniswig/create_wrapper.cpp	2009-02-05 20:06:07 UTC (rev 2411)
+++ tags/windstille-0.3.0/tools/miniswig/create_wrapper.cpp	2009-02-05 20:09:13 UTC (rev 2412)
@@ -0,0 +1,533 @@
+#include &lt;config.h&gt;
+
+#include &quot;tree.hpp&quot;
+#include &lt;iostream&gt;
+#include &lt;sstream&gt;
+#include &lt;stdexcept&gt;
+#include &quot;create_wrapper.hpp&quot;
+#include &quot;globals.hpp&quot;
+
+void
+WrapperCreator::create_wrapper(Namespace* ns)
+{
+    std::string fromfile = original_file != &quot;&quot; ? original_file : inputfile;
+
+    if(selected_namespace != &quot;&quot;) {
+        ns_prefix = selected_namespace;
+        ns_prefix += &quot;::&quot;;
+    }
+
+    // hpp file
+    hppout
+        &lt;&lt; &quot;/**\n&quot;
+        &lt;&lt; &quot; * WARNING: This file is automatically generated from:\n&quot;
+        &lt;&lt; &quot; *  '&quot; &lt;&lt; fromfile &lt;&lt; &quot;'\n&quot;
+        &lt;&lt; &quot; * DO NOT CHANGE\n&quot;
+        &lt;&lt; &quot; */\n&quot;
+        &lt;&lt; &quot;#ifndef __&quot; &lt;&lt; modulename &lt;&lt; &quot;_WRAPPER_H__\n&quot;
+        &lt;&lt; &quot;#define __&quot; &lt;&lt; modulename &lt;&lt; &quot;_WRAPPER_H__\n&quot;
+        &lt;&lt; &quot;\n&quot;
+        &lt;&lt; &quot;#include &lt;squirrel.h&gt;\n&quot;
+        &lt;&lt; &quot;#include \&quot;wrapper.interface.hpp\&quot;\n&quot;
+        &lt;&lt; &quot;\n&quot;
+        &lt;&lt; &quot;namespace Scripting\n&quot;
+        &lt;&lt; &quot;{\n&quot;
+        &lt;&lt; &quot;\n&quot;;
+
+    hppout &lt;&lt; &quot;void register_&quot; &lt;&lt; modulename &lt;&lt; &quot;_wrapper(HSQUIRRELVM v);\n&quot;
+           &lt;&lt; &quot;\n&quot;;
+
+    for(std::vector&lt;AtomicType*&gt;::iterator i = ns-&gt;types.begin();
+            i != ns-&gt;types.end(); ++i) {
+        AtomicType* type = *i;
+        Class* _class = dynamic_cast&lt;Class*&gt; (type);
+        if(_class == 0)
+            continue;
+
+        hppout &lt;&lt; &quot;void create_squirrel_instance(HSQUIRRELVM v, &quot;
+               &lt;&lt; ns_prefix &lt;&lt; _class-&gt;name
+               &lt;&lt; &quot;* object, bool setup_releasehook = false);\n&quot;;
+    }
+    hppout &lt;&lt;&quot;\n&quot;
+           &lt;&lt; &quot;}\n&quot;
+           &lt;&lt; &quot;\n&quot;
+           &lt;&lt; &quot;#endif\n&quot;
+           &lt;&lt; &quot;\n&quot;;
+
+    // cpp header
+    out &lt;&lt; &quot;/**\n&quot;
+        &lt;&lt; &quot; * WARNING: This file is automatically generated from:\n&quot;
+        &lt;&lt; &quot; *  '&quot; &lt;&lt; fromfile &lt;&lt; &quot;'\n&quot;
+        &lt;&lt; &quot; * DO NOT CHANGE\n&quot;
+        &lt;&lt; &quot; */\n&quot;
+        &lt;&lt; &quot;#include &lt;config.h&gt;\n&quot;
+        &lt;&lt; &quot;\n&quot;
+        &lt;&lt; &quot;#include &lt;new&gt;\n&quot;
+        &lt;&lt; &quot;#include &lt;assert.h&gt;\n&quot;
+        &lt;&lt; &quot;#include &lt;string&gt;\n&quot;
+        &lt;&lt; &quot;#include &lt;sstream&gt;\n&quot;
+        &lt;&lt; &quot;#include &lt;squirrel.h&gt;\n&quot;
+        &lt;&lt; &quot;#include \&quot;squirrel_error.hpp\&quot;\n&quot;
+        &lt;&lt; &quot;#include \&quot;wrapper.interface.hpp\&quot;\n&quot;
+        &lt;&lt; &quot;\n&quot;
+        &lt;&lt; &quot;namespace Scripting\n&quot;
+        &lt;&lt; &quot;{\n&quot;
+        &lt;&lt; &quot;namespace Wrapper\n&quot;
+        &lt;&lt; &quot;{\n&quot;
+        &lt;&lt; &quot;\n&quot;;
+
+    for(std::vector&lt;AtomicType*&gt;::iterator i = ns-&gt;types.begin();
+            i != ns-&gt;types.end(); ++i) {
+        AtomicType* type = *i;
+        Class* _class = dynamic_cast&lt;Class*&gt; (type);
+        if(_class != 0)
+            create_class_wrapper(_class);
+    }
+    for(std::vector&lt;Function*&gt;::iterator i = ns-&gt;functions.begin();
+            i != ns-&gt;functions.end(); ++i) {
+        create_function_wrapper(0, *i);
+    }
+
+    out &lt;&lt; &quot;} // end of namespace Wrapper\n&quot;;
+    out &lt;&lt; &quot;\n&quot;;
+
+    for(std::vector&lt;AtomicType*&gt;::iterator i = ns-&gt;types.begin();
+            i != ns-&gt;types.end(); ++i) {
+        AtomicType* type = *i;
+        Class* _class = dynamic_cast&lt;Class*&gt; (type);
+        if(_class != 0)
+            create_squirrel_instance(_class);
+    }
+
+    out &lt;&lt; &quot;void register_&quot; &lt;&lt; modulename &lt;&lt; &quot;_wrapper(HSQUIRRELVM v)\n&quot;
+        &lt;&lt; &quot;{\n&quot;
+        &lt;&lt; ind &lt;&lt; &quot;using namespace Wrapper;\n&quot;
+        &lt;&lt; &quot;\n&quot;;
+
+    create_register_constants_code(ns);
+    create_register_functions_code(ns);
+    create_register_classes_code(ns);
+
+    out &lt;&lt; &quot;}\n&quot;
+        &lt;&lt; &quot;\n&quot;
+        &lt;&lt; &quot;} // end of namespace Scripting\n&quot;
+        &lt;&lt; &quot;\n&quot;;
+}
+
+void
+WrapperCreator::create_register_function_code(Function* function, Class* _class)
+{
+    if(function-&gt;type == Function::DESTRUCTOR)
+        return;
+
+    out &lt;&lt; ind &lt;&lt; &quot;sq_pushstring(v, \&quot;&quot; &lt;&lt; function-&gt;name &lt;&lt; &quot;\&quot;, -1);\n&quot;;
+    out &lt;&lt; ind &lt;&lt; &quot;sq_newclosure(v, &amp;&quot;
+        &lt;&lt; (_class != 0 ? _class-&gt;name + &quot;_&quot; : &quot;&quot;) &lt;&lt; function-&gt;name
+        &lt;&lt; &quot;_wrapper, 0);\n&quot;;
+    create_register_slot_code(&quot;function&quot;, function-&gt;name);
+    out &lt;&lt; &quot;\n&quot;;
+}
+
+void
+WrapperCreator::create_register_functions_code(Namespace* ns)
+{
+    for(std::vector&lt;Function*&gt;::iterator i = ns-&gt;functions.begin();
+            i != ns-&gt;functions.end(); ++i) {
+        Function* function = *i;
+        create_register_function_code(function, 0);
+    }
+}
+
+void
+WrapperCreator::create_register_classes_code(Namespace* ns)
+{
+    for(std::vector&lt;AtomicType*&gt;::iterator i = ns-&gt;types.begin();
+            i != ns-&gt;types.end(); ++i) {
+        AtomicType* type = *i;
+        Class* _class = dynamic_cast&lt;Class*&gt; (type);
+        if(_class == 0)
+            continue;
+        if(_class-&gt;super_classes.size() &gt; 0)
+            continue;
+
+        create_register_class_code(_class);
+    }
+}
+
+void
+WrapperCreator::create_register_class_code(Class* _class)
+{
+    out &lt;&lt; ind &lt;&lt; &quot;// Register class &quot; &lt;&lt; _class-&gt;name &lt;&lt; &quot;\n&quot;;
+    out &lt;&lt; ind &lt;&lt; &quot;sq_pushstring(v, \&quot;&quot;
+        &lt;&lt; _class-&gt;name &lt;&lt; &quot;\&quot;, -1);\n&quot;;
+
+    if(_class-&gt;super_classes.size() &gt; 0) {
+        if(_class-&gt;super_classes.size() &gt; 1) {
+            std::ostringstream msg;
+            msg &lt;&lt; &quot;Multiple inheritance not supported (at class '&quot;
+                &lt;&lt; _class-&gt;name &lt;&lt; &quot;')&quot;;
+            throw std::runtime_error(msg.str());
+        }
+
+        out &lt;&lt; ind &lt;&lt; &quot;sq_pushstring(v, \&quot;&quot;
+            &lt;&lt; _class-&gt;super_classes[0]-&gt;name &lt;&lt; &quot;\&quot;, -1);\n&quot;;
+        out &lt;&lt; ind &lt;&lt; &quot;sq_get(v, -3);\n&quot;;
+    }
+    out &lt;&lt; ind &lt;&lt; &quot;if(sq_newclass(v, &quot;
+        &lt;&lt; (_class-&gt;super_classes.size() &gt; 0 ? &quot;SQTrue&quot; : &quot;SQFalse&quot;)
+        &lt;&lt; &quot;) &lt; 0) {\n&quot;;
+    out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;std::ostringstream msg;\n&quot;;
+    out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;msg &lt;&lt; \&quot;Couldn't create new class '&quot;
+        &lt;&lt; _class-&gt;name &lt;&lt; &quot;'\&quot;;\n&quot;;
+    out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;throw SquirrelError(v, msg.str());\n&quot;;
+    out &lt;&lt; ind &lt;&lt; &quot;}\n&quot;;
+
+    for(std::vector&lt;ClassMember*&gt;::iterator i = _class-&gt;members.begin();
+            i != _class-&gt;members.end(); ++i) {
+        ClassMember* member = *i;
+        if(member-&gt;visibility != ClassMember::PUBLIC)
+            continue;
+        Function* function = dynamic_cast&lt;Function*&gt; (member);
+        if(function) {
+            create_register_function_code(function, _class);
+        }
+        Field* field = dynamic_cast&lt;Field*&gt; (member);
+        if(field) {
+            create_register_constant_code(field);
+        }
+    }
+
+    create_register_slot_code(&quot;class&quot;, _class-&gt;name);
+    out &lt;&lt; &quot;\n&quot;;
+
+    for(std::vector&lt;Class*&gt;::iterator i = _class-&gt;sub_classes.begin();
+            i != _class-&gt;sub_classes.end(); ++i) {
+        Class* _class = *i;
+        create_register_class_code(_class);
+    }
+}
+
+void
+WrapperCreator::create_register_constants_code(Namespace* ns)
+{
+    for(std::vector&lt;Field*&gt;::iterator i = ns-&gt;fields.begin();
+            i != ns-&gt;fields.end(); ++i) {
+        Field* field = *i;
+        create_register_constant_code(field);
+    }
+}
+
+void
+WrapperCreator::create_register_constant_code(Field* field)
+{
+    if(!field-&gt;has_const_value)
+        return;
+    out &lt;&lt; ind &lt;&lt; &quot;sq_pushstring(v, \&quot;&quot; &lt;&lt; field-&gt;name &lt;&lt; &quot;\&quot;, -1);\n&quot;;
+    if(field-&gt;type-&gt;atomic_type == &amp;BasicType::INT) {
+        out &lt;&lt; ind &lt;&lt; &quot;sq_pushinteger(v, &quot; &lt;&lt; field-&gt;const_int_value &lt;&lt; &quot;);\n&quot;;
+    } else if(field-&gt;type-&gt;atomic_type == &amp;BasicType::FLOAT) {
+        out &lt;&lt; ind &lt;&lt; &quot;sq_pushfloat(v, &quot; &lt;&lt; field-&gt;const_float_value &lt;&lt; &quot;);\n&quot;;
+    } else if(field-&gt;type-&gt;atomic_type == StringType::instance()) {
+        out &lt;&lt; ind &lt;&lt; &quot;sq_pushstring(v, \&quot;&quot;
+            &lt;&lt; field-&gt;const_string_value &lt;&lt; &quot;\&quot;, -1);\n&quot;;
+    } else {
+      throw std::runtime_error(&quot;Constant is not int, float or string&quot;);
+    }
+    create_register_slot_code(&quot;constant&quot;, field-&gt;name);
+    out &lt;&lt; &quot;\n&quot;;
+}
+
+void
+WrapperCreator::create_register_slot_code(const std::string&amp; what,
+                                          const std::string&amp; name)
+{
+    out &lt;&lt; ind &lt;&lt; &quot;if(SQ_FAILED(sq_createslot(v, -3))) {\n&quot;;
+    out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;throw SquirrelError(v, \&quot;&quot;
+        &lt;&lt; &quot;Couldn't register &quot; &lt;&lt; what &lt;&lt; &quot; '&quot; &lt;&lt; name &lt;&lt; &quot;'\&quot;);\n&quot;;
+    out &lt;&lt; ind &lt;&lt; &quot;}\n&quot;;
+}
+
+void
+WrapperCreator::create_function_wrapper(Class* _class, Function* function)
+{
+    if(function-&gt;type == Function::DESTRUCTOR)
+        assert(false);
+
+    std::string ns_prefix;
+    if(selected_namespace != &quot;&quot;)
+        ns_prefix = selected_namespace + &quot;::&quot;;
+    if(function-&gt;type == Function::CONSTRUCTOR)
+        function-&gt;name = &quot;constructor&quot;;
+
+    out &lt;&lt; &quot;static SQInteger &quot;;
+    if(_class != 0) {
+        out &lt;&lt; _class-&gt;name &lt;&lt; &quot;_&quot;;
+    }
+    out &lt;&lt; function-&gt;name &lt;&lt; &quot;_wrapper(HSQUIRRELVM vm)\n&quot;
+        &lt;&lt; &quot;{\n&quot;;
+    // avoid warning...
+    if(_class == 0 &amp;&amp; function-&gt;parameters.empty()
+            &amp;&amp; function-&gt;return_type.is_void()
+            &amp;&amp; function-&gt;type != Function::CONSTRUCTOR) {
+        out &lt;&lt; ind &lt;&lt; &quot;(void) vm;\n&quot;;
+    }
+
+    // retrieve pointer to class instance
+    if(_class != 0 &amp;&amp; function-&gt;type != Function::CONSTRUCTOR) {
+        out &lt;&lt; ind &lt;&lt; &quot;SQUserPointer data;\n&quot;;
+        out &lt;&lt; ind &lt;&lt; &quot;if(SQ_FAILED(sq_getinstanceup(vm, 1, &amp;data, 0))) {\n&quot;;
+        out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;sq_throwerror(vm, _SC(\&quot;'&quot; &lt;&lt; function-&gt;name &lt;&lt; &quot;' called without instance\&quot;));\n&quot;;
+        out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;return SQ_ERROR;\n&quot;;
+        out &lt;&lt; ind &lt;&lt; &quot;}\n&quot;;
+        out &lt;&lt; ind &lt;&lt; ns_prefix &lt;&lt;  _class-&gt;name &lt;&lt; &quot;* _this = reinterpret_cast&lt;&quot; &lt;&lt; ns_prefix &lt;&lt; _class-&gt;name &lt;&lt; &quot;*&gt; (data);\n&quot;;
+    }
+
+    // custom function?
+    if(function-&gt;custom) {
+        if(function-&gt;type != Function::FUNCTION)
+            throw std::runtime_error(
+                    &quot;custom not allow constructor+destructor yet&quot;);
+        if(function-&gt;return_type.atomic_type != SQIntegerType::instance())
+            throw std::runtime_error(&quot;custom function has to return SQInteger&quot;);
+        if(function-&gt;parameters.size() != 1)
+            throw std::runtime_error(
+                    &quot;custom function must have 1 HSQUIRRELVM parameter&quot;);
+
+        out &lt;&lt; ind &lt;&lt; &quot;return &quot;;
+        if(_class != 0)
+            out &lt;&lt; &quot;_this-&gt;&quot;;
+        else
+            out &lt;&lt; ns_prefix;
+        out &lt;&lt; function-&gt;name &lt;&lt; &quot;(vm);\n&quot;;
+        out &lt;&lt; &quot;}\n&quot;;
+        out &lt;&lt; &quot;\n&quot;;
+        return;
+    }
+
+    // declare and retrieve arguments
+    int i = 0;
+    int arg_offset = 2;
+    for(std::vector&lt;Parameter&gt;::iterator p = function-&gt;parameters.begin();
+            p != function-&gt;parameters.end(); ++p) {
+        if(i == 0 &amp;&amp; p-&gt;type.atomic_type == HSQUIRRELVMType::instance()) {
+            out &lt;&lt; ind &lt;&lt; &quot;HSQUIRRELVM arg0 = vm;\n&quot;;
+            arg_offset--;
+        } else {
+            char argname[64];
+            snprintf(argname, sizeof(argname), &quot;arg%d&quot;, i);
+            prepare_argument(p-&gt;type, i + arg_offset, argname);
+        }
+        ++i;
+    }
+
+    // call function
+    out &lt;&lt; ind &lt;&lt; &quot;\n&quot;;
+    out &lt;&lt; ind &lt;&lt; &quot;try {\n&quot;;
+    out &lt;&lt; ind &lt;&lt; ind;
+    if(!function-&gt;return_type.is_void()) {
+        function-&gt;return_type.write_c_type(out);
+        out &lt;&lt; &quot; return_value = &quot;;
+    }
+    if(_class != 0) {
+        if(function-&gt;type == Function::CONSTRUCTOR) {
+            out &lt;&lt; ns_prefix &lt;&lt; _class-&gt;name &lt;&lt; &quot;* _this = new &quot; &lt;&lt; ns_prefix;
+        } else {
+            out &lt;&lt; &quot;_this-&gt;&quot;;
+        }
+    } else {
+        out &lt;&lt; ns_prefix;
+    }
+    if(function-&gt;type == Function::CONSTRUCTOR) {
+        out &lt;&lt; _class-&gt;name &lt;&lt; &quot;(&quot;;
+    } else {
+        out &lt;&lt; function-&gt;name &lt;&lt; &quot;(&quot;;
+    }
+    for(size_t i = 0; i &lt; function-&gt;parameters.size(); ++i) {
+        if(i != 0)
+            out &lt;&lt; &quot;, &quot;;
+        const Parameter param = function-&gt;parameters[i];
+        if(param.type.ref == 0 &amp;&amp; param.type.pointer == 0) {
+            if(param.type.atomic_type == &amp;BasicType::INT)
+                out &lt;&lt; &quot;static_cast&lt;int&gt; (arg&quot; &lt;&lt; i &lt;&lt; &quot;)&quot;;
+            else if(param.type.atomic_type == &amp;BasicType::FLOAT)
+                out &lt;&lt; &quot;static_cast&lt;float&gt; (arg&quot; &lt;&lt; i &lt;&lt; &quot;)&quot;;
+            else if(param.type.atomic_type == &amp;BasicType::BOOL)
+                out &lt;&lt; &quot;arg&quot; &lt;&lt; i &lt;&lt; &quot; == SQTrue&quot;;
+            else
+                out &lt;&lt; &quot;arg&quot; &lt;&lt; i;
+        } else {
+            out &lt;&lt; &quot;arg&quot; &lt;&lt; i;
+        }
+    }
+    out &lt;&lt; &quot;);\n&quot;;
+    if(function-&gt;type == Function::CONSTRUCTOR) {
+        out &lt;&lt; ind &lt;&lt; &quot;if(SQ_FAILED(sq_setinstanceup(vm, 1, _this))) {\n&quot;;
+        out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;sq_throwerror(vm, _SC(\&quot;Couldn't setup instance of '&quot; &lt;&lt; _class-&gt;name &lt;&lt; &quot;' class\&quot;));\n&quot;;
+        out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;return SQ_ERROR;\n&quot;;
+        out &lt;&lt; ind &lt;&lt; &quot;}\n&quot;;
+        out &lt;&lt; ind &lt;&lt; &quot;sq_setreleasehook(vm, 1, &quot;
+            &lt;&lt; _class-&gt;name &lt;&lt; &quot;_release_hook);\n&quot;;
+    }
+    out &lt;&lt; ind &lt;&lt; &quot;\n&quot;;
+    // push return value back on stack and return
+    if(function-&gt;suspend) {
+        if(!function-&gt;return_type.is_void()) {
+            std::stringstream msg;
+            msg &lt;&lt; &quot;Function '&quot; &lt;&lt; function-&gt;name &lt;&lt; &quot;' declared as suspend&quot;
+                &lt;&lt; &quot; but has a return value.&quot;;
+            throw std::runtime_error(msg.str());
+        }
+        out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;return sq_suspendvm(vm);\n&quot;;
+    } else if(function-&gt;return_type.is_void()) {
+        out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;return 0;\n&quot;;
+    } else {
+        push_to_stack(function-&gt;return_type, &quot;return_value&quot;);
+        out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;return 1;\n&quot;;
+    }
+
+    out &lt;&lt; ind &lt;&lt; &quot;\n&quot;;
+    out &lt;&lt; ind &lt;&lt; &quot;} catch(std::exception&amp; e) {\n&quot;;
+    out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;sq_throwerror(vm, e.what());\n&quot;;
+    out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;return SQ_ERROR;\n&quot;;
+    out &lt;&lt; ind &lt;&lt; &quot;} catch(...) {\n&quot;;
+    out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;sq_throwerror(vm, _SC(\&quot;Unexpected exception while executing function '&quot; &lt;&lt; function-&gt;name &lt;&lt; &quot;'\&quot;));\n&quot;;
+    out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;return SQ_ERROR;\n&quot;;
+    out &lt;&lt; ind &lt;&lt; &quot;}\n&quot;;
+    out &lt;&lt; ind &lt;&lt; &quot;\n&quot;;
+
+    out &lt;&lt; &quot;}\n&quot;;
+    out &lt;&lt; &quot;\n&quot;;
+}
+
+void
+WrapperCreator::prepare_argument(const Type&amp; type, size_t index,
+        const std::string&amp; var)
+{
+    if(type.ref &gt; 0 &amp;&amp; type.atomic_type != StringType::instance())
+        throw std::runtime_error(&quot;References not handled yet&quot;);
+    if(type.pointer &gt; 0)
+        throw std::runtime_error(&quot;Pointers not handled yet&quot;);
+    if(type.atomic_type == &amp;BasicType::INT) {
+        out &lt;&lt; ind &lt;&lt; &quot;SQInteger &quot; &lt;&lt; var &lt;&lt; &quot;;\n&quot;;
+        out &lt;&lt; ind &lt;&lt; &quot;if(SQ_FAILED(sq_getinteger(vm, &quot; &lt;&lt; index &lt;&lt; &quot;, &amp;&quot; &lt;&lt; var &lt;&lt; &quot;))) {\n&quot;;
+        out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;sq_throwerror(vm, _SC(\&quot;Argument &quot; &lt;&lt; (index-1) &lt;&lt; &quot; not an integer\&quot;));\n&quot;;
+        out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;return SQ_ERROR;\n&quot;;
+        out &lt;&lt; ind &lt;&lt; &quot;}\n&quot;;
+    } else if(type.atomic_type == &amp;BasicType::FLOAT) {
+        out &lt;&lt; ind &lt;&lt; &quot;SQFloat &quot; &lt;&lt; var &lt;&lt; &quot;;\n&quot;;
+        out &lt;&lt; ind &lt;&lt; &quot;if(SQ_FAILED(sq_getfloat(vm, &quot; &lt;&lt; index &lt;&lt; &quot;, &amp;&quot; &lt;&lt; var &lt;&lt; &quot;))) {\n&quot;;
+        out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;sq_throwerror(vm, _SC(\&quot;Argument &quot; &lt;&lt; (index-1) &lt;&lt; &quot; not a float\&quot;));\n&quot;;
+        out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;return SQ_ERROR;\n&quot;;
+        out &lt;&lt; ind &lt;&lt; &quot;}\n&quot;;
+    } else if(type.atomic_type == &amp;BasicType::BOOL) {
+        out &lt;&lt; ind &lt;&lt; &quot;SQBool &quot; &lt;&lt; var &lt;&lt; &quot;;\n&quot;;
+        out &lt;&lt; ind &lt;&lt; &quot;if(SQ_FAILED(sq_getbool(vm, &quot; &lt;&lt; index &lt;&lt; &quot;, &amp;&quot; &lt;&lt; var &lt;&lt; &quot;))) {\n&quot;;
+        out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;sq_throwerror(vm, _SC(\&quot;Argument &quot; &lt;&lt; (index-1) &lt;&lt; &quot; not a bool\&quot;));\n&quot;;
+        out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;return SQ_ERROR;\n&quot;;
+        out &lt;&lt; ind &lt;&lt; &quot;}\n&quot;;
+    } else if(type.atomic_type == StringType::instance()) {
+        out &lt;&lt; ind &lt;&lt; &quot;const SQChar* &quot; &lt;&lt; var &lt;&lt; &quot;;\n&quot;;
+        out &lt;&lt; ind &lt;&lt; &quot;if(SQ_FAILED(sq_getstring(vm, &quot; &lt;&lt; index &lt;&lt; &quot;, &amp;&quot; &lt;&lt; var &lt;&lt; &quot;))) {\n&quot;;
+        out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;sq_throwerror(vm, _SC(\&quot;Argument &quot; &lt;&lt; (index-1) &lt;&lt; &quot; not a string\&quot;));\n&quot;;
+        out &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;return SQ_ERROR;\n&quot;;
+        out &lt;&lt; ind &lt;&lt; &quot;}\n&quot;;
+    } else {
+        std::ostringstream msg;
+        msg &lt;&lt; &quot;Type '&quot; &lt;&lt; type.atomic_type-&gt;name &lt;&lt; &quot;' not supported yet.&quot;;
+        throw std::runtime_error(msg.str());
+    }
+}
+
+void
+WrapperCreator::push_to_stack(const Type&amp; type, const std::string&amp; var)
+{
+    if(type.ref &gt; 0 &amp;&amp; type.atomic_type != StringType::instance())
+        throw std::runtime_error(&quot;References not handled yet&quot;);
+    if(type.pointer &gt; 0)
+        throw std::runtime_error(&quot;Pointers not handled yet&quot;);
+    out &lt;&lt; ind &lt;&lt; ind;
+    if(type.atomic_type == &amp;BasicType::INT) {
+        out &lt;&lt; &quot;sq_pushinteger(vm, &quot; &lt;&lt; var &lt;&lt; &quot;);\n&quot;;
+    } else if(type.atomic_type == &amp;BasicType::FLOAT) {
+        out &lt;&lt; &quot;sq_pushfloat(vm, &quot; &lt;&lt; var &lt;&lt; &quot;);\n&quot;;
+    } else if(type.atomic_type == &amp;BasicType::BOOL) {
+        out &lt;&lt; &quot;sq_pushbool(vm, &quot; &lt;&lt; var &lt;&lt; &quot;);\n&quot;;
+    } else if(type.atomic_type == StringType::instance()) {
+        out &lt;&lt; &quot;sq_pushstring(vm, &quot; &lt;&lt; var &lt;&lt; &quot;.c_str(), &quot;
+            &lt;&lt; var &lt;&lt; &quot;.size());\n&quot;;
+    } else {
+        std::ostringstream msg;
+        msg &lt;&lt; &quot;Type '&quot; &lt;&lt; type.atomic_type-&gt;name &lt;&lt; &quot;' not supported yet.&quot;;
+        throw std::runtime_error(msg.str());
+    }
+}
+
+void
+WrapperCreator::create_class_wrapper(Class* _class)
+{
+    create_class_release_hook(_class);
+    for(std::vector&lt;ClassMember*&gt;::iterator i = _class-&gt;members.begin();
+            i != _class-&gt;members.end(); ++i) {
+        ClassMember* member = *i;
+        if(member-&gt;visibility != ClassMember::PUBLIC)
+            continue;
+        Function* function = dynamic_cast&lt;Function*&gt; (member);
+        if(!function)
+            continue;
+        // don't wrap destructors
+        if(function-&gt;type == Function::DESTRUCTOR)
+            continue;
+        create_function_wrapper(_class, function);
+    }
+}
+
+void
+WrapperCreator::create_squirrel_instance(Class* _class)
+{
+    out &lt;&lt; &quot;void create_squirrel_instance(HSQUIRRELVM v, &quot;
+        &lt;&lt; ns_prefix &lt;&lt; _class-&gt;name
+        &lt;&lt; &quot;* object, bool setup_releasehook)\n&quot;
+        &lt;&lt; &quot;{\n&quot;
+        &lt;&lt; ind &lt;&lt; &quot;using namespace Wrapper;\n&quot;
+        &lt;&lt; &quot;\n&quot;
+        &lt;&lt; ind &lt;&lt; &quot;sq_pushroottable(v);\n&quot;
+        &lt;&lt; ind &lt;&lt; &quot;sq_pushstring(v, \&quot;&quot; &lt;&lt; _class-&gt;name &lt;&lt; &quot;\&quot;, -1);\n&quot;
+        &lt;&lt; ind &lt;&lt; &quot;if(SQ_FAILED(sq_get(v, -2))) {\n&quot;
+        &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;std::ostringstream msg;\n&quot;
+        &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;msg &lt;&lt; \&quot;Couldn't resolved squirrel type '&quot;
+        &lt;&lt; _class-&gt;name &lt;&lt; &quot;'\&quot;;\n&quot;
+        &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;throw SquirrelError(v, msg.str());\n&quot;
+        &lt;&lt; ind &lt;&lt; &quot;}\n&quot;
+        &lt;&lt; &quot;\n&quot;
+        &lt;&lt; ind &lt;&lt; &quot;if(SQ_FAILED(sq_createinstance(v, -1)) || &quot;
+        &lt;&lt; &quot;SQ_FAILED(sq_setinstanceup(v, -1, object))) {\n&quot;
+        &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;std::ostringstream msg;\n&quot;
+        &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;msg &lt;&lt; \&quot;Couldn't setup squirrel instance for &quot;
+        &lt;&lt; &quot;object of type '&quot; &lt;&lt; _class-&gt;name &lt;&lt; &quot;'\&quot;;\n&quot;
+        &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;throw SquirrelError(v, msg.str());\n&quot;
+        &lt;&lt; ind &lt;&lt; &quot;}\n&quot;
+        &lt;&lt; ind &lt;&lt; &quot;sq_remove(v, -2); // remove object name\n&quot;
+        &lt;&lt; &quot;\n&quot;
+        &lt;&lt; ind &lt;&lt; &quot;if(setup_releasehook) {\n&quot;
+        &lt;&lt; ind &lt;&lt; ind &lt;&lt; &quot;sq_setreleasehook(v, -1, &quot;
+        &lt;&lt; _class-&gt;name &lt;&lt; &quot;_release_hook);\n&quot;
+        &lt;&lt; ind &lt;&lt; &quot;}\n&quot;
+        &lt;&lt; &quot;\n&quot;
+        &lt;&lt; ind &lt;&lt; &quot;sq_remove(v, -2); // remove root table\n&quot;
+        &lt;&lt; &quot;}\n&quot;
+        &lt;&lt; &quot;\n&quot;;
+}
+
+void
+WrapperCreator::create_class_release_hook(Class* _class)
+{
+    out &lt;&lt; &quot;static SQInteger &quot; &lt;&lt; _class-&gt;name &lt;&lt; &quot;_release_hook(SQUserPointer ptr, SQInteger )\n&quot;
+        &lt;&lt; &quot;{\n&quot;
+        &lt;&lt; ind &lt;&lt; ns_prefix &lt;&lt; _class-&gt;name
+        &lt;&lt; &quot;* _this = reinterpret_cast&lt;&quot; &lt;&lt; ns_prefix &lt;&lt; _class-&gt;name
+        &lt;&lt; &quot;*&gt; (ptr);\n&quot;
+        &lt;&lt; ind &lt;&lt; &quot;delete _this;\n&quot;
+        &lt;&lt; ind &lt;&lt; &quot;return 0;\n&quot;
+        &lt;&lt; &quot;}\n&quot;
+        &lt;&lt; &quot;\n&quot;;
+}


Property changes on: tags/windstille-0.3.0/tools/miniswig/create_wrapper.cpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Added: tags/windstille-0.3.0/tools/miniswig/create_wrapper.hpp
===================================================================
--- tags/windstille-0.3.0/tools/miniswig/create_wrapper.hpp	2009-02-05 20:06:07 UTC (rev 2411)
+++ tags/windstille-0.3.0/tools/miniswig/create_wrapper.hpp	2009-02-05 20:09:13 UTC (rev 2412)
@@ -0,0 +1,46 @@
+#ifndef __CREATE_WRAPPER_H__
+#define __CREATE_WRAPPER_H__
+
+#include &quot;tree.hpp&quot;
+
+class WrapperCreator
+{
+public:
+    /// this is used for indentation
+    const char* ind;
+    // output stream
+    std::ostream&amp; out;
+    std::ostream&amp; hppout;
+
+    WrapperCreator(std::ostream&amp; _out = std::cout, std::ostream&amp; _hppout = std::cout)
+        : out(_out), hppout(_hppout)
+    {
+        ind = &quot;  &quot;;
+    }
+
+    void create_wrapper(Namespace* ns);
+
+private:
+    std::string ns_prefix;
+
+    void create_register_functions_code(Namespace* ns);
+    void create_register_function_code(Function* function, Class* _class);
+    void create_register_classes_code(Namespace* ns);
+    void create_register_class_code(Class* _class);
+    void create_register_constant_code(Field* field);
+    void create_register_constants_code(Namespace* ns);
+    void create_register_slot_code(const std::string&amp; what,
+                                   const std::string&amp; name);
+
+    void create_function_list(Namespace* ns);
+    void create_const_lists(Namespace* ns);
+    void create_class_const_lists(Class* _class);
+    void create_class_wrapper(Class* _class);
+    void create_class_release_hook(Class* _class);
+    void create_squirrel_instance(Class* _class);
+    void create_function_wrapper(Class* _class, Function* function);
+    void prepare_argument(const Type&amp; type, size_t idx, const std::string&amp; var);
+    void push_to_stack(const Type&amp; type, const std::string&amp; var);
+};
+
+#endif


Property changes on: tags/windstille-0.3.0/tools/miniswig/create_wrapper.hpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Added: tags/windstille-0.3.0/tools/miniswig/globals.hpp
===================================================================
--- tags/windstille-0.3.0/tools/miniswig/globals.hpp	2009-02-05 20:06:07 UTC (rev 2411)
+++ tags/windstille-0.3.0/tools/miniswig/globals.hpp	2009-02-05 20:09:13 UTC (rev 2412)
@@ -0,0 +1,29 @@
+#ifndef __GLOBALS_H__
+#define __GLOBALS_H__
+
+#include &quot;tree.hpp&quot;
+#include &lt;iostream&gt;
+
+// parsing
+extern CompilationUnit* unit;
+extern bool search_down;
+extern Namespace* search_namespace;
+extern Namespace* current_namespace;
+extern std::string last_docucomment;
+// the first file indicated by # 1 &quot;...&quot;
+// (this is what the C preprocessor outputs so that you know which was the
+// original file before preprocessing
+extern std::string original_file;
+// the filename where the current fragment came from (before it was included by
+// the preprocessor)
+extern std::string current_file;
+// get line number inside the current_file
+int getCurrentLine();
+
+// config/output
+extern std::istream* input;
+extern std::string inputfile;
+extern std::string modulename;
+extern std::string selected_namespace;
+
+#endif


Property changes on: tags/windstille-0.3.0/tools/miniswig/globals.hpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Added: tags/windstille-0.3.0/tools/miniswig/lexer.ll
===================================================================
--- tags/windstille-0.3.0/tools/miniswig/lexer.ll	2009-02-05 20:06:07 UTC (rev 2411)
+++ tags/windstille-0.3.0/tools/miniswig/lexer.ll	2009-02-05 20:09:13 UTC (rev 2412)
@@ -0,0 +1,139 @@
+%{
+#include &lt;config.h&gt;
+  
+#include &lt;math.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;iostream&gt;
+#include &quot;tree.hpp&quot;
+#include &quot;parser.hpp&quot;
+#include &quot;globals.hpp&quot;
+
+// there seems to be a bug in flex that adds some ECHO directives
+// in some rules, we don't need debug output
+#define ECHO  {}
+
+#define YY_NEVER_INTERACTIVE 1
+#define YY_DECL int yylex(YYSTYPE* yylval)
+
+#define YY_INPUT(buf, result, max_size)                     \
+{                                                           \
+    input-&gt;read(buf, max_size);                             \
+    result = input-&gt;gcount();                               \
+}
+
+std::string last_docucomment;
+std::string original_file;
+std::string current_file;
+std::string comm;
+int offset_lnum;
+
+int getCurrentLine()
+{
+    return yylineno - offset_lnum;
+}
+    
+%}
+
+%option noyywrap
+%option yylineno
+/* %option never-interactive */
+
+%x comment
+%%
+
+#[ \t]+[0-9]+[ \t]+.*                         {
+    int lnum;
+    char file[1024];
+    if(sscanf(yytext, &quot;# %d \&quot;%1023[^\&quot;]\&quot;&quot;, &amp;lnum, file) == 2) {
+        offset_lnum = yylineno - lnum + 1;
+        current_file = file;
+        if(original_file == &quot;&quot;)
+            original_file = file;
+    } else {
+        std::cerr &lt;&lt; &quot;Warning: Parse error in processor info directive.\n&quot;;
+    }
+}
+#.*                                     /* ignore preprocessor directives */
+[[:space:]]+                            /* eat spaces */
+&quot;/*&quot;                                    { BEGIN(comment); comm = &quot;&quot;; }
+&lt;comment&gt;[^*\n]*                        { comm += yytext; }
+&lt;comment&gt;&quot;*&quot;+[^*/]*                     { comm += yytext; }
+&lt;comment&gt;&quot;*/&quot;                    {
+    BEGIN(INITIAL);
+    if(comm[0] == '*') { // It's a docu comment...
+        last_docucomment = &quot;&quot;;
+        bool linestart = true;
+        for(size_t i = 1; i &lt; comm.size(); ++i) {
+            if(linestart &amp;&amp; (comm[i] == '*' || isspace(comm[i]))) {
+                continue;
+            } else if(comm[i] == '\n') {
+                linestart = true;
+            } else {
+                linestart = false;
+            }
+            last_docucomment += comm[i];
+        }
+    }
+}
+\/\/[^\n]*\n                            {
+    if(yytext[2] == '/') { // it's a docu comment...
+        last_docucomment = std::string(yytext+3, strlen(yytext)-4);
+    }
+}
+class                                   { return T_CLASS; }
+struct                                  { return T_STRUCT; }
+static                                  { return T_STATIC; }
+virtual                                 { }
+const                                   { return T_CONST; }
+unsigned                                { return T_UNSIGNED; }
+signed                                  { return T_SIGNED; }
+void                                    { return T_VOID; }
+bool                                    { return T_BOOL; }
+char                                    { return T_CHAR; }
+short                                   { return T_SHORT; }
+int                                     { return T_INT; }
+long                                    { return T_LONG; }
+float                                   { return T_FLOAT; }
+double                                  { return T_DOUBLE; }
+public                                  { return T_PUBLIC; }
+protected                               { return T_PROTECTED; }
+private                                 { return T_PRIVATE; }
+namespace                               { return T_NAMESPACE; }
+__suspend                               { return T_SUSPEND; }
+__custom                                { return T_CUSTOM; }
+[a-zA-Z_][a-zA-Z_0-9]*                  {
+        Namespace* ns = search_namespace;
+        if(ns == 0)
+            ns = current_namespace;          
+        // is it a type?
+        yylval-&gt;atomic_type = ns-&gt;_findType(yytext, search_down);
+        if(yylval-&gt;atomic_type) {
+            return T_ATOMIC_TYPE;
+        }
+        // or a namespace? (hack for now...)
+        yylval-&gt;_namespace = ns-&gt;_findNamespace(yytext, search_down);
+        if(yylval-&gt;_namespace) {
+            return T_NAMESPACEREF;
+        }
+        // a new ID
+        yylval-&gt;str = strdup(yytext);
+        return T_ID;
+}
+\:\:                                    { return T_DDCOL; }
+(0x)?[0-9]+ {
+        sscanf(yytext, &quot;%i&quot;, &amp;(yylval-&gt;ival));
+        return T_INT;
+}
+[0-9]*\.[0-9]+(e[0-9]+)? { 
+        sscanf(yytext, &quot;%f&quot;, &amp;(yylval-&gt;fval));
+        return T_FLOAT;
+}
+\&quot;.*\&quot; {
+        yylval-&gt;str = strdup(yytext);
+        return T_STRING;
+}
+.                                       { return yytext[0]; }
+
+%%
+

Added: tags/windstille-0.3.0/tools/miniswig/main.cpp
===================================================================
--- tags/windstille-0.3.0/tools/miniswig/main.cpp	2009-02-05 20:06:07 UTC (rev 2411)
+++ tags/windstille-0.3.0/tools/miniswig/main.cpp	2009-02-05 20:09:13 UTC (rev 2412)
@@ -0,0 +1,145 @@
+#include &lt;config.h&gt;
+
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+#include &lt;vector&gt;
+#include &lt;string&gt;
+#include &quot;tree.hpp&quot;
+#include &quot;globals.hpp&quot;
+#include &quot;create_wrapper.hpp&quot;
+#include &quot;create_docu.hpp&quot;
+
+extern int yyparse();
+extern int yylex();
+
+CompilationUnit* unit = 0;
+std::istream* input = 0;
+std::string inputfile;
+std::string selected_namespace;
+std::string modulename = &quot;wrapper&quot;;
+
+void usage()
+{
+    std::cout &lt;&lt; &quot;Usage: miniswig --input FILE --output-cpp FILE --output-hpp FILE [--module NAME] [--select-namespace NAME]\n&quot;;
+    std::cout &lt;&lt; &quot;\n&quot;;
+}
+
+int main(int argc, char** argv)
+{
+    std::string outputcpp;
+    std::string outputhpp;
+    std::string output_doc;
+    for(int i = 0; i &lt; argc; ++i) {
+        if(strcmp(argv[i], &quot;--module&quot;) == 0) {
+            if(i+1 &gt;= argc) {
+                std::cerr &lt;&lt; &quot;Need to specify a module name.\n&quot;;
+                usage();
+                return 1;
+            }
+            modulename = argv[++i];
+        } else if(strcmp(argv[i], &quot;--input&quot;) == 0) {
+            if(i+1 &gt;= argc) {
+                std::cerr &lt;&lt; &quot;Need to specify input file name.\n&quot;;
+                usage();
+                return 1;
+            }
+            inputfile = argv[++i];
+        } else if(strcmp(argv[i], &quot;--output-cpp&quot;) == 0) {
+            if(i+1 &gt;= argc) {
+                std::cerr &lt;&lt; &quot;Need to specifiy output cpp name.\n&quot;;
+                usage();
+                return 1;
+            }
+            outputcpp = argv[++i];
+        } else if(strcmp(argv[i], &quot;--output-hpp&quot;) == 0) {
+            if(i+1 &gt;= argc) {
+                std::cerr &lt;&lt; &quot;Need to specify output hpp name.\n&quot;;
+                usage();
+                return 1;
+            }
+            outputhpp = argv[++i];
+        } else if(strcmp(argv[i], &quot;--select-namespace&quot;) == 0) {
+            if(i+1 &gt;= argc) {
+                std::cerr &lt;&lt; &quot;Need to specify a namespace.\n&quot;;
+                usage();
+                return 1;
+            }
+            selected_namespace = argv[++i];
+        } else if(strcmp(argv[i], &quot;--output-doc&quot;) == 0) {
+          if(i+1 &gt;= argc) {
+            std::cerr &lt;&lt; &quot;Need to specify document xml file.\n&quot;;
+            usage();
+            return 1;
+          }
+          output_doc = argv[++i];
+        } else if(argv[i][0] == '-') {
+            std::cerr &lt;&lt; &quot;Unknown option '&quot; &lt;&lt; argv[i] &lt;&lt; &quot;'.\n&quot;;
+            usage();
+            return 1;
+        } else {
+        }
+    }
+    if( inputfile == &quot;&quot; || (
+            (outputcpp == &quot;&quot; || outputhpp == &quot;&quot;) &amp;&amp; output_doc == &quot;&quot;)) {
+        std::cerr &lt;&lt; &quot;Not all options specified.\n&quot;;
+        usage();
+        return 1;
+    }
+
+    try {
+        input = new std::ifstream(inputfile.c_str());
+        if(!input-&gt;good()) {
+            std::cerr &lt;&lt; &quot;Couldn't open file '&quot; &lt;&lt; input &lt;&lt; &quot;' for reading.\n&quot;;
+            return 1;
+        }
+        current_file = inputfile;
+        unit = new CompilationUnit();
+        Namespace* std_namespace = new Namespace();
+        std_namespace-&gt;name = &quot;std&quot;;
+        std_namespace-&gt;types.push_back(new StringType());
+        unit-&gt;namespaces.push_back(std_namespace);
+        unit-&gt;types.push_back(new HSQUIRRELVMType());
+        unit-&gt;types.push_back(new SQIntegerType());
+
+        yyparse();
+
+        Namespace* ns = unit;
+        if(selected_namespace != &quot;&quot;) {
+            ns = ns-&gt;findNamespace(selected_namespace);
+        }
+
+        if(outputcpp != &quot;&quot;) {
+            std::ofstream cppout(outputcpp.c_str());
+            if(!cppout.good()) {
+                std::cerr &lt;&lt; &quot;Couldn't open file '&quot;
+                          &lt;&lt; outputcpp &lt;&lt; &quot;' for writing.\n&quot;;
+                return 1;
+            }
+            std::ofstream hppout(outputhpp.c_str());
+            if(!hppout.good()) {
+                std::cerr &lt;&lt; &quot;Couldn't open file '&quot; &lt;&lt; outputhpp
+                          &lt;&lt; &quot;' for writing.\n&quot;;
+                return 1;
+            }
+
+            WrapperCreator creator(cppout, hppout);
+            creator.create_wrapper(ns);
+        }
+
+        if(output_doc != &quot;&quot;) {
+            std::ofstream dout(output_doc.c_str());
+            if(!dout.good()) {
+                std::cerr &lt;&lt; &quot;Couldn't open file '&quot;
+                    &lt;&lt; output_doc &lt;&lt; &quot;' for writing.\n&quot;;
+                return 1;
+            }
+            DocuCreator creator(dout);
+            creator.create_docu(ns);
+        }
+    } catch(std::exception&amp; e) {
+        std::cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;
+        return 1;
+    }
+
+    return 0;
+}


Property changes on: tags/windstille-0.3.0/tools/miniswig/main.cpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Added: tags/windstille-0.3.0/tools/miniswig/parser.yy
===================================================================
--- tags/windstille-0.3.0/tools/miniswig/parser.yy	2009-02-05 20:06:07 UTC (rev 2411)
+++ tags/windstille-0.3.0/tools/miniswig/parser.yy	2009-02-05 20:09:13 UTC (rev 2412)
@@ -0,0 +1,447 @@
+%{
+#include &lt;config.h&gt;
+
+#include &lt;iostream&gt;
+#include &lt;sstream&gt;
+#include &lt;stdexcept&gt;
+#include &quot;tree.hpp&quot;
+#include &quot;globals.hpp&quot;
+
+%}
+
+%pure_parser
+%union {
+    char*       str;
+    int         ival;
+    float       fval;
+    Class*      _class;
+    Function*   function;
+    Field*      field;
+    Type*       type;
+    AtomicType* atomic_type;
+    Namespace*  _namespace;
+}
+
+%{
+
+extern int yylex(YYSTYPE* yylval);
+void yyerror(const char* s);
+extern int yylineno;
+
+bool search_down = true;
+Namespace* search_namespace = 0;
+Namespace* current_namespace = 0;
+static Class* current_class = 0;
+static Function* current_function = 0;
+static Type* current_type = 0;
+static Field* current_field = 0;
+static ClassMember::Visbility current_visibility;
+
+class ParseError : public std::exception
+{
+public:
+    ParseError(const std::string&amp; message) throw()
+    {
+        std::ostringstream msg;
+        msg &lt;&lt; &quot;Parse error in '&quot; &lt;&lt; current_file
+            &lt;&lt; &quot;' line &quot; &lt;&lt; getCurrentLine() &lt;&lt; &quot;: &quot;
+            &lt;&lt; message;
+        this-&gt;message = msg.str();
+    }
+    virtual ~ParseError() throw()
+    {}
+    const char* what() const throw()
+    {
+        return message.c_str();
+    }
+
+private:
+    std::string message;
+};
+
+%}
+
+%token &lt;ival&gt; T_INT
+%token &lt;fval&gt; T_FLOAT
+%token &lt;str&gt;  T_STRING
+%token &lt;str&gt;  T_ID
+%token &lt;atomic_type&gt; T_ATOMIC_TYPE
+%token &lt;_namespace&gt; T_NAMESPACEREF
+%token T_CLASS
+%token T_STRUCT
+%token T_STATIC
+%token T_SUSPEND
+%token T_CUSTOM
+%token T_CONST
+%token T_UNSIGNED
+%token T_SIGNED
+%token T_VOID
+%token T_BOOL
+%token T_CHAR
+%token T_SHORT
+%token T_LONG
+%token T_DOUBLE
+%token T_PUBLIC
+%token T_PROTECTED
+%token T_PRIVATE
+%token T_NAMESPACE
+%token T_DDCOL &quot;::&quot;
+
+%type &lt;_class&gt; class_declaration
+%type &lt;function&gt; function_declaration
+%type &lt;function&gt; constructor_declaration;
+%type &lt;function&gt; destructor_declaration;
+%type &lt;field&gt; field_declaration;
+%type &lt;type&gt;   type
+%type &lt;atomic_type&gt; type_identifier
+
+%%
+
+input:
+        {
+            current_namespace = unit;
+        }
+    namespace_members
+;
+
+namespace_members: /* empty */
+    | namespace_members namespace_member
+;
+
+namespace_declaration:
+    T_NAMESPACE T_ID '{' 
+        {
+            Namespace* newNamespace = new Namespace();
+            newNamespace-&gt;name = $2;
+            free($2);
+            current_namespace-&gt;add_namespace(newNamespace);
+            current_namespace = newNamespace;
+        }
+    namespace_members '}'
+        {
+            current_namespace = current_namespace-&gt;parent;
+        }
+    | T_NAMESPACE T_NAMESPACEREF '{'
+        {
+            current_namespace = $2;
+        }
+    namespace_members '}'
+        {
+            current_namespace = current_namespace-&gt;parent;
+        }
+;
+
+namespace_member:
+    class_declaration
+        { current_namespace-&gt;add_type($1); }
+    | function_declaration
+        { current_namespace-&gt;functions.push_back($1); }
+    | namespace_declaration
+    | field_declaration
+        { current_namespace-&gt;fields.push_back($1); }
+;  
+
+class_declaration:
+    T_CLASS T_ID 
+        {
+            current_class = new Class();
+            current_class-&gt;name = $2;
+            free($2);
+            current_class-&gt;docu_comment = last_docucomment;
+            last_docucomment = &quot;&quot;;
+            current_visibility = ClassMember::PROTECTED;
+        }
+    superclass_list '{' class_body '}' ';'
+        {
+            $$ = current_class;
+        }
+;
+
+superclass_list:
+    /* empty */
+    | ':' superclasses
+;
+
+superclasses:
+      superclass
+    | superclasses ',' superclass
+;
+
+superclass:
+    superclass_visibility type_identifier
+        {
+            Class* superclass = dynamic_cast&lt;Class*&gt; ($2);
+            if(superclass == 0)
+                throw ParseError(&quot;SuperClass is not a Class type&quot;);
+            current_class-&gt;super_classes.push_back(superclass);
+            superclass-&gt;sub_classes.push_back(current_class);
+        }
+;
+
+superclass_visibility:
+    T_PUBLIC
+    | T_PROTECTED
+    | T_PRIVATE
+;
+
+class_body: /* empty */
+        | class_body class_body_element
+;
+
+class_body_element:
+        visibility_change
+        | constructor_declaration
+            { 
+                $1-&gt;visibility = current_visibility;
+                current_class-&gt;members.push_back($1);
+            }
+        | destructor_declaration
+            {
+                $1-&gt;visibility = current_visibility;
+                current_class-&gt;members.push_back($1);
+            }
+        | function_declaration
+            {
+                $1-&gt;visibility = current_visibility;
+                current_class-&gt;members.push_back($1);
+            }
+        | field_declaration
+            {
+                $1-&gt;visibility = current_visibility;
+                current_class-&gt;members.push_back($1);
+            }
+;
+
+visibility_change:
+    T_PUBLIC ':'
+        { current_visibility = ClassMember::PUBLIC; }
+    |   T_PROTECTED ':'
+        { current_visibility = ClassMember::PROTECTED; }
+    |   T_PRIVATE ':'
+        { current_visibility = ClassMember::PRIVATE; }
+;
+
+constructor_declaration:    
+    T_ID '('
+        {
+            current_function = new Function();
+            current_function-&gt;type = Function::CONSTRUCTOR;
+            current_function-&gt;docu_comment = last_docucomment;
+            last_docucomment = &quot;&quot;;
+            free($1);
+        }
+    parameter_list ')' ';'
+        {
+            $$ = current_function;
+        }
+;
+
+destructor_declaration:
+    '~' T_ID '(' ')' abstract_declaration ';'
+        {
+            current_function = new Function();
+            current_function-&gt;type = Function::DESTRUCTOR;
+            current_function-&gt;docu_comment = last_docucomment;
+            last_docucomment = &quot;&quot;;
+            free($2);
+            $$ = current_function;
+        }
+;
+
+field_declaration:
+    type T_ID 
+        {
+            current_field = new Field();
+            current_field-&gt;type = $1;
+            current_field-&gt;docu_comment = last_docucomment;
+            last_docucomment = &quot;&quot;;
+            current_field-&gt;name = $2;
+            free($2);
+        }
+    maybe_const_initialisation ';'
+        {
+            $$ = current_field;
+        }
+;
+
+maybe_const_initialisation:
+    /* empty */
+    | '=' T_INT
+        {
+            if(current_field-&gt;type-&gt;atomic_type == &amp;BasicType::FLOAT) {
+                current_field-&gt;const_float_value = (float) $2;
+            } else {
+                current_field-&gt;const_int_value = $2;
+            }
+            current_field-&gt;has_const_value = true;
+        }
+    | '=' T_FLOAT
+        {
+            current_field-&gt;const_float_value = $2;
+            current_field-&gt;has_const_value = true;
+        }
+    | '=' T_STRING
+        {
+            current_field-&gt;const_string_value = $2;
+            current_field-&gt;has_const_value = true;
+        }
+;          
+
+function_declaration:
+    type T_ID '(' 
+        {
+            current_function = new Function();
+            current_function-&gt;type = Function::FUNCTION;
+            current_function-&gt;return_type = *($1);
+            delete $1;
+            current_function-&gt;name = $2;
+            free($2);
+            current_function-&gt;docu_comment = last_docucomment;
+            last_docucomment = &quot;&quot;;
+        }                           
+    parameter_list ')' function_attributes abstract_declaration ';'
+        {
+            $$ = current_function;
+        }
+;
+
+function_attributes:
+    /* empty */
+    | T_CONST function_attributes
+    | T_CUSTOM function_attributes
+      {
+        current_function-&gt;custom = true;
+      }
+    | T_SUSPEND function_attributes
+      {
+        current_function-&gt;suspend = true;
+      }
+;
+
+abstract_declaration:
+    /* empty */
+    | '=' T_INT
+;
+
+parameter_list:
+    /* empty */
+    | parameters
+;
+
+parameters:
+    parameter
+    | parameters ',' parameter
+;
+
+parameter:
+    type
+        {
+            Parameter parameter;
+            parameter.type = *($1);
+            delete $1;
+            current_function-&gt;parameters.push_back(parameter);
+        }
+    | type T_ID
+        {
+            Parameter parameter;
+            parameter.type = *($1);
+            delete $1;
+            parameter.name = $2;
+            free($2);
+            current_function-&gt;parameters.push_back(parameter);
+        }
+;
+
+type:
+        {
+            current_type = new Type();
+        }
+    prefix_type_modifiers atomic_type postfix_type_modifiers 
+        {
+            $$ = current_type;
+        }
+;
+
+prefix_type_modifiers:
+    /* empty */
+    | prefix_type_modifiers prefix_type_modifier
+;
+
+prefix_type_modifier:
+    T_UNSIGNED
+        { current_type-&gt;_unsigned = true; }
+    | T_SIGNED
+        { current_type-&gt;_unsigned = false; }
+    | T_STATIC
+        { current_type-&gt;_static = true; }
+    | T_CONST
+        { current_type-&gt;_const = true; }
+;
+
+postfix_type_modifiers:
+    /* empty */
+    | postfix_type_modifiers postfix_type_modifier
+;
+
+postfix_type_modifier:
+    T_CONST
+        { current_type-&gt;_const = true; }
+    |   '*'
+        { current_type-&gt;pointer++; }
+    |   '&amp;'
+        { current_type-&gt;ref++; }
+;
+
+atomic_type:
+    T_VOID
+        { current_type-&gt;atomic_type = &amp;BasicType::VOID; }
+    | T_BOOL
+        { current_type-&gt;atomic_type = &amp;BasicType::BOOL; }
+    | T_CHAR
+        { current_type-&gt;atomic_type = &amp;BasicType::CHAR; }
+    | T_SHORT
+        { current_type-&gt;atomic_type = &amp;BasicType::SHORT; }
+    | T_INT
+        { current_type-&gt;atomic_type = &amp;BasicType::INT; }
+    | T_LONG
+        { current_type-&gt;atomic_type = &amp;BasicType::LONG; }
+    | T_FLOAT
+        { current_type-&gt;atomic_type = &amp;BasicType::FLOAT; }
+    | T_DOUBLE
+        { current_type-&gt;atomic_type = &amp;BasicType::DOUBLE; }
+    | type_identifier
+        { current_type-&gt;atomic_type = $1; }
+;
+
+type_identifier:
+    T_ATOMIC_TYPE
+        {
+            $$ = $1;
+        }
+    | namespace_refs &quot;::&quot; T_ATOMIC_TYPE
+        {
+            $$ = $3;
+            search_namespace = 0;
+            search_down = true;
+        }
+;
+
+namespace_refs:
+    T_NAMESPACEREF
+        {
+            search_namespace = $1;
+            search_down = false;
+        }
+    | namespace_refs &quot;::&quot; T_NAMESPACEREF
+        {
+            search_namespace = $3;
+        }
+;
+
+%%
+
+void yyerror(const char* error)
+{
+    throw ParseError(error);
+}
+

Added: tags/windstille-0.3.0/tools/miniswig/tree.cpp
===================================================================
--- tags/windstille-0.3.0/tools/miniswig/tree.cpp	2009-02-05 20:06:07 UTC (rev 2411)
+++ tags/windstille-0.3.0/tools/miniswig/tree.cpp	2009-02-05 20:09:13 UTC (rev 2412)
@@ -0,0 +1,15 @@
+#include &lt;config.h&gt;
+#include &quot;tree.hpp&quot;
+
+BasicType BasicType::VOID(&quot;void&quot;);
+BasicType BasicType::BOOL(&quot;bool&quot;);
+BasicType BasicType::CHAR(&quot;char&quot;);
+BasicType BasicType::SHORT(&quot;short&quot;);
+BasicType BasicType::INT(&quot;int&quot;);
+BasicType BasicType::LONG(&quot;long&quot;);
+BasicType BasicType::FLOAT(&quot;float&quot;);
+BasicType BasicType::DOUBLE(&quot;double&quot;);
+
+StringType* StringType::_instance = NULL;
+HSQUIRRELVMType* HSQUIRRELVMType::_instance = NULL;
+SQIntegerType* SQIntegerType::_instance = NULL;


Property changes on: tags/windstille-0.3.0/tools/miniswig/tree.cpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Added: tags/windstille-0.3.0/tools/miniswig/tree.hpp
===================================================================
--- tags/windstille-0.3.0/tools/miniswig/tree.hpp	2009-02-05 20:06:07 UTC (rev 2411)
+++ tags/windstille-0.3.0/tools/miniswig/tree.hpp	2009-02-05 20:09:13 UTC (rev 2412)
@@ -0,0 +1,311 @@
+#ifndef __TREE_H__
+#define __TREE_H__
+
+#include &lt;vector&gt;
+#include &lt;string&gt;
+#include &lt;iostream&gt;
+#include &lt;sstream&gt;
+#include &lt;stdexcept&gt;
+#include &lt;assert.h&gt;
+
+class Namespace;
+
+class AtomicType {
+public:
+    AtomicType()
+        : parent(0)
+    { }
+    virtual ~AtomicType()
+    { }
+
+    virtual void write_c(std::ostream&amp; out)
+    {
+        out &lt;&lt; name;
+    }
+
+    std::string name;
+    Namespace* parent;
+};
+
+class BasicType : public AtomicType {
+public:
+    static BasicType VOID;
+    static BasicType BOOL;
+    static BasicType CHAR;
+    static BasicType SHORT;
+    static BasicType INT;
+    static BasicType LONG;
+    static BasicType FLOAT;
+    static BasicType DOUBLE;
+
+private:
+    BasicType(const std::string&amp; name)
+    {
+        this-&gt;name = name;
+    }
+};
+
+class Type {
+public:
+    Type()
+        : atomic_type(0), _unsigned(false), _const(false), _static(false),
+        pointer(0), ref(0)
+    { }
+
+    void write_c_type(std::ostream&amp; out)
+    {
+        if(_static)
+            out &lt;&lt; &quot;static &quot;;
+        if(_const)
+            out &lt;&lt; &quot;const &quot;;
+        atomic_type-&gt;write_c(out);
+        for(int i = 0; i &lt; pointer; ++i)
+            out &lt;&lt; &quot;*&quot;;
+        for(int i = 0; i &lt; ref; ++i)
+            out &lt;&lt; &quot;&amp;&quot;;
+    }
+
+    bool is_void() const
+    {
+        if(atomic_type == 0)
+            return true;
+        if(atomic_type == &amp;BasicType::VOID &amp;&amp; pointer == 0)
+            return true;
+        return false;
+    }
+
+    AtomicType* atomic_type;
+    bool _unsigned;
+    bool _const;
+    bool _static;
+    // number of '*' in the type declaration...
+    int pointer;
+    // number of '&amp;' in the type declaration...
+    int ref;
+};
+
+class SQIntegerType : public AtomicType {
+public:
+    SQIntegerType()
+    {
+        this-&gt;name = &quot;SQInteger&quot;;
+        assert(_instance == 0);
+        _instance = this;
+    }
+    virtual ~SQIntegerType()
+    {
+        assert(_instance == this);
+        _instance = NULL;
+    }
+
+    static SQIntegerType* instance()
+    {
+        return _instance;
+    }
+private:
+    static SQIntegerType* _instance;
+};
+
+class HSQUIRRELVMType : public AtomicType {
+public:
+    HSQUIRRELVMType()
+    {
+        this-&gt;name = &quot;HSQUIRRELVM&quot;;
+        assert(_instance == 0);
+        _instance = this;
+    }
+    virtual ~HSQUIRRELVMType()
+    {
+        assert(_instance == this);
+        _instance = NULL;
+    }
+
+    static HSQUIRRELVMType* instance()
+    {
+        return _instance;
+    }
+private:
+    static HSQUIRRELVMType* _instance;
+};
+
+class StringType : public AtomicType {
+public:
+    StringType()
+    {
+        this-&gt;name = &quot;string&quot;;
+        assert(_instance == 0);
+        _instance = this;
+    }
+    virtual ~StringType()
+    {
+        assert(_instance == this);
+        _instance = 0;
+    }
+
+    static StringType* instance()
+    {
+        return _instance;
+    }
+
+    virtual void write_c(std::ostream&amp; out)
+    {
+        out &lt;&lt; &quot;std::string&quot;;
+    }
+
+private:
+    static StringType* _instance;
+};
+
+class Parameter {
+public:
+    std::string name;
+    Type type;
+};
+
+class ClassMember {
+public:
+    virtual ~ClassMember()
+    { }
+
+    enum Visbility {
+        PUBLIC,
+        PROTECTED,
+        PRIVATE
+    };
+    Visbility visibility;
+};
+
+class Function : public ClassMember {
+public:
+    Function() {
+      type = FUNCTION;
+      suspend = false;
+      custom = false;
+    }
+
+    enum FuncType {
+        FUNCTION,
+        CONSTRUCTOR,
+        DESTRUCTOR
+    };
+    FuncType type;
+    /// function should suspend squirrel VM after execution
+    bool suspend;
+    /// a custom wrapper (just pass along HSQUIRRELVM)
+    bool custom;
+    std::string docu_comment;
+    std::string name;
+    Type return_type;
+    std::vector&lt;Parameter&gt; parameters;
+};
+
+class Field : public ClassMember {
+public:
+    Field()
+    {
+        has_const_value = false;
+    }
+
+    Type* type;
+    std::string docu_comment;
+    std::string name;
+    bool has_const_value;
+
+    union {
+        float const_float_value;
+        int const_int_value;
+    };
+    std::string const_string_value;
+};
+
+class Class : public AtomicType {
+public:
+    ~Class() {
+        for(std::vector&lt;ClassMember*&gt;::iterator i = members.begin();
+                i != members.end(); ++i)
+            delete *i;
+    }
+
+    std::vector&lt;ClassMember*&gt; members;
+    std::vector&lt;Class*&gt; super_classes;
+    std::vector&lt;Class*&gt; sub_classes;
+    std::string docu_comment;
+};
+
+class Namespace {
+public:
+    Namespace() {
+        parent = 0;
+    }
+    virtual ~Namespace() {
+        for(std::vector&lt;Function*&gt;::iterator i = functions.begin();
+                i != functions.end(); ++i)
+            delete *i;
+        for(std::vector&lt;AtomicType*&gt;::iterator i = types.begin();
+                i != types.end(); ++i)
+            delete *i;
+        for(std::vector&lt;Namespace*&gt;::iterator i = namespaces.begin();
+                i != namespaces.end(); ++i)
+            delete *i;
+    }
+    void add_type(AtomicType* type)
+    {
+        types.push_back(type);
+        type-&gt;parent = this;
+    }
+    void add_namespace(Namespace* ns)
+    {
+        namespaces.push_back(ns);
+        ns-&gt;parent = this;
+    }
+    AtomicType* _findType(const std::string&amp; name, bool godown = false) {
+        for(std::vector&lt;AtomicType*&gt;::iterator i = types.begin();
+                i != types.end(); ++i) {
+            AtomicType* type = *i;
+            if(type-&gt;name == name)
+                return type;
+        }
+        if(godown &amp;&amp; parent)
+            return parent-&gt;_findType(name, true);
+
+        return 0;
+    }
+
+    Namespace* _findNamespace(const std::string&amp; name, bool godown = false) {
+        for(std::vector&lt;Namespace*&gt;::iterator i = namespaces.begin();
+                i != namespaces.end(); ++i) {
+            Namespace* ns = *i;
+            if(ns-&gt;name == name)
+                return ns;
+        }
+        if(godown &amp;&amp; parent)
+            return parent-&gt;_findNamespace(name, true);
+
+        return 0;
+    }
+
+    Namespace* findNamespace(const std::string&amp; name, bool godown = false) {
+        Namespace* ret = _findNamespace(name, godown);
+        if(!ret) {
+            std::ostringstream msg;
+            msg &lt;&lt; &quot;Couldn't find namespace '&quot; &lt;&lt; name &lt;&lt; &quot;'.&quot;;
+            throw std::runtime_error(msg.str());
+        }
+
+        return ret;
+    }
+
+    std::vector&lt;Function*&gt; functions;
+    std::vector&lt;Field*&gt; fields;
+    std::vector&lt;AtomicType*&gt; types;
+    std::vector&lt;Namespace*&gt; namespaces;
+
+    Namespace* parent;
+    std::string name;
+};
+
+class CompilationUnit : public Namespace {
+public:
+};
+
+#endif


Property changes on: tags/windstille-0.3.0/tools/miniswig/tree.hpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Added: tags/windstille-0.3.0/tools/miniswig/xmlwriter.cpp
===================================================================
--- tags/windstille-0.3.0/tools/miniswig/xmlwriter.cpp	2009-02-05 20:06:07 UTC (rev 2411)
+++ tags/windstille-0.3.0/tools/miniswig/xmlwriter.cpp	2009-02-05 20:09:13 UTC (rev 2412)
@@ -0,0 +1,77 @@
+#include &lt;config.h&gt;
+
+#include &lt;stdexcept&gt;
+#include &lt;sstream&gt;
+#include &quot;xmlwriter.hpp&quot;
+
+XmlWriter::XmlWriter(std::ostream&amp; outstream)
+    : out(outstream), indent(0)
+{
+}
+
+XmlWriter::~XmlWriter()
+{
+    if(sections.size() &gt; 0) {
+        std::cerr &lt;&lt; &quot;WARNING: NOT CLOSED: &quot;;
+        for(std::vector&lt;std::string&gt;::iterator i = sections.begin();
+                i != sections.end(); ++i)
+            std::cerr &lt;&lt; *i &lt;&lt; &quot; &quot;;
+        std::cerr &lt;&lt; &quot;\n&quot;;
+    }
+
+    closeTag();
+}
+
+void XmlWriter::openTag(const char* name)
+{
+    newLine();
+    out &lt;&lt; &quot;&lt;&quot; &lt;&lt; name;
+    closetag = &quot;&gt;&quot;;
+    indent++;
+
+    sections.push_back(name);
+}
+
+void XmlWriter::closeTag(const char* name)
+{
+    if(sections.size() == 0)
+	throw std::runtime_error(&quot;got closeSection without prior openSection.&quot;);
+
+    const std::string&amp; lastsection = sections.back();
+    if (lastsection != name) {
+        std::ostringstream msg;
+        msg &lt;&lt; &quot;mismtach in open/closeSection. Expected '&quot;
+            &lt;&lt; lastsection &lt;&lt; &quot;' got '&quot; &lt;&lt; name &lt;&lt; &quot;'&quot;;
+        throw std::runtime_error(msg.str());
+    }
+    sections.pop_back();
+
+    indent--;
+    newLine();
+    // XXX: We should check for consistency here
+    out &lt;&lt; &quot;&lt;/&quot; &lt;&lt; name;
+    closetag = &quot;&gt;&quot; ;
+}
+
+void XmlWriter::writeTag(const char* name)
+{
+    newLine();
+    out &lt;&lt; &quot;&lt;&quot; &lt;&lt; name;
+    closetag = &quot;/&gt;&quot;;
+    lasttag = name;
+}
+
+void XmlWriter::newLine()
+{
+    if(closetag != &quot;&quot;) {
+        closeTag();
+        for (int i=0;i&lt;indent;i++)
+            out &lt;&lt; &quot;\t&quot;;
+    }
+}
+
+void XmlWriter::closeTag()
+{
+    if (closetag != &quot;&quot;)
+	out &lt;&lt; closetag &lt;&lt; &quot;\n&quot;;
+}


Property changes on: tags/windstille-0.3.0/tools/miniswig/xmlwriter.cpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Added: tags/windstille-0.3.0/tools/miniswig/xmlwriter.hpp
===================================================================
--- tags/windstille-0.3.0/tools/miniswig/xmlwriter.hpp	2009-02-05 20:06:07 UTC (rev 2411)
+++ tags/windstille-0.3.0/tools/miniswig/xmlwriter.hpp	2009-02-05 20:09:13 UTC (rev 2412)
@@ -0,0 +1,78 @@
+#ifndef __XMLWRITER_H__
+#define __XMLWRITER_H__
+
+#include &lt;iostream&gt;
+#include &lt;vector&gt;
+#include &lt;string&gt;
+
+/** This class is a class which helps printing formated xml output.
+ * Example:
+ *  This sequence:
+ *   xml.openTag(&quot;world&quot;);
+ *   xml.writeAttribute(&quot;name&quot;, &quot;foo&quot;);
+ *   xml.writeTag(&quot;bar&quot;);
+ *   xml.writeTag(&quot;baz&quot;);
+ *   xml.writeAttribute(&quot;name&quot;, &quot;boo&quot;);
+ *   xml.writeAttribute(&quot;style&quot;, &quot;old&quot;);
+ *   xml.write(&quot;text&quot;);
+ *   xml.closeTag(&quot;world&quot;);
+ *  results in this output:
+ *   &lt;world name=&quot;foo&quot;&gt;
+ *     &lt;bar/&gt;
+ *     &lt;baz name=&quot;boo&quot; style=&quot;old&quot;&gt;text&lt;/baz&gt;
+ *   &lt;/world&gt;
+ */
+class XmlWriter {
+public:
+    XmlWriter(std::ostream&amp; out);
+    ~XmlWriter();
+
+    /** Start a xml tag which contains subtags */
+    void openTag(const char* name);
+    /** Closes an xml tag with subtags */
+    void closeTag(const char* name);
+
+    void writeTag(const char* name);
+
+    template &lt;class T&gt;
+      void comment(const T&amp; outp)
+      {   // This routine writes just about anything as an XML comment.
+	newLine();
+	out &lt;&lt; &quot;&lt;!-- &quot; &lt;&lt; outp ;
+	closetag = &quot; --&gt;&quot;;
+      }
+
+
+    template&lt;class T&gt;
+    void write(const T&amp; text)
+    {
+        if (closetag[0]=='&gt;') {
+            out &lt;&lt; &quot;&gt;&quot;;
+            closetag = &quot;&quot;;
+        } else if (closetag[0]=='/') {
+      	    out &lt;&lt; &quot;&gt;&quot;; // eventually we should place a \n here
+	    closetag = &quot;&lt;/&quot;;
+	    closetag += lasttag;
+	    closetag += &quot;&gt;&quot;;
+	}
+	out &lt;&lt; text;
+    }
+
+    template&lt;class T&gt;
+    void writeAttribute(const char* name, T value)
+    {
+	out &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot;=\&quot;&quot; &lt;&lt; value &lt;&lt; &quot;\&quot;&quot;;
+    }
+
+private:
+    void newLine();
+    void closeTag();
+
+    std::ostream&amp; out;
+    int indent;
+    std::string closetag;
+    std::string lasttag;
+    std::vector&lt;std::string&gt; sections;
+};
+
+#endif


Property changes on: tags/windstille-0.3.0/tools/miniswig/xmlwriter.hpp
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001408.html">[Windstille-commit] r2411 - tags
</A></li>
	<LI>Next message: <A HREF="001410.html">[Windstille-commit] r2413 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1409">[ date ]</a>
              <a href="thread.html#1409">[ thread ]</a>
              <a href="subject.html#1409">[ subject ]</a>
              <a href="author.html#1409">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/windstille-commit">More information about the Windstille-commit
mailing list</a><br>
</body></html>
