From grumbel at mail.berlios.de  Sun Aug 29 02:44:35 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Sun, 29 Aug 2010 02:44:35 +0200
Subject: [Windstille-commit] r3338 - in trunk/windstille/extra: . slideshow
Message-ID: <20100829004435.C5623480F60@sheep.berlios.de>

Author: grumbel
Date: 2010-08-29 02:44:35 +0200 (Sun, 29 Aug 2010)
New Revision: 3338

Added:
   trunk/windstille/extra/slideshow/
   trunk/windstille/extra/slideshow/script.slideshow
   trunk/windstille/extra/slideshow/slide_builder.cpp
   trunk/windstille/extra/slideshow/slide_builder.hpp
   trunk/windstille/extra/slideshow/slide_object.cpp
   trunk/windstille/extra/slideshow/slide_object.hpp
   trunk/windstille/extra/slideshow/slide_path.cpp
   trunk/windstille/extra/slideshow/slide_path.hpp
   trunk/windstille/extra/slideshow/slide_show.cpp
   trunk/windstille/extra/slideshow/slide_show.hpp
   trunk/windstille/extra/slideshow/slideshow.cpp
Log:
Some work on a little slideshow app

Added: trunk/windstille/extra/slideshow/script.slideshow
===================================================================
--- trunk/windstille/extra/slideshow/script.slideshow	                        (rev 0)
+++ trunk/windstille/extra/slideshow/script.slideshow	2010-08-29 00:44:35 UTC (rev 3338)
@@ -0,0 +1,34 @@
+# This is a comment
+
+fade 1.0
+
+image landscape.jpg
+  zoom 0.1
+  pos center center
+
+  duration 20
+
+  zoom 5.0
+  pos 320 240
+
+  duration 2
+
+  zoom 0.75
+  pos 320 240
+end
+
+fade 2.0
+
+image two.jpg
+  zoom 1.0
+  pos 320 200
+
+  duration 5
+
+  zoom 1.2
+  pos 320 240
+end
+
+fade 1.0
+
+# EOF #

Added: trunk/windstille/extra/slideshow/slide_builder.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.cpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/slide_builder.cpp	2010-08-29 00:44:35 UTC (rev 3338)
@@ -0,0 +1,364 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "slideshow/slide_builder.hpp"
+
+#include <boost/tokenizer.hpp>
+#include <boost/lexical_cast.hpp>
+#include <string.h>
+#include <errno.h>
+#include <fstream>
+#include <iostream>
+#include <stdexcept>
+#include <sstream>
+
+#include "slideshow/slide_show.hpp"
+
+SlideBuilder::SlideBuilder(SlideShow& slideshow, const Sizef& screen_size) :
+  m_slideshow(slideshow),
+  m_screen_size(screen_size),
+  m_context(),
+  m_line(),
+  m_fade(0.0f),
+  m_state(kGlobal),
+  m_time(0.0f),
+  m_image(),
+  m_last_image(),
+  m_node_has_pos(false),
+  m_node_has_zoom(false),
+  m_path_node()
+{
+}
+
+void
+SlideBuilder::load_from_file(const std::string& filename)
+{
+  std::ifstream in(filename.c_str());
+  if (!in)
+  {
+    throw std::runtime_error(strerror(errno));
+  }
+  else
+  {
+    m_context = filename;
+    m_line = 0;
+    load_from_stream(in);
+  }
+}
+
+std::string
+strip_comment(const std::string& line)
+{
+  std::string::size_type p = line.find('#');
+  return line.substr(0, p);
+}
+
+void
+SlideBuilder::error(const std::string& str)
+{
+  std::ostringstream out;
+  out << m_context << ':' << m_line << ": error: " << str;
+  throw std::runtime_error(out.str());
+}
+
+void
+SlideBuilder::load_from_stream(std::istream& stream)
+{
+  try 
+  {
+    std::string line;
+    while(std::getline(stream, line))
+    {
+      m_line += 1;
+      line = strip_comment(line);
+
+      boost::char_separator<char> sep(" \t");
+      boost::tokenizer<boost::char_separator<char> > tokens(line, sep);
+      std::vector<std::string> args(tokens.begin(), tokens.end());
+
+      if (args.empty())
+      {
+        // empty line, skip it
+      }
+      else
+      {
+        if (false)
+        { // debug output
+          for(std::vector<std::string>::iterator i = args.begin(); i != args.end(); ++i)
+          {
+            std::cout << "(" << *i << ") ";
+          }
+          std::cout << std::endl;
+        }
+
+        if (args[0] == "image")
+        {
+          handle_image(args);
+        }
+        else if (args[0] == "zoom")
+        {
+          handle_zoom(args);
+        }
+        else if (args[0] == "pos")
+        {
+          handle_pos(args);
+        }
+        else if (args[0] == "duration")
+        {
+          handle_duration(args);
+        }
+        else if (args[0] == "fade")
+        {
+          handle_fade(args);
+        }
+        else if (args[0] == "end")
+        {
+          handle_end(args);
+        }
+        else
+        {
+          error("unknown tag '" + args[0] + "'");
+        }
+      }
+    }
+
+    if (m_state != kGlobal)
+    {
+      error("not in global scope at end of file");
+    }
+  }
+  catch(std::exception& err)
+  {
+    error(err.what());
+  }
+}
+
+void
+SlideBuilder::handle_image(const std::vector<std::string>& args)
+{
+  if (m_state != kGlobal)
+  {
+    error("image must be in global scope");
+  }
+  else if (args.size() != 2)
+  {
+    error("image requires one argument");
+  }
+  else
+  {
+    m_state = kImage;
+    std::cout << ";; time = " << m_time << std::endl;
+    std::cout << "(image \"" << args[1] << "\")" << std::endl;
+    m_image = SlideObjectPtr(new SlideObject(Pathname(args[1], Pathname::kSysPath)));
+
+    if (m_slideshow.size() != 0)
+      m_image->set_begin(m_time - m_fade);
+
+    m_image->set_fade_in(m_fade);
+    m_fade = 0.0f;
+  }
+}
+
+void
+SlideBuilder::handle_pos(const std::vector<std::string>& args)
+{
+  if (m_state != kImage)
+  {
+    error("pos must be in image scope");
+  }
+  else if (args.size() != 3)
+  {
+    error("pos requires two arguments");
+  }
+  else if (m_node_has_pos)
+  {
+    error("pos already given");
+  }
+  else
+  {
+    m_node_has_pos = true;
+
+    if (args[1] == "left")
+    {
+      m_path_node.pos.x = m_screen_size.width/2.0f;
+    }
+    else if (args[1] == "right")
+    {
+      m_path_node.pos.x = m_image->get_width() - m_screen_size.width/2.0f;
+    }
+    else if (args[1] == "center")
+    {
+      m_path_node.pos.x = m_screen_size.width/2.0f;
+    }
+    else
+    {
+      m_path_node.pos.x = boost::lexical_cast<float>(args[1]);
+    }
+
+    if (args[2] == "top")
+    {
+      m_path_node.pos.y = 0.0f;
+    }
+    else if (args[2] == "bottom")
+    {
+      m_path_node.pos.y = m_image->get_height() - m_screen_size.height/2.0f;
+    }
+    else if (args[2] == "center")
+    {
+      m_path_node.pos.y = m_screen_size.height/2.0f;
+    }
+    else
+    {
+      m_path_node.pos.y = boost::lexical_cast<float>(args[2]);
+    }
+
+    std::cout << "  (pos " << m_path_node.pos.x << " " << m_path_node.pos.y << ")" << std::endl;
+  }
+}
+
+void
+SlideBuilder::handle_zoom(const std::vector<std::string>& args)
+{
+  if (m_state != kImage)
+  {
+    error("zoom must be in image scope");
+  }
+  else if (args.size() != 2)
+  {
+    error("zoom requires one argument");
+  }
+  else if (m_node_has_zoom)
+  {
+    error("zoom already given");
+  }
+  else
+  {
+    if (args[1] == "fit")
+    {
+      m_path_node.zoom = std::min(m_screen_size.width / m_image->get_width(),
+                                  m_screen_size.height / m_image->get_height());
+    }
+    else if (args[1] == "width")
+    {
+      m_path_node.zoom = m_screen_size.width / m_image->get_width();
+    }
+    else if (args[1] == "height")
+    {
+      m_path_node.zoom = m_screen_size.height / m_image->get_height();
+    }
+    else
+    {
+      m_path_node.zoom = boost::lexical_cast<float>(args[1]);
+      std::cout << "  (zoom " << m_path_node.zoom << ")" << std::endl;
+    }
+
+    m_node_has_zoom = true;
+  }
+}
+ 
+void
+SlideBuilder::handle_duration(const std::vector<std::string>& args)
+{
+  if (m_state != kImage)
+  {
+    error("duration must be in image scope");
+  }
+  else if (args.size() != 2)
+  {
+    error("duration requires one argument");
+  }
+  else
+  {
+    float duration = boost::lexical_cast<float>(args[1]);
+
+    assert(m_image);
+    add_node();
+    m_image->get_path().add_edge(duration);
+    std::cout << "  (duration " << duration << ")" << std::endl;
+  }
+}
+
+void
+SlideBuilder::add_node()
+{
+  if (!m_node_has_pos)
+  {
+    error("getting default pos not implemented");
+  }
+
+  if (!m_node_has_zoom)
+  {
+    error("getting default zoom not implemented");
+  }
+
+  m_image->get_path().add_node(m_path_node.pos, m_path_node.zoom);
+
+  m_node_has_zoom = false;
+  m_node_has_pos  = false;
+}
+
+void
+SlideBuilder::handle_fade(const std::vector<std::string>& args)
+{
+  if (m_state != kGlobal)
+  {
+    error("fade must be in global scope");
+  }
+  else if (args.size() != 2)
+  {
+    error("fade requires one argument");
+  }
+  else
+  {
+    m_fade = boost::lexical_cast<float>(args[1]);
+    std::cout << "(fade " << m_fade << ")" << std::endl;
+
+    if (m_last_image)
+    {
+      m_last_image->set_fade_out(m_fade);
+    }
+  }
+}
+
+void
+SlideBuilder::handle_end(const std::vector<std::string>& args)
+{
+  if (m_state != kImage)
+  {
+    error("end must be in image scope");
+  }
+  else if (args.size() != 1)
+  {
+    error("end requires no argument");
+  }
+  else
+  {
+    m_state = kGlobal;
+    
+    assert(m_image);
+    add_node();
+    m_image->get_path().finish();
+
+    m_time += m_image->length();
+    m_slideshow.add(m_image);
+    m_last_image = m_image;
+    std::cout << "(end)" << std::endl;
+  }
+}
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/slide_builder.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/slide_builder.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.hpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/slide_builder.hpp	2010-08-29 00:44:35 UTC (rev 3338)
@@ -0,0 +1,81 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_WINDSTILLE_EXTRA_SLIDESHOW_SLIDE_BUILDER_HPP
+#define HEADER_WINDSTILLE_EXTRA_SLIDESHOW_SLIDE_BUILDER_HPP
+
+#include <string>
+#include <vector>
+
+#include "math/size.hpp"
+#include "slideshow/slide_object.hpp"
+#include "slideshow/slide_path.hpp"
+
+class SlideShow;
+
+class SlideBuilder
+{
+private:
+  SlideShow& m_slideshow;
+  Sizef m_screen_size;
+
+  std::string m_context;
+  int m_line;
+
+  enum State {
+    kGlobal,
+    kImage
+  };
+
+  float m_fade;
+
+  State m_state;
+  float m_time;
+  SlideObjectPtr m_image;
+  SlideObjectPtr m_last_image;
+
+  bool m_node_has_pos;
+  bool m_node_has_zoom;
+  SlidePathNode m_path_node;
+
+public:
+  SlideBuilder(SlideShow& slideshow, const Sizef& screen_size);
+
+  void load_from_file(const std::string& filename);
+  void load_from_stream(std::istream& stream);
+
+private:
+  void error(const std::string& str);
+
+  void handle_image(const std::vector<std::string>& args);
+  void handle_pos(const std::vector<std::string>& args);
+  void handle_zoom(const std::vector<std::string>& args);
+  void handle_duration(const std::vector<std::string>& args);
+  void handle_fade(const std::vector<std::string>& args);
+  void handle_end(const std::vector<std::string>& args);
+
+  void add_node();
+
+private:
+  SlideBuilder(const SlideBuilder&);
+  SlideBuilder& operator=(const SlideBuilder&);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/slide_builder.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/slide_object.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_object.cpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/slide_object.cpp	2010-08-29 00:44:35 UTC (rev 3338)
@@ -0,0 +1,107 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "slide_object.hpp"
+
+#include <math.h>
+
+#include "display/surface_drawing_parameters.hpp"
+
+SlideObject::SlideObject(const Pathname& filename) :
+  m_surface(filename),
+  m_begin(0.0f),
+  m_path(),
+  m_fade_in_time(0.0f),
+  m_fade_out_time(0.0f)
+{  
+}
+
+void
+SlideObject::set_fade_in(float f)
+{
+  m_fade_in_time = f;
+}
+
+void
+SlideObject::set_fade_out(float f)
+{
+  m_fade_out_time = f;
+}
+
+void
+SlideObject::draw(float relative_time)
+{
+  SlidePathNode node = m_path.get(relative_time);
+
+  // FIXME: hardcoded fade hack
+  Color color(1.0f, 1.0f, 1.0f, 1.0f);
+  if (relative_time < m_fade_in_time)
+  {
+    color.a = relative_time / m_fade_in_time;
+  }
+  else if (relative_time + m_fade_out_time > length())
+  {
+    color.a = (length() - relative_time) / m_fade_out_time;
+  }
+
+  Vector2f pos(node.pos);
+
+  // zoom needs to grow exponentially to be linear
+  float scale = node.zoom;
+
+  pos.x -= m_surface.get_width() /2.0f * scale;
+  pos.y -= m_surface.get_height()/2.0f * scale;
+
+  m_surface.draw(SurfaceDrawingParameters()
+                 .set_color(color)
+                 .set_blend_func(GL_SRC_ALPHA, GL_ONE)
+                 .set_pos(pos)
+                 .set_scale(scale));
+}
+
+float
+SlideObject::length() const
+{
+  return m_path.length();
+}
+
+float
+SlideObject::begin() const
+{
+  return m_begin;
+}
+
+void
+SlideObject::set_begin(float beg)
+{
+  m_begin = beg;
+}
+
+float
+SlideObject::get_width() const
+{
+  return m_surface.get_width();
+}
+
+float
+SlideObject::get_height() const
+{
+  return m_surface.get_height();
+}
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/slide_object.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/slide_object.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_object.hpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/slide_object.hpp	2010-08-29 00:44:35 UTC (rev 3338)
@@ -0,0 +1,63 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_WINDSTILLE_EXTRA_SLIDESHOW_SLIDE_OBJECT_HPP
+#define HEADER_WINDSTILLE_EXTRA_SLIDESHOW_SLIDE_OBJECT_HPP
+
+#include <boost/shared_ptr.hpp>
+
+#include "display/surface.hpp"
+
+#include "slideshow/slide_path.hpp"
+
+class SlideObject
+{
+private:
+  Surface m_surface;
+  float m_begin;
+  SlidePath m_path;
+
+  float m_fade_in_time;
+  float m_fade_out_time;
+
+public:
+  SlideObject(const Pathname& filename);
+  
+  void draw(float relative_time);
+
+  float length() const;
+  float begin() const;
+  void set_begin(float beg);
+  void set_fade_in(float f);
+  void set_fade_out(float f);
+
+  SlidePath& get_path() { return m_path; }
+
+  float get_width() const;
+  float get_height() const;
+
+private:
+  SlideObject(const SlideObject&);
+  SlideObject& operator=(const SlideObject&);
+};
+
+typedef boost::shared_ptr<SlideObject> SlideObjectPtr;
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/slide_object.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/slide_path.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_path.cpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/slide_path.cpp	2010-08-29 00:44:35 UTC (rev 3338)
@@ -0,0 +1,123 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "slide_path.hpp"
+
+#include <iostream>
+#include <assert.h>
+#include <math.h>
+#include <stdexcept>
+
+SlidePath::SlidePath() :
+  m_nodes(),
+  m_edges()
+{
+}
+
+void
+SlidePath::add_node(const Vector2f& pos, float zoom)
+{
+  SlidePathNode node;
+  node.pos  = pos;
+  node.zoom = zoom;
+  m_nodes.push_back(node);
+}
+
+void
+SlidePath::add_edge(float duration)
+{
+  SlidePathEdge edge;
+  edge.duration = duration;
+  m_edges.push_back(edge);
+}
+
+SlidePathNode
+SlidePath::get(float relative_time)
+{
+  assert(m_nodes.size() == m_edges.size()+1);
+
+  if (m_nodes.empty())
+  {
+    return SlidePathNode();
+  }
+  else
+  {
+    int idx = -1;
+    float passed = 0.0f;
+    for(size_t i = 0; i < m_edges.size(); ++i)
+    {
+      passed += m_edges[i].duration;
+      if (passed > relative_time)
+      {
+        idx = i;
+        break;
+      }
+    }
+
+    if (idx == -1)
+    {
+      std::cout << "XXX BUMMER: not implemented" << std::endl;
+      SlidePathNode node;
+      return node;
+    }
+    else
+    {
+      SlidePathNode lhs = m_nodes[idx];
+      SlidePathNode rhs = m_nodes[idx+1];
+      
+      float t = relative_time - (passed - m_edges[idx].duration);
+
+      float factor = t / m_edges[idx].duration;
+
+      SlidePathNode node;
+      node.pos  = lhs.pos  * (1.0f - factor) + rhs.pos  * factor;
+      node.zoom = lhs.zoom * (1.0f - factor) + rhs.zoom * factor;
+      return node;
+    }
+  }
+}
+
+void
+SlidePath::finish()
+{
+  if (m_nodes.empty())
+  {
+    throw std::runtime_error("nodes empty");
+  }
+  else if (m_edges.empty())
+  {
+    throw std::runtime_error("edges empty");
+  }
+  else if (m_nodes.size() == m_edges.size())
+  {
+    m_nodes.push_back(m_nodes.back());
+  }
+}
+
+float
+SlidePath::length() const
+{
+  float total = 0.0f;
+  for(Edges::const_iterator i = m_edges.begin(); i != m_edges.end(); ++i)
+  {
+    total += i->duration;
+  }
+  return total;
+}
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/slide_path.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/slide_path.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_path.hpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/slide_path.hpp	2010-08-29 00:44:35 UTC (rev 3338)
@@ -0,0 +1,71 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_WINDSTILLE_EXTRA_SLIDESHOW_SLIDE_PATH_HPP
+#define HEADER_WINDSTILLE_EXTRA_SLIDESHOW_SLIDE_PATH_HPP
+
+#include <vector>
+
+#include "math/vector2f.hpp"
+
+class SlidePathNode
+{
+public:
+  Vector2f  pos;
+  float     zoom;
+
+  SlidePathNode() :
+    pos(0.0f, 0.0f),
+    zoom(1.0f)
+  {}
+};
+
+class SlidePathEdge
+{
+public:
+  float duration;
+};
+
+class SlidePath
+{
+private:
+  typedef std::vector<SlidePathNode> Nodes;
+  typedef std::vector<SlidePathEdge> Edges; 
+
+  Nodes m_nodes;
+  Edges m_edges;
+  
+public:
+  SlidePath();
+
+  SlidePathNode get(float relative_time);
+
+  void add_node(const Vector2f& pos, float zoom);
+  void add_edge(float duration);
+  void finish();
+
+  float length() const;
+
+private:
+  SlidePath(const SlidePath&);
+  SlidePath& operator=(const SlidePath&);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/slide_path.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/slide_show.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_show.cpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/slide_show.cpp	2010-08-29 00:44:35 UTC (rev 3338)
@@ -0,0 +1,73 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "slideshow/slide_show.hpp"
+
+SlideShow::SlideShow() :
+  m_objects(),
+  m_time(0.0f),
+  m_length(0.0f)
+{
+}
+
+void
+SlideShow::update(float delta)
+{
+  m_time += delta;
+}
+
+void
+SlideShow::draw()
+{
+  for(std::vector<SlideObjectPtr>::iterator i = m_objects.begin(); i != m_objects.end(); ++i)
+  {
+    SlideObjectPtr& obj = *i;
+
+    //std::cout << obj.get() << ": " << obj->begin() << " " << obj->length() << std::endl;
+
+    if (obj->begin() <= m_time && m_time < (obj->begin() + obj->length()))
+    {
+      //std::cout << "draw" << std::endl;
+      // active object
+      float relative_time = m_time - obj->begin();
+      //std::cout << m_time << " " << relative_time << std::endl;
+      obj->draw(relative_time);
+    }
+  }
+}
+
+void
+SlideShow::add(SlideObjectPtr object)
+{
+  m_length = std::max(m_length, object->begin() + object->length());
+  m_objects.push_back(object);
+}
+
+bool
+SlideShow::done() const
+{
+  return (m_time >= m_length);
+}
+
+int
+SlideShow::size() const
+{
+  return m_objects.size();
+}
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/slide_show.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/slide_show.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_show.hpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/slide_show.hpp	2010-08-29 00:44:35 UTC (rev 3338)
@@ -0,0 +1,51 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_WINDSTILLE_EXTRA_SLIDESHOW_SLIDE_SHOW_HPP
+#define HEADER_WINDSTILLE_EXTRA_SLIDESHOW_SLIDE_SHOW_HPP
+
+#include <vector>
+
+#include "slideshow/slide_object.hpp"
+
+class SlideShow
+{
+private:
+  std::vector<SlideObjectPtr> m_objects;
+  float m_time;
+  float m_length;
+  
+public:
+  SlideShow();
+
+  void update(float delta);
+  void draw();
+  void add(SlideObjectPtr object);
+
+  bool done() const;
+
+  int size() const;
+
+private:
+  SlideShow(const SlideShow&);
+  SlideShow& operator=(const SlideShow&);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/slide_show.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/slideshow.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slideshow.cpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/slideshow.cpp	2010-08-29 00:44:35 UTC (rev 3338)
@@ -0,0 +1,157 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <SDL.h>
+
+#include <sstream>
+#include <stdexcept>
+
+#include "display/opengl_window.hpp"
+#include "display/surface_manager.hpp"
+#include "display/surface_drawing_parameters.hpp"
+#include "display/surface.hpp"
+#include "display/texture_manager.hpp"
+#include "util/system.hpp"
+
+#include "slideshow/slide_show.hpp"
+#include "slideshow/slide_builder.hpp"
+
+void
+init_sdl()
+{
+  Uint32 flags = SDL_INIT_VIDEO | SDL_INIT_JOYSTICK;
+
+  if (SDL_Init(flags) < 0)
+  {
+    std::ostringstream msg;
+    msg << "Couldn't initialize SDL: " << SDL_GetError();
+    throw std::runtime_error(msg.str());
+  }
+  else
+  {
+    atexit(SDL_Quit);
+    SDL_EnableUNICODE(1);
+  }
+}
+
+int main(int argc, char** argv)
+{
+  if (argc < 1)
+  {
+    std::cerr << "Usage: " << argv[0] << " FILE..." << std::endl;
+    return 0;
+  }
+  else
+  {
+    try 
+    {
+      init_sdl();
+      
+      Size aspect(640, 480);
+      //std::cout << "OpenGLWindow" << std::endl;
+      OpenGLWindow window(Size(640, 480), // window size
+                          aspect, // aspect ratio
+                          false, // fullscreen
+                          4); // anti-alias
+
+      TextureManager    texture_manager;
+      SurfaceManager    surface_manager;
+
+      SlideShow slide_show;
+      
+      { // read from file
+        SlideBuilder slide_builder(slide_show, aspect);
+        for(int i = 1; i < argc; ++i)
+        {
+          //std::cout << "Reading " << argv[i] << std::endl;
+          slide_builder.load_from_file(argv[i]);
+        }
+      }
+
+      // Surface surface1(Pathname(argv[1], Pathname::kSysPath));
+      // Surface surface2(Pathname(argv[2], Pathname::kSysPath));
+  
+      bool loop = true;
+      //float progress = 0.0f;
+
+      Uint32 last_ticks = SDL_GetTicks();
+      while(loop && !slide_show.done())
+      {
+        SDL_Event event;
+        while(SDL_PollEvent(&event))
+        {
+          switch(event.type)
+          {
+            case SDL_QUIT:
+              loop = false;
+              break;
+
+            case SDL_KEYDOWN:
+            case SDL_KEYUP:
+              if (event.key.state)
+              {    
+                switch (event.key.keysym.sym)
+                {
+                  case SDLK_F6:
+                    break;
+
+                  default:
+                    break;
+                }
+              }
+                     
+              return 0;
+          }
+        }
+
+        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+        Uint32 ticks = SDL_GetTicks();
+        slide_show.update(static_cast<float>(ticks - last_ticks) / 1000.0f);
+        last_ticks = ticks;
+        slide_show.draw();
+
+        // surface1.draw(SurfaceDrawingParameters()
+        //               .set_blend_func(GL_SRC_ALPHA, GL_ONE)
+        //               .set_color(Color(1.0f, 1.0f, 1.0f, 1.0f - progress))
+        //               .set_scale(1.0f)
+        //               .set_pos(Vector2f(0.0f, 0.0f)));
+    
+        // surface2.draw(SurfaceDrawingParameters()
+        //               .set_blend_func(GL_SRC_ALPHA, GL_ONE)
+        //               .set_color(Color(1.0f, 1.0f, 1.0f, progress))
+        //               .set_scale(1.0f + progress)
+        //               .set_pos(Vector2f(0.0f - (100.0f * progress),
+        //                                 0.0f)));
+
+        SDL_GL_SwapBuffers();
+
+        SDL_Delay(10);
+      }
+    }
+    catch(std::exception& err)
+    {
+      std::cout << err.what() << std::endl;
+      return 1;
+    }
+    return 0;
+  }
+}
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/slideshow.cpp
___________________________________________________________________
Added: svn:eol-style
   + native



From grumbel at mail.berlios.de  Sun Aug 29 15:54:01 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Sun, 29 Aug 2010 15:54:01 +0200
Subject: [Windstille-commit] r3339 - trunk/windstille/extra/slideshow
Message-ID: <20100829135402.04ED8480FDA@sheep.berlios.de>

Author: grumbel
Date: 2010-08-29 15:54:01 +0200 (Sun, 29 Aug 2010)
New Revision: 3339

Modified:
   trunk/windstille/extra/slideshow/script.slideshow
   trunk/windstille/extra/slideshow/slide_builder.cpp
   trunk/windstille/extra/slideshow/slide_builder.hpp
   trunk/windstille/extra/slideshow/slide_object.cpp
Log:
slideshow: implemented left,right,top,bottom handling, fixed position handling

Modified: trunk/windstille/extra/slideshow/script.slideshow
===================================================================
--- trunk/windstille/extra/slideshow/script.slideshow	2010-08-29 00:44:35 UTC (rev 3338)
+++ trunk/windstille/extra/slideshow/script.slideshow	2010-08-29 13:54:01 UTC (rev 3339)
@@ -2,23 +2,44 @@
 
 fade 1.0
 
+image portrait.jpg
+  zoom 0.1
+  pos center center
+
+  duration 4
+
+  zoom 1.5
+  pos center center
+end
+
+fade 1.0
+
 image landscape.jpg
   zoom 0.1
   pos center center
 
-  duration 20
+  duration 3
 
-  zoom 5.0
-  pos 320 240
+  zoom 3.0
+  pos center center
+end
 
-  duration 2
+fade 1.0
 
-  zoom 0.75
-  pos 320 240
+image landscape.jpg
+  zoom 0.1
+  pos center center
+
+  duration 3
+
+  zoom 3.0
+  pos center center
 end
 
-fade 2.0
+fade 1.0
 
+breakpoint "Foobar"
+
 image two.jpg
   zoom 1.0
   pos 320 200

Modified: trunk/windstille/extra/slideshow/slide_builder.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.cpp	2010-08-29 00:44:35 UTC (rev 3338)
+++ trunk/windstille/extra/slideshow/slide_builder.cpp	2010-08-29 13:54:01 UTC (rev 3339)
@@ -130,6 +130,10 @@
         {
           handle_end(args);
         }
+        else if (args[0] == "breakpoint")
+        {
+          handle_breakpoint(args);
+        }
         else
         {
           error("unknown tag '" + args[0] + "'");
@@ -189,42 +193,54 @@
   {
     error("pos already given");
   }
+  else if (!m_node_has_zoom)
+  {
+    error("zoom must come before pos");
+  }
   else
   {
     m_node_has_pos = true;
 
+    float img_w = m_image->get_width()  * m_path_node.zoom;
+    float img_h = m_image->get_height() * m_path_node.zoom;
+
+    float scr_w = m_screen_size.width;
+    float scr_h = m_screen_size.height;
+
     if (args[1] == "left")
     {
-      m_path_node.pos.x = m_screen_size.width/2.0f;
+      m_path_node.pos.x = img_w/2.0f - scr_w/2.0f + scr_w/2.0f;
     }
     else if (args[1] == "right")
     {
-      m_path_node.pos.x = m_image->get_width() - m_screen_size.width/2.0f;
+      m_path_node.pos.x = -img_w/2.0f + scr_w/2.0f + scr_w/2.0f;
     }
     else if (args[1] == "center")
     {
-      m_path_node.pos.x = m_screen_size.width/2.0f;
+      m_path_node.pos.x = scr_w/2;
     }
     else
     {
-      m_path_node.pos.x = boost::lexical_cast<float>(args[1]);
+      float x = boost::lexical_cast<float>(args[1]) * m_path_node.zoom;
+      m_path_node.pos.x = img_w/2.0f - x + scr_w/2.0f;
     }
 
     if (args[2] == "top")
     {
-      m_path_node.pos.y = 0.0f;
+      m_path_node.pos.y = img_h/2.0f - scr_h/2.0f + scr_h/2.0f;
     }
     else if (args[2] == "bottom")
     {
-      m_path_node.pos.y = m_image->get_height() - m_screen_size.height/2.0f;
+      m_path_node.pos.y = -img_h/2.0f + scr_h/2.0f + scr_h/2.0f;
     }
     else if (args[2] == "center")
     {
-      m_path_node.pos.y = m_screen_size.height/2.0f;
+      m_path_node.pos.y = scr_h/2;
     }
     else
     {
-      m_path_node.pos.y = boost::lexical_cast<float>(args[2]);
+      float y = boost::lexical_cast<float>(args[2]) * m_path_node.zoom;
+      m_path_node.pos.y = img_h/2.0f - y + scr_h/2.0f;
     }
 
     std::cout << "  (pos " << m_path_node.pos.x << " " << m_path_node.pos.y << ")" << std::endl;
@@ -261,9 +277,19 @@
     {
       m_path_node.zoom = m_screen_size.height / m_image->get_height();
     }
+    else if (args[1] == "original")
+    {
+      m_path_node.zoom = 1.0f;
+    }
     else
     {
       m_path_node.zoom = boost::lexical_cast<float>(args[1]);
+      
+      // 1.0f means "fit", so recalculate values relative to that
+      float fit = std::min(m_screen_size.width / m_image->get_width(),
+                           m_screen_size.height / m_image->get_height());
+      m_path_node.zoom = fit * m_path_node.zoom;
+
       std::cout << "  (zoom " << m_path_node.zoom << ")" << std::endl;
     }
 
@@ -361,4 +387,10 @@
   }
 }
 
+void
+SlideBuilder::handle_breakpoint(const std::vector<std::string>& args)
+{
+  std::cout << "breakpoint not implemented" << std::endl;
+}
+
 /* EOF */

Modified: trunk/windstille/extra/slideshow/slide_builder.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.hpp	2010-08-29 00:44:35 UTC (rev 3338)
+++ trunk/windstille/extra/slideshow/slide_builder.hpp	2010-08-29 13:54:01 UTC (rev 3339)
@@ -68,6 +68,7 @@
   void handle_duration(const std::vector<std::string>& args);
   void handle_fade(const std::vector<std::string>& args);
   void handle_end(const std::vector<std::string>& args);
+  void handle_breakpoint(const std::vector<std::string>& args);
 
   void add_node();
 

Modified: trunk/windstille/extra/slideshow/slide_object.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_object.cpp	2010-08-29 00:44:35 UTC (rev 3338)
+++ trunk/windstille/extra/slideshow/slide_object.cpp	2010-08-29 13:54:01 UTC (rev 3339)
@@ -64,6 +64,7 @@
   // zoom needs to grow exponentially to be linear
   float scale = node.zoom;
 
+  // recalc pos so that we are draw the image centered
   pos.x -= m_surface.get_width() /2.0f * scale;
   pos.y -= m_surface.get_height()/2.0f * scale;
 



From grumbel at mail.berlios.de  Sun Aug 29 23:30:54 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Sun, 29 Aug 2010 23:30:54 +0200
Subject: [Windstille-commit] r3340 - trunk/windstille/src/display
Message-ID: <20100829213054.27256480FD8@sheep.berlios.de>

Author: grumbel
Date: 2010-08-29 23:30:53 +0200 (Sun, 29 Aug 2010)
New Revision: 3340

Modified:
   trunk/windstille/src/display/display.cpp
Log:
Quick&Dirty JPEG support for screenshots

Modified: trunk/windstille/src/display/display.cpp
===================================================================
--- trunk/windstille/src/display/display.cpp	2010-08-29 13:54:01 UTC (rev 3339)
+++ trunk/windstille/src/display/display.cpp	2010-08-29 21:30:53 UTC (rev 3340)
@@ -20,10 +20,13 @@
 
 #include <boost/scoped_array.hpp>
 #include <png.h>
+#include <jpeglib.h>
 #include <errno.h>
 #include <fstream>
 #include <GL/glew.h>
 #include <GL/glext.h>
+#include <sstream>
+#include <stdexcept>
 
 #include "display/color.hpp"
 #include "math/quad.hpp"
@@ -478,7 +481,7 @@
   glPixelStorei(GL_PACK_ALIGNMENT, 1);
   glReadPixels(0, 0, size.width, size.height, GL_RGB, GL_UNSIGNED_BYTE, pixels.get());
 
-  if (0)
+  if (false)
   { // PPM saving
     int pitch = size.width * 3;
 
@@ -494,6 +497,60 @@
 
     out.close();
   }
+  else if (true)
+  {
+    FILE* m_out = fopen(filename.get_sys_path().c_str(), "wb");
+
+    if (!m_out)
+    {
+      std::ostringstream out;
+      out << "FileJPEGCompressor(): Error: " << filename << ": " << strerror(errno);
+      throw std::runtime_error(out.str());
+    }
+    else
+    {
+      int pitch = size.width * 3;
+      struct jpeg_compress_struct m_cinfo;
+      struct jpeg_error_mgr m_jerr;
+
+      jpeg_std_error(&m_jerr);
+      m_cinfo.err = &m_jerr;
+
+      jpeg_create_compress(&m_cinfo);
+
+      jpeg_stdio_dest(&m_cinfo, m_out);
+
+      m_cinfo.image_width  = size.width;
+      m_cinfo.image_height = size.height;
+
+      m_cinfo.input_components = 3;         /* # of color components per pixel */
+      m_cinfo.in_color_space   = JCS_RGB;   /* colorspace of input image */
+
+      jpeg_set_defaults(&m_cinfo);
+      //jpeg_set_quality(&m_cinfo, quality, TRUE /* limit to baseline-JPEG values */);
+ 
+      jpeg_start_compress(&m_cinfo, TRUE);
+
+      boost::scoped_array<JSAMPROW> row_pointer(new JSAMPROW[size.height]);
+  
+      for(int y = 0; y < size.height; ++y)
+      {
+        row_pointer[size.height - y - 1] = reinterpret_cast<JSAMPLE*>(pixels.get() + y*pitch);
+      }
+
+      while(m_cinfo.next_scanline < m_cinfo.image_height)
+      {
+        jpeg_write_scanlines(&m_cinfo, &row_pointer[m_cinfo.next_scanline], 
+                             size.height - m_cinfo.next_scanline);
+      }
+
+      jpeg_finish_compress(&m_cinfo);  
+
+      jpeg_destroy_compress(&m_cinfo);
+    
+      fclose(m_out);
+    }
+  }
   else 
   { // PNG saving
     FILE* fp = fopen(filename.get_sys_path().c_str(), "w");
@@ -521,7 +578,7 @@
                    PNG_COMPRESSION_TYPE_BASE, 
                    PNG_FILTER_TYPE_BASE);
       
-      png_set_compression_level(png_ptr, 3);
+      png_set_compression_level(png_ptr, 0);
       png_write_info(png_ptr, info_ptr);
 
       boost::scoped_array<png_bytep> row_pointers(new png_bytep[size.height]);



From grumbel at mail.berlios.de  Sun Aug 29 23:32:01 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Sun, 29 Aug 2010 23:32:01 +0200
Subject: [Windstille-commit] r3341 - trunk/windstille/extra/slideshow
Message-ID: <20100829213202.00550480FD8@sheep.berlios.de>

Author: grumbel
Date: 2010-08-29 23:32:01 +0200 (Sun, 29 Aug 2010)
New Revision: 3341

Added:
   trunk/windstille/extra/slideshow/slideshow.hpp
Modified:
   trunk/windstille/extra/slideshow/slide_builder.cpp
   trunk/windstille/extra/slideshow/slide_builder.hpp
   trunk/windstille/extra/slideshow/slide_show.cpp
   trunk/windstille/extra/slideshow/slide_show.hpp
   trunk/windstille/extra/slideshow/slideshow.cpp
Log:
slideshow: added command line parsing, offline rendering

Modified: trunk/windstille/extra/slideshow/slide_builder.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.cpp	2010-08-29 21:30:53 UTC (rev 3340)
+++ trunk/windstille/extra/slideshow/slide_builder.cpp	2010-08-29 21:32:01 UTC (rev 3341)
@@ -134,6 +134,10 @@
         {
           handle_breakpoint(args);
         }
+        else if (args[0] == "include")
+        {
+          handle_include(args);
+        }
         else
         {
           error("unknown tag '" + args[0] + "'");
@@ -145,6 +149,8 @@
     {
       error("not in global scope at end of file");
     }
+
+    std::cout << "Total time: " << m_time << std::endl;
   }
   catch(std::exception& err)
   {
@@ -171,7 +177,10 @@
     m_image = SlideObjectPtr(new SlideObject(Pathname(args[1], Pathname::kSysPath)));
 
     if (m_slideshow.size() != 0)
-      m_image->set_begin(m_time - m_fade);
+    {
+      m_time -= m_fade;
+      m_image->set_begin(m_time);
+    }
 
     m_image->set_fade_in(m_fade);
     m_fade = 0.0f;
@@ -269,6 +278,11 @@
       m_path_node.zoom = std::min(m_screen_size.width / m_image->get_width(),
                                   m_screen_size.height / m_image->get_height());
     }
+    else if (args[1] == "fill")
+    {
+      m_path_node.zoom = std::max(m_screen_size.width / m_image->get_width(),
+                                  m_screen_size.height / m_image->get_height());
+    }
     else if (args[1] == "width")
     {
       m_path_node.zoom = m_screen_size.width / m_image->get_width();
@@ -393,4 +407,10 @@
   std::cout << "breakpoint not implemented" << std::endl;
 }
 
+void
+SlideBuilder::handle_include(const std::vector<std::string>& args)
+{
+  
+}
+
 /* EOF */

Modified: trunk/windstille/extra/slideshow/slide_builder.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.hpp	2010-08-29 21:30:53 UTC (rev 3340)
+++ trunk/windstille/extra/slideshow/slide_builder.hpp	2010-08-29 21:32:01 UTC (rev 3341)
@@ -69,6 +69,7 @@
   void handle_fade(const std::vector<std::string>& args);
   void handle_end(const std::vector<std::string>& args);
   void handle_breakpoint(const std::vector<std::string>& args);
+  void handle_include(const std::vector<std::string>& args);
 
   void add_node();
 

Modified: trunk/windstille/extra/slideshow/slide_show.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_show.cpp	2010-08-29 21:30:53 UTC (rev 3340)
+++ trunk/windstille/extra/slideshow/slide_show.cpp	2010-08-29 21:32:01 UTC (rev 3341)
@@ -18,6 +18,8 @@
 
 #include "slideshow/slide_show.hpp"
 
+#include "slideshow/slide_builder.hpp"
+
 SlideShow::SlideShow() :
   m_objects(),
   m_time(0.0f),
@@ -70,4 +72,19 @@
   return m_objects.size();
 }
 
+void
+SlideShow::clear()
+{
+  m_objects.clear();
+  //FIXMEm_time = 0.0f;
+  m_length = 0.0f;
+}
+
+void
+SlideShow::load(const std::string& filename, const Sizef& aspect)
+{
+  SlideBuilder slide_builder(*this, aspect);
+  slide_builder.load_from_file(filename);
+}
+
 /* EOF */

Modified: trunk/windstille/extra/slideshow/slide_show.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_show.hpp	2010-08-29 21:30:53 UTC (rev 3340)
+++ trunk/windstille/extra/slideshow/slide_show.hpp	2010-08-29 21:32:01 UTC (rev 3341)
@@ -35,12 +35,16 @@
 
   void update(float delta);
   void draw();
-  void add(SlideObjectPtr object);
 
   bool done() const;
 
   int size() const;
 
+  void add(SlideObjectPtr object);
+  void clear();
+
+  void load(const std::string& filename, const Sizef& aspect);
+
 private:
   SlideShow(const SlideShow&);
   SlideShow& operator=(const SlideShow&);

Modified: trunk/windstille/extra/slideshow/slideshow.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slideshow.cpp	2010-08-29 21:30:53 UTC (rev 3340)
+++ trunk/windstille/extra/slideshow/slideshow.cpp	2010-08-29 21:32:01 UTC (rev 3341)
@@ -16,23 +16,38 @@
 **  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
+#include "slideshow/slideshow.hpp"
+
 #include <SDL.h>
 
 #include <sstream>
 #include <stdexcept>
 
+#include "util/command_line.hpp"
 #include "display/opengl_window.hpp"
+#include "display/framebuffer.hpp"
 #include "display/surface_manager.hpp"
 #include "display/surface_drawing_parameters.hpp"
 #include "display/surface.hpp"
+#include "display/display.hpp"
 #include "display/texture_manager.hpp"
 #include "util/system.hpp"
 
 #include "slideshow/slide_show.hpp"
 #include "slideshow/slide_builder.hpp"
 
+App::App() :
+  m_aspect_ratio(1280, 800),
+  m_window_size(1280, 800),
+  m_fullscreen(false),
+  m_files(),
+  m_output_dir(),
+  m_fps(25.0f)
+{
+}
+
 void
-init_sdl()
+App::init_sdl()
 {
   Uint32 flags = SDL_INIT_VIDEO | SDL_INIT_JOYSTICK;
 
@@ -49,109 +64,218 @@
   }
 }
 
-int main(int argc, char** argv)
+void
+App::parse_args(int argc, char** argv)
 {
-  if (argc < 1)
+  CommandLine argp;
+  argp.add_usage("[OPTIONS] FILE...");
+  argp.add_doc("A script driven slideshow viewer");
+
+  argp.add_group("Options:");
+  argp.add_option('f', "fullscreen", "", "Use fullscreen mode");
+  argp.add_option('g', "geometry", "WxH", "Use given geometry");
+  argp.add_option('a', "aspect", "WxH", "Use given aspect ratio");
+  argp.add_option('b', "breakpoint", "POINT", "Start at POINT");
+  argp.add_option('F', "fps", "FPS", "Generate FPS frames per seconds");
+  argp.add_option('o', "output", "DIR", "Write screenshots to DIR");
+  argp.add_option('h', "help", "", "Print help");
+
+  argp.parse_args(argc, argv);
+
+  while (argp.next())
   {
-    std::cerr << "Usage: " << argv[0] << " FILE..." << std::endl;
-    return 0;
+    switch (argp.get_key())
+    {
+      case 'f':
+        m_fullscreen = true;
+        break;
+
+      case 'g':
+        if (sscanf(argp.get_argument().c_str(), "%dx%d", &m_window_size.width, &m_window_size.height) != 2)
+        {
+          throw std::runtime_error("--geometry argument wrong");
+        }
+        break;
+
+      case 'a':
+        if (sscanf(argp.get_argument().c_str(), "%dx%d", &m_aspect_ratio.width, &m_aspect_ratio.height) != 2)
+        {
+          throw std::runtime_error("--aspect argument wrong");
+        }
+        break;
+
+      case 'b':
+        break;
+
+      case 'o':
+        m_output_dir = argp.get_argument();
+        break;
+
+      case 'h':
+        argp.print_help();
+        exit(0);
+        break;
+
+      case CommandLine::REST_ARG:
+        m_files.push_back(argp.get_argument());
+        break;
+
+      default:
+        throw std::runtime_error("unhandled argument");
+    }
   }
-  else
+
+  if (m_files.empty())
   {
-    try 
-    {
-      init_sdl();
+    argp.print_help();
+    exit(0);
+  }
+}
+
+int
+App::main(int argc, char** argv)
+{
+  parse_args(argc, argv);
+    
+  init_sdl();
       
-      Size aspect(640, 480);
-      //std::cout << "OpenGLWindow" << std::endl;
-      OpenGLWindow window(Size(640, 480), // window size
-                          aspect, // aspect ratio
-                          false, // fullscreen
-                          4); // anti-alias
+  //std::cout << "OpenGLWindow" << std::endl;
+  OpenGLWindow window(m_window_size, // window size
+                      m_aspect_ratio, // aspect ratio
+                      m_fullscreen, // fullscreen
+                      4); // anti-alias
 
-      TextureManager    texture_manager;
-      SurfaceManager    surface_manager;
+  TextureManager    texture_manager;
+  SurfaceManager    surface_manager;
 
-      SlideShow slide_show;
+  SlideShow slide_show;
       
-      { // read from file
-        SlideBuilder slide_builder(slide_show, aspect);
-        for(int i = 1; i < argc; ++i)
-        {
-          //std::cout << "Reading " << argv[i] << std::endl;
-          slide_builder.load_from_file(argv[i]);
-        }
-      }
+  for(std::vector<std::string>::iterator i = m_files.begin(); i != m_files.end(); ++i)
+  {
+    slide_show.load(*i, m_aspect_ratio);
+  }
+ 
+  Framebuffer framebuffer(GL_TEXTURE_2D, m_window_size.width, m_window_size.height);
 
-      // Surface surface1(Pathname(argv[1], Pathname::kSysPath));
-      // Surface surface2(Pathname(argv[2], Pathname::kSysPath));
-  
-      bool loop = true;
-      //float progress = 0.0f;
+  bool loop = true;
+  bool pause = false;
 
-      Uint32 last_ticks = SDL_GetTicks();
-      while(loop && !slide_show.done())
+  int frame_number = 0;
+  Uint32 last_ticks = SDL_GetTicks();
+  while(loop && !slide_show.done())
+  {
+    SDL_Event event;
+    while(SDL_PollEvent(&event))
+    {
+      switch(event.type)
       {
-        SDL_Event event;
-        while(SDL_PollEvent(&event))
-        {
-          switch(event.type)
-          {
-            case SDL_QUIT:
-              loop = false;
-              break;
+        case SDL_QUIT:
+          loop = false;
+          break;
 
-            case SDL_KEYDOWN:
-            case SDL_KEYUP:
-              if (event.key.state)
-              {    
-                switch (event.key.keysym.sym)
+        case SDL_KEYDOWN:
+        case SDL_KEYUP:
+          if (event.key.state)
+          {    
+            switch (event.key.keysym.sym)
+            {
+              case SDLK_ESCAPE:
+                loop = false;
+                break;
+
+              case SDLK_F5:
+                slide_show.clear();
+                for(int i = 1; i < argc; ++i)
                 {
-                  case SDLK_F6:
-                    break;
+                  slide_show.load(argv[i], m_aspect_ratio);
+                }
+                break;
 
-                  default:
-                    break;
-                }
-              }
-                     
-              return 0;
+              case SDLK_F10:
+                Display::save_screenshot(Pathname("/tmp/out.png", Pathname::kSysPath));
+                break;
+
+              case SDLK_LEFT:
+                slide_show.update(-1.0f);
+                break;
+
+              case SDLK_RIGHT:
+                slide_show.update(1.0f);
+                break;
+
+
+              case SDLK_UP:
+                slide_show.update(10.0f);
+                break;
+
+              case SDLK_DOWN:
+                slide_show.update(-10.0f);
+                break;
+
+              case SDLK_SPACE:
+                pause = !pause;
+                break;
+
+              default:
+                break;
+            }
           }
-        }
+      }
+    }
 
-        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
-        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+    if (m_output_dir.empty())
+    {
+      // realtime rendering
+      Uint32 ticks = SDL_GetTicks();
 
-        Uint32 ticks = SDL_GetTicks();
+      if (!pause)
         slide_show.update(static_cast<float>(ticks - last_ticks) / 1000.0f);
-        last_ticks = ticks;
-        slide_show.draw();
+      last_ticks = ticks;
 
-        // surface1.draw(SurfaceDrawingParameters()
-        //               .set_blend_func(GL_SRC_ALPHA, GL_ONE)
-        //               .set_color(Color(1.0f, 1.0f, 1.0f, 1.0f - progress))
-        //               .set_scale(1.0f)
-        //               .set_pos(Vector2f(0.0f, 0.0f)));
-    
-        // surface2.draw(SurfaceDrawingParameters()
-        //               .set_blend_func(GL_SRC_ALPHA, GL_ONE)
-        //               .set_color(Color(1.0f, 1.0f, 1.0f, progress))
-        //               .set_scale(1.0f + progress)
-        //               .set_pos(Vector2f(0.0f - (100.0f * progress),
-        //                                 0.0f)));
+      glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 
-        SDL_GL_SwapBuffers();
+      slide_show.draw();
 
-        SDL_Delay(10);
-      }
+      SDL_GL_SwapBuffers();
+
+      SDL_Delay(10);
     }
-    catch(std::exception& err)
+    else
     {
-      std::cout << err.what() << std::endl;
-      return 1;
+      slide_show.update(1.0f/m_fps);
+
+      // rendering to output dir
+      Display::push_framebuffer(framebuffer);
+      glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+      slide_show.draw();
+
+      char out[1024];
+      sprintf(out, "%s/%08d.jpg", m_output_dir.c_str(), frame_number);
+      Display::save_screenshot(Pathname(out, Pathname::kSysPath));
+      std::cout << "Wrote: " << out << std::endl;
+      frame_number += 1;
+      Display::pop_framebuffer();
     }
-    return 0;
   }
+  return 0;
 }
 
+int main(int argc, char** argv)
+{
+  try 
+  {
+    App app;
+    app.main(argc, argv);
+  }
+  catch(std::exception& err)
+  {
+    std::cout << err.what() << std::endl;
+    return 1;
+  }
+
+  return 0;
+}
+
 /* EOF */

Added: trunk/windstille/extra/slideshow/slideshow.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slideshow.hpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/slideshow.hpp	2010-08-29 21:32:01 UTC (rev 3341)
@@ -0,0 +1,50 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef HEADER_WINDSTILLE_EXTRA_SLIDESHOW_SLIDESHOW_HPP
+#define HEADER_WINDSTILLE_EXTRA_SLIDESHOW_SLIDESHOW_HPP
+
+#include <vector>
+
+#include "math/size.hpp"
+
+class App
+{
+private:
+  Size m_aspect_ratio;
+  Size m_window_size;
+  bool m_fullscreen;
+  std::vector<std::string> m_files;
+  std::string m_output_dir;
+  float m_fps;
+
+public:
+  App();
+
+  void init_sdl();
+  int main(int argc, char** argv);
+  void parse_args(int argc, char** argv);
+
+private:
+  App(const App&);
+  App& operator=(const App&);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/slideshow.hpp
___________________________________________________________________
Added: svn:eol-style
   + native



From grumbel at mail.berlios.de  Mon Aug 30 17:06:35 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Mon, 30 Aug 2010 17:06:35 +0200
Subject: [Windstille-commit] r3342 - trunk/windstille/extra/slideshow
Message-ID: <20100830150635.558D8480FE3@sheep.berlios.de>

Author: grumbel
Date: 2010-08-30 17:06:35 +0200 (Mon, 30 Aug 2010)
New Revision: 3342

Modified:
   trunk/windstille/extra/slideshow/slide_builder.cpp
   trunk/windstille/extra/slideshow/slide_builder.hpp
Log:
slideshow: some preparations to add default value handling to the SlideBuilder


Modified: trunk/windstille/extra/slideshow/slide_builder.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.cpp	2010-08-29 21:32:01 UTC (rev 3341)
+++ trunk/windstille/extra/slideshow/slide_builder.cpp	2010-08-30 15:06:35 UTC (rev 3342)
@@ -29,6 +29,82 @@
 
 #include "slideshow/slide_show.hpp"
 
+float
+NodePosX::get(const Sizef& scr, const Sizef& img) const
+{
+  switch(m_type)
+  {
+    case kNodePosXLeft:
+      return img.width/2.0f - scr.width/2.0f + scr.width/2.0f;
+
+    case kNodePosXRight:
+      return -img.width/2.0f + scr.width/2.0f + scr.width/2.0f;
+
+    case kNodePosXCenter:
+      return scr.width/2;
+
+    case kNodePosXFloat:
+      return m_value;
+  }
+
+  assert(!"never reached");
+}
+
+float
+NodePosY::get(const Sizef& scr, const Sizef& img) const
+{
+  switch(m_type)
+  {
+    case kNodePosYTop:
+      return img.height/2.0f - scr.height/2.0f + scr.height/2.0f;
+      
+    case kNodePosYBottom:
+      return -img.height/2.0f + scr.height/2.0f + scr.height/2.0f;
+
+    case kNodePosYCenter:
+      return scr.height/2;
+      
+    case kNodePosYFloat:
+      return m_value;
+  }
+
+  assert(!"never reached");
+}
+
+float
+NodeZoom::get(const Sizef& scr, const Sizef& img) const
+{
+  switch(m_type)
+  {
+    case kNodeZoomFit:
+      return std::min(scr.width / img.width,
+                      scr.height / img.height);
+
+    case kNodeZoomFill:
+      return std::max(scr.width / img.width,
+                      scr.height / img.height);
+
+    case kNodeZoomWidth:
+      return scr.width / img.width;
+      
+    case kNodeZoomHeight:
+      return scr.height / img.height;
+      
+    case kNodeZoomOriginal:
+      return 1.0f;
+
+    case kNodeZoomFloat:
+      {
+      // 1.0f means "fit", so recalculate values relative to that
+      float fit = std::min(scr.width / img.width,
+                           scr.height / img.height);
+      return fit * m_value;
+      }
+  }
+
+  assert(!"never reached");
+}
+
 SlideBuilder::SlideBuilder(SlideShow& slideshow, const Sizef& screen_size) :
   m_slideshow(slideshow),
   m_screen_size(screen_size),
@@ -41,7 +117,8 @@
   m_last_image(),
   m_node_has_pos(false),
   m_node_has_zoom(false),
-  m_path_node()
+  m_path_node(),
+  m_node()
 {
 }
 
@@ -346,7 +423,13 @@
     error("getting default zoom not implemented");
   }
 
+  Sizef m_image_size(m_image->get_width(),
+                     m_image->get_height());
+
   m_image->get_path().add_node(m_path_node.pos, m_path_node.zoom);
+  //m_image->get_path().add_node(Vector2f(m_node.pos_x.get(m_screen_size, m_image_size),
+  //                                     m_node.pos_y.get(m_screen_size, m_image_size)),
+  //                           m_node.zoom.get(m_screen_size, m_image_size));
 
   m_node_has_zoom = false;
   m_node_has_pos  = false;

Modified: trunk/windstille/extra/slideshow/slide_builder.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.hpp	2010-08-29 21:32:01 UTC (rev 3341)
+++ trunk/windstille/extra/slideshow/slide_builder.hpp	2010-08-30 15:06:35 UTC (rev 3342)
@@ -27,7 +27,110 @@
 #include "slideshow/slide_path.hpp"
 
 class SlideShow;
+
+class NodePosX
+{
+public:
+  enum NodePosXType
+  {
+    kNodePosXLeft,
+    kNodePosXRight,
+    kNodePosXCenter,
+    kNodePosXFloat
+  };
+  
+public:
+  NodePosX() :
+    m_type(kNodePosXCenter),
+    m_value(0.0f)
+  {}
 
+  NodePosX(NodePosXType type, float value) :
+    m_type(type),
+    m_value(value)
+  {}
+
+  float get(const Sizef& screen_size, const Sizef& image_size) const;
+
+private:
+  NodePosXType m_type;  
+  float m_value;
+};
+
+class NodePosY
+{
+public:
+  enum NodePosYType
+  {
+    kNodePosYTop,
+    kNodePosYBottom,
+    kNodePosYCenter,
+    kNodePosYFloat
+  };
+  
+public:
+  NodePosY() :
+    m_type(kNodePosYCenter),
+    m_value(0.0f)
+  {}
+
+  NodePosY(NodePosYType type, float value) :
+    m_type(type),
+    m_value(value)
+  {}
+
+  float get(const Sizef& screen_size, const Sizef& image_size) const;
+
+private:
+  NodePosYType m_type;
+  float m_value;
+};
+
+class NodeZoom
+{
+public:
+  enum NodeZoomType
+  {
+    kNodeZoomOriginal,
+    kNodeZoomFit,
+    kNodeZoomFill,
+    kNodeZoomWidth,
+    kNodeZoomHeight,
+    kNodeZoomFloat
+  };
+
+public:
+  NodeZoom() :
+    m_type(kNodeZoomFit),
+    m_value(0.0f)
+  {}
+
+  NodeZoom(NodeZoomType type, float value = 0.0f) :
+    m_type(type),
+    m_value(value)
+  {}
+
+  float get(const Sizef& screen_size, const Sizef& image_size) const;
+
+private:
+  NodeZoomType m_type;
+  float m_value;
+};
+
+class Node
+{
+public:
+  NodeZoom zoom;
+  NodePosX pos_x;
+  NodePosY pos_y;
+
+  Node() :
+    zoom(),
+    pos_x(),
+    pos_y()
+  {}
+};
+
 class SlideBuilder
 {
 private:
@@ -52,6 +155,7 @@
   bool m_node_has_pos;
   bool m_node_has_zoom;
   SlidePathNode m_path_node;
+  Node m_node;
 
 public:
   SlideBuilder(SlideShow& slideshow, const Sizef& screen_size);
@@ -77,7 +181,7 @@
   SlideBuilder(const SlideBuilder&);
   SlideBuilder& operator=(const SlideBuilder&);
 };
-
+
 #endif
 
 /* EOF */



From grumbel at mail.berlios.de  Mon Aug 30 17:46:37 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Mon, 30 Aug 2010 17:46:37 +0200
Subject: [Windstille-commit] r3343 - trunk/windstille/extra/slideshow
Message-ID: <20100830154637.26A9B480FE3@sheep.berlios.de>

Author: grumbel
Date: 2010-08-30 17:46:36 +0200 (Mon, 30 Aug 2010)
New Revision: 3343

Modified:
   trunk/windstille/extra/slideshow/slide_builder.cpp
   trunk/windstille/extra/slideshow/slide_builder.hpp
   trunk/windstille/extra/slideshow/slide_show.cpp
   trunk/windstille/extra/slideshow/slide_show.hpp
   trunk/windstille/extra/slideshow/slideshow.cpp
   trunk/windstille/extra/slideshow/slideshow.hpp
Log:
slideshow: implemented default values


Modified: trunk/windstille/extra/slideshow/slide_builder.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.cpp	2010-08-30 15:06:35 UTC (rev 3342)
+++ trunk/windstille/extra/slideshow/slide_builder.cpp	2010-08-30 15:46:36 UTC (rev 3343)
@@ -30,7 +30,7 @@
 #include "slideshow/slide_show.hpp"
 
 float
-NodePosX::get(const Sizef& scr, const Sizef& img) const
+NodePosX::get(const Sizef& scr, const Sizef& img, float zoom) const
 {
   switch(m_type)
   {
@@ -44,14 +44,17 @@
       return scr.width/2;
 
     case kNodePosXFloat:
-      return m_value;
+      {
+        float x = m_value * zoom;
+        return img.width/2.0f - x + scr.width/2.0f;
+      }
   }
 
   assert(!"never reached");
 }
 
 float
-NodePosY::get(const Sizef& scr, const Sizef& img) const
+NodePosY::get(const Sizef& scr, const Sizef& img, float zoom) const
 {
   switch(m_type)
   {
@@ -65,7 +68,10 @@
       return scr.height/2;
       
     case kNodePosYFloat:
-      return m_value;
+      {
+        float y = m_value * zoom;
+        return img.height/2.0f - y + scr.height/2.0f;
+      }
   }
 
   assert(!"never reached");
@@ -95,10 +101,10 @@
 
     case kNodeZoomFloat:
       {
-      // 1.0f means "fit", so recalculate values relative to that
-      float fit = std::min(scr.width / img.width,
-                           scr.height / img.height);
-      return fit * m_value;
+        // 1.0f means "fit", so recalculate values relative to that
+        float fit = std::min(scr.width / img.width,
+                             scr.height / img.height);
+        return fit * m_value;
       }
   }
 
@@ -117,7 +123,7 @@
   m_last_image(),
   m_node_has_pos(false),
   m_node_has_zoom(false),
-  m_path_node(),
+  //m_path_node(),
   m_node()
 {
 }
@@ -249,6 +255,10 @@
   else
   {
     m_state = kImage;
+
+    // reset pan/zoom pos
+    m_node = Node();
+
     std::cout << ";; time = " << m_time << std::endl;
     std::cout << "(image \"" << args[1] << "\")" << std::endl;
     m_image = SlideObjectPtr(new SlideObject(Pathname(args[1], Pathname::kSysPath)));
@@ -279,57 +289,70 @@
   {
     error("pos already given");
   }
-  else if (!m_node_has_zoom)
-  {
-    error("zoom must come before pos");
-  }
   else
   {
     m_node_has_pos = true;
 
-    float img_w = m_image->get_width()  * m_path_node.zoom;
-    float img_h = m_image->get_height() * m_path_node.zoom;
+    //float img_w = m_image->get_width()  * m_path_node.zoom;
+    //float img_h = m_image->get_height() * m_path_node.zoom;
 
-    float scr_w = m_screen_size.width;
-    float scr_h = m_screen_size.height;
+    //float scr_w = m_screen_size.width;
+    //float scr_h = m_screen_size.height;
 
     if (args[1] == "left")
     {
-      m_path_node.pos.x = img_w/2.0f - scr_w/2.0f + scr_w/2.0f;
+      //m_path_node.pos.x = img_w/2.0f - scr_w/2.0f + scr_w/2.0f;
+      m_node.pos_x = NodePosX(NodePosX::kNodePosXLeft);
     }
     else if (args[1] == "right")
     {
-      m_path_node.pos.x = -img_w/2.0f + scr_w/2.0f + scr_w/2.0f;
+      //m_path_node.pos.x = -img_w/2.0f + scr_w/2.0f + scr_w/2.0f;
+      m_node.pos_x = NodePosX(NodePosX::kNodePosXRight);
     }
     else if (args[1] == "center")
     {
-      m_path_node.pos.x = scr_w/2;
+      //m_path_node.pos.x = scr_w/2;
+      m_node.pos_x = NodePosX(NodePosX::kNodePosXCenter);
     }
+    else if (args[1] == "prev")
+    {
+      // reuse previous value      
+    }
     else
     {
-      float x = boost::lexical_cast<float>(args[1]) * m_path_node.zoom;
-      m_path_node.pos.x = img_w/2.0f - x + scr_w/2.0f;
+      //float x = boost::lexical_cast<float>(args[1]) * m_path_node.zoom;
+      //m_path_node.pos.x = img_w/2.0f - x + scr_w/2.0f;
+
+      m_node.pos_x = NodePosX(NodePosX::kNodePosXFloat, boost::lexical_cast<float>(args[1]));
     }
 
     if (args[2] == "top")
     {
-      m_path_node.pos.y = img_h/2.0f - scr_h/2.0f + scr_h/2.0f;
+      //m_path_node.pos.y = img_h/2.0f - scr_h/2.0f + scr_h/2.0f;
+      m_node.pos_y = NodePosY(NodePosY::kNodePosYTop);
     }
     else if (args[2] == "bottom")
     {
-      m_path_node.pos.y = -img_h/2.0f + scr_h/2.0f + scr_h/2.0f;
+      //m_path_node.pos.y = -img_h/2.0f + scr_h/2.0f + scr_h/2.0f;
+      m_node.pos_y = NodePosY(NodePosY::kNodePosYBottom);
     }
     else if (args[2] == "center")
     {
-      m_path_node.pos.y = scr_h/2;
+      //m_path_node.pos.y = scr_h/2;
+      m_node.pos_y = NodePosY(NodePosY::kNodePosYCenter);
     }
+    else if (args[2] == "prev")
+    {
+      // reuse previous value
+    }
     else
     {
-      float y = boost::lexical_cast<float>(args[2]) * m_path_node.zoom;
-      m_path_node.pos.y = img_h/2.0f - y + scr_h/2.0f;
+      //float y = boost::lexical_cast<float>(args[2]) * m_path_node.zoom;
+      //m_path_node.pos.y = img_h/2.0f - y + scr_h/2.0f;
+      m_node.pos_y = NodePosY(NodePosY::kNodePosYFloat, boost::lexical_cast<float>(args[2]));
     }
 
-    std::cout << "  (pos " << m_path_node.pos.x << " " << m_path_node.pos.y << ")" << std::endl;
+    //std::cout << "  (pos " << m_path_node.pos.x << " " << m_path_node.pos.y << ")" << std::endl;
   }
 }
 
@@ -352,28 +375,38 @@
   {
     if (args[1] == "fit")
     {
-      m_path_node.zoom = std::min(m_screen_size.width / m_image->get_width(),
-                                  m_screen_size.height / m_image->get_height());
+      //m_path_node.zoom = std::min(m_screen_size.width / m_image->get_width(),
+      //                            m_screen_size.height / m_image->get_height());
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomFit);
     }
     else if (args[1] == "fill")
     {
-      m_path_node.zoom = std::max(m_screen_size.width / m_image->get_width(),
-                                  m_screen_size.height / m_image->get_height());
+      //m_path_node.zoom = std::max(m_screen_size.width / m_image->get_width(),
+      //m_screen_size.height / m_image->get_height());
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomFill);
     }
     else if (args[1] == "width")
     {
-      m_path_node.zoom = m_screen_size.width / m_image->get_width();
+      //m_path_node.zoom = m_screen_size.width / m_image->get_width();
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomWidth);
     }
     else if (args[1] == "height")
     {
-      m_path_node.zoom = m_screen_size.height / m_image->get_height();
+      //m_path_node.zoom = m_screen_size.height / m_image->get_height();
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomHeight);
     }
     else if (args[1] == "original")
     {
-      m_path_node.zoom = 1.0f;
+      //m_path_node.zoom = 1.0f;
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomOriginal);
     }
+    else if (args[1] == "prev")
+    {
+      // reuse previous value      
+    }
     else
     {
+      /*
       m_path_node.zoom = boost::lexical_cast<float>(args[1]);
       
       // 1.0f means "fit", so recalculate values relative to that
@@ -382,6 +415,8 @@
       m_path_node.zoom = fit * m_path_node.zoom;
 
       std::cout << "  (zoom " << m_path_node.zoom << ")" << std::endl;
+      */
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomFloat, boost::lexical_cast<float>(args[1]));
     }
 
     m_node_has_zoom = true;
@@ -413,24 +448,16 @@
 void
 SlideBuilder::add_node()
 {
-  if (!m_node_has_pos)
-  {
-    error("getting default pos not implemented");
-  }
+  Sizef image_size(m_image->get_width(), m_image->get_height());
+  float zoom = m_node.zoom.get(m_screen_size, image_size);
+  Sizef image_size_zoom(zoom * m_image->get_width(), 
+                        zoom * m_image->get_height());
+  
+  //m_image->get_path().add_node(m_path_node.pos, m_path_node.zoom);
+  m_image->get_path().add_node(Vector2f(m_node.pos_x.get(m_screen_size, image_size_zoom, zoom),
+                                        m_node.pos_y.get(m_screen_size, image_size_zoom, zoom)),
+                               zoom);
 
-  if (!m_node_has_zoom)
-  {
-    error("getting default zoom not implemented");
-  }
-
-  Sizef m_image_size(m_image->get_width(),
-                     m_image->get_height());
-
-  m_image->get_path().add_node(m_path_node.pos, m_path_node.zoom);
-  //m_image->get_path().add_node(Vector2f(m_node.pos_x.get(m_screen_size, m_image_size),
-  //                                     m_node.pos_y.get(m_screen_size, m_image_size)),
-  //                           m_node.zoom.get(m_screen_size, m_image_size));
-
   m_node_has_zoom = false;
   m_node_has_pos  = false;
 }

Modified: trunk/windstille/extra/slideshow/slide_builder.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.hpp	2010-08-30 15:06:35 UTC (rev 3342)
+++ trunk/windstille/extra/slideshow/slide_builder.hpp	2010-08-30 15:46:36 UTC (rev 3343)
@@ -45,12 +45,12 @@
     m_value(0.0f)
   {}
 
-  NodePosX(NodePosXType type, float value) :
+  NodePosX(NodePosXType type, float value = 0.0f) :
     m_type(type),
     m_value(value)
   {}
 
-  float get(const Sizef& screen_size, const Sizef& image_size) const;
+  float get(const Sizef& screen_size, const Sizef& image_size, float zoom) const;
 
 private:
   NodePosXType m_type;  
@@ -74,12 +74,12 @@
     m_value(0.0f)
   {}
 
-  NodePosY(NodePosYType type, float value) :
+  NodePosY(NodePosYType type, float value = 0.0f) :
     m_type(type),
     m_value(value)
   {}
 
-  float get(const Sizef& screen_size, const Sizef& image_size) const;
+  float get(const Sizef& screen_size, const Sizef& image_size, float zoom) const;
 
 private:
   NodePosYType m_type;
@@ -105,7 +105,7 @@
     m_value(0.0f)
   {}
 
-  NodeZoom(NodeZoomType type, float value = 0.0f) :
+  NodeZoom(NodeZoomType type, float value = 1.0f) :
     m_type(type),
     m_value(value)
   {}
@@ -154,7 +154,7 @@
 
   bool m_node_has_pos;
   bool m_node_has_zoom;
-  SlidePathNode m_path_node;
+  //SlidePathNode m_path_node;
   Node m_node;
 
 public:

Modified: trunk/windstille/extra/slideshow/slide_show.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_show.cpp	2010-08-30 15:06:35 UTC (rev 3342)
+++ trunk/windstille/extra/slideshow/slide_show.cpp	2010-08-30 15:46:36 UTC (rev 3343)
@@ -22,32 +22,25 @@
 
 SlideShow::SlideShow() :
   m_objects(),
-  m_time(0.0f),
   m_length(0.0f)
 {
 }
 
 void
-SlideShow::update(float delta)
+SlideShow::draw(float time)
 {
-  m_time += delta;
-}
-
-void
-SlideShow::draw()
-{
   for(std::vector<SlideObjectPtr>::iterator i = m_objects.begin(); i != m_objects.end(); ++i)
   {
     SlideObjectPtr& obj = *i;
 
     //std::cout << obj.get() << ": " << obj->begin() << " " << obj->length() << std::endl;
 
-    if (obj->begin() <= m_time && m_time < (obj->begin() + obj->length()))
+    if (obj->begin() <= time && time < (obj->begin() + obj->length()))
     {
       //std::cout << "draw" << std::endl;
       // active object
-      float relative_time = m_time - obj->begin();
-      //std::cout << m_time << " " << relative_time << std::endl;
+      float relative_time = time - obj->begin();
+      //std::cout << time << " " << relative_time << std::endl;
       obj->draw(relative_time);
     }
   }
@@ -61,9 +54,9 @@
 }
 
 bool
-SlideShow::done() const
+SlideShow::done(float time) const
 {
-  return (m_time >= m_length);
+  return (time >= m_length);
 }
 
 int
@@ -76,7 +69,6 @@
 SlideShow::clear()
 {
   m_objects.clear();
-  //FIXMEm_time = 0.0f;
   m_length = 0.0f;
 }
 

Modified: trunk/windstille/extra/slideshow/slide_show.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_show.hpp	2010-08-30 15:06:35 UTC (rev 3342)
+++ trunk/windstille/extra/slideshow/slide_show.hpp	2010-08-30 15:46:36 UTC (rev 3343)
@@ -27,16 +27,14 @@
 {
 private:
   std::vector<SlideObjectPtr> m_objects;
-  float m_time;
   float m_length;
   
 public:
   SlideShow();
 
-  void update(float delta);
-  void draw();
+  void draw(float time);
 
-  bool done() const;
+  bool done(float time) const;
 
   int size() const;
 

Modified: trunk/windstille/extra/slideshow/slideshow.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slideshow.cpp	2010-08-30 15:06:35 UTC (rev 3342)
+++ trunk/windstille/extra/slideshow/slideshow.cpp	2010-08-30 15:46:36 UTC (rev 3343)
@@ -42,7 +42,8 @@
   m_fullscreen(false),
   m_files(),
   m_output_dir(),
-  m_fps(25.0f)
+  m_fps(25.0f),
+  m_edit_mode(false)
 {
 }
 
@@ -73,6 +74,7 @@
 
   argp.add_group("Options:");
   argp.add_option('f', "fullscreen", "", "Use fullscreen mode");
+  argp.add_option('e', "edit", "", "Edit mode");
   argp.add_option('g', "geometry", "WxH", "Use given geometry");
   argp.add_option('a', "aspect", "WxH", "Use given aspect ratio");
   argp.add_option('b', "breakpoint", "POINT", "Start at POINT");
@@ -90,6 +92,10 @@
         m_fullscreen = true;
         break;
 
+      case 'e':
+        m_edit_mode = true;
+        break;
+
       case 'g':
         if (sscanf(argp.get_argument().c_str(), "%dx%d", &m_window_size.width, &m_window_size.height) != 2)
         {
@@ -162,7 +168,8 @@
 
   int frame_number = 0;
   Uint32 last_ticks = SDL_GetTicks();
-  while(loop && !slide_show.done())
+  float time = 0.0f;
+  while(loop && !slide_show.done(time))
   {
     SDL_Event event;
     while(SDL_PollEvent(&event))
@@ -196,20 +203,20 @@
                 break;
 
               case SDLK_LEFT:
-                slide_show.update(-1.0f);
+                time -= 1.0f;
                 break;
 
               case SDLK_RIGHT:
-                slide_show.update(1.0f);
+                time += 1.0f;
                 break;
 
 
               case SDLK_UP:
-                slide_show.update(10.0f);
+                time += 10.0f;
                 break;
 
               case SDLK_DOWN:
-                slide_show.update(-10.0f);
+                time -= 10.0f;
                 break;
 
               case SDLK_SPACE:
@@ -229,13 +236,15 @@
       Uint32 ticks = SDL_GetTicks();
 
       if (!pause)
-        slide_show.update(static_cast<float>(ticks - last_ticks) / 1000.0f);
+      {
+        time += static_cast<float>(ticks - last_ticks) / 1000.0f;
+      }
       last_ticks = ticks;
 
       glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 
-      slide_show.draw();
+      slide_show.draw(time);
 
       SDL_GL_SwapBuffers();
 
@@ -243,13 +252,13 @@
     }
     else
     {
-      slide_show.update(1.0f/m_fps);
+      time += 1.0f/m_fps;
 
       // rendering to output dir
       Display::push_framebuffer(framebuffer);
       glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-      slide_show.draw();
+      slide_show.draw(time);
 
       char out[1024];
       sprintf(out, "%s/%08d.jpg", m_output_dir.c_str(), frame_number);
@@ -258,6 +267,11 @@
       frame_number += 1;
       Display::pop_framebuffer();
     }
+
+    if (m_edit_mode)
+    {
+      std::cout << "Time: " << time << std::endl;
+    }
   }
   return 0;
 }

Modified: trunk/windstille/extra/slideshow/slideshow.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slideshow.hpp	2010-08-30 15:06:35 UTC (rev 3342)
+++ trunk/windstille/extra/slideshow/slideshow.hpp	2010-08-30 15:46:36 UTC (rev 3343)
@@ -32,6 +32,7 @@
   std::vector<std::string> m_files;
   std::string m_output_dir;
   float m_fps;
+  bool m_edit_mode;
 
 public:
   App();



From grumbel at mail.berlios.de  Mon Aug 30 19:22:37 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Mon, 30 Aug 2010 19:22:37 +0200
Subject: [Windstille-commit] r3344 - trunk/windstille/extra/slideshow
Message-ID: <20100830172237.879CB480FE3@sheep.berlios.de>

Author: grumbel
Date: 2010-08-30 19:22:37 +0200 (Mon, 30 Aug 2010)
New Revision: 3344

Modified:
   trunk/windstille/extra/slideshow/slide_builder.cpp
   trunk/windstille/extra/slideshow/slide_builder.hpp
Log:
slideshow: added support for variables

Modified: trunk/windstille/extra/slideshow/slide_builder.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.cpp	2010-08-30 15:46:36 UTC (rev 3343)
+++ trunk/windstille/extra/slideshow/slide_builder.cpp	2010-08-30 17:22:37 UTC (rev 3344)
@@ -124,7 +124,8 @@
   m_node_has_pos(false),
   m_node_has_zoom(false),
   //m_path_node(),
-  m_node()
+  m_node(),
+  m_variables()
 {
 }
 
@@ -189,10 +190,31 @@
           std::cout << std::endl;
         }
 
+        // handle variable replacement
+        for(std::vector<std::string>::iterator i = args.begin(); i != args.end(); ++i)
+        {
+          if ((*i)[0] == '$')
+          {
+            Variables::iterator it = m_variables.find(i->substr(1));
+            if (it == m_variables.end())
+            {
+              error("unknown variable: " + *i);
+            }
+            else
+            {
+              *i = it->second;
+            }
+          }
+        }
+
         if (args[0] == "image")
         {
           handle_image(args);
         }
+        else if (args[0] == "set")
+        {
+          handle_set(args);
+        }
         else if (args[0] == "zoom")
         {
           handle_zoom(args);
@@ -520,7 +542,20 @@
 void
 SlideBuilder::handle_include(const std::vector<std::string>& args)
 {
-  
+  std::cout << "include not implemented" << std::endl;
 }
 
+void
+SlideBuilder::handle_set(const std::vector<std::string>& args)
+{
+  if (args.size() != 3)
+  {
+    error("set requires exactly one argument");
+  }
+  else
+  {
+    m_variables[args[1]] = args[2];
+  }
+}
+
 /* EOF */

Modified: trunk/windstille/extra/slideshow/slide_builder.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.hpp	2010-08-30 15:46:36 UTC (rev 3343)
+++ trunk/windstille/extra/slideshow/slide_builder.hpp	2010-08-30 17:22:37 UTC (rev 3344)
@@ -21,6 +21,7 @@
 
 #include <string>
 #include <vector>
+#include <map>
 
 #include "math/size.hpp"
 #include "slideshow/slide_object.hpp"
@@ -157,6 +158,9 @@
   //SlidePathNode m_path_node;
   Node m_node;
 
+  typedef std::map<std::string, std::string> Variables;
+  Variables m_variables;
+
 public:
   SlideBuilder(SlideShow& slideshow, const Sizef& screen_size);
 
@@ -174,6 +178,7 @@
   void handle_end(const std::vector<std::string>& args);
   void handle_breakpoint(const std::vector<std::string>& args);
   void handle_include(const std::vector<std::string>& args);
+  void handle_set(const std::vector<std::string>& args);
 
   void add_node();
 



From grumbel at mail.berlios.de  Mon Aug 30 19:45:15 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Mon, 30 Aug 2010 19:45:15 +0200
Subject: [Windstille-commit] r3345 - trunk/windstille/extra/slideshow
Message-ID: <20100830174516.07C30480FE3@sheep.berlios.de>

Author: grumbel
Date: 2010-08-30 19:45:15 +0200 (Mon, 30 Aug 2010)
New Revision: 3345

Modified:
   trunk/windstille/extra/slideshow/slideshow.cpp
Log:
slideshow: added fast forward

Modified: trunk/windstille/extra/slideshow/slideshow.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slideshow.cpp	2010-08-30 17:22:37 UTC (rev 3344)
+++ trunk/windstille/extra/slideshow/slideshow.cpp	2010-08-30 17:45:15 UTC (rev 3345)
@@ -169,6 +169,7 @@
   int frame_number = 0;
   Uint32 last_ticks = SDL_GetTicks();
   float time = 0.0f;
+  bool fast_forward = false;
   while(loop && !slide_show.done(time))
   {
     SDL_Event event;
@@ -180,8 +181,10 @@
           loop = false;
           break;
 
+        case SDL_KEYUP:
+          break;
+
         case SDL_KEYDOWN:
-        case SDL_KEYUP:
           if (event.key.state)
           {    
             switch (event.key.keysym.sym)
@@ -210,6 +213,10 @@
                 time += 1.0f;
                 break;
 
+              case SDLK_f:
+                fast_forward = !fast_forward;
+                std::cout << fast_forward << std::endl;
+                break;
 
               case SDLK_UP:
                 time += 10.0f;
@@ -237,7 +244,14 @@
 
       if (!pause)
       {
-        time += static_cast<float>(ticks - last_ticks) / 1000.0f;
+        if (fast_forward)
+        {
+          time += (static_cast<float>(ticks - last_ticks) / 1000.0f) * 25.0f;
+        }
+        else
+        {
+          time += static_cast<float>(ticks - last_ticks) / 1000.0f;
+        }
       }
       last_ticks = ticks;
 
@@ -253,7 +267,7 @@
     else
     {
       time += 1.0f/m_fps;
-
+      
       // rendering to output dir
       Display::push_framebuffer(framebuffer);
       glClearColor(0.0f, 0.0f, 0.0f, 1.0f);



From grumbel at mail.berlios.de  Mon Aug 30 21:58:30 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Mon, 30 Aug 2010 21:58:30 +0200
Subject: [Windstille-commit] r3346 - trunk/windstille/extra/slideshow
Message-ID: <20100830195831.06D9B480FE3@sheep.berlios.de>

Author: grumbel
Date: 2010-08-30 21:58:30 +0200 (Mon, 30 Aug 2010)
New Revision: 3346

Modified:
   trunk/windstille/extra/slideshow/slide_show.cpp
   trunk/windstille/extra/slideshow/slide_show.hpp
   trunk/windstille/extra/slideshow/slideshow.cpp
Log:
slideshow: added keyboard shortcuts to jump forward/backward in images and to begin/end of slideshow


Modified: trunk/windstille/extra/slideshow/slide_show.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_show.cpp	2010-08-30 17:45:15 UTC (rev 3345)
+++ trunk/windstille/extra/slideshow/slide_show.cpp	2010-08-30 19:58:30 UTC (rev 3346)
@@ -79,4 +79,49 @@
   slide_builder.load_from_file(filename);
 }
 
+float
+SlideShow::find_next(float time)
+{
+  float best_time = m_length;
+  for(std::vector<SlideObjectPtr>::iterator i = m_objects.begin(); i != m_objects.end(); ++i)
+  {
+    if ((*i)->begin() > time && (*i)->begin() < best_time)
+    {
+      best_time = (*i)->begin();
+    }
+  }
+  return best_time;
+}
+
+float
+SlideShow::find_prev(float time)
+{
+  float best_time = 0.0f;
+  
+  // find the start of the current object
+  for(std::vector<SlideObjectPtr>::iterator i = m_objects.begin(); i != m_objects.end(); ++i)
+  {
+    if ((*i)->begin() < time && (*i)->begin() > best_time)
+    {
+      best_time = (*i)->begin();
+    }
+  }
+
+  if (true /* FIXME: not_last_object */ )
+  {
+    // find the start of the object before the current object
+    time = best_time;
+    best_time = 0.0f;
+    for(std::vector<SlideObjectPtr>::iterator i = m_objects.begin(); i != m_objects.end(); ++i)
+    {
+      if ((*i)->begin() < time && (*i)->begin() > best_time)
+      {
+        best_time = (*i)->begin();
+      }
+    }
+  }
+
+  return best_time;
+}
+
 /* EOF */

Modified: trunk/windstille/extra/slideshow/slide_show.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_show.hpp	2010-08-30 17:45:15 UTC (rev 3345)
+++ trunk/windstille/extra/slideshow/slide_show.hpp	2010-08-30 19:58:30 UTC (rev 3346)
@@ -36,6 +36,7 @@
 
   bool done(float time) const;
 
+  float length() const { return m_length; }
   int size() const;
 
   void add(SlideObjectPtr object);
@@ -43,6 +44,10 @@
 
   void load(const std::string& filename, const Sizef& aspect);
 
+  /** search for the start time of the next SlideObject, starting from time */
+  float find_next(float time);
+  float find_prev(float time);
+
 private:
   SlideShow(const SlideShow&);
   SlideShow& operator=(const SlideShow&);

Modified: trunk/windstille/extra/slideshow/slideshow.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slideshow.cpp	2010-08-30 17:45:15 UTC (rev 3345)
+++ trunk/windstille/extra/slideshow/slideshow.cpp	2010-08-30 19:58:30 UTC (rev 3346)
@@ -170,7 +170,7 @@
   Uint32 last_ticks = SDL_GetTicks();
   float time = 0.0f;
   bool fast_forward = false;
-  while(loop && !slide_show.done(time))
+  while(loop && (!slide_show.done(time) || m_edit_mode))
   {
     SDL_Event event;
     while(SDL_PollEvent(&event))
@@ -213,6 +213,22 @@
                 time += 1.0f;
                 break;
 
+              case SDLK_HOME:
+                time = 0.0f;
+                break;
+
+              case SDLK_END:
+                time = slide_show.length();
+                break;
+
+              case SDLK_PAGEUP:
+                time = slide_show.find_prev(time);
+                break;
+
+              case SDLK_PAGEDOWN:
+                time = slide_show.find_next(time);
+                break;
+
               case SDLK_f:
                 fast_forward = !fast_forward;
                 std::cout << fast_forward << std::endl;



From grumbel at mail.berlios.de  Mon Aug 30 23:13:50 2010
From: grumbel at mail.berlios.de (grumbel at mail.berlios.de)
Date: Mon, 30 Aug 2010 23:13:50 +0200
Subject: [Windstille-commit] r3347 - trunk/windstille/extra/slideshow
Message-ID: <20100830211350.60126480FE3@sheep.berlios.de>

Author: grumbel
Date: 2010-08-30 23:13:50 +0200 (Mon, 30 Aug 2010)
New Revision: 3347

Modified:
   trunk/windstille/extra/slideshow/slideshow.cpp
   trunk/windstille/extra/slideshow/slideshow.hpp
Log:
slideshow: added --start option to select startup time


Modified: trunk/windstille/extra/slideshow/slideshow.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slideshow.cpp	2010-08-30 19:58:30 UTC (rev 3346)
+++ trunk/windstille/extra/slideshow/slideshow.cpp	2010-08-30 21:13:50 UTC (rev 3347)
@@ -22,6 +22,7 @@
 
 #include <sstream>
 #include <stdexcept>
+#include <boost/lexical_cast.hpp>
 
 #include "util/command_line.hpp"
 #include "display/opengl_window.hpp"
@@ -43,7 +44,8 @@
   m_files(),
   m_output_dir(),
   m_fps(25.0f),
-  m_edit_mode(false)
+  m_edit_mode(false),
+  m_start_time(0.0f)
 {
 }
 
@@ -80,6 +82,7 @@
   argp.add_option('b', "breakpoint", "POINT", "Start at POINT");
   argp.add_option('F', "fps", "FPS", "Generate FPS frames per seconds");
   argp.add_option('o', "output", "DIR", "Write screenshots to DIR");
+  argp.add_option('s', "start", "SEC", "Time where the playback should start");
   argp.add_option('h', "help", "", "Print help");
 
   argp.parse_args(argc, argv);
@@ -113,6 +116,10 @@
       case 'b':
         break;
 
+      case 's':
+        m_start_time = boost::lexical_cast<float>(argp.get_argument());
+        break;
+
       case 'o':
         m_output_dir = argp.get_argument();
         break;
@@ -168,7 +175,7 @@
 
   int frame_number = 0;
   Uint32 last_ticks = SDL_GetTicks();
-  float time = 0.0f;
+  float time = m_start_time;
   bool fast_forward = false;
   while(loop && (!slide_show.done(time) || m_edit_mode))
   {

Modified: trunk/windstille/extra/slideshow/slideshow.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slideshow.hpp	2010-08-30 19:58:30 UTC (rev 3346)
+++ trunk/windstille/extra/slideshow/slideshow.hpp	2010-08-30 21:13:50 UTC (rev 3347)
@@ -33,6 +33,7 @@
   std::string m_output_dir;
   float m_fps;
   bool m_edit_mode;
+  float m_start_time;
 
 public:
   App();



