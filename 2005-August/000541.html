<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Windstille-commit] r888 - in trunk/src: . collision scripting signals
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/windstille-commit/2005-August/index.html" >
   <LINK REL="made" HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r888%20-%20in%20trunk/src%3A%20.%20collision%20scripting%20signals&In-Reply-To=%3C200508032333.j73NXowC001454%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000540.html">
   <LINK REL="Next"  HREF="000542.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Windstille-commit] r888 - in trunk/src: . collision scripting signals</H1>
    <B>Ingo Ruhnke at BerliOS</B> 
    <A HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r888%20-%20in%20trunk/src%3A%20.%20collision%20scripting%20signals&In-Reply-To=%3C200508032333.j73NXowC001454%40sheep.berlios.de%3E"
       TITLE="[Windstille-commit] r888 - in trunk/src: . collision scripting signals">grumbel at berlios.de
       </A><BR>
    <I>Thu Aug  4 01:33:50 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000540.html">[Windstille-commit] r887 - in trunk/data: . images/tiles levels
</A></li>
        <LI>Next message: <A HREF="000542.html">[Windstille-commit] r889 - in trunk/src: . scripting
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#541">[ date ]</a>
              <a href="thread.html#541">[ thread ]</a>
              <a href="subject.html#541">[ subject ]</a>
              <a href="author.html#541">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: grumbel
Date: 2005-08-04 01:33:16 +0200 (Thu, 04 Aug 2005)
New Revision: 888

Added:
   trunk/src/signals/
   trunk/src/signals/signal.hpp
   trunk/src/signals/signal_v0.hpp
   trunk/src/signals/signal_v1.hpp
   trunk/src/signals/signal_v2.hpp
   trunk/src/signals/signal_v3.hpp
   trunk/src/signals/signal_v4.hpp
   trunk/src/signals/signal_v5.hpp
   trunk/src/signals/signals.hpp
   trunk/src/signals/slot.cpp
   trunk/src/signals/slot.hpp
   trunk/src/signals/slot_generic.cpp
   trunk/src/signals/slot_generic.hpp
   trunk/src/signals/slot_v0.hpp
   trunk/src/signals/slot_v1.hpp
   trunk/src/signals/slot_v2.hpp
   trunk/src/signals/slot_v3.hpp
   trunk/src/signals/slot_v4.hpp
   trunk/src/signals/slot_v5.hpp
   trunk/src/signals/slotbuffer_v0.hpp
   trunk/src/signals/slotbuffer_v1.hpp
Modified:
   trunk/src/Jamfile
   trunk/src/box.hpp
   trunk/src/collision/collision_object.hpp
   trunk/src/entity.hpp
   trunk/src/player.hpp
   trunk/src/screen.hpp
   trunk/src/scripting/wrapper.cpp
   trunk/src/scripting/wrapper.hpp
Log:
- copied ClanLibs signal code over to windstille

Modified: trunk/src/Jamfile
===================================================================
--- trunk/src/Jamfile	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/Jamfile	2005-08-03 23:33:16 UTC (rev 888)
@@ -15,6 +15,7 @@
 SubInclude TOP src collision ;
 SubInclude TOP src particles ;
 SubInclude TOP src math ;
+SubInclude TOP src signals ;
 
 sources = 
         baby_xml.cpp
@@ -135,6 +136,8 @@
 
         $(math_objects)
 
+        $(signals_objects)
+
         $(sources)
 ;
 

Modified: trunk/src/box.hpp
===================================================================
--- trunk/src/box.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/box.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -32,7 +32,7 @@
 private:
   Sprite sprite;
   CollisionObject* colobj;
-  CL_Slot slot;
+  Slot slot;
   float gravity;
 
 public:

Modified: trunk/src/collision/collision_object.hpp
===================================================================
--- trunk/src/collision/collision_object.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/collision/collision_object.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -22,7 +22,7 @@
 #ifndef HEADER_COLLISION_OBJECT_HPP
 #define HEADER_COLLISION_OBJECT_HPP
 
-#include &lt;ClanLib/core.h&gt;
+#include &quot;signals/signals.hpp&quot;
 #include &quot;math/vector.hpp&quot;
 #include &quot;math/rect.hpp&quot;
 #include &quot;collision_data.hpp&quot;
@@ -53,7 +53,7 @@
 
   GameObject* game_object;
 
-  CL_Signal_v2&lt;const CollisionData &amp;, CollisionObject &amp;&gt; collision;
+  Signal_v2&lt;const CollisionData &amp;, CollisionObject &amp;&gt; collision;
 
   Rectf primitive;
   TileMap* tilemap;
@@ -107,7 +107,7 @@
   void set_unstuck(bool s) { is_unstuckable = s; }
   void set_unstuck_movable(bool s) { is_unstuck_movable = s; }
 
-  CL_Signal_v2&lt;const CollisionData &amp;, CollisionObject &amp;&gt;&amp; sig_collision() { return collision; }
+  Signal_v2&lt;const CollisionData &amp;, CollisionObject &amp;&gt;&amp; sig_collision() { return collision; }
 
   friend class CollisionEngine;
 };

Modified: trunk/src/entity.hpp
===================================================================
--- trunk/src/entity.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/entity.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -26,6 +26,7 @@
 #ifndef HEADER_ENTITY_HXX
 #define HEADER_ENTITY_HXX
 
+#include &quot;signals/signal_v0.hpp&quot;
 #include &quot;math/vector.hpp&quot;
 #include &quot;game_object.hpp&quot;
 #include &quot;collision/collision_object.hpp&quot;
@@ -35,7 +36,7 @@
 class Entity : public GameObject
 {
 private:
-  CL_Signal_v0 done; 
+  Signal_v0 done; 
 
 protected:
   bool on_ground() const;
@@ -75,7 +76,7 @@
 
   void set_parent(Entity* parent_);
 
-  CL_Signal_v0&amp; sig_done() { return done; }
+  Signal_v0&amp; sig_done() { return done; }
 
 private:
   Entity (const Entity&amp;);

Modified: trunk/src/player.hpp
===================================================================
--- trunk/src/player.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/player.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -48,7 +48,7 @@
   int energy;
 
   CollisionObject* c_object;
-  CL_Slot slot;
+  Slot slot;
 
 public:
   enum State

Modified: trunk/src/screen.hpp
===================================================================
--- trunk/src/screen.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/screen.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -20,6 +20,8 @@
 #ifndef HEADER_SCREEN_HXX
 #define HEADER_SCREEN_HXX
 
+#include &quot;signals/slot.hpp&quot;
+
 class CL_InputEvent;
 
 namespace Windstille {

Modified: trunk/src/scripting/wrapper.cpp
===================================================================
--- trunk/src/scripting/wrapper.cpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/scripting/wrapper.cpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -1,6 +1,6 @@
 /**
  * WARNING: This file is automatically generated from:
- *  'src/scripting/wrapper.interface.hpp'
+ *  'scripting/wrapper.interface.hpp'
  * DO NOT CHANGE
  */
 #include &lt;config.h&gt;

Modified: trunk/src/scripting/wrapper.hpp
===================================================================
--- trunk/src/scripting/wrapper.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/scripting/wrapper.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -1,6 +1,6 @@
 /**
  * WARNING: This file is automatically generated from:
- *  'src/scripting/wrapper.interface.hpp'
+ *  'scripting/wrapper.interface.hpp'
  * DO NOT CHANGE
  */
 #ifndef __windstille_WRAPPER_H__

Added: trunk/src/signals/signal.hpp
===================================================================
--- trunk/src/signals/signal.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/signal.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,55 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SIGNAL_HPP
+#define HEADER_SIGNALS_SIGNAL_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class Slot;
+
+//: Parent class for all signal types.
+class Signal
+{
+//! Construction:
+public:
+	virtual ~Signal() { return; }
+
+//! Operations:
+public:
+	//: Disconnect
+	virtual void disconnect(Slot &amp;disconnect_slot)=0;
+};
+
+#endif

Added: trunk/src/signals/signal_v0.hpp
===================================================================
--- trunk/src/signals/signal_v0.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/signal_v0.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,279 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SIGNAL_V0_HPP
+#define HEADER_SIGNALS_SIGNAL_V0_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning ( disable : 4786 )
+#pragma warning ( disable : 4355 ) // warning C4355: 'this' : used in base member initializer list
+#endif
+
+#include &quot;signal.hpp&quot;
+#include &quot;slot.hpp&quot;
+#include &quot;slot_v0.hpp&quot;
+#include &lt;list&gt;
+#include &lt;algorithm&gt;
+
+//: CL Signal v0 class
+//- !group=Signal/System!
+//- !header=signals.h!
+class Signal_v0 : public Signal
+{
+public:
+	typedef Slot_v0 *Slot;
+	typedef std::list&lt;Slot&gt;::iterator SlotIterator;
+
+	class Signal_v0_Generic
+	{
+	public:
+		Signal_v0_Generic(Signal_v0 *owner) : in_call(false), deleted(false), in_call_remove_slots(0), owner(owner) { return; }
+
+		~Signal_v0_Generic()
+		{
+			for (SlotIterator slot_it = slots.begin(); slot_it != slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+				slot-&gt;release_signal_ref(owner);
+			}
+		}
+
+		bool in_call, deleted;
+		std::list&lt;SlotIterator&gt; *in_call_remove_slots;
+		std::list&lt;Slot&gt; slots;
+		Signal_v0 *owner;
+	};
+
+//! Construction:
+public:
+	//: CL Signal v0 constructor
+	Signal_v0() : impl(new Signal_v0_Generic(this))
+	{
+	}
+
+	Signal_v0(const Signal_v0 &amp;copy) : Signal(copy), impl(new Signal_v0_Generic(this))
+	{
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+	}
+
+	//: CL Signal v0 destructor
+	~Signal_v0()
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+	}
+
+//! Operations:
+public:
+	Signal_v0 &amp;operator =(const Signal_v0 &amp;copy)
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+
+		impl = new Signal_v0_Generic(this);
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+		return *this;
+	}
+
+	//: Operator
+	void operator() ()
+	{
+		call();
+	}
+
+	//: Call
+	void call()
+	{
+		Signal_v0_Generic *data = impl;
+		data-&gt;in_call = true;
+
+		std::list&lt;SlotIterator&gt; remove_slots;
+		try
+		{
+			data-&gt;in_call_remove_slots = &amp;remove_slots;
+
+			// call slots connected to signal:
+			SlotParent_v0 super(data-&gt;slots.begin(), data-&gt;slots.end());
+			super();
+		}
+		catch(...)
+		{
+			catch_final(data, remove_slots);
+			throw;
+		}
+
+		catch_final(data, remove_slots);
+	}
+
+	//: Connect slot.
+	::Slot connect(Slot slot)
+	{
+		slot-&gt;add_signal_ref(this);
+		impl-&gt;slots.push_front(slot);
+		return ::Slot(slot);
+	}
+
+	//: Connect callback function slot.
+	::Slot connect(void (*callback)())
+	{
+		return connect(new FunctionSlot_v0(callback, 0));
+	}
+
+	//: Connect virtual callback function slot.
+	::Slot connect_virtual(void (*virtual_callback)(SlotParent_v0 &amp;))
+	{
+		return connect(new FunctionSlot_v0(0, virtual_callback));
+	}
+
+	//: Connect functor slot.
+	template&lt;class Functor&gt;
+	::Slot connect_functor(const Functor &amp;functor)
+	{
+		return connect(new FunctorSlot_v0&lt;Functor&gt;(functor));
+	}
+
+	//: Connect virtual functor slot.
+	template&lt;class Functor&gt;
+	::Slot connect_functor_virtual(const Functor &amp;functor)
+	{
+		return connect(new FunctorVirtualSlot_v0&lt;Functor&gt;(functor));
+	}
+
+	//: Connect member function slot.
+	template &lt;class CallbackClass&gt;
+	::Slot connect(CallbackClass *cb_class, void (CallbackClass::*callback)())
+	{
+		return connect(new MethodSlot_v0&lt;CallbackClass&gt;(cb_class, callback, 0));
+	}
+
+	//: Connect virtual member function slot.
+	template &lt;class CallbackClass&gt;
+	::Slot connect_virtual(CallbackClass *cb_class, void (CallbackClass::*virtual_callback)(SlotParent_v0 &amp;))
+	{
+		return connect(new MethodSlot_v0&lt;CallbackClass&gt;(cb_class, 0, virtual_callback));
+	}
+
+	//: Connect member function with user data slot.
+	template &lt;class CallbackClass, class UserData&gt;
+	::Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(UserData),
+		UserData user_data)
+	{
+		return connect(new UserDataMethodSlot_v0&lt;CallbackClass, UserData&gt;(cb_class, callback, 0, user_data));
+	}
+
+	//: Create virtual member function with user data slot.
+	template &lt;class CallbackClass, class UserData&gt;
+	::Slot connect_virtual(
+		CallbackClass *cb_class,
+		void (CallbackClass::*virtual_callback)(SlotParent_v0 &amp;, UserData),
+		UserData user_data)
+	{
+		return connect(new UserDataMethodSlot_v0&lt;CallbackClass, UserData&gt;(cb_class, 0, virtual_callback, user_data));
+	}
+
+	//: Disconnect
+	void disconnect(::Slot &amp;disconnect_slot)
+	{
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end();)
+		{
+			Slot slot = *slot_it;
+			if (disconnect_slot.impl == slot)
+			{
+				if (impl-&gt;in_call)
+				{
+					impl-&gt;in_call_remove_slots-&gt;push_back(slot_it);
+					++slot_it;
+				}
+				else
+				{
+					slot-&gt;release_signal_ref(this);
+					slot_it = impl-&gt;slots.erase(slot_it);
+				}
+			}
+			else
+				++slot_it;
+		}
+	}
+
+//! Implementation:
+private:
+	void catch_final(Signal_v0_Generic *data, std::list&lt;SlotIterator&gt; &amp;remove_slots)
+	{
+		data-&gt;in_call_remove_slots = 0;
+
+		// find slots to be removed:
+		for (SlotIterator slot_it = data-&gt;slots.begin(); slot_it != data-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+
+			// skip slot if it has no more references left in application.
+			// (make it pending for removal)
+			if (slot-&gt;get_slot_ref() == 0 &amp;&amp; slot-&gt;is_persistent() == false)
+			{
+				if (std::find(remove_slots.begin(), remove_slots.end(), slot_it)==remove_slots.end())
+					remove_slots.push_back(slot_it);
+			}
+		}
+
+		// remove all slots no longer connected to any Slot.
+		std::list&lt;SlotIterator&gt;::iterator remove_it;
+		for (remove_it = remove_slots.begin(); remove_it != remove_slots.end(); remove_it++)
+		{
+			Slot slot = **remove_it;
+			slot-&gt;release_signal_ref(this);
+			data-&gt;slots.erase(*remove_it);
+		}
+
+		data-&gt;in_call = false;
+		if (data-&gt;deleted) delete data;
+	}
+
+	Signal_v0_Generic *impl;
+};
+
+#endif

Added: trunk/src/signals/signal_v1.hpp
===================================================================
--- trunk/src/signals/signal_v1.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/signal_v1.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,257 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SIGNAL_V1_HPP
+#define HEADER_SIGNALS_SIGNAL_V1_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning ( disable : 4786 )
+#pragma warning ( disable : 4355 ) // warning C4355: 'this' : used in base member initializer list
+#endif
+
+#include &quot;signal.hpp&quot;
+#include &quot;slot.hpp&quot;
+#include &quot;slot_v1.hpp&quot;
+#include &lt;list&gt;
+#include &lt;algorithm&gt;
+
+//: CL Signal V1 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1&gt;
+class Signal_v1 : public Signal
+{
+public:
+	typedef Slot_v1&lt;PARAM1&gt; *Slot;
+	typedef typename std::list&lt;Slot&gt;::iterator SlotIterator;
+
+	class Signal_v1_Generic
+	{
+	public:
+		Signal_v1_Generic(Signal_v1 *owner) : in_call(false), deleted(false), in_call_remove_slots(0), owner(owner) { return; }
+
+		~Signal_v1_Generic()
+		{
+			for (SlotIterator slot_it = slots.begin(); slot_it != slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+				slot-&gt;release_signal_ref(owner);
+			}
+		}
+
+		bool in_call, deleted;
+		std::list&lt;SlotIterator&gt; *in_call_remove_slots;
+		std::list&lt;Slot&gt; slots;
+		Signal_v1 *owner;
+	};
+
+//! Construction:
+public:
+	//: CL Signal V1 constructor
+	Signal_v1() : impl(new Signal_v1_Generic(this))
+	{
+	}
+
+	Signal_v1(const Signal_v1 &amp;copy) : Signal(copy), impl(new Signal_v1_Generic(this))
+	{
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+	}
+
+	//: CL Signal V1 destructor
+	~Signal_v1()
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+	}
+
+//! Attributes:
+public:
+	bool has_slots_connected() const
+	{
+		return !impl-&gt;slots.empty();
+	}
+
+//! Operations:
+public:
+	Signal_v1 &amp;operator =(const Signal_v1 &amp;copy)
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+
+		impl = new Signal_v1_Generic(this);
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+		return *this;
+	}
+
+	//: Operator
+	void operator() (PARAM1 param1)
+	{
+		call(param1);
+	}
+
+	//: Call
+	void call(PARAM1 param1)
+	{
+		Signal_v1_Generic *data = impl;
+		data-&gt;in_call = true;
+
+		std::list&lt;SlotIterator&gt; remove_slots;
+		try
+		{
+			data-&gt;in_call_remove_slots = &amp;remove_slots;
+			
+			// call slots connected to signal:
+			for (SlotIterator slot_it = data-&gt;slots.begin(); slot_it != data-&gt;slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+
+				// skip slot if it has no more references left in application.
+				// (make it pending for removal)
+				if (slot-&gt;get_slot_ref() == 0 &amp;&amp; slot-&gt;is_persistent() == false)
+				{
+					if (std::find(remove_slots.begin(), remove_slots.end(), slot_it)==remove_slots.end())
+						remove_slots.push_back(slot_it);
+				}
+				
+				slot-&gt;call(param1);
+				if (data-&gt;deleted) break;
+			}
+		}
+		catch (...)
+		{
+			catch_final(data, remove_slots);
+			throw;
+		}
+		catch_final(data, remove_slots);
+	}
+
+	//: Connect slot.
+	::Slot connect(Slot slot)
+	{
+		slot-&gt;add_signal_ref(this);
+		impl-&gt;slots.push_back(slot);
+		return ::Slot(slot);
+	}
+
+	//: Connect callback function slot.
+	::Slot connect(void (*callback)(PARAM1))
+	{
+		return connect(new FunctionSlot_v1&lt;PARAM1&gt;(callback));
+	}
+
+	//: Connect functor slot.
+	template&lt;class Functor&gt;
+	::Slot connect_functor(const Functor &amp;functor)
+	{
+		return connect(new FunctorSlot_v1&lt;Functor, PARAM1&gt;(functor));
+	}
+
+	//: Connect member function slot.
+	template &lt;class CallbackClass&gt;
+	::Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1))
+	{
+		return connect(new MethodSlot_v1&lt;CallbackClass, PARAM1&gt;(cb_class, callback));
+	}
+
+	//: Connect member function with user data slot.
+	template &lt;class CallbackClass, class UserData&gt;
+	::Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, UserData),
+		UserData user_data)
+	{
+		return connect(new UserDataMethodSlot_v1&lt;CallbackClass, PARAM1, UserData&gt;(cb_class, callback, user_data));
+	}
+
+	//: Disconnect
+	void disconnect(::Slot &amp;disconnect_slot)
+	{
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end();)
+		{
+			Slot slot = *slot_it;
+			if (disconnect_slot.impl == slot)
+			{
+				if (impl-&gt;in_call)
+				{
+					impl-&gt;in_call_remove_slots-&gt;push_back(slot_it);
+					++slot_it;
+				}
+				else
+				{
+					slot-&gt;release_signal_ref(this);
+					slot_it = impl-&gt;slots.erase(slot_it);
+				}
+			}
+			else
+				++slot_it;
+		}
+	}
+
+//! Implementation:
+private:
+	void catch_final(Signal_v1_Generic *data, std::list&lt;SlotIterator&gt; &amp;remove_slots)
+	{
+		data-&gt;in_call_remove_slots = 0;
+
+		// remove all slots no longer connected to any Slot.
+		typename std::list&lt;SlotIterator&gt;::iterator remove_it;
+		for (remove_it = remove_slots.begin(); remove_it != remove_slots.end(); remove_it++)
+		{
+			Slot slot = **remove_it;
+			slot-&gt;release_signal_ref(this);
+			data-&gt;slots.erase(*remove_it);
+		}
+
+		data-&gt;in_call = false;
+		if (data-&gt;deleted) delete data;
+	}
+
+	Signal_v1_Generic *impl;
+};
+
+#endif

Added: trunk/src/signals/signal_v2.hpp
===================================================================
--- trunk/src/signals/signal_v2.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/signal_v2.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,257 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SIGNAL_V2_HPP
+#define HEADER_SIGNALS_SIGNAL_V2_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning ( disable : 4786 )
+#pragma warning ( disable : 4355 ) // warning C4355: 'this' : used in base member initializer list
+#endif
+
+#include &lt;list&gt;
+#include &lt;algorithm&gt;
+#include &quot;signal.hpp&quot;
+#include &quot;slot.hpp&quot;
+#include &quot;slot_v2.hpp&quot;
+
+//: Signal V2 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2&gt;
+class Signal_v2 : public Signal
+{
+public:
+	typedef Slot_v2&lt;PARAM1, PARAM2&gt; *Slot;
+	typedef typename std::list&lt;Slot&gt;::iterator SlotIterator;
+
+	class Signal_v2_Generic
+	{
+	public:
+		Signal_v2_Generic(Signal_v2 *owner) : in_call(false), deleted(false), in_call_remove_slots(0), owner(owner) { return; }
+
+		~Signal_v2_Generic()
+		{
+			for (SlotIterator slot_it = slots.begin(); slot_it != slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+				slot-&gt;release_signal_ref(owner);
+			}
+		}
+
+		bool in_call, deleted;
+		std::list&lt;SlotIterator&gt; *in_call_remove_slots;
+		std::list&lt;Slot&gt; slots;
+		Signal_v2 *owner;
+	};
+
+//! Construction:
+public:
+	//: Signal V2 Constructor
+	Signal_v2() : impl(new Signal_v2_Generic(this))
+	{
+	}
+
+	Signal_v2(const Signal_v2 &amp;copy) : Signal(copy), impl(new Signal_v2_Generic(this))
+	{
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+	}
+
+	//: Signal V2 Destructor
+	~Signal_v2()
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+	}
+
+//! Attributes:
+public:
+	bool has_slots_connected() const
+	{
+		return !impl-&gt;slots.empty();
+	}
+
+//! Operations:
+public:
+	Signal_v2 &amp;operator =(const Signal_v2 &amp;copy)
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+
+		impl = new Signal_v2_Generic(this);
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+		return *this;
+	}
+
+	//: Operator
+	void operator() (PARAM1 param1, PARAM2 param2)
+	{
+		call(param1, param2);
+	}
+
+	//: Call
+	void call(PARAM1 param1, PARAM2 param2)
+	{
+		Signal_v2_Generic *data = impl;
+		data-&gt;in_call = true;
+
+		std::list&lt;SlotIterator&gt; remove_slots;
+		try
+		{
+			data-&gt;in_call_remove_slots = &amp;remove_slots;
+
+			// call slots connected to signal:
+			for (SlotIterator slot_it = data-&gt;slots.begin(); slot_it != data-&gt;slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+	
+				// skip slot if it has no more references left in application.
+				// (make it pending for removal)
+				if (slot-&gt;get_slot_ref() == 0 &amp;&amp; slot-&gt;is_persistent() == false)
+				{
+					if (std::find(remove_slots.begin(), remove_slots.end(), slot_it)==remove_slots.end())
+						remove_slots.push_back(slot_it);
+				}
+			
+				slot-&gt;call(param1, param2);
+				if (data-&gt;deleted) break;
+			}
+		}
+		catch (...)
+		{
+			catch_final(data, remove_slots);
+			throw;
+		}
+		catch_final(data, remove_slots);
+	}
+
+	//: Connect slot.
+	::Slot connect(Slot slot)
+	{
+		slot-&gt;add_signal_ref(this);
+		impl-&gt;slots.push_back(slot);
+		return ::Slot(slot);
+	}
+
+	//: Connect callback function slot.
+	::Slot connect(void (*callback)(PARAM1, PARAM2))
+	{
+		return connect(new FunctionSlot_v2&lt;PARAM1, PARAM2&gt;(callback));
+	}
+
+	//: Connect functor slot.
+	template&lt;class Functor&gt;
+	::Slot connect_functor(const Functor &amp;functor)
+	{
+		return connect(new FunctorSlot_v2&lt;Functor, PARAM1, PARAM2&gt;(functor));
+	}
+
+	//: Connect member function slot.
+	template &lt;class CallbackClass&gt;
+	::Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2))
+	{
+		return connect(new MethodSlot_v2&lt;CallbackClass, PARAM1, PARAM2&gt;(cb_class, callback));
+	}
+
+	//: Connect member function with user data slot.
+	template &lt;class CallbackClass, class UserData&gt;
+	::Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2, UserData),
+		UserData user_data)
+	{
+		return connect(new UserDataMethodSlot_v2&lt;CallbackClass, PARAM1, PARAM2, UserData&gt;(cb_class, callback, user_data));
+	}
+
+	//: Disconnect
+	void disconnect(::Slot &amp;disconnect_slot)
+	{
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end();)
+		{
+			Slot slot = *slot_it;
+			if (disconnect_slot.impl == slot)
+			{
+				if (impl-&gt;in_call)
+				{
+					impl-&gt;in_call_remove_slots-&gt;push_back(slot_it);
+					++slot_it;
+				}
+				else
+				{
+					slot-&gt;release_signal_ref(this);
+					slot_it = impl-&gt;slots.erase(slot_it);
+				}
+			}
+			else
+				++slot_it;
+		}
+	}
+
+//! Implementation:
+private:
+	void catch_final(Signal_v2_Generic *data, std::list&lt;SlotIterator&gt; &amp;remove_slots)
+	{
+		data-&gt;in_call_remove_slots = 0;
+
+		// remove all slots no longer connected to any Slot.
+		typename std::list&lt;SlotIterator&gt;::iterator remove_it;
+		for (remove_it = remove_slots.begin(); remove_it != remove_slots.end(); remove_it++)
+		{
+			Slot slot = **remove_it;
+			slot-&gt;release_signal_ref(this);
+			data-&gt;slots.erase(*remove_it);
+		}
+
+		data-&gt;in_call = false;
+		if (data-&gt;deleted) delete data;
+	}
+
+	Signal_v2_Generic *impl;
+};
+
+#endif

Added: trunk/src/signals/signal_v3.hpp
===================================================================
--- trunk/src/signals/signal_v3.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/signal_v3.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,256 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SIGNAL_V3_HPP
+#define HEADER_SIGNALS_SIGNAL_V3_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning ( disable : 4786 )
+#pragma warning ( disable : 4355 ) // warning C4355: 'this' : used in base member initializer list
+#endif
+
+#include &quot;signal.hpp&quot;
+#include &quot;slot.hpp&quot;
+#include &quot;slot_v3.hpp&quot;
+#include &lt;list&gt;
+
+//: Signal V3 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3&gt;
+class Signal_v3 : public Signal
+{
+public:
+	typedef Slot_v3&lt;PARAM1, PARAM2, PARAM3&gt; *Slot;
+	typedef typename std::list&lt;Slot&gt;::iterator SlotIterator;
+
+	class Signal_v3_Generic
+	{
+	public:
+		Signal_v3_Generic(Signal_v3 *owner) : in_call(false), deleted(false), in_call_remove_slots(0), owner(owner) { return; }
+
+		~Signal_v3_Generic()
+		{
+			for (SlotIterator slot_it = slots.begin(); slot_it != slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+				slot-&gt;release_signal_ref(this-&gt;owner);
+			}
+		}
+
+		bool in_call, deleted;
+		std::list&lt;SlotIterator&gt; *in_call_remove_slots;
+		std::list&lt;Slot&gt; slots;
+		Signal_v3 *owner;
+	};
+
+//! Construction:
+public:
+	//: Signal V3 Constructor
+	Signal_v3() : impl(new Signal_v3_Generic(this))
+	{
+	}
+
+	Signal_v3(const Signal_v3 &amp;copy) : Signal(copy), impl(new Signal_v3_Generic(this))
+	{
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this-&gt;owner);
+		}
+	}
+
+	//: Signal V3 Destructor
+	~Signal_v3()
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+	}
+
+//! Attributes:
+public:
+	bool has_slots_connected() const
+	{
+		return !impl-&gt;slots.empty();
+	}
+
+//! Operations:
+public:
+	Signal_v3 &amp;operator =(const Signal_v3 &amp;copy)
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+
+		impl = new Signal_v3_Generic(this);
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+		return *this;
+	}
+
+	//: Operator
+	void operator() (PARAM1 param1, PARAM2 param2, PARAM3 param3)
+	{
+		call(param1, param2, param3);
+	}
+
+	//: Call
+	void call(PARAM1 param1, PARAM2 param2, PARAM3 param3)
+	{
+		Signal_v3_Generic *data = impl;
+		data-&gt;in_call = true;
+
+		std::list&lt;SlotIterator&gt; remove_slots;
+		try
+		{
+			data-&gt;in_call_remove_slots = &amp;remove_slots;
+
+			// call slots connected to signal:
+			for (SlotIterator slot_it = data-&gt;slots.begin(); slot_it != data-&gt;slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+
+				// skip slot if it has no more references left in application.
+				// (make it pending for removal)
+				if (slot-&gt;get_slot_ref() == 0 &amp;&amp; slot-&gt;is_persistent() == false)
+				{
+					if (std::find(remove_slots.begin(), remove_slots.end(), slot_it)==remove_slots.end())
+						remove_slots.push_back(slot_it);
+				}
+			
+				slot-&gt;call(param1, param2, param3);
+				if (data-&gt;deleted) break;
+			}
+		}
+		catch (...)
+		{
+			catch_final(data, remove_slots);
+			throw;
+		}
+		catch_final(data, remove_slots);
+	}
+
+	//: Connect slot.
+	::Slot connect(Slot slot)
+	{
+		slot-&gt;add_signal_ref(this);
+		impl-&gt;slots.push_back(slot);
+		return ::Slot(slot);
+	}
+
+	//: Connect callback function slot.
+	::Slot connect(void (*callback)(PARAM1, PARAM2, PARAM3))
+	{
+		return connect(new FunctionSlot_v3&lt;PARAM1,PARAM2,PARAM3&gt;(callback));
+	}
+
+	//: Connect functor slot.
+	template&lt;class Functor&gt;
+	::Slot connect_functor(const Functor &amp;functor)
+	{
+		return connect(new FunctorSlot_v3&lt;Functor, PARAM1, PARAM2, PARAM3&gt;(functor));
+	}
+
+	//: Connect member function slot.
+	template &lt;class CallbackClass&gt;
+	::Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2, PARAM3))
+	{
+		return connect(new MethodSlot_v3&lt;CallbackClass, PARAM1, PARAM2, PARAM3&gt;(cb_class, callback));
+	}
+
+	//: Connect member function with user data slot.
+	template &lt;class CallbackClass, class UserData&gt;
+	::Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2, PARAM3, UserData),
+		UserData user_data)
+	{
+		return connect(new UserDataMethodSlot_v3&lt;CallbackClass, PARAM1, PARAM2, PARAM3, UserData&gt;(cb_class, callback, user_data));
+	}
+
+	//: Disconnect
+	void disconnect(::Slot &amp;disconnect_slot)
+	{
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end();)
+		{
+			Slot slot = *slot_it;
+			if (disconnect_slot.impl == slot)
+			{
+				if (impl-&gt;in_call)
+				{
+					impl-&gt;in_call_remove_slots-&gt;push_back(slot_it);
+					++slot_it;
+				}
+				else
+				{
+					slot-&gt;release_signal_ref(this);
+					slot_it = impl-&gt;slots.erase(slot_it);
+				}
+			}
+			else
+				++slot_it;
+		}
+	}
+
+//! Implementation:
+private:
+	void catch_final(Signal_v3_Generic *data, std::list&lt;SlotIterator&gt; &amp;remove_slots)
+	{
+		data-&gt;in_call_remove_slots = 0;
+
+		// remove all slots no longer connected to any Slot.
+		typename std::list&lt;SlotIterator&gt;::iterator remove_it;
+		for (remove_it = remove_slots.begin(); remove_it != remove_slots.end(); remove_it++)
+		{
+			Slot slot = **remove_it;
+			slot-&gt;release_signal_ref(this);
+			data-&gt;slots.erase(*remove_it);
+		}
+
+		data-&gt;in_call = false;
+		if (data-&gt;deleted) delete data;
+	}
+
+	Signal_v3_Generic *impl;
+};
+
+#endif

Added: trunk/src/signals/signal_v4.hpp
===================================================================
--- trunk/src/signals/signal_v4.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/signal_v4.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,256 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SIGNAL_V4_HPP
+#define HEADER_SIGNALS_SIGNAL_V4_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning ( disable : 4786 )
+#pragma warning ( disable : 4355 ) // warning C4355: 'this' : used in base member initializer list
+#endif
+
+#include &quot;signal.hpp&quot;
+#include &quot;slot.hpp&quot;
+#include &quot;slot_v4.hpp&quot;
+#include &lt;list&gt;
+
+//: Signal V4 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3, class PARAM4&gt;
+class Signal_v4 : public Signal
+{
+public:
+	typedef Slot_v4&lt;PARAM1, PARAM2, PARAM3, PARAM4&gt; *Slot;
+	typedef typename std::list&lt;Slot&gt;::iterator SlotIterator;
+
+	class Signal_v4_Generic
+	{
+	public:
+		Signal_v4_Generic(Signal_v4 *owner) : in_call(false), deleted(false), in_call_remove_slots(0), owner(owner) { return; }
+
+		~Signal_v4_Generic()
+		{
+			for (SlotIterator slot_it = slots.begin(); slot_it != slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+				slot-&gt;release_signal_ref(owner);
+			}
+		}
+
+		bool in_call, deleted;
+		std::list&lt;SlotIterator&gt; *in_call_remove_slots;
+		std::list&lt;Slot&gt; slots;
+		Signal_v4 *owner;
+	};
+
+//! Construction:
+public:
+	//: Signal V4 constructor
+	Signal_v4() : impl(new Signal_v4_Generic(this))
+	{
+	}
+
+	Signal_v4(const Signal_v4 &amp;copy) : Signal(copy), impl(new Signal_v4_Generic(this))
+	{
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+	}
+
+	//: Signal V4 destructor
+	~Signal_v4()
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+	}
+
+//! Attributes:
+public:
+	bool has_slots_connected() const
+	{
+		return !impl-&gt;slots.empty();
+	}
+
+//! Operations:
+public:
+	Signal_v4 &amp;operator =(const Signal_v4 &amp;copy)
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+
+		impl = new Signal_v4_Generic(this);
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+		return *this;
+	}
+
+	//: Opererator
+	void operator() (PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4)
+	{
+		call(param1, param2, param3, param4);
+	}
+
+	//: Call
+	void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4)
+	{
+		Signal_v4_Generic *data = impl;
+		data-&gt;in_call = true;
+
+		std::list&lt;SlotIterator&gt; remove_slots;
+		try
+		{
+			data-&gt;in_call_remove_slots = &amp;remove_slots;
+
+			// call slots connected to signal:
+			for (SlotIterator slot_it = data-&gt;slots.begin(); slot_it != data-&gt;slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+
+				// skip slot if it has no more references left in application.
+				// (make it pending for removal)
+				if (slot-&gt;get_slot_ref() == 0 &amp;&amp; slot-&gt;is_persistent() == false)
+				{
+					if (std::find(remove_slots.begin(), remove_slots.end(), slot_it)==remove_slots.end())
+						remove_slots.push_back(slot_it);
+				}
+			
+				slot-&gt;call(param1, param2, param3, param4);
+				if (data-&gt;deleted) break;
+			}
+		}
+		catch (...)
+		{
+			catch_final(data, remove_slots);
+			throw;
+		}
+		catch_final(data, remove_slots);
+	}
+
+	//: Connect slot.
+	::Slot connect(Slot slot)
+	{
+		slot-&gt;add_signal_ref(this);
+		impl-&gt;slots.push_back(slot);
+		return ::Slot(slot);
+	}
+
+	//: Connect callback function slot.
+	::Slot connect(void (*callback)(PARAM1, PARAM2, PARAM3, PARAM4))
+	{
+		return connect(new FunctionSlot_v4&lt;PARAM1,PARAM2,PARAM3,PARAM4&gt;(callback));
+	}
+
+	//: Connect functor slot.
+	template&lt;class Functor&gt;
+	::Slot connect_functor(const Functor &amp;functor)
+	{
+		return connect(new FunctorSlot_v4&lt;Functor, PARAM1, PARAM2, PARAM3, PARAM4&gt;(functor));
+	}
+
+	//: Connect member function slot.
+	template &lt;class CallbackClass&gt;
+	::Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2, PARAM3, PARAM4))
+	{
+		return connect(new MethodSlot_v4&lt;CallbackClass, PARAM1, PARAM2, PARAM3, PARAM4&gt;(cb_class, callback));
+	}
+
+	//: Connect member function with user data slot.
+	template &lt;class CallbackClass, class UserData&gt;
+	::Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2, PARAM3, PARAM4, UserData),
+		UserData user_data)
+	{
+		return connect(new UserDataMethodSlot_v4&lt;CallbackClass, PARAM1, PARAM2, PARAM3, PARAM4, UserData&gt;(cb_class, callback, user_data));
+	}
+
+	//: Disconnect
+	void disconnect(::Slot &amp;disconnect_slot)
+	{
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end();)
+		{
+			Slot slot = *slot_it;
+			if (disconnect_slot.impl == slot)
+			{
+				if (impl-&gt;in_call)
+				{
+					impl-&gt;in_call_remove_slots-&gt;push_back(slot_it);
+					++slot_it;
+				}
+				else
+				{
+					slot-&gt;release_signal_ref(this);
+					slot_it = impl-&gt;slots.erase(slot_it);
+				}
+			}
+			else
+				++slot_it;
+		}
+	}
+
+//! Implementation:
+private:
+	void catch_final(Signal_v4_Generic *data, std::list&lt;SlotIterator&gt; &amp;remove_slots)
+	{
+		data-&gt;in_call_remove_slots = 0;
+
+		// remove all slots no longer connected to any Slot.
+		typename std::list&lt;SlotIterator&gt;::iterator remove_it;
+		for (remove_it = remove_slots.begin(); remove_it != remove_slots.end(); remove_it++)
+		{
+			Slot slot = **remove_it;
+			slot-&gt;release_signal_ref(this);
+			data-&gt;slots.erase(*remove_it);
+		}
+
+		data-&gt;in_call = false;
+		if (data-&gt;deleted) delete data;
+	}
+
+	Signal_v4_Generic *impl;
+};
+
+#endif

Added: trunk/src/signals/signal_v5.hpp
===================================================================
--- trunk/src/signals/signal_v5.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/signal_v5.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,256 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SIGNAL_V5_HPP
+#define HEADER_SIGNALS_SIGNAL_V5_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning ( disable : 4786 )
+#pragma warning ( disable : 4355 ) // warning C4355: 'this' : used in base member initializer list
+#endif
+
+#include &quot;signal.hpp&quot;
+#include &quot;slot.hpp&quot;
+#include &quot;slot_v5.hpp&quot;
+#include &lt;list&gt;
+
+//: Signal V5 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3, class PARAM4, class PARAM5&gt;
+class Signal_v5 : public Signal
+{
+public:
+	typedef Slot_v5&lt;PARAM1, PARAM2, PARAM3, PARAM4, PARAM5&gt; *Slot;
+	typedef typename std::list&lt;Slot&gt;::iterator SlotIterator;
+
+	class Signal_v5_Generic
+	{
+	public:
+		Signal_v5_Generic(Signal_v5 *owner) : in_call(false), deleted(false), in_call_remove_slots(0), owner(owner) { return; }
+
+		~Signal_v5_Generic()
+		{
+			for (SlotIterator slot_it = slots.begin(); slot_it != slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+				slot-&gt;release_signal_ref(owner);
+			}
+		}
+
+		bool in_call, deleted;
+		std::list&lt;SlotIterator&gt; *in_call_remove_slots;
+		std::list&lt;Slot&gt; slots;
+		Signal_v5 *owner;
+	};
+
+//! Construction:
+public:
+	//: Signal V5 Constructor
+	Signal_v5() : impl(new Signal_v5_Generic(this))
+	{
+	}
+
+	Signal_v5(const Signal_v5 &amp;copy) : Signal(copy), impl(new Signal_v5_Generic(this))
+	{
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+	}
+
+	//: Signal V5 Destructor
+	~Signal_v5()
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+	}
+
+//! Attributes:
+public:
+	bool has_slots_connected() const
+	{
+		return !impl-&gt;slots.empty();
+	}
+
+//! Operations:
+public:
+	Signal_v5 &amp;operator =(const Signal_v5 &amp;copy)
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+
+		impl = new Signal_v5_Generic(this);
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+		return *this;
+	}
+
+	//: Operator
+	void operator() (PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4, PARAM5 param5)
+	{
+		call(param1, param2, param3, param4, param5);
+	}
+
+	//: Call
+	void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4, PARAM5 param5)
+	{
+		Signal_v5_Generic *data = impl;
+		data-&gt;in_call = true;
+
+		std::list&lt;SlotIterator&gt; remove_slots;
+		try
+		{
+			data-&gt;in_call_remove_slots = &amp;remove_slots;
+
+			// call slots connected to signal:
+			for (SlotIterator slot_it = data-&gt;slots.begin(); slot_it != data-&gt;slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+
+				// skip slot if it has no more references left in application.
+				// (make it pending for removal)
+				if (slot-&gt;get_slot_ref() == 0 &amp;&amp; slot-&gt;is_persistent() == false)
+				{
+					if (std::find(remove_slots.begin(), remove_slots.end(), slot_it)==remove_slots.end())
+						remove_slots.push_back(slot_it);
+				}
+			
+				slot-&gt;call(param1, param2, param3, param4, param5);
+				if (data-&gt;deleted) break;
+			}
+		}
+		catch (...)
+		{
+			catch_final(data, remove_slots);
+			throw;
+		}
+		catch_final(data, remove_slots);
+	}
+
+	//: Connect slot.
+	Slot connect(Slot slot)
+	{
+		slot-&gt;add_signal_ref(this);
+		impl-&gt;slots.push_back(slot);
+		return Slot(slot);
+	}
+
+	//: Connect callback function slot.
+	Slot connect(void (*callback)(PARAM1, PARAM2, PARAM3, PARAM4, PARAM5))
+	{
+		return connect(new FunctionSlot_v5&lt;PARAM1,PARAM2,PARAM3,PARAM4,PARAM5&gt;(callback));
+	}
+
+	//: Connect functor slot.
+	template&lt;class Functor&gt;
+	Slot connect_functor(const Functor &amp;functor)
+	{
+		return connect(new FunctorSlot_v5&lt;Functor, PARAM1, PARAM2, PARAM3, PARAM4, PARAM5&gt;(functor));
+	}
+
+	//: Connect member function slot.
+	template &lt;class CallbackClass&gt;
+	Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2, PARAM3, PARAM4, PARAM5))
+	{
+		return connect(new MethodSlot_v5&lt;CallbackClass, PARAM1, PARAM2, PARAM3, PARAM4, PARAM5&gt;(cb_class, callback));
+	}
+
+	//: Connect member function with user data slot.
+	template &lt;class CallbackClass, class UserData&gt;
+	Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2, PARAM3, PARAM4, PARAM5, UserData),
+		UserData user_data)
+	{
+		return connect(new UserDataMethodSlot_v5&lt;CallbackClass, PARAM1, PARAM2, PARAM3, PARAM4, PARAM5, UserData&gt;(cb_class, callback, user_data));
+	}
+
+	//: Disconnect
+	void disconnect(::Slot &amp;disconnect_slot)
+	{
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end();)
+		{
+			Slot slot = *slot_it;
+			if (disconnect_slot.impl == slot)
+			{
+				if (impl-&gt;in_call)
+				{
+					impl-&gt;in_call_remove_slots-&gt;push_back(slot_it);
+					++slot_it;
+				}
+				else
+				{
+					slot-&gt;release_signal_ref(this);
+					slot_it = impl-&gt;slots.erase(slot_it);
+				}
+			}
+			else
+				++slot_it;
+		}
+	}
+
+//! Implementation:
+private:
+	void catch_final(Signal_v5_Generic *data, std::list&lt;SlotIterator&gt; &amp;remove_slots)
+	{
+		data-&gt;in_call_remove_slots = 0;
+
+		// remove all slots no longer connected to any Slot.
+		typename std::list&lt;SlotIterator&gt;::iterator remove_it;
+		for (remove_it = remove_slots.begin(); remove_it != remove_slots.end(); remove_it++)
+		{
+			Slot slot = **remove_it;
+			slot-&gt;release_signal_ref(this);
+			data-&gt;slots.erase(*remove_it);
+		}
+
+		data-&gt;in_call = false;
+		if (data-&gt;deleted) delete data;
+	}
+
+	Signal_v5_Generic *impl;
+};
+
+#endif

Added: trunk/src/signals/signals.hpp
===================================================================
--- trunk/src/signals/signals.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/signals.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,42 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  &gt; |__| |__|____/____/\___  &gt;
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_SIGNALS_SIGNALS_HPP
+#define HEADER_SIGNALS_SIGNALS_HPP
+
+
+#include &quot;signals/slot.hpp&quot;
+#include &quot;signals/signal_v0.hpp&quot;
+#include &quot;signals/signal_v1.hpp&quot;
+#include &quot;signals/signal_v2.hpp&quot;
+#include &quot;signals/signal_v3.hpp&quot;
+#include &quot;signals/signal_v4.hpp&quot;
+#include &quot;signals/signal_v5.hpp&quot;
+#include &quot;signals/slotbuffer_v0.hpp&quot;
+#include &quot;signals/slotbuffer_v1.hpp&quot;
+
+#endif
+
+/* EOF */

Added: trunk/src/signals/slot.cpp
===================================================================
--- trunk/src/signals/slot.cpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/slot.cpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,91 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;signals/slot.hpp&quot;
+#include &quot;signals/slot_generic.hpp&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Slot construction:
+
+Slot::Slot() : impl(0)
+{
+}
+
+Slot::Slot(const Slot &amp;copy) : impl(copy.impl)
+{
+	if (impl != 0) impl-&gt;add_slot_ref();
+}
+
+Slot::~Slot()
+{
+	if (impl != 0) impl-&gt;release_slot_ref();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Slot attributes:
+
+int Slot::get_slot_ref() const
+{
+	if (impl) return impl-&gt;get_slot_ref();
+	else return 0;
+}
+
+int Slot::get_signal_ref() const
+{
+	if (impl) return impl-&gt;get_signal_ref();
+	else return 0;
+}
+
+bool Slot::is_persistent() const
+{
+	return impl-&gt;is_persistent();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Slot operations:
+
+void Slot::operator =(const Slot &amp;copy)
+{
+	if (impl) impl-&gt;release_slot_ref();
+	impl = copy.impl;
+	if (impl) impl-&gt;add_slot_ref();
+}
+
+void Slot::set_persistent(bool flag)
+{
+	if (impl) impl-&gt;set_persistent(flag);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Slot implementation:
+
+Slot::Slot(Slot_Generic *impl) : impl(impl)
+{
+	if (impl != 0) impl-&gt;add_slot_ref();
+}

Added: trunk/src/signals/slot.hpp
===================================================================
--- trunk/src/signals/slot.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/slot.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,90 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SLOT_HPP
+#define HEADER_SIGNALS_SLOT_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class Slot_Generic;
+
+//: Slot class
+//- !group=Signal/System!
+//- !header=signals.h!
+class Slot
+{
+//! Construction:
+public:
+	//: Create an unconnected slot.
+	Slot();
+
+	//: Copy a slot.
+	Slot(const Slot &amp;copy);
+
+	//: Slot destructor
+	~Slot();
+
+//! Attributes:
+public:
+	//: Returns the number of Slot references still pointing at this slot.
+	int get_slot_ref() const;
+
+	//: Returns the number of signals this slot is connected to.
+	int get_signal_ref() const;
+
+	//: Returns true if slot is persistent.
+	//- &lt;p&gt;If the slot is persistent, it will remain connected to
+	//- signals even when all references to Slot are gone.&lt;/p&gt;
+	bool is_persistent() const;
+
+//! Operations:
+public:
+	//: Slot copy operator
+	void operator =(const Slot &amp;copy);
+
+	//: Sets the persistent flag.
+	//- &lt;p&gt;If the slot is persistent, it will remain connected to
+	//- signals even when all references to Slot are gone.&lt;/p&gt;
+	void set_persistent(bool flag = true);
+
+//! Implementation:
+public:
+	//: Slot constructor
+	Slot(Slot_Generic *impl);
+
+	//: Slot Generic Implementation
+	Slot_Generic *impl;
+};
+
+#endif

Added: trunk/src/signals/slot_generic.cpp
===================================================================
--- trunk/src/signals/slot_generic.cpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/slot_generic.cpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,121 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;signals/slot_generic.hpp&quot;
+#include &quot;signals/slot.hpp&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Slot_Generic construction:
+
+Slot_Generic::Slot_Generic() : persistent(false), slot_ref_count(0), signal_ref_count(0)
+{
+}
+
+Slot_Generic::~Slot_Generic()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Slot_Generic attributes:
+
+int Slot_Generic::get_slot_ref() const
+{
+	return slot_ref_count;
+}
+
+int Slot_Generic::get_signal_ref() const
+{
+	return signal_ref_count;
+}
+
+bool Slot_Generic::is_persistent() const
+{
+	return persistent;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Slot_Generic operations:
+
+void Slot_Generic::add_slot_ref()
+{
+	slot_ref_count++;
+}
+
+void Slot_Generic::release_slot_ref()
+{
+	slot_ref_count--;
+	check_delete();
+}
+
+void Slot_Generic::add_signal_ref(Signal *signal)
+{
+	connected_signals.push_back(signal);
+	signal_ref_count++;
+}
+
+void Slot_Generic::release_signal_ref(Signal *signal)
+{
+	connected_signals.remove(signal);
+	signal_ref_count--;
+	check_delete();
+}
+
+void Slot_Generic::set_persistent(bool flag)
+{
+	persistent = flag;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//! Implementation:
+
+void Slot_Generic::check_delete()
+{
+	// Try remove from signals immidiately, if possible:
+	if (slot_ref_count == 0 &amp;&amp; signal_ref_count &gt; 0)
+	{
+		// Prevent recursive looping (and allows us to create a helper Slot object):
+		slot_ref_count++;
+
+		std::list&lt;Signal *&gt; signals = connected_signals;
+		connected_signals.clear(); // clear member list to avoid recursive loop problems
+
+		std::list&lt;Signal *&gt;::iterator it;
+		for (it = signals.begin(); it != signals.end(); ++it)
+		{
+			Signal *cur = (*it);
+			Slot slot(this);
+			cur-&gt;disconnect(slot);
+		}
+
+		slot_ref_count--;
+	}
+
+	// Delete ourselves if nobody reference us anymore
+	if (slot_ref_count == 0 &amp;&amp; signal_ref_count == 0) delete this;
+}

Added: trunk/src/signals/slot_generic.hpp
===================================================================
--- trunk/src/signals/slot_generic.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/slot_generic.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,103 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SLOT_GENERIC
+#define HEADER_SIGNALS_SLOT_GENERIC
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;list&gt;
+#include &quot;signal.hpp&quot;
+
+class Slot;
+
+//: Slot Generic Class
+//- !group=Signal/System!
+//- !header=signals.h!
+class Slot_Generic
+{
+//! Construction:
+public:
+	//: Slot Generic Constructor
+	Slot_Generic();
+
+	//: Slot Generic Destructor
+	virtual ~Slot_Generic();
+
+//! Attributes:
+public:
+	//: Get slot ref
+	int get_slot_ref() const;
+
+	//: Get signal ref
+	int get_signal_ref() const;
+
+	//: Returns true if persistent.
+	//- &lt;p&gt;If the slot is persistent, it will remain connected to
+	//- signals even when all references to Slot are gone.&lt;/p&gt;
+	bool is_persistent() const;
+
+//! Operations:
+public:
+	//: Add slot ref
+	void add_slot_ref();
+
+	//: Release slot ref
+	void release_slot_ref();
+
+	//: Add signal ref
+	void add_signal_ref(Signal *signal);
+
+	//: Release signal ref
+	void release_signal_ref(Signal *signal);
+
+	//: Sets the persistent flag.
+	//- &lt;p&gt;If the slot is persistent, it will remain connected to
+	//- signals even when all references to Slot are gone.&lt;/p&gt;
+	void set_persistent(bool flag = true);
+
+//! Implementation:
+private:
+	void check_delete();
+
+	bool persistent;
+
+	int slot_ref_count;
+
+	int signal_ref_count;
+
+	std::list&lt;Signal *&gt; connected_signals;
+};
+
+#endif

Added: trunk/src/signals/slot_v0.hpp
===================================================================
--- trunk/src/signals/slot_v0.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/slot_v0.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,216 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SLOT_V0_HPP
+#define HEADER_SIGNALS_SLOT_V0_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;slot_generic.hpp&quot;
+#include &lt;list&gt;
+
+//: Slot V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+class Slot_v0 : public Slot_Generic
+{
+public:
+	//: Call
+	virtual void call(class SlotParent_v0 &amp;super)=0;
+};
+
+//: Slot Parent V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+class SlotParent_v0
+{
+public:
+	typedef Slot_v0 *Slot;
+	typedef std::list&lt;Slot&gt;::iterator SlotIterator;
+
+//! Construction:
+public:
+	
+	//: Slot Parent V0 Constructor
+	SlotParent_v0(const SlotIterator &amp;pos, const SlotIterator &amp;end)
+	: pos(pos), end(end)
+	{
+	}
+
+//! Operations:
+public:
+	//: Operator
+	void operator() ()
+	{
+		if (pos == end) return;
+
+		SlotIterator next = pos;
+		next++;
+
+		if ((*pos)-&gt;get_slot_ref() &gt; 0)
+		{
+			SlotParent_v0 super(next, end);
+			(*pos)-&gt;call(super);
+		}
+	}
+
+//! Implementation:
+private:
+	SlotIterator pos, end;
+};
+
+//: FunctionSlot V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+class FunctionSlot_v0 : public Slot_v0
+{
+public:
+	typedef void (*Callback)();
+	typedef void (*VirtualCallback)(SlotParent_v0 &amp;);
+
+	//: FunctionSlot V0 Constructor
+	FunctionSlot_v0(Callback callback, VirtualCallback virtual_callback)
+	: callback(callback), virtual_callback(virtual_callback) { return; }
+
+	//: Call
+	virtual void call(SlotParent_v0 &amp;super)
+	{
+		if (callback) { super(); callback(); }
+		else virtual_callback(super);
+	}
+
+private:
+	Callback callback;
+	VirtualCallback virtual_callback;
+};
+
+//: FunctorSlot V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template&lt;class Functor&gt;
+class FunctorSlot_v0 : public Slot_v0
+{
+public:
+	//: FunctorSlot V0 Constructor
+	FunctorSlot_v0(const Functor &amp;functor)
+	: functor(functor) { return; }
+
+	//: Call
+	virtual void call(SlotParent_v0 &amp;super)
+	{
+		super();
+		functor();
+	}
+
+private:
+	Functor functor;
+};
+
+//: FunctorSlot V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template&lt;class Functor&gt;
+class FunctorVirtualSlot_v0 : public Slot_v0
+{
+public:
+	//: FunctorVirtualSlot V0 Constructor
+	FunctorVirtualSlot_v0(const Functor &amp;functor)
+	: functor(functor) { return; }
+
+	//: Call
+	virtual void call(SlotParent_v0 &amp;super)
+	{
+		functor(super);
+	}
+
+private:
+	Functor functor;
+};
+
+//: Method Slot V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass&gt;
+class MethodSlot_v0 : public Slot_v0
+{
+public:
+	typedef void (CallbackClass::*Callback)();
+	typedef void (CallbackClass::*VirtualCallback)(SlotParent_v0 &amp;);
+
+	//: Method Slot V0 Constructor
+	MethodSlot_v0(CallbackClass *cb_class, Callback callback, VirtualCallback virtual_callback)
+	: cb_class(cb_class), callback(callback), virtual_callback(virtual_callback) { return; }
+
+	//: Call
+	virtual void call(SlotParent_v0 &amp;super)
+	{
+		if (callback) { super(); (cb_class-&gt;*callback)(); }
+		else (cb_class-&gt;*virtual_callback)(super);
+	}
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+	VirtualCallback virtual_callback;
+};
+
+//: User Data Methane Slot V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class UserData&gt;
+class UserDataMethodSlot_v0 : public Slot_v0
+{
+public:
+	typedef void (CallbackClass::*Callback)(UserData);
+	typedef void (CallbackClass::*VirtualCallback)(SlotParent_v0 &amp;, UserData);
+
+	//: User Data Methane Slot V0 Constructor
+	UserDataMethodSlot_v0(CallbackClass *cb_class, Callback callback, VirtualCallback virtual_callback, UserData user_data)
+	: cb_class(cb_class), callback(callback), virtual_callback(virtual_callback), user_data(user_data) { return; }
+
+	//: Call
+	virtual void call(SlotParent_v0 &amp;super)
+	{
+		if (callback) { super(); (cb_class-&gt;*callback)(user_data); }
+		else (cb_class-&gt;*virtual_callback)(super, user_data);
+	}
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+	VirtualCallback virtual_callback;
+	UserData user_data;
+};
+
+#endif

Added: trunk/src/signals/slot_v1.hpp
===================================================================
--- trunk/src/signals/slot_v1.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/slot_v1.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,133 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SLOT_V1_HPP
+#define HEADER_SIGNALS_SLOT_V1_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;slot_generic.hpp&quot;
+
+//: Slot V1 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1&gt;
+class Slot_v1 : public Slot_Generic
+{
+public:
+	//: Call
+	virtual void call(PARAM1 param1)=0;
+};
+
+//: Funtion Slot V1 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1&gt;
+class FunctionSlot_v1 : public Slot_v1&lt;PARAM1&gt;
+{
+public:
+	typedef void (*Callback)(PARAM1);
+
+	//: Funtion Slot V1 constructor
+	FunctionSlot_v1(Callback callback) : callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1) { callback(param1); }
+
+private:
+	Callback callback;
+};
+
+//: FunctorSlot V1 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template&lt;class Functor, class PARAM1&gt;
+class FunctorSlot_v1 : public Slot_v1&lt;PARAM1&gt;
+{
+public:
+	//: FunctorSlot V1 Constructor
+	FunctorSlot_v1(const Functor &amp;functor)
+	: functor(functor) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1) { functor(param1); }
+
+private:
+	Functor functor;
+};
+
+//: Method Slot V1
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1&gt;
+class MethodSlot_v1 : public Slot_v1&lt;PARAM1&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1);
+
+	//: Method Slot V1 constructor
+	MethodSlot_v1(CallbackClass *cb_class, Callback callback)
+	: cb_class(cb_class), callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1) { (cb_class-&gt;*callback)(param1); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+};
+
+//: User Data Method Slot V1 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class UserData&gt;
+class UserDataMethodSlot_v1 : public Slot_v1&lt;PARAM1&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, UserData);
+
+	//: User Data Method Slot V1 constructor
+	UserDataMethodSlot_v1(CallbackClass *cb_class, Callback callback, UserData user_data)
+	: cb_class(cb_class), callback(callback), user_data(user_data) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1) { (cb_class-&gt;*callback)(param1, user_data); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+	UserData user_data;
+};
+
+#endif

Added: trunk/src/signals/slot_v2.hpp
===================================================================
--- trunk/src/signals/slot_v2.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/slot_v2.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,133 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SLOT_V2_HPP
+#define HEADER_SIGNALS_SLOT_V2_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;slot_generic.hpp&quot;
+
+//: Slot V2 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2&gt;
+class Slot_v2 : public Slot_Generic
+{
+public:
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2)=0;
+};
+
+//: FunctionSlot V2 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2&gt;
+class FunctionSlot_v2 : public Slot_v2&lt;PARAM1, PARAM2&gt;
+{
+public:
+	typedef void (*Callback)(PARAM1, PARAM2);
+
+	//: FunctionSlot V2 Constructor
+	FunctionSlot_v2(Callback callback) : callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2) { callback(param1, param2); }
+
+private:
+	Callback callback;
+};
+
+//: FunctorSlot V2 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template&lt;class Functor, class PARAM1, class PARAM2&gt;
+class FunctorSlot_v2 : public Slot_v2&lt;PARAM1, PARAM2&gt;
+{
+public:
+	//: FunctorSlot V2 Constructor
+	FunctorSlot_v2(const Functor &amp;functor)
+	: functor(functor) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2) { functor(param1, param2); }
+
+private:
+	Functor functor;
+};
+
+//: Methane Slot V2 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2&gt;
+class MethodSlot_v2 : public Slot_v2&lt;PARAM1, PARAM2&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2);
+
+	//: Methane Slot V2 constructor
+	MethodSlot_v2(CallbackClass *cb_class, Callback callback)
+	: cb_class(cb_class), callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2) { (cb_class-&gt;*callback)(param1, param2); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+};
+
+//: User Data Methane Slot V2 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2, class UserData&gt;
+class UserDataMethodSlot_v2 : public Slot_v2&lt;PARAM1, PARAM2&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2, UserData);
+
+	//: User Data Methane Slot V2 Constructor
+	UserDataMethodSlot_v2(CallbackClass *cb_class, Callback callback, UserData user_data)
+	: cb_class(cb_class), callback(callback), user_data(user_data) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2) { (cb_class-&gt;*callback)(param1, param2, user_data); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+	UserData user_data;
+};
+
+#endif

Added: trunk/src/signals/slot_v3.hpp
===================================================================
--- trunk/src/signals/slot_v3.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/slot_v3.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,133 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SLOT_V3_HPP
+#define HEADER_SIGNALS_SLOT_V3_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;slot_generic.hpp&quot;
+
+//: Slot V3 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3&gt;
+class Slot_v3 : public Slot_Generic
+{
+public:
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3)=0;
+};
+
+//: FunctionSlot V3 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3&gt;
+class FunctionSlot_v3 : public Slot_v3&lt;PARAM1, PARAM2, PARAM3&gt;
+{
+public:
+	typedef void (*Callback)(PARAM1, PARAM2, PARAM3);
+
+	//: FunctionSlot V3 Constructor
+	FunctionSlot_v3(Callback callback) : callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3) { callback(param1, param2, param3); }
+
+private:
+	Callback callback;
+};
+
+//: FunctorSlot V3 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template&lt;class Functor, class PARAM1, class PARAM2, class PARAM3&gt;
+class FunctorSlot_v3 : public Slot_v3&lt;PARAM1, PARAM2, PARAM3&gt;
+{
+public:
+	//: FunctorSlot V3 Constructor
+	FunctorSlot_v3(const Functor &amp;functor)
+	: functor(functor) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3) { functor(param1, param2, param3); }
+
+private:
+	Functor functor;
+};
+
+//: Methane Slot V3 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2, class PARAM3&gt;
+class MethodSlot_v3 : public Slot_v3&lt;PARAM1, PARAM2, PARAM3&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2, PARAM3);
+
+	//: Methane Slot V3 constructor
+	MethodSlot_v3(CallbackClass *cb_class, Callback callback)
+	: cb_class(cb_class), callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3) { (cb_class-&gt;*callback)(param1, param2, param3); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+};
+
+//: User Data Methane Slot V3 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2, class PARAM3, class UserData&gt;
+class UserDataMethodSlot_v3 : public Slot_v3&lt;PARAM1, PARAM2, PARAM3&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2, PARAM3, UserData);
+
+	//: User Data Methane Slot V3 Constructor
+	UserDataMethodSlot_v3(CallbackClass *cb_class, Callback callback, UserData user_data)
+	: cb_class(cb_class), callback(callback), user_data(user_data) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3) { (cb_class-&gt;*callback)(param1, param2, param3, user_data); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+	UserData user_data;
+};
+
+#endif

Added: trunk/src/signals/slot_v4.hpp
===================================================================
--- trunk/src/signals/slot_v4.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/slot_v4.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,133 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SLOT_V4_HPP
+#define HEADER_SIGNALS_SLOT_V4_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;slot_generic.hpp&quot;
+
+//: Slot V4 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3, class PARAM4&gt;
+class Slot_v4 : public Slot_Generic
+{
+public:
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4)=0;
+};
+
+//: FunctionSlot V4 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3, class PARAM4&gt;
+class FunctionSlot_v4 : public Slot_v4&lt;PARAM1, PARAM2, PARAM3, PARAM4&gt;
+{
+public:
+	typedef void (*Callback)(PARAM1, PARAM2, PARAM3, PARAM4);
+
+	//: FunctionSlot V4 Constructor
+	FunctionSlot_v4(Callback callback) : callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4) { callback(param1, param2, param3, param4); }
+
+private:
+	Callback callback;
+};
+
+//: FunctorSlot V4 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template&lt;class Functor, class PARAM1, class PARAM2, class PARAM3, class PARAM4&gt;
+class FunctorSlot_v4 : public Slot_v4&lt;PARAM1, PARAM2, PARAM3, PARAM4&gt;
+{
+public:
+	//: FunctorSlot V4 Constructor
+	FunctorSlot_v4(const Functor &amp;functor)
+	: functor(functor) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4) { functor(param1, param2, param3, param4); }
+
+private:
+	Functor functor;
+};
+
+//: Methane Slot V4 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2, class PARAM3, class PARAM4&gt;
+class MethodSlot_v4 : public Slot_v4&lt;PARAM1, PARAM2, PARAM3, PARAM4&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2, PARAM3, PARAM4);
+
+	//: Methane Slot V4 constructor
+	MethodSlot_v4(CallbackClass *cb_class, Callback callback)
+	: cb_class(cb_class), callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4) { (cb_class-&gt;*callback)(param1, param2, param3, param4); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+};
+
+//: User Data Methane Slot V4 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2, class PARAM3, class PARAM4, class UserData&gt;
+class UserDataMethodSlot_v4 : public Slot_v4&lt;PARAM1, PARAM2, PARAM3, PARAM4&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2, PARAM3, PARAM4, UserData);
+
+	//: User Data Methane Slot V4 Constructor
+	UserDataMethodSlot_v4(CallbackClass *cb_class, Callback callback, UserData user_data)
+	: cb_class(cb_class), callback(callback), user_data(user_data) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4) { (cb_class-&gt;*callback)(param1, param2, param3, param4, user_data); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+	UserData user_data;
+};
+
+#endif

Added: trunk/src/signals/slot_v5.hpp
===================================================================
--- trunk/src/signals/slot_v5.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/slot_v5.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,133 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SLOT_V5_HPP
+#define HEADER_SIGNALS_SLOT_V5_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;slot_generic.hpp&quot;
+
+//: Slot V5 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3, class PARAM4, class PARAM5&gt;
+class Slot_v5 : public Slot_Generic
+{
+public:
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4, PARAM5 param5)=0;
+};
+
+//: FunctionSlot V5 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3, class PARAM4, class PARAM5&gt;
+class FunctionSlot_v5 : public Slot_v5&lt;PARAM1, PARAM2, PARAM3, PARAM4, PARAM5&gt;
+{
+public:
+	typedef void (*Callback)(PARAM1, PARAM2, PARAM3, PARAM4, PARAM5);
+
+	//: FunctionSlot V5 Constructor
+	FunctionSlot_v5(Callback callback) : callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4, PARAM5 param5) { callback(param1, param2, param3, param4, param5); }
+
+private:
+	Callback callback;
+};
+
+//: FunctorSlot V5 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template&lt;class Functor, class PARAM1, class PARAM2, class PARAM3, class PARAM4, class PARAM5&gt;
+class FunctorSlot_v5 : public Slot_v5&lt;PARAM1, PARAM2, PARAM3, PARAM4, PARAM5&gt;
+{
+public:
+	//: FunctorSlot V5 Constructor
+	FunctorSlot_v5(const Functor &amp;functor)
+	: functor(functor) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4, PARAM5 param5) { functor(param1, param2, param3, param4, param5); }
+
+private:
+	Functor functor;
+};
+
+//: Methane Slot V5 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2, class PARAM3, class PARAM4, class PARAM5&gt;
+class MethodSlot_v5 : public Slot_v5&lt;PARAM1, PARAM2, PARAM3, PARAM4, PARAM5&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2, PARAM3, PARAM4, PARAM5);
+
+	//: Methane Slot V5 constructor
+	MethodSlot_v5(CallbackClass *cb_class, Callback callback)
+	: cb_class(cb_class), callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4, PARAM5 param5) { (cb_class-&gt;*callback)(param1, param2, param3, param4, param5); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+};
+
+//: User Data Methane Slot V5 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2, class PARAM3, class PARAM4, class PARAM5, class UserData&gt;
+class UserDataMethodSlot_v5 : public Slot_v5&lt;PARAM1, PARAM2, PARAM3, PARAM4, PARAM5&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2, PARAM3, PARAM4, PARAM5, UserData);
+
+	//: User Data Methane Slot V5 Constructor
+	UserDataMethodSlot_v5(CallbackClass *cb_class, Callback callback, UserData user_data)
+	: cb_class(cb_class), callback(callback), user_data(user_data) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4, PARAM5 param5) { (cb_class-&gt;*callback)(param1, param2, param3, param4, param5, user_data); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+	UserData user_data;
+};
+
+#endif

Added: trunk/src/signals/slotbuffer_v0.hpp
===================================================================
--- trunk/src/signals/slotbuffer_v0.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/slotbuffer_v0.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,99 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SLOTBUFFER_V0_HPP
+#define HEADER_SIGNALS_SLOTBUFFER_V0_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;signal_v0.hpp&quot;
+
+//: Slot Buffer V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+class SlotBuffer_v0
+{
+//! Construction:
+public:
+	//: Slot Buffer V0 Constructor
+	SlotBuffer_v0() : count(0)
+	{
+	}
+
+	//: Slot Buffer V0 Constructor
+	SlotBuffer_v0(Signal_v0 &amp;signal) : count(0)
+	{
+		connect(signal);
+	}
+
+//! Attributes:
+public:
+	//: Bool
+	operator bool()
+	{
+		return count &gt; 0;
+	}
+
+	//: Size
+	int size()
+	{
+		return count;
+	}
+
+//! Operations:
+public:
+	//: Connect
+	void connect(Signal_v0 &amp;signal)
+	{
+		slot = signal.connect(this, &amp;SlotBuffer_v0::callback);
+	}
+
+	//: Disconnect
+	void disconnect(Signal_v0 &amp;signal)
+	{
+		signal.disconnect(slot);
+	}
+
+//! Implementation:
+private:
+	void callback()
+	{
+		count++;
+	}
+
+	Slot slot;
+	int count;
+};
+
+#endif

Added: trunk/src/signals/slotbuffer_v1.hpp
===================================================================
--- trunk/src/signals/slotbuffer_v1.hpp	2005-08-03 15:00:17 UTC (rev 887)
+++ trunk/src/signals/slotbuffer_v1.hpp	2005-08-03 23:33:16 UTC (rev 888)
@@ -0,0 +1,118 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef HEADER_SIGNALS_SLOTBUFFER_V1_HPP
+#define HEADER_SIGNALS_SLOTBUFFER_V1_HPP
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;vector&gt;
+#include &quot;slot.hpp&quot;
+
+template &lt;class PARAM1&gt; class Signal_v1;
+
+//: SlotBuffer V1 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1&gt;
+class SlotBuffer_v1
+{
+public:
+	struct Params
+	{
+		PARAM1 p1;
+	};
+
+//! Construction:
+public:
+	//: Slot Buffer V1 Constructor
+	SlotBuffer_v1()
+	{
+	}
+
+	//: Slot Buffer V1 Constructor
+	SlotBuffer_v1(Signal_v1&lt;PARAM1&gt; &amp;signal)
+	{
+		connect(signal);
+	}
+
+//! Attributes:
+public:
+	//: Bool
+	operator bool()
+	{
+		return !params.empty();
+	}
+
+	//: Size
+	int size()
+	{
+		return params.size();
+	}
+
+	//: Operator
+	Params &amp;operator[](int index)
+	{
+		return params[index];
+	}
+
+//! Operations:
+public:
+	//: Connect
+	void connect(Signal_v1&lt;PARAM1&gt; &amp;signal)
+	{
+		slot = signal.connect(this, &amp;SlotBuffer_v1::callback);
+	}
+
+	//: Disconnect
+	void disconnect(Signal_v1&lt;PARAM1&gt; &amp;signal)
+	{
+		signal.disconnect(slot);
+	}
+
+//! Implementation:
+private:
+	void callback(PARAM1 p1)
+	{
+		Params p;
+		p.p1 = p1;
+
+		params.push_back(p);
+	}
+
+	std::vector&lt;Params&gt; params;
+	Slot slot;
+};
+
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000540.html">[Windstille-commit] r887 - in trunk/data: . images/tiles levels
</A></li>
	<LI>Next message: <A HREF="000542.html">[Windstille-commit] r889 - in trunk/src: . scripting
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#541">[ date ]</a>
              <a href="thread.html#541">[ thread ]</a>
              <a href="subject.html#541">[ subject ]</a>
              <a href="author.html#541">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/windstille-commit">More information about the Windstille-commit
mailing list</a><br>
</body></html>
