<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Windstille-commit] r3359 - in trunk/windstille: extra/slideshow	src/app src/display
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/windstille-commit/2010-September/index.html" >
   <LINK REL="made" HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r3359%20-%20in%20trunk/windstille%3A%20extra/slideshow%0A%09src/app%20src/display&In-Reply-To=%3C20100913220939.367B9481034%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002355.html">
   <LINK REL="Next"  HREF="002357.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Windstille-commit] r3359 - in trunk/windstille: extra/slideshow	src/app src/display</H1>
    <B>grumbel at mail.berlios.de</B> 
    <A HREF="mailto:windstille-commit%40lists.berlios.de?Subject=Re%3A%20%5BWindstille-commit%5D%20r3359%20-%20in%20trunk/windstille%3A%20extra/slideshow%0A%09src/app%20src/display&In-Reply-To=%3C20100913220939.367B9481034%40sheep.berlios.de%3E"
       TITLE="[Windstille-commit] r3359 - in trunk/windstille: extra/slideshow	src/app src/display">grumbel at mail.berlios.de
       </A><BR>
    <I>Tue Sep 14 00:09:39 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002355.html">[Windstille-commit] r3358 - trunk/windstille/src/display
</A></li>
        <LI>Next message: <A HREF="002357.html">[Windstille-commit] r3360 - in trunk/windstille/src: display	particles
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2356">[ date ]</a>
              <a href="thread.html#2356">[ thread ]</a>
              <a href="subject.html#2356">[ subject ]</a>
              <a href="author.html#2356">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: grumbel
Date: 2010-09-14 00:09:39 +0200 (Tue, 14 Sep 2010)
New Revision: 3359

Added:
   trunk/windstille/extra/slideshow/slide_parser.cpp
   trunk/windstille/extra/slideshow/slide_parser.hpp
Modified:
   trunk/windstille/extra/slideshow/slide_builder.cpp
   trunk/windstille/extra/slideshow/slide_builder.hpp
   trunk/windstille/extra/slideshow/slide_show.cpp
   trunk/windstille/extra/slideshow/slideshow.cpp
   trunk/windstille/src/app/windstille_main.cpp
   trunk/windstille/src/display/opengl_window.cpp
   trunk/windstille/src/display/opengl_window.hpp
Log:
Renamed SlideBuilder to SlideParser
Added configurable title to OpenGLWindow


Modified: trunk/windstille/extra/slideshow/slide_builder.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.cpp	2010-09-13 22:08:13 UTC (rev 3358)
+++ trunk/windstille/extra/slideshow/slide_builder.cpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -29,622 +29,5 @@
 
 #include &quot;slideshow/slide_show.hpp&quot;
 
-float
-NodePosX::get(const Sizef&amp; scr, const Sizef&amp; img, float zoom) const
-{
-  // FIXME: Warning img is already multiplied by zoom
-  switch(m_type)
-  {
-    case kNodePosXLeft:
-      return img.width/2.0f - scr.width/2.0f + scr.width/2.0f;
 
-    case kNodePosXRight:
-      return -img.width/2.0f + scr.width/2.0f + scr.width/2.0f;
-
-    case kNodePosXCenter:
-      return scr.width/2;
-
-    case kNodePosXAbsFloat:
-      {
-        float x = m_value * zoom;
-        return img.width/2.0f - x + scr.width/2.0f;
-      }
-
-    case kNodePosXRelFloat:
-      {
-        float x = (m_value/100.0f) * img.width;
-        return img.width/2.0f - x + scr.width/2.0f;
-      }
-  }
-
-  assert(!&quot;never reached&quot;);
-}
-
-float
-NodePosY::get(const Sizef&amp; scr, const Sizef&amp; img, float zoom) const
-{
-  // FIXME: Warning img is already multiplied by zoom
-  switch(m_type)
-  {
-    case kNodePosYTop:
-      return img.height/2.0f - scr.height/2.0f + scr.height/2.0f;
-      
-    case kNodePosYBottom:
-      return -img.height/2.0f + scr.height/2.0f + scr.height/2.0f;
-
-    case kNodePosYCenter:
-      return scr.height/2;
-      
-    case kNodePosYAbsFloat:
-      {
-        float y = m_value * zoom;
-        return img.height/2.0f - y + scr.height/2.0f;
-      }
-      
-    case kNodePosYRelFloat:
-      {
-        float y = (m_value/100.0f) * img.height;
-        return img.height/2.0f - y + scr.height/2.0f;
-      }
-  }
-
-  assert(!&quot;never reached&quot;);
-}
-
-float
-NodeZoom::get(const Sizef&amp; scr, const Sizef&amp; img) const
-{
-  switch(m_type)
-  {
-    case kNodeZoomFit:
-      return std::min(scr.width / img.width,
-                      scr.height / img.height);
-
-    case kNodeZoomFill:
-      return std::max(scr.width / img.width,
-                      scr.height / img.height);
-
-    case kNodeZoomWidth:
-      return scr.width / img.width;
-      
-    case kNodeZoomHeight:
-      return scr.height / img.height;
-      
-    case kNodeZoomOriginal:
-      return 1.0f;
-
-    case kNodeZoomFloat:
-      {
-        // 1.0f means &quot;fit&quot;, so recalculate values relative to that
-        float fit = std::min(scr.width / img.width,
-                             scr.height / img.height);
-        return fit * m_value;
-      }
-  }
-
-  assert(!&quot;never reached&quot;);
-}
-
-SlideBuilder::SlideBuilder(SlideShow&amp; slideshow, const Sizef&amp; screen_size) :
-  m_slideshow(slideshow),
-  m_screen_size(screen_size),
-  m_context(),
-  m_line(),
-  m_fade(0.0f),
-  m_state(kGlobal),
-  m_time(0.0f),
-  m_image(),
-  m_last_image(),
-  m_node_has_pos(false),
-  m_node_has_zoom(false),
-  //m_path_node(),
-  m_node(),
-  m_variables()
-{
-}
-
-void
-SlideBuilder::load_from_file(const std::string&amp; filename)
-{
-  std::ifstream in(filename.c_str());
-  if (!in)
-  {
-    std::ostringstream str;
-    str &lt;&lt; filename &lt;&lt; &quot;: &quot; &lt;&lt; strerror(errno);
-    throw std::runtime_error(str.str());
-  }
-  else
-  {
-    m_context = filename;
-    m_line = 0;
-    load_from_stream(in);
-  }
-}
-
-std::string
-strip_comment(const std::string&amp; line)
-{
-  std::string::size_type p = line.find('#');
-  return line.substr(0, p);
-}
-
-void
-SlideBuilder::error(const std::string&amp; str) const
-{
-  std::ostringstream out;
-  out &lt;&lt; m_context &lt;&lt; ':' &lt;&lt; m_line &lt;&lt; &quot;: error: &quot; &lt;&lt; str;
-  throw std::runtime_error(out.str());
-}
-
-void
-SlideBuilder::load_from_stream(std::istream&amp; stream)
-{
-  try 
-  {
-    std::string line;
-    while(std::getline(stream, line))
-    {
-      m_line += 1;
-      line = strip_comment(line);
-
-      std::vector&lt;std::string&gt; args = tokenize(line);
-
-      if (args.empty())
-      {
-        // empty line, skip it
-      }
-      else
-      {
-        if (false)
-        { // debug output
-          for(std::vector&lt;std::string&gt;::iterator i = args.begin(); i != args.end(); ++i)
-          {
-            std::cout &lt;&lt; &quot;(&quot; &lt;&lt; *i &lt;&lt; &quot;) &quot;;
-          }
-          std::cout &lt;&lt; std::endl;
-        }
-
-        // handle variable replacement
-        for(std::vector&lt;std::string&gt;::iterator i = args.begin(); i != args.end(); ++i)
-        {
-          if ((*i)[0] == '$')
-          {
-            Variables::iterator it = m_variables.find(i-&gt;substr(1));
-            if (it == m_variables.end())
-            {
-              error(&quot;unknown variable: &quot; + *i);
-            }
-            else
-            {
-              *i = it-&gt;second;
-            }
-          }
-        }
-
-        if (args[0] == &quot;image&quot;)
-        {
-          handle_image(args);
-        }
-        else if (args[0] == &quot;set&quot;)
-        {
-          handle_set(args);
-        }
-        else if (args[0] == &quot;zoom&quot;)
-        {
-          handle_zoom(args);
-        }
-        else if (args[0] == &quot;pos&quot;)
-        {
-          handle_pos(args);
-        }
-        else if (args[0] == &quot;duration&quot;)
-        {
-          handle_duration(args);
-        }
-        else if (args[0] == &quot;fade&quot;)
-        {
-          handle_fade(args);
-        }
-        else if (args[0] == &quot;end&quot;)
-        {
-          handle_end(args);
-        }
-        else if (args[0] == &quot;breakpoint&quot;)
-        {
-          handle_breakpoint(args);
-        }
-        else if (args[0] == &quot;include&quot;)
-        {
-          handle_include(args);
-        }
-        else
-        {
-          error(&quot;unknown tag '&quot; + args[0] + &quot;'&quot;);
-        }
-      }
-    }
-
-    if (m_state != kGlobal)
-    {
-      error(&quot;not in global scope at end of file&quot;);
-    }
-
-    std::cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; m_time &lt;&lt; std::endl;
-  }
-  catch(std::exception&amp; err)
-  {
-    error(err.what());
-  }
-}
-
-void
-SlideBuilder::handle_image(const std::vector&lt;std::string&gt;&amp; args)
-{
-  if (m_state != kGlobal)
-  {
-    error(&quot;image must be in global scope&quot;);
-  }
-  else if (args.size() != 2)
-  {
-    error(&quot;image requires one argument&quot;);
-  }
-  else
-  {
-    m_state = kImage;
-
-    // reset pan/zoom pos
-    m_node = Node();
-
-    std::cout &lt;&lt; &quot;;; time = &quot; &lt;&lt; m_time &lt;&lt; std::endl;
-    std::cout &lt;&lt; &quot;(image \&quot;&quot; &lt;&lt; args[1] &lt;&lt; &quot;\&quot;)&quot; &lt;&lt; std::endl;
-    m_image = SlideObjectPtr(new SlideObject(Pathname(args[1], Pathname::kSysPath)));
-
-    if (m_slideshow.size() != 0)
-    {
-      m_time -= m_fade;
-      m_image-&gt;set_begin(m_time);
-    }
-
-    m_image-&gt;set_fade_in(m_fade);
-    m_fade = 0.0f;
-  }
-}
-
-void
-SlideBuilder::handle_pos(const std::vector&lt;std::string&gt;&amp; args)
-{
-  if (m_state != kImage)
-  {
-    error(&quot;pos must be in image scope&quot;);
-  }
-  else if (args.size() != 3)
-  {
-    error(&quot;pos requires two arguments&quot;);
-  }
-  else if (m_node_has_pos)
-  {
-    error(&quot;pos already given&quot;);
-  }
-  else
-  {
-    m_node_has_pos = true;
-
-    //float img_w = m_image-&gt;get_width()  * m_path_node.zoom;
-    //float img_h = m_image-&gt;get_height() * m_path_node.zoom;
-
-    //float scr_w = m_screen_size.width;
-    //float scr_h = m_screen_size.height;
-
-    if (args[1] == &quot;left&quot;)
-    {
-      //m_path_node.pos.x = img_w/2.0f - scr_w/2.0f + scr_w/2.0f;
-      m_node.pos_x = NodePosX(NodePosX::kNodePosXLeft);
-    }
-    else if (args[1] == &quot;right&quot;)
-    {
-      //m_path_node.pos.x = -img_w/2.0f + scr_w/2.0f + scr_w/2.0f;
-      m_node.pos_x = NodePosX(NodePosX::kNodePosXRight);
-    }
-    else if (args[1] == &quot;center&quot;)
-    {
-      //m_path_node.pos.x = scr_w/2;
-      m_node.pos_x = NodePosX(NodePosX::kNodePosXCenter);
-    }
-    else if (args[1] == &quot;prev&quot;)
-    {
-      // reuse previous value
-    }
-    else
-    {
-      //float x = boost::lexical_cast&lt;float&gt;(args[1]) * m_path_node.zoom;
-      //m_path_node.pos.x = img_w/2.0f - x + scr_w/2.0f;
-      if (args[1][args[1].length()-1] == '%')
-      {
-        m_node.pos_x = NodePosX(NodePosX::kNodePosXRelFloat, 
-                                boost::lexical_cast&lt;float&gt;(args[1].substr(0, args[1].length()-1)));
-      }
-      else
-      {
-        m_node.pos_x = NodePosX(NodePosX::kNodePosXAbsFloat, 
-                                boost::lexical_cast&lt;float&gt;(args[1]));
-      }
-    }
-
-    if (args[2] == &quot;top&quot;)
-    {
-      //m_path_node.pos.y = img_h/2.0f - scr_h/2.0f + scr_h/2.0f;
-      m_node.pos_y = NodePosY(NodePosY::kNodePosYTop);
-    }
-    else if (args[2] == &quot;bottom&quot;)
-    {
-      //m_path_node.pos.y = -img_h/2.0f + scr_h/2.0f + scr_h/2.0f;
-      m_node.pos_y = NodePosY(NodePosY::kNodePosYBottom);
-    }
-    else if (args[2] == &quot;center&quot;)
-    {
-      //m_path_node.pos.y = scr_h/2;
-      m_node.pos_y = NodePosY(NodePosY::kNodePosYCenter);
-    }
-    else if (args[2] == &quot;prev&quot;)
-    {
-      // reuse previous value
-    }
-    else
-    {
-      //float y = boost::lexical_cast&lt;float&gt;(args[2]) * m_path_node.zoom;
-      //m_path_node.pos.y = img_h/2.0f - y + scr_h/2.0f;
-      if (args[2][args[2].length()-1] == '%')
-      {
-        m_node.pos_y = NodePosY(NodePosY::kNodePosYRelFloat, 
-                                boost::lexical_cast&lt;float&gt;(args[2].substr(0, args[2].length()-1)));
-      }
-      else
-      {
-        m_node.pos_y = NodePosY(NodePosY::kNodePosYAbsFloat, 
-                                boost::lexical_cast&lt;float&gt;(args[2]));
-      }
-    }
-
-    //std::cout &lt;&lt; &quot;  (pos &quot; &lt;&lt; m_path_node.pos.x &lt;&lt; &quot; &quot; &lt;&lt; m_path_node.pos.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
-  }
-}
-
-void
-SlideBuilder::handle_zoom(const std::vector&lt;std::string&gt;&amp; args)
-{
-  if (m_state != kImage)
-  {
-    error(&quot;zoom must be in image scope&quot;);
-  }
-  else if (args.size() != 2)
-  {
-    error(&quot;zoom requires one argument&quot;);
-  }
-  else if (m_node_has_zoom)
-  {
-    error(&quot;zoom already given&quot;);
-  }
-  else
-  {
-    if (args[1] == &quot;fit&quot;)
-    {
-      //m_path_node.zoom = std::min(m_screen_size.width / m_image-&gt;get_width(),
-      //                            m_screen_size.height / m_image-&gt;get_height());
-      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomFit);
-    }
-    else if (args[1] == &quot;fill&quot;)
-    {
-      //m_path_node.zoom = std::max(m_screen_size.width / m_image-&gt;get_width(),
-      //m_screen_size.height / m_image-&gt;get_height());
-      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomFill);
-    }
-    else if (args[1] == &quot;width&quot;)
-    {
-      //m_path_node.zoom = m_screen_size.width / m_image-&gt;get_width();
-      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomWidth);
-    }
-    else if (args[1] == &quot;height&quot;)
-    {
-      //m_path_node.zoom = m_screen_size.height / m_image-&gt;get_height();
-      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomHeight);
-    }
-    else if (args[1] == &quot;original&quot;)
-    {
-      //m_path_node.zoom = 1.0f;
-      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomOriginal);
-    }
-    else if (args[1] == &quot;prev&quot;)
-    {
-      // reuse previous value      
-    }
-    else
-    {
-      /*
-      m_path_node.zoom = boost::lexical_cast&lt;float&gt;(args[1]);
-      
-      // 1.0f means &quot;fit&quot;, so recalculate values relative to that
-      float fit = std::min(m_screen_size.width / m_image-&gt;get_width(),
-                           m_screen_size.height / m_image-&gt;get_height());
-      m_path_node.zoom = fit * m_path_node.zoom;
-
-      std::cout &lt;&lt; &quot;  (zoom &quot; &lt;&lt; m_path_node.zoom &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
-      */
-      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomFloat, boost::lexical_cast&lt;float&gt;(args[1]));
-    }
-
-    m_node_has_zoom = true;
-  }
-}
- 
-void
-SlideBuilder::handle_duration(const std::vector&lt;std::string&gt;&amp; args)
-{
-  if (m_state != kImage)
-  {
-    error(&quot;duration must be in image scope&quot;);
-  }
-  else if (args.size() != 2)
-  {
-    error(&quot;duration requires one argument&quot;);
-  }
-  else
-  {
-    float duration = boost::lexical_cast&lt;float&gt;(args[1]);
-
-    assert(m_image);
-    add_node();
-    m_image-&gt;get_path().add_edge(duration);
-    std::cout &lt;&lt; &quot;  (duration &quot; &lt;&lt; duration &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
-  }
-}
-
-void
-SlideBuilder::add_node()
-{
-  Sizef image_size(m_image-&gt;get_width(), m_image-&gt;get_height());
-  float zoom = m_node.zoom.get(m_screen_size, image_size);
-  Sizef image_size_zoom(zoom * m_image-&gt;get_width(), 
-                        zoom * m_image-&gt;get_height());
-  
-  //m_image-&gt;get_path().add_node(m_path_node.pos, m_path_node.zoom);
-  m_image-&gt;get_path().add_node(Vector2f(m_node.pos_x.get(m_screen_size, image_size_zoom, zoom),
-                                        m_node.pos_y.get(m_screen_size, image_size_zoom, zoom)),
-                               zoom);
-
-  m_node_has_zoom = false;
-  m_node_has_pos  = false;
-}
-
-void
-SlideBuilder::handle_fade(const std::vector&lt;std::string&gt;&amp; args)
-{
-  if (m_state != kGlobal)
-  {
-    error(&quot;fade must be in global scope&quot;);
-  }
-  else if (args.size() != 2)
-  {
-    error(&quot;fade requires one argument&quot;);
-  }
-  else
-  {
-    m_fade = boost::lexical_cast&lt;float&gt;(args[1]);
-    std::cout &lt;&lt; &quot;(fade &quot; &lt;&lt; m_fade &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
-
-    if (m_last_image)
-    {
-      m_last_image-&gt;set_fade_out(m_fade);
-    }
-  }
-}
-
-void
-SlideBuilder::handle_end(const std::vector&lt;std::string&gt;&amp; args)
-{
-  if (m_state != kImage)
-  {
-    error(&quot;end must be in image scope&quot;);
-  }
-  else if (args.size() != 1)
-  {
-    error(&quot;end requires no argument&quot;);
-  }
-  else
-  {
-    m_state = kGlobal;
-    
-    assert(m_image);
-    add_node();
-    m_image-&gt;get_path().finish();
-
-    m_time += m_image-&gt;length();
-    m_slideshow.add(m_image);
-    m_last_image = m_image;
-    std::cout &lt;&lt; &quot;(end)&quot; &lt;&lt; std::endl;
-  }
-}
-
-void
-SlideBuilder::handle_breakpoint(const std::vector&lt;std::string&gt;&amp; args)
-{
-  std::cout &lt;&lt; &quot;breakpoint not implemented&quot; &lt;&lt; std::endl;
-}
-
-void
-SlideBuilder::handle_include(const std::vector&lt;std::string&gt;&amp; args)
-{
-  std::cout &lt;&lt; &quot;include not implemented&quot; &lt;&lt; std::endl;
-}
-
-void
-SlideBuilder::handle_set(const std::vector&lt;std::string&gt;&amp; args)
-{
-  if (args.size() != 3)
-  {
-    error(&quot;set requires exactly one argument&quot;);
-  }
-  else
-  {
-    m_variables[args[1]] = args[2];
-  }
-}
-
-std::vector&lt;std::string&gt;
-SlideBuilder::tokenize(const std::string&amp; line) const
-{
-  if (true)
-  {
-    boost::char_separator&lt;char&gt; sep(&quot; \t&quot;);
-    boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokens(line, sep);
-    std::vector&lt;std::string&gt; lst(tokens.begin(), tokens.end());
-    return lst;
-  }
-  else
-  {
-    //enum { kWhitespace, kString } state;
-
-    std::vector&lt;std::string&gt; lst;  
-    std::ostringstream str;
-    std::string::const_iterator i = line.begin();
-
-    while(i != line.end())
-    {
-    
-      if (*i == ' ' || *i == '\t')
-      {
-      
-      }
-      else if (*i == '\\')
-      {
-        ++i;
-        if (i != line.end())
-        {
-          switch(*i)
-          {
-            case '\\': str &lt;&lt; '\\'; break;
-            case '0': str &lt;&lt; '\0'; break;
-            case 'a': str &lt;&lt; '\a'; break;
-            case 'b': str &lt;&lt; '\b'; break;
-            case 't': str &lt;&lt; '\t'; break;
-            case 'r': str &lt;&lt; '\r'; break;
-            case 'n': str &lt;&lt; '\n'; break;
-            default: str &lt;&lt; '\\' &lt;&lt; *i; break;
-          }
-        }
-        else
-        {
-          error(&quot;couldn't tokenize line&quot;);
-        }
-      }
-      else
-      {
-      }
-
-      ++i;
-    }
-  
-    return lst;
-  }
-}
-
 /* EOF */

Modified: trunk/windstille/extra/slideshow/slide_builder.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_builder.hpp	2010-09-13 22:08:13 UTC (rev 3358)
+++ trunk/windstille/extra/slideshow/slide_builder.hpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -28,165 +28,15 @@
 #include &quot;slideshow/slide_path.hpp&quot;
 
 class SlideShow;
-
-class NodePosX
-{
-public:
-  enum NodePosXType
-  {
-    kNodePosXLeft,
-    kNodePosXRight,
-    kNodePosXCenter,
-    kNodePosXAbsFloat,
-    kNodePosXRelFloat
-  };
-  
-public:
-  NodePosX() :
-    m_type(kNodePosXCenter),
-    m_value(0.0f)
-  {}
 
-  NodePosX(NodePosXType type, float value = 0.0f) :
-    m_type(type),
-    m_value(value)
-  {}
-
-  float get(const Sizef&amp; screen_size, const Sizef&amp; image_size, float zoom) const;
-
-private:
-  NodePosXType m_type;  
-  float m_value;
-};
-
-class NodePosY
-{
-public:
-  enum NodePosYType
-  {
-    kNodePosYTop,
-    kNodePosYBottom,
-    kNodePosYCenter,
-    kNodePosYAbsFloat,
-    kNodePosYRelFloat
-  };
-  
-public:
-  NodePosY() :
-    m_type(kNodePosYCenter),
-    m_value(0.0f)
-  {}
-
-  NodePosY(NodePosYType type, float value = 0.0f) :
-    m_type(type),
-    m_value(value)
-  {}
-
-  float get(const Sizef&amp; screen_size, const Sizef&amp; image_size, float zoom) const;
-
-private:
-  NodePosYType m_type;
-  float m_value;
-};
-
-class NodeZoom
-{
-public:
-  enum NodeZoomType
-  {
-    kNodeZoomOriginal,
-    kNodeZoomFit,
-    kNodeZoomFill,
-    kNodeZoomWidth,
-    kNodeZoomHeight,
-    kNodeZoomFloat
-  };
-
-public:
-  NodeZoom() :
-    m_type(kNodeZoomFit),
-    m_value(0.0f)
-  {}
-
-  NodeZoom(NodeZoomType type, float value = 1.0f) :
-    m_type(type),
-    m_value(value)
-  {}
-
-  float get(const Sizef&amp; screen_size, const Sizef&amp; image_size) const;
-
-private:
-  NodeZoomType m_type;
-  float m_value;
-};
-
-class Node
-{
-public:
-  NodeZoom zoom;
-  NodePosX pos_x;
-  NodePosY pos_y;
-
-  Node() :
-    zoom(),
-    pos_x(),
-    pos_y()
-  {}
-};
-
 class SlideBuilder
 {
 private:
-  SlideShow&amp; m_slideshow;
-  Sizef m_screen_size;
 
-  std::string m_context;
-  int m_line;
-
-  enum State {
-    kGlobal,
-    kImage
-  };
-
-  float m_fade;
-
-  State m_state;
-  float m_time;
-  SlideObjectPtr m_image;
-  SlideObjectPtr m_last_image;
-
-  bool m_node_has_pos;
-  bool m_node_has_zoom;
-  //SlidePathNode m_path_node;
-  Node m_node;
-
-  typedef std::map&lt;std::string, std::string&gt; Variables;
-  Variables m_variables;
-
 public:
-  SlideBuilder(SlideShow&amp; slideshow, const Sizef&amp; screen_size);
+  SlideBuilder();
 
-  void load_from_file(const std::string&amp; filename);
-  void load_from_stream(std::istream&amp; stream);
-
 private:
-  void error(const std::string&amp; str) const;
-
-  void handle_image(const std::vector&lt;std::string&gt;&amp; args);
-  void handle_pos(const std::vector&lt;std::string&gt;&amp; args);
-  void handle_zoom(const std::vector&lt;std::string&gt;&amp; args);
-  void handle_duration(const std::vector&lt;std::string&gt;&amp; args);
-  void handle_fade(const std::vector&lt;std::string&gt;&amp; args);
-  void handle_end(const std::vector&lt;std::string&gt;&amp; args);
-  void handle_breakpoint(const std::vector&lt;std::string&gt;&amp; args);
-  void handle_include(const std::vector&lt;std::string&gt;&amp; args);
-  void handle_set(const std::vector&lt;std::string&gt;&amp; args);
-
-  void add_node();
-
-  std::vector&lt;std::string&gt; tokenize(const std::string&amp; str) const;
-
-private:
   SlideBuilder(const SlideBuilder&amp;);
   SlideBuilder&amp; operator=(const SlideBuilder&amp;);
 };

Added: trunk/windstille/extra/slideshow/slide_parser.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_parser.cpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/slide_parser.cpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -0,0 +1,650 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;slideshow/slide_parser.hpp&quot;
+
+#include &lt;boost/tokenizer.hpp&gt;
+#include &lt;boost/lexical_cast.hpp&gt;
+#include &lt;string.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;fstream&gt;
+#include &lt;iostream&gt;
+#include &lt;stdexcept&gt;
+#include &lt;sstream&gt;
+
+#include &quot;slideshow/slide_show.hpp&quot;
+
+float
+NodePosX::get(const Sizef&amp; scr, const Sizef&amp; img, float zoom) const
+{
+  // FIXME: Warning img is already multiplied by zoom
+  switch(m_type)
+  {
+    case kNodePosXLeft:
+      return img.width/2.0f - scr.width/2.0f + scr.width/2.0f;
+
+    case kNodePosXRight:
+      return -img.width/2.0f + scr.width/2.0f + scr.width/2.0f;
+
+    case kNodePosXCenter:
+      return scr.width/2;
+
+    case kNodePosXAbsFloat:
+      {
+        float x = m_value * zoom;
+        return img.width/2.0f - x + scr.width/2.0f;
+      }
+
+    case kNodePosXRelFloat:
+      {
+        float x = (m_value/100.0f) * img.width;
+        return img.width/2.0f - x + scr.width/2.0f;
+      }
+  }
+
+  assert(!&quot;never reached&quot;);
+}
+
+float
+NodePosY::get(const Sizef&amp; scr, const Sizef&amp; img, float zoom) const
+{
+  // FIXME: Warning img is already multiplied by zoom
+  switch(m_type)
+  {
+    case kNodePosYTop:
+      return img.height/2.0f - scr.height/2.0f + scr.height/2.0f;
+      
+    case kNodePosYBottom:
+      return -img.height/2.0f + scr.height/2.0f + scr.height/2.0f;
+
+    case kNodePosYCenter:
+      return scr.height/2;
+      
+    case kNodePosYAbsFloat:
+      {
+        float y = m_value * zoom;
+        return img.height/2.0f - y + scr.height/2.0f;
+      }
+      
+    case kNodePosYRelFloat:
+      {
+        float y = (m_value/100.0f) * img.height;
+        return img.height/2.0f - y + scr.height/2.0f;
+      }
+  }
+
+  assert(!&quot;never reached&quot;);
+}
+
+float
+NodeZoom::get(const Sizef&amp; scr, const Sizef&amp; img) const
+{
+  switch(m_type)
+  {
+    case kNodeZoomFit:
+      return std::min(scr.width / img.width,
+                      scr.height / img.height);
+
+    case kNodeZoomFill:
+      return std::max(scr.width / img.width,
+                      scr.height / img.height);
+
+    case kNodeZoomWidth:
+      return scr.width / img.width;
+      
+    case kNodeZoomHeight:
+      return scr.height / img.height;
+      
+    case kNodeZoomOriginal:
+      return 1.0f;
+
+    case kNodeZoomFloat:
+      {
+        // 1.0f means &quot;fit&quot;, so recalculate values relative to that
+        float fit = std::min(scr.width / img.width,
+                             scr.height / img.height);
+        return fit * m_value;
+      }
+  }
+
+  assert(!&quot;never reached&quot;);
+}
+
+SlideParser::SlideParser(SlideShow&amp; slideshow, const Sizef&amp; screen_size) :
+  m_slideshow(slideshow),
+  m_screen_size(screen_size),
+  m_context(),
+  m_line(),
+  m_fade(0.0f),
+  m_state(kGlobal),
+  m_time(0.0f),
+  m_image(),
+  m_last_image(),
+  m_node_has_pos(false),
+  m_node_has_zoom(false),
+  //m_path_node(),
+  m_node(),
+  m_variables()
+{
+}
+
+void
+SlideParser::load_from_file(const std::string&amp; filename)
+{
+  std::ifstream in(filename.c_str());
+  if (!in)
+  {
+    std::ostringstream str;
+    str &lt;&lt; filename &lt;&lt; &quot;: &quot; &lt;&lt; strerror(errno);
+    throw std::runtime_error(str.str());
+  }
+  else
+  {
+    m_context = filename;
+    m_line = 0;
+    load_from_stream(in);
+  }
+}
+
+std::string
+strip_comment(const std::string&amp; line)
+{
+  std::string::size_type p = line.find('#');
+  return line.substr(0, p);
+}
+
+void
+SlideParser::error(const std::string&amp; str) const
+{
+  std::ostringstream out;
+  out &lt;&lt; m_context &lt;&lt; ':' &lt;&lt; m_line &lt;&lt; &quot;: error: &quot; &lt;&lt; str;
+  throw std::runtime_error(out.str());
+}
+
+void
+SlideParser::load_from_stream(std::istream&amp; stream)
+{
+  try 
+  {
+    std::string line;
+    while(std::getline(stream, line))
+    {
+      m_line += 1;
+      line = strip_comment(line);
+
+      std::vector&lt;std::string&gt; args = tokenize(line);
+
+      if (args.empty())
+      {
+        // empty line, skip it
+      }
+      else
+      {
+        if (false)
+        { // debug output
+          for(std::vector&lt;std::string&gt;::iterator i = args.begin(); i != args.end(); ++i)
+          {
+            std::cout &lt;&lt; &quot;(&quot; &lt;&lt; *i &lt;&lt; &quot;) &quot;;
+          }
+          std::cout &lt;&lt; std::endl;
+        }
+
+        // handle variable replacement
+        for(std::vector&lt;std::string&gt;::iterator i = args.begin(); i != args.end(); ++i)
+        {
+          if ((*i)[0] == '$')
+          {
+            Variables::iterator it = m_variables.find(i-&gt;substr(1));
+            if (it == m_variables.end())
+            {
+              error(&quot;unknown variable: &quot; + *i);
+            }
+            else
+            {
+              *i = it-&gt;second;
+            }
+          }
+        }
+
+        if (args[0] == &quot;image&quot;)
+        {
+          handle_image(args);
+        }
+        else if (args[0] == &quot;set&quot;)
+        {
+          handle_set(args);
+        }
+        else if (args[0] == &quot;zoom&quot;)
+        {
+          handle_zoom(args);
+        }
+        else if (args[0] == &quot;pos&quot;)
+        {
+          handle_pos(args);
+        }
+        else if (args[0] == &quot;duration&quot;)
+        {
+          handle_duration(args);
+        }
+        else if (args[0] == &quot;fade&quot;)
+        {
+          handle_fade(args);
+        }
+        else if (args[0] == &quot;end&quot;)
+        {
+          handle_end(args);
+        }
+        else if (args[0] == &quot;breakpoint&quot;)
+        {
+          handle_breakpoint(args);
+        }
+        else if (args[0] == &quot;include&quot;)
+        {
+          handle_include(args);
+        }
+        else
+        {
+          error(&quot;unknown tag '&quot; + args[0] + &quot;'&quot;);
+        }
+      }
+    }
+
+    if (m_state != kGlobal)
+    {
+      error(&quot;not in global scope at end of file&quot;);
+    }
+
+    std::cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; m_time &lt;&lt; std::endl;
+  }
+  catch(std::exception&amp; err)
+  {
+    error(err.what());
+  }
+}
+
+void
+SlideParser::handle_image(const std::vector&lt;std::string&gt;&amp; args)
+{
+  if (m_state != kGlobal)
+  {
+    error(&quot;image must be in global scope&quot;);
+  }
+  else if (args.size() != 2)
+  {
+    error(&quot;image requires one argument&quot;);
+  }
+  else
+  {
+    m_state = kImage;
+
+    // reset pan/zoom pos
+    m_node = Node();
+
+    std::cout &lt;&lt; &quot;;; time = &quot; &lt;&lt; m_time &lt;&lt; std::endl;
+    std::cout &lt;&lt; &quot;(image \&quot;&quot; &lt;&lt; args[1] &lt;&lt; &quot;\&quot;)&quot; &lt;&lt; std::endl;
+    m_image = SlideObjectPtr(new SlideObject(Pathname(args[1], Pathname::kSysPath)));
+
+    if (m_slideshow.size() != 0)
+    {
+      m_time -= m_fade;
+      m_image-&gt;set_begin(m_time);
+    }
+
+    m_image-&gt;set_fade_in(m_fade);
+    m_fade = 0.0f;
+  }
+}
+
+void
+SlideParser::handle_pos(const std::vector&lt;std::string&gt;&amp; args)
+{
+  if (m_state != kImage)
+  {
+    error(&quot;pos must be in image scope&quot;);
+  }
+  else if (args.size() != 3)
+  {
+    error(&quot;pos requires two arguments&quot;);
+  }
+  else if (m_node_has_pos)
+  {
+    error(&quot;pos already given&quot;);
+  }
+  else
+  {
+    m_node_has_pos = true;
+
+    //float img_w = m_image-&gt;get_width()  * m_path_node.zoom;
+    //float img_h = m_image-&gt;get_height() * m_path_node.zoom;
+
+    //float scr_w = m_screen_size.width;
+    //float scr_h = m_screen_size.height;
+
+    if (args[1] == &quot;left&quot;)
+    {
+      //m_path_node.pos.x = img_w/2.0f - scr_w/2.0f + scr_w/2.0f;
+      m_node.pos_x = NodePosX(NodePosX::kNodePosXLeft);
+    }
+    else if (args[1] == &quot;right&quot;)
+    {
+      //m_path_node.pos.x = -img_w/2.0f + scr_w/2.0f + scr_w/2.0f;
+      m_node.pos_x = NodePosX(NodePosX::kNodePosXRight);
+    }
+    else if (args[1] == &quot;center&quot;)
+    {
+      //m_path_node.pos.x = scr_w/2;
+      m_node.pos_x = NodePosX(NodePosX::kNodePosXCenter);
+    }
+    else if (args[1] == &quot;prev&quot;)
+    {
+      // reuse previous value
+    }
+    else
+    {
+      //float x = boost::lexical_cast&lt;float&gt;(args[1]) * m_path_node.zoom;
+      //m_path_node.pos.x = img_w/2.0f - x + scr_w/2.0f;
+      if (args[1][args[1].length()-1] == '%')
+      {
+        m_node.pos_x = NodePosX(NodePosX::kNodePosXRelFloat, 
+                                boost::lexical_cast&lt;float&gt;(args[1].substr(0, args[1].length()-1)));
+      }
+      else
+      {
+        m_node.pos_x = NodePosX(NodePosX::kNodePosXAbsFloat, 
+                                boost::lexical_cast&lt;float&gt;(args[1]));
+      }
+    }
+
+    if (args[2] == &quot;top&quot;)
+    {
+      //m_path_node.pos.y = img_h/2.0f - scr_h/2.0f + scr_h/2.0f;
+      m_node.pos_y = NodePosY(NodePosY::kNodePosYTop);
+    }
+    else if (args[2] == &quot;bottom&quot;)
+    {
+      //m_path_node.pos.y = -img_h/2.0f + scr_h/2.0f + scr_h/2.0f;
+      m_node.pos_y = NodePosY(NodePosY::kNodePosYBottom);
+    }
+    else if (args[2] == &quot;center&quot;)
+    {
+      //m_path_node.pos.y = scr_h/2;
+      m_node.pos_y = NodePosY(NodePosY::kNodePosYCenter);
+    }
+    else if (args[2] == &quot;prev&quot;)
+    {
+      // reuse previous value
+    }
+    else
+    {
+      //float y = boost::lexical_cast&lt;float&gt;(args[2]) * m_path_node.zoom;
+      //m_path_node.pos.y = img_h/2.0f - y + scr_h/2.0f;
+      if (args[2][args[2].length()-1] == '%')
+      {
+        m_node.pos_y = NodePosY(NodePosY::kNodePosYRelFloat, 
+                                boost::lexical_cast&lt;float&gt;(args[2].substr(0, args[2].length()-1)));
+      }
+      else
+      {
+        m_node.pos_y = NodePosY(NodePosY::kNodePosYAbsFloat, 
+                                boost::lexical_cast&lt;float&gt;(args[2]));
+      }
+    }
+
+    //std::cout &lt;&lt; &quot;  (pos &quot; &lt;&lt; m_path_node.pos.x &lt;&lt; &quot; &quot; &lt;&lt; m_path_node.pos.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+  }
+}
+
+void
+SlideParser::handle_zoom(const std::vector&lt;std::string&gt;&amp; args)
+{
+  if (m_state != kImage)
+  {
+    error(&quot;zoom must be in image scope&quot;);
+  }
+  else if (args.size() != 2)
+  {
+    error(&quot;zoom requires one argument&quot;);
+  }
+  else if (m_node_has_zoom)
+  {
+    error(&quot;zoom already given&quot;);
+  }
+  else
+  {
+    if (args[1] == &quot;fit&quot;)
+    {
+      //m_path_node.zoom = std::min(m_screen_size.width / m_image-&gt;get_width(),
+      //                            m_screen_size.height / m_image-&gt;get_height());
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomFit);
+    }
+    else if (args[1] == &quot;fill&quot;)
+    {
+      //m_path_node.zoom = std::max(m_screen_size.width / m_image-&gt;get_width(),
+      //m_screen_size.height / m_image-&gt;get_height());
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomFill);
+    }
+    else if (args[1] == &quot;width&quot;)
+    {
+      //m_path_node.zoom = m_screen_size.width / m_image-&gt;get_width();
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomWidth);
+    }
+    else if (args[1] == &quot;height&quot;)
+    {
+      //m_path_node.zoom = m_screen_size.height / m_image-&gt;get_height();
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomHeight);
+    }
+    else if (args[1] == &quot;original&quot;)
+    {
+      //m_path_node.zoom = 1.0f;
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomOriginal);
+    }
+    else if (args[1] == &quot;prev&quot;)
+    {
+      // reuse previous value      
+    }
+    else
+    {
+      /*
+      m_path_node.zoom = boost::lexical_cast&lt;float&gt;(args[1]);
+      
+      // 1.0f means &quot;fit&quot;, so recalculate values relative to that
+      float fit = std::min(m_screen_size.width / m_image-&gt;get_width(),
+                           m_screen_size.height / m_image-&gt;get_height());
+      m_path_node.zoom = fit * m_path_node.zoom;
+
+      std::cout &lt;&lt; &quot;  (zoom &quot; &lt;&lt; m_path_node.zoom &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+      */
+      m_node.zoom = NodeZoom(NodeZoom::kNodeZoomFloat, boost::lexical_cast&lt;float&gt;(args[1]));
+    }
+
+    m_node_has_zoom = true;
+  }
+}
+ 
+void
+SlideParser::handle_duration(const std::vector&lt;std::string&gt;&amp; args)
+{
+  if (m_state != kImage)
+  {
+    error(&quot;duration must be in image scope&quot;);
+  }
+  else if (args.size() != 2)
+  {
+    error(&quot;duration requires one argument&quot;);
+  }
+  else
+  {
+    float duration = boost::lexical_cast&lt;float&gt;(args[1]);
+
+    assert(m_image);
+    add_node();
+    m_image-&gt;get_path().add_edge(duration);
+    std::cout &lt;&lt; &quot;  (duration &quot; &lt;&lt; duration &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+  }
+}
+
+void
+SlideParser::add_node()
+{
+  Sizef image_size(m_image-&gt;get_width(), m_image-&gt;get_height());
+  float zoom = m_node.zoom.get(m_screen_size, image_size);
+  Sizef image_size_zoom(zoom * m_image-&gt;get_width(), 
+                        zoom * m_image-&gt;get_height());
+  
+  //m_image-&gt;get_path().add_node(m_path_node.pos, m_path_node.zoom);
+  m_image-&gt;get_path().add_node(Vector2f(m_node.pos_x.get(m_screen_size, image_size_zoom, zoom),
+                                        m_node.pos_y.get(m_screen_size, image_size_zoom, zoom)),
+                               zoom);
+
+  m_node_has_zoom = false;
+  m_node_has_pos  = false;
+}
+
+void
+SlideParser::handle_fade(const std::vector&lt;std::string&gt;&amp; args)
+{
+  if (m_state != kGlobal)
+  {
+    error(&quot;fade must be in global scope&quot;);
+  }
+  else if (args.size() != 2)
+  {
+    error(&quot;fade requires one argument&quot;);
+  }
+  else
+  {
+    m_fade = boost::lexical_cast&lt;float&gt;(args[1]);
+    std::cout &lt;&lt; &quot;(fade &quot; &lt;&lt; m_fade &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+
+    if (m_last_image)
+    {
+      m_last_image-&gt;set_fade_out(m_fade);
+    }
+  }
+}
+
+void
+SlideParser::handle_end(const std::vector&lt;std::string&gt;&amp; args)
+{
+  if (m_state != kImage)
+  {
+    error(&quot;end must be in image scope&quot;);
+  }
+  else if (args.size() != 1)
+  {
+    error(&quot;end requires no argument&quot;);
+  }
+  else
+  {
+    m_state = kGlobal;
+    
+    assert(m_image);
+    add_node();
+    m_image-&gt;get_path().finish();
+
+    m_time += m_image-&gt;length();
+    m_slideshow.add(m_image);
+    m_last_image = m_image;
+    std::cout &lt;&lt; &quot;(end)&quot; &lt;&lt; std::endl;
+  }
+}
+
+void
+SlideParser::handle_breakpoint(const std::vector&lt;std::string&gt;&amp; args)
+{
+  std::cout &lt;&lt; &quot;breakpoint not implemented&quot; &lt;&lt; std::endl;
+}
+
+void
+SlideParser::handle_include(const std::vector&lt;std::string&gt;&amp; args)
+{
+  std::cout &lt;&lt; &quot;include not implemented&quot; &lt;&lt; std::endl;
+}
+
+void
+SlideParser::handle_set(const std::vector&lt;std::string&gt;&amp; args)
+{
+  if (args.size() != 3)
+  {
+    error(&quot;set requires exactly one argument&quot;);
+  }
+  else
+  {
+    m_variables[args[1]] = args[2];
+  }
+}
+
+std::vector&lt;std::string&gt;
+SlideParser::tokenize(const std::string&amp; line) const
+{
+  if (true)
+  {
+    boost::char_separator&lt;char&gt; sep(&quot; \t&quot;);
+    boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; tokens(line, sep);
+    std::vector&lt;std::string&gt; lst(tokens.begin(), tokens.end());
+    return lst;
+  }
+  else
+  {
+    //enum { kWhitespace, kString } state;
+
+    std::vector&lt;std::string&gt; lst;  
+    std::ostringstream str;
+    std::string::const_iterator i = line.begin();
+
+    while(i != line.end())
+    {
+    
+      if (*i == ' ' || *i == '\t')
+      {
+      
+      }
+      else if (*i == '\\')
+      {
+        ++i;
+        if (i != line.end())
+        {
+          switch(*i)
+          {
+            case '\\': str &lt;&lt; '\\'; break;
+            case '0': str &lt;&lt; '\0'; break;
+            case 'a': str &lt;&lt; '\a'; break;
+            case 'b': str &lt;&lt; '\b'; break;
+            case 't': str &lt;&lt; '\t'; break;
+            case 'r': str &lt;&lt; '\r'; break;
+            case 'n': str &lt;&lt; '\n'; break;
+            default: str &lt;&lt; '\\' &lt;&lt; *i; break;
+          }
+        }
+        else
+        {
+          error(&quot;couldn't tokenize line&quot;);
+        }
+      }
+      else
+      {
+      }
+
+      ++i;
+    }
+  
+    return lst;
+  }
+}
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/slide_parser.cpp
___________________________________________________________________
Added: svn:eol-style
   + native

Added: trunk/windstille/extra/slideshow/slide_parser.hpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_parser.hpp	                        (rev 0)
+++ trunk/windstille/extra/slideshow/slide_parser.hpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -0,0 +1,196 @@
+/*
+**  Windstille - A Sci-Fi Action-Adventure Game
+**  Copyright (C) 2010 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/windstille-commit">grumbel at gmx.de</A>&gt;
+**
+**  This program is free software: you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation, either version 3 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef HEADER_WINDSTILLE_EXTRA_SLIDESHOW_SLIDE_BUILDER_HPP
+#define HEADER_WINDSTILLE_EXTRA_SLIDESHOW_SLIDE_BUILDER_HPP
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;map&gt;
+
+#include &quot;math/size.hpp&quot;
+#include &quot;slideshow/slide_object.hpp&quot;
+#include &quot;slideshow/slide_path.hpp&quot;
+
+class SlideShow;
+
+class NodePosX
+{
+public:
+  enum NodePosXType
+  {
+    kNodePosXLeft,
+    kNodePosXRight,
+    kNodePosXCenter,
+    kNodePosXAbsFloat,
+    kNodePosXRelFloat
+  };
+  
+public:
+  NodePosX() :
+    m_type(kNodePosXCenter),
+    m_value(0.0f)
+  {}
+
+  NodePosX(NodePosXType type, float value = 0.0f) :
+    m_type(type),
+    m_value(value)
+  {}
+
+  float get(const Sizef&amp; screen_size, const Sizef&amp; image_size, float zoom) const;
+
+private:
+  NodePosXType m_type;  
+  float m_value;
+};
+
+class NodePosY
+{
+public:
+  enum NodePosYType
+  {
+    kNodePosYTop,
+    kNodePosYBottom,
+    kNodePosYCenter,
+    kNodePosYAbsFloat,
+    kNodePosYRelFloat
+  };
+  
+public:
+  NodePosY() :
+    m_type(kNodePosYCenter),
+    m_value(0.0f)
+  {}
+
+  NodePosY(NodePosYType type, float value = 0.0f) :
+    m_type(type),
+    m_value(value)
+  {}
+
+  float get(const Sizef&amp; screen_size, const Sizef&amp; image_size, float zoom) const;
+
+private:
+  NodePosYType m_type;
+  float m_value;
+};
+
+class NodeZoom
+{
+public:
+  enum NodeZoomType
+  {
+    kNodeZoomOriginal,
+    kNodeZoomFit,
+    kNodeZoomFill,
+    kNodeZoomWidth,
+    kNodeZoomHeight,
+    kNodeZoomFloat
+  };
+
+public:
+  NodeZoom() :
+    m_type(kNodeZoomFit),
+    m_value(0.0f)
+  {}
+
+  NodeZoom(NodeZoomType type, float value = 1.0f) :
+    m_type(type),
+    m_value(value)
+  {}
+
+  float get(const Sizef&amp; screen_size, const Sizef&amp; image_size) const;
+
+private:
+  NodeZoomType m_type;
+  float m_value;
+};
+
+class Node
+{
+public:
+  NodeZoom zoom;
+  NodePosX pos_x;
+  NodePosY pos_y;
+
+  Node() :
+    zoom(),
+    pos_x(),
+    pos_y()
+  {}
+};
+
+class SlideParser
+{
+private:
+  SlideShow&amp; m_slideshow;
+  Sizef m_screen_size;
+
+  std::string m_context;
+  int m_line;
+
+  enum State {
+    kGlobal,
+    kImage
+  };
+
+  float m_fade;
+
+  State m_state;
+  float m_time;
+  SlideObjectPtr m_image;
+  SlideObjectPtr m_last_image;
+
+  bool m_node_has_pos;
+  bool m_node_has_zoom;
+  //SlidePathNode m_path_node;
+  Node m_node;
+
+  typedef std::map&lt;std::string, std::string&gt; Variables;
+  Variables m_variables;
+
+public:
+  SlideParser(SlideShow&amp; slideshow, const Sizef&amp; screen_size);
+
+  void load_from_file(const std::string&amp; filename);
+  void load_from_stream(std::istream&amp; stream);
+
+private:
+  void error(const std::string&amp; str) const;
+
+  void handle_image(const std::vector&lt;std::string&gt;&amp; args);
+  void handle_pos(const std::vector&lt;std::string&gt;&amp; args);
+  void handle_zoom(const std::vector&lt;std::string&gt;&amp; args);
+  void handle_duration(const std::vector&lt;std::string&gt;&amp; args);
+  void handle_fade(const std::vector&lt;std::string&gt;&amp; args);
+  void handle_end(const std::vector&lt;std::string&gt;&amp; args);
+  void handle_breakpoint(const std::vector&lt;std::string&gt;&amp; args);
+  void handle_include(const std::vector&lt;std::string&gt;&amp; args);
+  void handle_set(const std::vector&lt;std::string&gt;&amp; args);
+
+  void add_node();
+
+  std::vector&lt;std::string&gt; tokenize(const std::string&amp; str) const;
+
+private:
+  SlideParser(const SlideParser&amp;);
+  SlideParser&amp; operator=(const SlideParser&amp;);
+};
+
+#endif
+
+/* EOF */


Property changes on: trunk/windstille/extra/slideshow/slide_parser.hpp
___________________________________________________________________
Added: svn:eol-style
   + native

Modified: trunk/windstille/extra/slideshow/slide_show.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slide_show.cpp	2010-09-13 22:08:13 UTC (rev 3358)
+++ trunk/windstille/extra/slideshow/slide_show.cpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -20,7 +20,7 @@
 
 #include &quot;display/surface_manager.hpp&quot;
 #include &quot;display/texture_manager.hpp&quot;
-#include &quot;slideshow/slide_builder.hpp&quot;
+#include &quot;slideshow/slide_parser.hpp&quot;
 
 SlideShow::SlideShow() :
   m_objects(),
@@ -97,8 +97,8 @@
 void
 SlideShow::load(const std::string&amp; filename, const Sizef&amp; aspect)
 {
-  SlideBuilder slide_builder(*this, aspect);
-  slide_builder.load_from_file(filename);
+  SlideParser slide_parser(*this, aspect);
+  slide_parser.load_from_file(filename);
 }
 
 float

Modified: trunk/windstille/extra/slideshow/slideshow.cpp
===================================================================
--- trunk/windstille/extra/slideshow/slideshow.cpp	2010-09-13 22:08:13 UTC (rev 3358)
+++ trunk/windstille/extra/slideshow/slideshow.cpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -39,8 +39,8 @@
 #include &quot;slideshow/slide_builder.hpp&quot;
 
 App::App() :
-  m_aspect_ratio(1280, 800),
-  m_window_size(1280, 800),
+  m_aspect_ratio(768, 576),
+  m_window_size(768, 576),
   m_fullscreen(false),
   m_files(),
   m_output_dir(),
@@ -106,6 +106,10 @@
         m_edit_mode = true;
         break;
 
+      case 'F':
+        m_fps = boost::lexical_cast&lt;float&gt;(argp.get_argument());
+        break;
+
       case 'g':
         if (sscanf(argp.get_argument().c_str(), &quot;%dx%d&quot;, &amp;m_window_size.width, &amp;m_window_size.height) != 2)
         {
@@ -141,7 +145,7 @@
         break;
 
       default:
-        throw std::runtime_error(&quot;unhandled argument&quot;);
+        throw std::runtime_error(&quot;unhandled argument: &quot; + argp.get_key());
     }
   }
 
@@ -160,7 +164,8 @@
   init_sdl();
       
   //std::cout &lt;&lt; &quot;OpenGLWindow&quot; &lt;&lt; std::endl;
-  OpenGLWindow window(m_window_size, // window size
+  OpenGLWindow window(&quot;Slideshow&quot;,
+                      m_window_size, // window size
                       m_aspect_ratio, // aspect ratio
                       m_fullscreen, // fullscreen
                       4); // anti-alias
@@ -253,6 +258,10 @@
                 time = slide_show.find_next(time);
                 break;
 
+              case SDLK_e:
+                m_edit_mode = !m_edit_mode;
+                break;
+
               case SDLK_f:
                 fast_forward = !fast_forward;
                 std::cout &lt;&lt; fast_forward &lt;&lt; std::endl;
@@ -302,7 +311,7 @@
 
       SDL_GL_SwapBuffers();
 
-      SDL_Delay(10);
+      SDL_Delay(30);
     }
     else
     {
@@ -350,6 +359,16 @@
       std::cout &lt;&lt; &quot;Time: &quot; &lt;&lt; time &lt;&lt; std::endl;
     }
   }
+
+  
+  if (!loop)
+    std::cout &lt;&lt; &quot;Playback interrupted: &quot; &lt;&lt; std::endl;
+  else
+    std::cout &lt;&lt; &quot;Playback finished: &quot; &lt;&lt; std::endl;
+
+  std::cout &lt;&lt; &quot;  frame: &quot; &lt;&lt; frame_number &lt;&lt; std::endl;
+  std::cout &lt;&lt; &quot;  time:  &quot; &lt;&lt; time &lt;&lt; std::endl;
+
   return 0;
 }
 

Modified: trunk/windstille/src/app/windstille_main.cpp
===================================================================
--- trunk/windstille/src/app/windstille_main.cpp	2010-09-13 22:08:13 UTC (rev 3358)
+++ trunk/windstille/src/app/windstille_main.cpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -66,7 +66,8 @@
     config.parse_args(argc, argv);
 
     {
-      OpenGLWindow      window(Size(config.get_int(&quot;screen-width&quot;), config.get_int(&quot;screen-height&quot;)),
+      OpenGLWindow      window(&quot;Windstille&quot;,
+                               Size(config.get_int(&quot;screen-width&quot;), config.get_int(&quot;screen-height&quot;)),
                                Size(config.get_int(&quot;aspect-width&quot;), config.get_int(&quot;aspect-height&quot;)),
                                config.get_bool(&quot;fullscreen&quot;), config.get_int(&quot;anti-aliasing&quot;));
       TTFFontManager    ttffont_manager;

Modified: trunk/windstille/src/display/opengl_window.cpp
===================================================================
--- trunk/windstille/src/display/opengl_window.cpp	2010-09-13 22:08:13 UTC (rev 3358)
+++ trunk/windstille/src/display/opengl_window.cpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -40,7 +40,8 @@
   {}
 };
 
-OpenGLWindow::OpenGLWindow(const Size&amp; size, const Size&amp; aspect, bool fullscreen, int anti_aliasing) :
+OpenGLWindow::OpenGLWindow(const std::string&amp; title, 
+                           const Size&amp; size, const Size&amp; aspect, bool fullscreen, int anti_aliasing) :
   m_impl(new OpenGLWindowImpl)
 {
   m_impl-&gt;m_size = size;
@@ -58,7 +59,7 @@
     SDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, anti_aliasing ); // 0, 2, or 4 for number of samples
   }
   
-  SDL_WM_SetCaption(&quot;Windstille&quot;, &quot;Windstille&quot;);
+  SDL_WM_SetCaption(title.c_str(), title.c_str());
   SDL_WM_SetIcon(IMG_Load(Pathname(&quot;icon.png&quot;).get_sys_path().c_str()), NULL);
 
   m_impl-&gt;m_window = SDL_SetVideoMode(size.width, size.height,

Modified: trunk/windstille/src/display/opengl_window.hpp
===================================================================
--- trunk/windstille/src/display/opengl_window.hpp	2010-09-13 22:08:13 UTC (rev 3358)
+++ trunk/windstille/src/display/opengl_window.hpp	2010-09-13 22:09:39 UTC (rev 3359)
@@ -29,7 +29,8 @@
 class OpenGLWindow : public Currenton&lt;OpenGLWindow&gt;
 {
 public:
-  OpenGLWindow(const Size&amp; size, const Size&amp; aspect, 
+  OpenGLWindow(const std::string&amp; title, 
+               const Size&amp; size, const Size&amp; aspect, 
                bool fullscreen = false, int anti_aliasing = 0);
   ~OpenGLWindow();
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002355.html">[Windstille-commit] r3358 - trunk/windstille/src/display
</A></li>
	<LI>Next message: <A HREF="002357.html">[Windstille-commit] r3360 - in trunk/windstille/src: display	particles
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2356">[ date ]</a>
              <a href="thread.html#2356">[ thread ]</a>
              <a href="subject.html#2356">[ subject ]</a>
              <a href="author.html#2356">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/windstille-commit">More information about the Windstille-commit
mailing list</a><br>
</body></html>
