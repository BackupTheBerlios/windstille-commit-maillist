From jamesgregory at mail.berlios.de  Thu Jun 26 23:34:09 2008
From: jamesgregory at mail.berlios.de (jamesgregory at mail.berlios.de)
Date: Thu, 26 Jun 2008 23:34:09 +0200
Subject: [Windstille-commit] r2265 - in trunk/windstille: . contrib
	contrib/vs2003build src src/display src/gui src/input
	src/objects src/particles src/sprite3d src/tinygettext
Message-ID: <200806262134.m5QLY9rG027329@sheep.berlios.de>

Author: jamesgregory
Date: 2008-06-26 23:33:50 +0200 (Thu, 26 Jun 2008)
New Revision: 2265

Added:
   trunk/windstille/contrib/
   trunk/windstille/contrib/vs2003build/
   trunk/windstille/contrib/vs2003build/Windstille.sln
   trunk/windstille/contrib/vs2003build/Windstille.vcproj
Modified:
   trunk/windstille/src/display/display.cpp
   trunk/windstille/src/display/surface_manager.cpp
   trunk/windstille/src/display/texture_manager.cpp
   trunk/windstille/src/gui/root_component.cpp
   trunk/windstille/src/input/input_manager_sdl.cpp
   trunk/windstille/src/math.hpp
   trunk/windstille/src/menu_manager.cpp
   trunk/windstille/src/objects/swarm.cpp
   trunk/windstille/src/particles/particle_system.hpp
   trunk/windstille/src/screen_manager.cpp
   trunk/windstille/src/sector.cpp
   trunk/windstille/src/sprite3d/data.cpp
   trunk/windstille/src/sprite3d/sprite3d.cpp
   trunk/windstille/src/tinygettext/tinygettext.cpp
   trunk/windstille/src/util.cpp
   trunk/windstille/src/util.hpp
   trunk/windstille/src/windstille_main.cpp
Log:
a bunch of minor changes to make it compile and run with MSVC 2003

Added: trunk/windstille/contrib/vs2003build/Windstille.sln
===================================================================
--- trunk/windstille/contrib/vs2003build/Windstille.sln	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/contrib/vs2003build/Windstille.sln	2008-06-26 21:33:50 UTC (rev 2265)
@@ -0,0 +1,35 @@
+?
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Windstille", "Windstille.vcproj", "{DC61143E-A9ED-4309-88AA-314F6E76F99D}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfiguration) = preSolution
+		Debug = Debug
+		Release = Release
+	EndGlobalSection
+	GlobalSection(ProjectConfiguration) = postSolution
+		{DC61143E-A9ED-4309-88AA-314F6E76F99D}.Debug.ActiveCfg = Debug|Win32
+		{DC61143E-A9ED-4309-88AA-314F6E76F99D}.Debug.Build.0 = Debug|Win32
+		{DC61143E-A9ED-4309-88AA-314F6E76F99D}.Release.ActiveCfg = Release|Win32
+		{DC61143E-A9ED-4309-88AA-314F6E76F99D}.Release.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+	EndGlobalSection
+	GlobalSection(ExtensibilityAddIns) = postSolution
+	EndGlobalSection
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{DC61143E-A9ED-4309-88AA-314F6E76F99D}.Debug|Win32.ActiveCfg = Debug|Win32
+		{DC61143E-A9ED-4309-88AA-314F6E76F99D}.Debug|Win32.Build.0 = Debug|Win32
+		{DC61143E-A9ED-4309-88AA-314F6E76F99D}.Release|Win32.ActiveCfg = Release|Win32
+		{DC61143E-A9ED-4309-88AA-314F6E76F99D}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal

Added: trunk/windstille/contrib/vs2003build/Windstille.vcproj
===================================================================
--- trunk/windstille/contrib/vs2003build/Windstille.vcproj	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/contrib/vs2003build/Windstille.vcproj	2008-06-26 21:33:50 UTC (rev 2265)
@@ -0,0 +1,1412 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="Windstille"
+	ProjectGUID="{DC61143E-A9ED-4309-88AA-314F6E76F99D}"
+	RootNamespace="Windstille"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="1">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="&quot;F:\Documents and Settings\James\My Documents\Development\windstille\src&quot;;&quot;F:\Documents and Settings\James\My Documents\Development\windstille\inc&quot;"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				RuntimeTypeInfo="TRUE"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="SDL.lib SDLmain.lib squirrel.lib sqstdlib.lib opengl32.lib zlib.lib libpng.lib OpenAL32.lib libiconv.lib libcharset.lib freetype235MT.lib SDL_image.lib libogg.lib libvorbis.lib libvorbisfile.lib"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="lib"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="1"
+			WholeProgramOptimization="TRUE">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="&quot;F:\Documents and Settings\James\My Documents\Development\windstille\src&quot;;&quot;F:\Documents and Settings\James\My Documents\Development\windstille\inc&quot;"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				RuntimeTypeInfo="TRUE"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="SDL.lib SDLmain.lib squirrel.lib sqstdlib.lib opengl32.lib libpng.lib zlib.lib OpenAL32.lib libiconv.lib libcharset.lib freetype235MT.lib SDL_image.lib libogg.lib libvorbis.lib libvorbisfile.lib"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="lib"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Quelldateien"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath=".\src\armature_test.cpp">
+			</File>
+			<File
+				RelativePath=".\src\baby_xml.cpp">
+			</File>
+			<File
+				RelativePath=".\src\blitter.cpp">
+			</File>
+			<File
+				RelativePath=".\src\box.cpp">
+			</File>
+			<File
+				RelativePath=".\src\camera.cpp">
+			</File>
+			<File
+				RelativePath=".\src\character.cpp">
+			</File>
+			<File
+				RelativePath=".\src\command_line.cpp">
+			</File>
+			<File
+				RelativePath=".\src\command_line_generic.cpp">
+			</File>
+			<File
+				RelativePath=".\src\config.cpp">
+			</File>
+			<File
+				RelativePath=".\src\console.cpp">
+			</File>
+			<File
+				RelativePath=".\src\controller_def.cpp">
+			</File>
+			<File
+				RelativePath=".\src\controller_help_window.cpp">
+			</File>
+			<File
+				RelativePath=".\src\conversation.cpp">
+			</File>
+			<File
+				RelativePath=".\src\dialog_manager.cpp">
+			</File>
+			<File
+				RelativePath=".\src\elevator.cpp">
+			</File>
+			<File
+				RelativePath=".\src\energy_bar.cpp">
+			</File>
+			<File
+				RelativePath=".\src\entity.cpp">
+			</File>
+			<File
+				RelativePath=".\src\file_reader.cpp">
+			</File>
+			<File
+				RelativePath=".\src\game_object.cpp">
+			</File>
+			<File
+				RelativePath=".\src\game_session.cpp">
+			</File>
+			<File
+				RelativePath=".\src\geometry_test.cpp">
+			</File>
+			<File
+				RelativePath=".\src\getter.cpp">
+			</File>
+			<File
+				RelativePath=".\src\globals.cpp">
+			</File>
+			<File
+				RelativePath=".\src\graphic_context_state.cpp">
+			</File>
+			<File
+				RelativePath=".\src\grenade.cpp">
+			</File>
+			<File
+				RelativePath=".\src\inventory.cpp">
+			</File>
+			<File
+				RelativePath=".\src\laser_pointer.cpp">
+			</File>
+			<File
+				RelativePath=".\src\liquid.cpp">
+			</File>
+			<File
+				RelativePath=".\src\menu_manager.cpp">
+			</File>
+			<File
+				RelativePath=".\src\navigation_test.cpp">
+			</File>
+			<File
+				RelativePath=".\src\particle_viewer.cpp">
+			</File>
+			<File
+				RelativePath=".\src\pda.cpp">
+			</File>
+			<File
+				RelativePath=".\src\physics.cpp">
+			</File>
+			<File
+				RelativePath=".\src\pistol.cpp">
+			</File>
+			<File
+				RelativePath=".\src\player.cpp">
+			</File>
+			<File
+				RelativePath=".\src\random.cpp">
+			</File>
+			<File
+				RelativePath=".\src\response_curve.cpp">
+			</File>
+			<File
+				RelativePath=".\src\screen.cpp">
+			</File>
+			<File
+				RelativePath=".\src\screen_manager.cpp">
+			</File>
+			<File
+				RelativePath=".\src\script_manager.cpp">
+			</File>
+			<File
+				RelativePath=".\src\scriptable_object.cpp">
+			</File>
+			<File
+				RelativePath=".\src\sector.cpp">
+			</File>
+			<File
+				RelativePath=".\src\sexpr_file_reader.cpp">
+			</File>
+			<File
+				RelativePath=".\src\sexpr_file_reader.hpp">
+			</File>
+			<File
+				RelativePath=".\src\sprite2dview.cpp">
+			</File>
+			<File
+				RelativePath=".\src\sprite3dview.cpp">
+			</File>
+			<File
+				RelativePath=".\src\text_area.cpp">
+			</File>
+			<File
+				RelativePath=".\src\tile.cpp">
+			</File>
+			<File
+				RelativePath=".\src\tile_description.cpp">
+			</File>
+			<File
+				RelativePath=".\src\tile_factory.cpp">
+			</File>
+			<File
+				RelativePath=".\src\tile_map.cpp">
+			</File>
+			<File
+				RelativePath=".\src\tile_packer.cpp">
+			</File>
+			<File
+				RelativePath=".\src\timer.cpp">
+			</File>
+			<File
+				RelativePath=".\src\title_screen.cpp">
+			</File>
+			<File
+				RelativePath=".\src\trigger.cpp">
+			</File>
+			<File
+				RelativePath=".\src\util.cpp">
+			</File>
+			<File
+				RelativePath=".\src\view.cpp">
+			</File>
+			<File
+				RelativePath=".\src\windstille_main.cpp">
+			</File>
+			<Filter
+				Name="collision">
+				<File
+					RelativePath=".\src\collision\collision_data.cpp">
+				</File>
+				<File
+					RelativePath=".\src\collision\collision_engine.cpp">
+				</File>
+				<File
+					RelativePath=".\src\collision\collision_object.cpp">
+				</File>
+				<File
+					RelativePath=".\src\collision\collision_test.cpp">
+				</File>
+				<File
+					RelativePath=".\src\collision\ladder_contact.cpp">
+				</File>
+				<File
+					RelativePath=".\src\collision\stair_contact.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="display">
+				<File
+					RelativePath=".\src\display\display.cpp">
+				</File>
+				<File
+					RelativePath=".\src\display\drawing_context.cpp">
+				</File>
+				<File
+					RelativePath=".\src\display\framebuffer.cpp">
+				</File>
+				<File
+					RelativePath=".\src\display\opengl_state.cpp">
+				</File>
+				<File
+					RelativePath=".\src\display\render_buffer.cpp">
+				</File>
+				<File
+					RelativePath=".\src\display\scene_context.cpp">
+				</File>
+				<File
+					RelativePath=".\src\display\shader_object.cpp">
+				</File>
+				<File
+					RelativePath=".\src\display\shader_program.cpp">
+				</File>
+				<File
+					RelativePath=".\src\display\surface.cpp">
+				</File>
+				<File
+					RelativePath=".\src\display\surface_manager.cpp">
+				</File>
+				<File
+					RelativePath=".\src\display\texture.cpp">
+				</File>
+				<File
+					RelativePath=".\src\display\texture_manager.cpp">
+				</File>
+				<File
+					RelativePath=".\src\display\vertex_array_drawing_request.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="font">
+				<File
+					RelativePath=".\src\font\border_font_effect.cpp">
+				</File>
+				<File
+					RelativePath=".\src\font\fonts.cpp">
+				</File>
+				<File
+					RelativePath=".\src\font\ttf_font.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="gui">
+				<File
+					RelativePath=".\src\gui\automap.cpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\button.cpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\component.cpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\component_factory.cpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\grid_component.cpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\group_component.cpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\gui_manager.cpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\label.cpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\list_view.cpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\menu_component.cpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\menu_item.cpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\root_component.cpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\slider.cpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\tab_component.cpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\text_view.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="lisp">
+				<File
+					RelativePath=".\src\lisp\getters.cpp">
+				</File>
+				<File
+					RelativePath=".\src\lisp\lexer.cpp">
+				</File>
+				<File
+					RelativePath=".\src\lisp\lisp.cpp">
+				</File>
+				<File
+					RelativePath=".\src\lisp\parser.cpp">
+				</File>
+				<File
+					RelativePath=".\src\lisp\properties.cpp">
+				</File>
+				<File
+					RelativePath=".\src\lisp\writer.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="input">
+				<File
+					RelativePath=".\src\input\controller.cpp">
+				</File>
+				<File
+					RelativePath=".\src\input\controller_description.cpp">
+				</File>
+				<File
+					RelativePath=".\src\input\input_configurator.cpp">
+				</File>
+				<File
+					RelativePath=".\src\input\input_manager.cpp">
+				</File>
+				<File
+					RelativePath=".\src\input\input_manager_impl.cpp">
+				</File>
+				<File
+					RelativePath=".\src\input\input_manager_sdl.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="math">
+				<File
+					RelativePath=".\src\math\line.cpp">
+				</File>
+				<File
+					RelativePath=".\src\math\matrix.cpp">
+				</File>
+				<File
+					RelativePath=".\src\math\origin.cpp">
+				</File>
+				<File
+					RelativePath=".\src\math\quaternion.cpp">
+				</File>
+				<File
+					RelativePath=".\src\math\rect.cpp">
+				</File>
+				<File
+					RelativePath=".\src\math\vector.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="objects">
+				<File
+					RelativePath=".\src\objects\background_gradient.cpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\bomb.cpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\hedgehog.cpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\nightvision.cpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\shockwave.cpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\spider_mine.cpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\swarm.cpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\test_object.cpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\vrdummy.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="particles">
+				<File
+					RelativePath=".\src\particles\deform_drawer.cpp">
+				</File>
+				<File
+					RelativePath=".\src\particles\particle_system.cpp">
+				</File>
+				<File
+					RelativePath=".\src\particles\spark_drawer.cpp">
+				</File>
+				<File
+					RelativePath=".\src\particles\surface_drawer.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="physfs">
+				<File
+					RelativePath=".\src\physfs\physfs_sdl.cpp">
+				</File>
+				<File
+					RelativePath=".\src\physfs\physfs_stream.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="scripting">
+				<File
+					RelativePath=".\src\scripting\game_objects.cpp">
+				</File>
+				<File
+					RelativePath=".\src\scripting\interface.cpp">
+				</File>
+				<File
+					RelativePath=".\src\scripting\squirrel_error.cpp">
+				</File>
+				<File
+					RelativePath=".\src\scripting\util.cpp">
+					<FileConfiguration
+						Name="Debug|Win32">
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)/$(InputName)1.obj"/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32">
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)/$(InputName)1.obj"/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath=".\src\scripting\wrapper.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="signals">
+				<File
+					RelativePath=".\src\signals\slot.cpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\slot_generic.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="sound">
+				<File
+					RelativePath=".\src\sound\sound_file.cpp">
+				</File>
+				<File
+					RelativePath=".\src\sound\sound_manager.cpp">
+				</File>
+				<File
+					RelativePath=".\src\sound\sound_source.cpp">
+				</File>
+				<File
+					RelativePath=".\src\sound\stream_sound_source.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="sprite2d">
+				<File
+					RelativePath=".\src\sprite2d\data.cpp">
+					<FileConfiguration
+						Name="Debug|Win32">
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32">
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath=".\src\sprite2d\manager.cpp">
+					<FileConfiguration
+						Name="Debug|Win32">
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32">
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)\$(InputName)1.obj"/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath=".\src\sprite2d\sprite.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="sprite3d">
+				<File
+					RelativePath=".\src\sprite3d\data.cpp">
+				</File>
+				<File
+					RelativePath=".\src\sprite3d\manager.cpp">
+				</File>
+				<File
+					RelativePath=".\src\sprite3d\sprite3d.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="tinygettext">
+				<File
+					RelativePath=".\src\tinygettext\gettext.cpp">
+				</File>
+				<File
+					RelativePath=".\src\tinygettext\tinygettext.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="lib">
+				<File
+					RelativePath=".\lib\src\glew.c">
+				</File>
+				<File
+					RelativePath=".\lib\src\physfs.c">
+				</File>
+				<File
+					RelativePath=".\lib\src\physfs_byteorder.c">
+				</File>
+				<File
+					RelativePath=".\lib\src\physfs_unicode.c">
+				</File>
+				<File
+					RelativePath=".\lib\src\windows.c">
+				</File>
+				<Filter
+					Name="archivers">
+					<File
+						RelativePath=".\lib\src\archivers\dir.c">
+					</File>
+					<File
+						RelativePath=".\lib\src\archivers\grp.c">
+					</File>
+					<File
+						RelativePath=".\lib\src\archivers\hog.c">
+					</File>
+					<File
+						RelativePath=".\lib\src\archivers\lzma.c">
+					</File>
+					<File
+						RelativePath=".\lib\src\archivers\mvl.c">
+					</File>
+					<File
+						RelativePath=".\lib\src\archivers\qpak.c">
+					</File>
+					<File
+						RelativePath=".\lib\src\archivers\wad.c">
+					</File>
+					<File
+						RelativePath=".\lib\src\archivers\zip.c">
+					</File>
+				</Filter>
+			</Filter>
+			<Filter
+				Name="armature"
+				Filter="">
+				<File
+					RelativePath=".\src\armature\armature.cpp">
+				</File>
+				<File
+					RelativePath=".\src\armature\bone.cpp">
+				</File>
+				<File
+					RelativePath=".\src\armature\mesh.cpp">
+				</File>
+				<File
+					RelativePath=".\src\armature\model.cpp">
+				</File>
+				<File
+					RelativePath=".\src\armature\pose.cpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="navigation"
+				Filter="">
+				<File
+					RelativePath=".\src\navigation\navigation_graph.cpp">
+				</File>
+				<File
+					RelativePath=".\src\navigation\node.cpp">
+				</File>
+				<File
+					RelativePath=".\src\navigation\properties.cpp">
+					<FileConfiguration
+						Name="Debug|Win32">
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)/$(InputName)1.obj"/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32">
+						<Tool
+							Name="VCCLCompilerTool"
+							ObjectFile="$(IntDir)/$(InputName)1.obj"/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath=".\src\navigation\segment.cpp">
+				</File>
+				<File
+					RelativePath=".\src\navigation\segment_position.cpp">
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="Headerdateien"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+			<File
+				RelativePath=".\src\armature_test.hpp">
+			</File>
+			<File
+				RelativePath=".\src\baby_xml.hpp">
+			</File>
+			<File
+				RelativePath=".\src\blitter.hpp">
+			</File>
+			<File
+				RelativePath=".\src\box.hpp">
+			</File>
+			<File
+				RelativePath=".\src\camera.hpp">
+			</File>
+			<File
+				RelativePath=".\src\character.hpp">
+			</File>
+			<File
+				RelativePath=".\src\color.hpp">
+			</File>
+			<File
+				RelativePath=".\src\command_line.hpp">
+			</File>
+			<File
+				RelativePath=".\src\command_line_generic.hpp">
+			</File>
+			<File
+				RelativePath=".\src\config.hpp">
+			</File>
+			<File
+				RelativePath=".\src\console.hpp">
+			</File>
+			<File
+				RelativePath=".\src\controller_def.hpp">
+			</File>
+			<File
+				RelativePath=".\src\controller_help_window.hpp">
+			</File>
+			<File
+				RelativePath=".\src\conversation.hpp">
+			</File>
+			<File
+				RelativePath=".\src\dialog_manager.hpp">
+			</File>
+			<File
+				RelativePath=".\src\elevator.hpp">
+			</File>
+			<File
+				RelativePath=".\src\energy_bar.hpp">
+			</File>
+			<File
+				RelativePath=".\src\entity.hpp">
+			</File>
+			<File
+				RelativePath=".\src\field.hpp">
+			</File>
+			<File
+				RelativePath=".\src\file_reader.hpp">
+			</File>
+			<File
+				RelativePath=".\src\file_reader_impl.hpp">
+			</File>
+			<File
+				RelativePath=".\src\game_object.hpp">
+			</File>
+			<File
+				RelativePath=".\src\game_session.hpp">
+			</File>
+			<File
+				RelativePath=".\src\geometry_test.hpp">
+			</File>
+			<File
+				RelativePath=".\src\getter.hpp">
+			</File>
+			<File
+				RelativePath=".\src\globals.hpp">
+			</File>
+			<File
+				RelativePath=".\src\graphic_context_state.hpp">
+			</File>
+			<File
+				RelativePath=".\src\grenade.hpp">
+			</File>
+			<File
+				RelativePath=".\src\handle.hpp">
+			</File>
+			<File
+				RelativePath=".\src\inventory.hpp">
+			</File>
+			<File
+				RelativePath=".\src\laser_pointer.hpp">
+			</File>
+			<File
+				RelativePath=".\src\liquid.hpp">
+			</File>
+			<File
+				RelativePath=".\src\lisp_getters.hpp">
+			</File>
+			<File
+				RelativePath=".\src\math.hpp">
+			</File>
+			<File
+				RelativePath=".\src\menu_manager.hpp">
+			</File>
+			<File
+				RelativePath=".\src\navigation_test.hpp">
+			</File>
+			<File
+				RelativePath=".\src\particle_viewer.hpp">
+			</File>
+			<File
+				RelativePath=".\src\pda.hpp">
+			</File>
+			<File
+				RelativePath=".\src\physics.hpp">
+			</File>
+			<File
+				RelativePath=".\src\pistol.hpp">
+			</File>
+			<File
+				RelativePath=".\src\player.hpp">
+			</File>
+			<File
+				RelativePath=".\src\random.hpp">
+			</File>
+			<File
+				RelativePath=".\src\ref.hpp">
+			</File>
+			<File
+				RelativePath=".\src\refcounter.hpp">
+			</File>
+			<File
+				RelativePath=".\src\response_curve.hpp">
+			</File>
+			<File
+				RelativePath=".\src\screen.hpp">
+			</File>
+			<File
+				RelativePath=".\src\screen_manager.hpp">
+			</File>
+			<File
+				RelativePath=".\src\script_manager.hpp">
+			</File>
+			<File
+				RelativePath=".\src\scriptable_object.hpp">
+			</File>
+			<File
+				RelativePath=".\src\sector.hpp">
+			</File>
+			<File
+				RelativePath=".\src\sharedptr.hpp">
+			</File>
+			<File
+				RelativePath=".\src\spawnpoint.hpp">
+			</File>
+			<File
+				RelativePath=".\src\sprite2dview.hpp">
+			</File>
+			<File
+				RelativePath=".\src\sprite3dview.hpp">
+			</File>
+			<File
+				RelativePath=".\src\text_area.hpp">
+			</File>
+			<File
+				RelativePath=".\src\tile.hpp">
+			</File>
+			<File
+				RelativePath=".\src\tile_description.hpp">
+			</File>
+			<File
+				RelativePath=".\src\tile_factory.hpp">
+			</File>
+			<File
+				RelativePath=".\src\tile_map.hpp">
+			</File>
+			<File
+				RelativePath=".\src\tile_packer.hpp">
+			</File>
+			<File
+				RelativePath=".\src\timer.hpp">
+			</File>
+			<File
+				RelativePath=".\src\title_screen.hpp">
+			</File>
+			<File
+				RelativePath=".\src\trigger.hpp">
+			</File>
+			<File
+				RelativePath=".\src\util.hpp">
+			</File>
+			<File
+				RelativePath=".\src\view.hpp">
+			</File>
+			<File
+				RelativePath=".\src\weapon.hpp">
+			</File>
+			<File
+				RelativePath=".\src\windstille.hpp">
+			</File>
+			<File
+				RelativePath=".\src\windstille_main.hpp">
+			</File>
+			<Filter
+				Name="collision">
+				<File
+					RelativePath=".\src\collision\collision_data.hpp">
+				</File>
+				<File
+					RelativePath=".\src\collision\collision_engine.hpp">
+				</File>
+				<File
+					RelativePath=".\src\collision\collision_object.hpp">
+				</File>
+				<File
+					RelativePath=".\src\collision\collision_test.hpp">
+				</File>
+				<File
+					RelativePath=".\src\collision\contact.hpp">
+				</File>
+				<File
+					RelativePath=".\src\collision\ladder_contact.hpp">
+				</File>
+				<File
+					RelativePath=".\src\collision\stair_contact.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="display">
+				<File
+					RelativePath=".\src\display\display.hpp">
+				</File>
+				<File
+					RelativePath=".\src\display\drawing_context.hpp">
+				</File>
+				<File
+					RelativePath=".\src\display\drawing_request.hpp">
+				</File>
+				<File
+					RelativePath=".\src\display\framebuffer.hpp">
+				</File>
+				<File
+					RelativePath=".\src\display\opengl_state.hpp">
+				</File>
+				<File
+					RelativePath=".\src\display\render_buffer.hpp">
+				</File>
+				<File
+					RelativePath=".\src\display\scene_context.hpp">
+				</File>
+				<File
+					RelativePath=".\src\display\shader_object.hpp">
+				</File>
+				<File
+					RelativePath=".\src\display\shader_program.hpp">
+				</File>
+				<File
+					RelativePath=".\src\display\surface.hpp">
+				</File>
+				<File
+					RelativePath=".\src\display\surface_drawing_parameters.hpp">
+				</File>
+				<File
+					RelativePath=".\src\display\surface_manager.hpp">
+				</File>
+				<File
+					RelativePath=".\src\display\texture.hpp">
+				</File>
+				<File
+					RelativePath=".\src\display\texture_manager.hpp">
+				</File>
+				<File
+					RelativePath=".\src\display\vertex_array_drawing_request.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="font">
+				<File
+					RelativePath=".\src\font\border_font_effect.hpp">
+				</File>
+				<File
+					RelativePath=".\src\font\font_effect.hpp">
+				</File>
+				<File
+					RelativePath=".\src\font\fonts.hpp">
+				</File>
+				<File
+					RelativePath=".\src\font\ttf_font.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="gui">
+				<File
+					RelativePath=".\src\gui\automap.hpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\button.hpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\component.hpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\component_factory.hpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\grid_component.hpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\group_component.hpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\gui_manager.hpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\label.hpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\list_view.hpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\menu_component.hpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\menu_item.hpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\root_component.hpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\slider.hpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\tab_component.hpp">
+				</File>
+				<File
+					RelativePath=".\src\gui\text_view.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="lisp">
+				<File
+					RelativePath=".\src\lisp\getters.hpp">
+				</File>
+				<File
+					RelativePath=".\src\lisp\lexer.hpp">
+				</File>
+				<File
+					RelativePath=".\src\lisp\lisp.hpp">
+				</File>
+				<File
+					RelativePath=".\src\lisp\parser.hpp">
+				</File>
+				<File
+					RelativePath=".\src\lisp\properties.hpp">
+				</File>
+				<File
+					RelativePath=".\src\lisp\property_iterator.hpp">
+				</File>
+				<File
+					RelativePath=".\src\lisp\writer.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="input">
+				<File
+					RelativePath=".\src\input\controller.hpp">
+				</File>
+				<File
+					RelativePath=".\src\input\controller_description.hpp">
+				</File>
+				<File
+					RelativePath=".\src\input\input_configurator.hpp">
+				</File>
+				<File
+					RelativePath=".\src\input\input_event.hpp">
+				</File>
+				<File
+					RelativePath=".\src\input\input_manager.hpp">
+				</File>
+				<File
+					RelativePath=".\src\input\input_manager_impl.hpp">
+				</File>
+				<File
+					RelativePath=".\src\input\input_manager_sdl.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="math">
+				<File
+					RelativePath=".\src\math\line.hpp">
+				</File>
+				<File
+					RelativePath=".\src\math\matrix.hpp">
+				</File>
+				<File
+					RelativePath=".\src\math\origin.hpp">
+				</File>
+				<File
+					RelativePath=".\src\math\point.hpp">
+				</File>
+				<File
+					RelativePath=".\src\math\quaternion.hpp">
+				</File>
+				<File
+					RelativePath=".\src\math\rect.hpp">
+				</File>
+				<File
+					RelativePath=".\src\math\size.hpp">
+				</File>
+				<File
+					RelativePath=".\src\math\vector.hpp">
+				</File>
+				<File
+					RelativePath=".\src\math\vector3.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="tinygettext">
+				<File
+					RelativePath=".\src\tinygettext\gettext.hpp">
+				</File>
+				<File
+					RelativePath=".\src\tinygettext\tinygettext.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="sprite2d">
+				<File
+					RelativePath=".\src\sprite2d\data.hpp">
+				</File>
+				<File
+					RelativePath=".\src\sprite2d\manager.hpp">
+				</File>
+				<File
+					RelativePath=".\src\sprite2d\sprite.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="sprite3d">
+				<File
+					RelativePath=".\src\sprite3d\data.hpp">
+				</File>
+				<File
+					RelativePath=".\src\sprite3d\manager.hpp">
+				</File>
+				<File
+					RelativePath=".\src\sprite3d\sprite3d.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="sound">
+				<File
+					RelativePath=".\src\sound\sound_file.hpp">
+				</File>
+				<File
+					RelativePath=".\src\sound\sound_manager.hpp">
+				</File>
+				<File
+					RelativePath=".\src\sound\sound_source.hpp">
+				</File>
+				<File
+					RelativePath=".\src\sound\stream_sound_source.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="signals">
+				<File
+					RelativePath=".\src\signals\signal.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\signal_v0.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\signal_v1.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\signal_v2.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\signal_v3.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\signal_v4.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\signal_v5.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\signals.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\slot.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\slot_generic.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\slot_v0.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\slot_v1.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\slot_v2.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\slot_v3.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\slot_v4.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\slot_v5.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\slotbuffer_v0.hpp">
+				</File>
+				<File
+					RelativePath=".\src\signals\slotbuffer_v1.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="scripting">
+				<File
+					RelativePath=".\src\scripting\game_objects.hpp">
+				</File>
+				<File
+					RelativePath=".\src\scripting\interface.hpp">
+				</File>
+				<File
+					RelativePath=".\src\scripting\serialize.hpp">
+				</File>
+				<File
+					RelativePath=".\src\scripting\spawn_object.hpp">
+				</File>
+				<File
+					RelativePath=".\src\scripting\squirrel_error.hpp">
+				</File>
+				<File
+					RelativePath=".\src\scripting\util.hpp">
+				</File>
+				<File
+					RelativePath=".\src\scripting\wrapper.hpp">
+				</File>
+				<File
+					RelativePath=".\src\scripting\wrapper.interface.hpp">
+				</File>
+				<File
+					RelativePath=".\src\scripting\wrapper_util.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="physfs">
+				<File
+					RelativePath=".\src\physfs\physfs_sdl.hpp">
+				</File>
+				<File
+					RelativePath=".\src\physfs\physfs_stream.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="particles">
+				<File
+					RelativePath=".\src\particles\deform_drawer.hpp">
+				</File>
+				<File
+					RelativePath=".\src\particles\drawer.hpp">
+				</File>
+				<File
+					RelativePath=".\src\particles\particle_system.hpp">
+				</File>
+				<File
+					RelativePath=".\src\particles\randomizer.hpp">
+				</File>
+				<File
+					RelativePath=".\src\particles\spark_drawer.hpp">
+				</File>
+				<File
+					RelativePath=".\src\particles\surface_drawer.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="objects">
+				<File
+					RelativePath=".\src\objects\background_gradient.hpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\bomb.hpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\hedgehog.hpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\nightvision.hpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\shockwave.hpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\spider_mine.hpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\swarm.hpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\test_object.hpp">
+				</File>
+				<File
+					RelativePath=".\src\objects\vrdummy.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="armature"
+				Filter="">
+				<File
+					RelativePath=".\src\armature\action.hpp">
+				</File>
+				<File
+					RelativePath=".\src\armature\armature.hpp">
+				</File>
+				<File
+					RelativePath=".\src\armature\bone.hpp">
+				</File>
+				<File
+					RelativePath=".\src\armature\mesh.hpp">
+				</File>
+				<File
+					RelativePath=".\src\armature\model.hpp">
+				</File>
+				<File
+					RelativePath=".\src\armature\pose.hpp">
+				</File>
+				<File
+					RelativePath=".\src\armature\pose_bone.hpp">
+				</File>
+			</Filter>
+			<Filter
+				Name="navigation"
+				Filter="">
+				<File
+					RelativePath=".\src\navigation\navigation_graph.hpp">
+				</File>
+				<File
+					RelativePath=".\src\navigation\node.hpp">
+				</File>
+				<File
+					RelativePath=".\src\navigation\properties.hpp">
+				</File>
+				<File
+					RelativePath=".\src\navigation\segment.hpp">
+				</File>
+				<File
+					RelativePath=".\src\navigation\segment_position.hpp">
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="Ressourcendateien"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>

Modified: trunk/windstille/src/display/display.cpp
===================================================================
--- trunk/windstille/src/display/display.cpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/display/display.cpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -495,7 +495,7 @@
 Display::save_screenshot(const std::string& filename)
 {
   int len = get_width() * get_height() * 3;
-  GLbyte pixels[len];
+  GLbyte* pixels = new GLbyte[len];
   glReadPixels(0, 0, get_width(), get_height(), GL_RGB, GL_UNSIGNED_BYTE, pixels);
 
   if (0)
@@ -558,7 +558,8 @@
           png_write_info(png_ptr, info_ptr);
 
           png_uint_32 height = get_height();
-          png_bytep row_pointers[height];
+
+		  png_bytep* row_pointers = new png_bytep[height];
    
           // generate row pointers
           for (unsigned int k = 0; k < height; k++)
@@ -569,6 +570,9 @@
           png_write_end(png_ptr, info_ptr);
 
           fclose(fp);
+
+		  delete[] pixels;
+		  delete[] row_pointers;
         }
     }
 }

Modified: trunk/windstille/src/display/surface_manager.cpp
===================================================================
--- trunk/windstille/src/display/surface_manager.cpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/display/surface_manager.cpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -14,7 +14,7 @@
 #include "texture_manager.hpp"
 #include "physfs/physfs_sdl.hpp"
 
-SurfaceManager::SurfaceManager* surface_manager = 0;
+SurfaceManager* surface_manager = 0;
 
 SurfaceManager::SurfaceManager()
 {

Modified: trunk/windstille/src/display/texture_manager.cpp
===================================================================
--- trunk/windstille/src/display/texture_manager.cpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/display/texture_manager.cpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -12,7 +12,7 @@
 #include "texture.hpp"
 #include "physfs/physfs_sdl.hpp"
 
-TextureManager::TextureManager* texture_manager = 0;
+TextureManager* texture_manager = 0;
 
 TextureManager::TextureManager()
 {

Modified: trunk/windstille/src/gui/root_component.cpp
===================================================================
--- trunk/windstille/src/gui/root_component.cpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/gui/root_component.cpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -24,6 +24,7 @@
 */
 
 #include <iostream>
+#include <algorithm>
 #include "console.hpp"
 #include "input/controller.hpp"
 #include "root_component.hpp"

Modified: trunk/windstille/src/input/input_manager_sdl.cpp
===================================================================
--- trunk/windstille/src/input/input_manager_sdl.cpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/input/input_manager_sdl.cpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -36,7 +36,9 @@
 #include "file_reader.hpp"
 #include "controller_def.hpp"
 #include "input_manager_sdl.hpp"
+#ifdef HAVE_CWIID
 #include "wiimote.hpp"
+#endif
 
 InputManagerSDL* InputManagerSDL::current_ = 0;
 

Modified: trunk/windstille/src/math.hpp
===================================================================
--- trunk/windstille/src/math.hpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/math.hpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -57,7 +57,7 @@
 
 inline float normalize_angle(float radians)
 {
-  radians = fmod (radians, 2.0 * M_PI);
+  radians = fmod (radians, static_cast<float>(2.0 * M_PI));
   if (radians < 0.0)
     radians += 2.0 * M_PI;
   // Floating point math is so loathsome.  In sp98test, the assertion

Modified: trunk/windstille/src/menu_manager.cpp
===================================================================
--- trunk/windstille/src/menu_manager.cpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/menu_manager.cpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -43,7 +43,9 @@
 #include "armature_test.hpp"
 #include "navigation_test.hpp"
 #include "gui/menu_item.hpp"
+#ifdef HAVE_CWIID
 #include "input/wiimote.hpp"
+#endif
 #include "menu_manager.hpp"
 
 MenuManager menu_manager;
@@ -110,12 +112,14 @@
   slots.push_back(gamma_item->sig_change().connect(this, &MenuManager::menu_gamma));
   menu->add_item(gamma_item);
 
+  #ifdef HAVE_CWIID
   if (wiimote)
     {
       ButtonMenuItem* wiimote_button = new ButtonMenuItem(menu,  "Try to Connect Wiimote");
       slots.push_back(wiimote_button->sig_click().connect(this, &MenuManager::menu_wiimote));
       menu->add_item(wiimote_button);
     }
+  #endif
 
   manager->get_root()->add_child(group);
   group->layout();

Modified: trunk/windstille/src/objects/swarm.cpp
===================================================================
--- trunk/windstille/src/objects/swarm.cpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/objects/swarm.cpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -95,7 +95,7 @@
 static float normalize(float angle)
 {
   // brings angle into [0,2*M_PI[ range
-  float ret = fmod(fmod(angle, 2*M_PI) + 2*M_PI, 2*M_PI);
+  float ret = fmod(static_cast<float>(fmod(angle, static_cast<float>(2*M_PI)) + 2*M_PI), static_cast<float>(2*M_PI));
   assert(ret >= 0 && ret < 2*M_PI);
   return ret;
 }

Modified: trunk/windstille/src/particles/particle_system.hpp
===================================================================
--- trunk/windstille/src/particles/particle_system.hpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/particles/particle_system.hpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -34,7 +34,7 @@
 
 class SceneContext;
 class Randomizer;
-class Particle;
+struct Particle;
 class ParticleSystem;
 
 struct Particle {

Modified: trunk/windstille/src/screen_manager.cpp
===================================================================
--- trunk/windstille/src/screen_manager.cpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/screen_manager.cpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -25,7 +25,9 @@
 
 #include <boost/format.hpp>
 #include <iostream>
+#ifndef WIN32
 #include <unistd.h>
+#endif
 #include "game_session.hpp"
 #include "input/input_manager_sdl.hpp"
 #include "display/display.hpp"
@@ -50,6 +52,9 @@
 #include "gui/text_view.hpp"
 #include "gui/automap.hpp"
 
+#ifdef WIN32
+#define snprintf _snprintf
+#endif
 
 using gui::GUIManager;
 
@@ -245,6 +250,7 @@
                   Display::set_fullscreen(config.get_bool("fullscreen"));
                   break;
               
+	            #ifndef WIN32
                 case SDLK_F12:
                   {
                     // FIXME: Replace this with Physfs stuff
@@ -259,6 +265,7 @@
                     console << "Writing screenshot to: '" << filename << "'" << std::endl;
                   }
                   break;
+				  #endif
               
                 default:
                   if (!console.is_active())

Modified: trunk/windstille/src/sector.cpp
===================================================================
--- trunk/windstille/src/sector.cpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/sector.cpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -49,6 +49,7 @@
 #include "scriptable_object.hpp"
 #include "navigation/navigation_graph.hpp"
 #include "scripting/squirrel_error.hpp"
+#include "util.hpp"
 
 // The table (works like a namespace here) where the game objects will appear
 #define OBJECTS_TABLE "objects"
@@ -61,9 +62,7 @@
 {
   // make sure squirrel has an "objects" table
   script_manager->run_script(
-      "if(! (\"" OBJECTS_TABLE "\" in this)) {"
-      "  " OBJECTS_TABLE " <- {};"
-      "}", "");
+      "" OBJECTS_TABLE " <- {};", "");
   
   if (debug) std::cout << "Creating new Sector" << std::endl;
   collision_engine = new CollisionEngine();
@@ -268,7 +267,7 @@
   // get objects table
   HSQUIRRELVM v = script_manager->get_vm();
   sq_pushroottable(v);
-  sq_pushstring(v, OBJECTS_TABLE, -1);
+  sq_pushstring(v, string_to_wstring(OBJECTS_TABLE).c_str(), -1);
   if(SQ_FAILED(sq_get(v, -2)))
   {
     std::ostringstream msg;
@@ -277,7 +276,7 @@
   }
 
   // remove object from table
-  sq_pushstring(v, object->get_name().c_str(), object->get_name().size());
+  sq_pushstring(v, string_to_wstring(object->get_name()).c_str(), object->get_name().size());
   if(SQ_FAILED(sq_deleteslot(v, -2, SQFalse) < 0)) {
     std::ostringstream msg;
     msg << "Couldn't remove squirrel object for '" << object->get_name()
@@ -323,7 +322,7 @@
   // get objects table
   HSQUIRRELVM v = script_manager->get_vm();
   sq_pushroottable(v);
-  sq_pushstring(v, OBJECTS_TABLE, -1);
+  sq_pushstring(v, string_to_wstring(OBJECTS_TABLE).c_str(), -1);
   if(SQ_FAILED(sq_get(v, -2)))
   {
     std::ostringstream msg;
@@ -332,7 +331,7 @@
   }
   
   // create squirrel instance and register in table
-  sq_pushstring(v, object->get_name().c_str(), object->get_name().size());
+  sq_pushstring(v, string_to_wstring(object->get_name()).c_str(), object->get_name().size());
   create_squirrel_instance(v, object);
   if(SQ_FAILED(sq_createslot(v, -3)))
   {

Modified: trunk/windstille/src/sprite3d/data.cpp
===================================================================
--- trunk/windstille/src/sprite3d/data.cpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/sprite3d/data.cpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -46,15 +46,17 @@
 
 static inline std::string read_string(PHYSFS_file* file, size_t size)
 {
-  char buffer[size+1];
+  char* buffer = new char[size+1];
   if(PHYSFS_read(file, buffer, size, 1) != 1) {
     std::ostringstream msg;
     msg << "Problem reading string value: " << PHYSFS_getLastError();
     throw std::runtime_error(msg.str());
   }
   buffer[size] = 0;
+  std::string ret = buffer;
+  delete[] buffer;
 
-  return buffer;
+  return ret;
 }
 
 Data::Data(const std::string& filename)

Modified: trunk/windstille/src/sprite3d/sprite3d.cpp
===================================================================
--- trunk/windstille/src/sprite3d/sprite3d.cpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/sprite3d/sprite3d.cpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -363,7 +363,7 @@
       state.bind_texture(mesh.texture);
 
       // blend between frame1 + frame2
-      float verts[mesh.vertex_count * 3];
+	  float* verts = new float[mesh.vertex_count * 3];
       if(frame1.rot == frame2.rot) {
         for(uint16_t v = 0; v < mesh.vertex_count*3; ++v) {
           float v1 = vertices1.vertices[v];
@@ -397,6 +397,8 @@
       glTexCoordPointer(2, GL_FLOAT, 0, &*mesh.tex_coords.begin());
       glDrawElements(GL_TRIANGLES, mesh.triangle_count * 3, GL_UNSIGNED_SHORT,
                      &*mesh.vertex_indices.begin());
+
+	  delete[] verts;
     }
 
   assert_gl("rendering 3d sprite");      

Modified: trunk/windstille/src/tinygettext/tinygettext.cpp
===================================================================
--- trunk/windstille/src/tinygettext/tinygettext.cpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/tinygettext/tinygettext.cpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -28,6 +28,10 @@
 #include "tinygettext.hpp"
 #include "physfs/physfs_stream.hpp"
 
+#ifdef WIN32
+#define ICONV_CONST const
+#endif
+
 //#define TRANSLATION_DEBUG
 
 namespace tinygettext {

Modified: trunk/windstille/src/util.cpp
===================================================================
--- trunk/windstille/src/util.cpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/util.cpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -47,4 +47,9 @@
   return out;
 }
 
+const std::wstring string_to_wstring(const std::string& str) {
+	std::wstring tmp(str.begin(), str.end());
+	return tmp;
+}
+
 /* EOF */

Modified: trunk/windstille/src/util.hpp
===================================================================
--- trunk/windstille/src/util.hpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/util.hpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -39,5 +39,7 @@
 #endif
 }
 
+const std::wstring string_to_wstring(const std::string& str);
+
 #endif
 

Modified: trunk/windstille/src/windstille_main.cpp
===================================================================
--- trunk/windstille/src/windstille_main.cpp	2008-05-27 03:54:44 UTC (rev 2264)
+++ trunk/windstille/src/windstille_main.cpp	2008-06-26 21:33:50 UTC (rev 2265)
@@ -53,6 +53,11 @@
 #include "particle_viewer.hpp"
 #include "sprite2d/manager.hpp"
 
+#ifdef WIN32
+#include "shlwapi.h"
+#define strcasecmp lstrcmpiA 
+#endif
+
 WindstilleMain::WindstilleMain()
 {
 }
@@ -320,6 +325,7 @@
     size_t l = strlen(*i);
     if((l > extlen) && ((*i)[l - extlen - 1] == '.')) {
       const char* ext = (*i) + (l - extlen);
+
       if(strcasecmp(ext, archiveExt) == 0) {
         const char* d = PHYSFS_getRealDir(*i);
         char* str = new char[strlen(d) + strlen(dirsep) + l + 1];



From jamesgregory at mail.berlios.de  Fri Jun 27 00:22:28 2008
From: jamesgregory at mail.berlios.de (jamesgregory at mail.berlios.de)
Date: Fri, 27 Jun 2008 00:22:28 +0200
Subject: [Windstille-commit] r2266 - trunk/windstille/src
Message-ID: <200806262222.m5QMMST2031104@sheep.berlios.de>

Author: jamesgregory
Date: 2008-06-27 00:22:26 +0200 (Fri, 27 Jun 2008)
New Revision: 2266

Modified:
   trunk/windstille/src/sector.cpp
Log:
accidentally committed a change I didn't mean to

Modified: trunk/windstille/src/sector.cpp
===================================================================
--- trunk/windstille/src/sector.cpp	2008-06-26 21:33:50 UTC (rev 2265)
+++ trunk/windstille/src/sector.cpp	2008-06-26 22:22:26 UTC (rev 2266)
@@ -62,7 +62,9 @@
 {
   // make sure squirrel has an "objects" table
   script_manager->run_script(
-      "" OBJECTS_TABLE " <- {};", "");
+      "if(! (\"" OBJECTS_TABLE "\" in this)) {"
+      "  " OBJECTS_TABLE " <- {};"
+      "}", "");
   
   if (debug) std::cout << "Creating new Sector" << std::endl;
   collision_engine = new CollisionEngine();



From jamesgregory at mail.berlios.de  Fri Jun 27 01:36:03 2008
From: jamesgregory at mail.berlios.de (jamesgregory at mail.berlios.de)
Date: Fri, 27 Jun 2008 01:36:03 +0200
Subject: [Windstille-commit] r2267 - in trunk/windstille/src: . scripting
Message-ID: <200806262336.m5QNa3G8026511@sheep.berlios.de>

Author: jamesgregory
Date: 2008-06-27 01:36:01 +0200 (Fri, 27 Jun 2008)
New Revision: 2267

Modified:
   trunk/windstille/src/script_manager.cpp
   trunk/windstille/src/scripting/util.cpp
   trunk/windstille/src/util.cpp
   trunk/windstille/src/util.hpp
Log:
error messages from squirrel are successfully written to log file. As far as I can remember this has always been broken, and it seems it was due to treating SQChar (which are type deffed to wchar_t) as normal char *

Modified: trunk/windstille/src/script_manager.cpp
===================================================================
--- trunk/windstille/src/script_manager.cpp	2008-06-26 22:22:26 UTC (rev 2266)
+++ trunk/windstille/src/script_manager.cpp	2008-06-26 23:36:01 UTC (rev 2267)
@@ -17,20 +17,28 @@
 #include "scripting/util.hpp"
 #include "scripting/squirrel_error.hpp"
 #include "physfs/physfs_stream.hpp"
+#include "util.hpp"
 
 using namespace Scripting;
 
 ScriptManager* script_manager = 0;
 
-static void printfunc(HSQUIRRELVM, const char* str, ...)
+
+
+static void printfunc(HSQUIRRELVM, const SQChar *str, ...)
 {
-  char buf[4096];
-  va_list arglist; 
-  va_start(arglist, str); 
-  vsprintf(buf, str, arglist);
-  console << (char*)buf;
-  puts(buf);
-  va_end(arglist); 
+  std::wostringstream ss;
+	wchar_t buf[4096];
+
+	va_list arglist;
+	va_start(arglist, str);
+	vswprintf(buf, str, arglist);
+	ss << (const wchar_t*) buf << std::flush;
+	va_end(arglist);
+
+  std::string to_print = wstring_to_string(ss.str());
+  console << ss.str().c_str();
+  std::cout << to_print.c_str();
 }
 
 ScriptManager::ScriptManager()
@@ -108,7 +116,7 @@
   sq_addref(v, &vm_obj);
   sq_pop(v, 1);
   
-  if(sq_compile(vm, squirrel_read_char, &in, sourcename.c_str(), true) < 0)
+  if(sq_compile(vm, squirrel_read_char, &in, string_to_wstring(sourcename).c_str(), true) < 0)
     throw SquirrelError(vm, "Couldn't parse script");
 	
   squirrel_vms.push_back(SquirrelVM(sourcename, vm, vm_obj));

Modified: trunk/windstille/src/scripting/util.cpp
===================================================================
--- trunk/windstille/src/scripting/util.cpp	2008-06-26 22:22:26 UTC (rev 2266)
+++ trunk/windstille/src/scripting/util.cpp	2008-06-26 23:36:01 UTC (rev 2267)
@@ -32,8 +32,8 @@
 #include "lisp/parser.hpp"
 #include "lisp/properties.hpp"
 #include "lisp/writer.hpp"
-
 #include "util.hpp"
+#include "../util.hpp"
 
 namespace Scripting {
 
@@ -63,9 +63,9 @@
       break;
     }
     case OT_STRING: {
-      const char* str;
+      const wchar_t* str;
       sq_getstring(v, -1, &str);      
-      entries.push_back(new lisp::Lisp(lisp::Lisp::TYPE_STRING, str));
+      entries.push_back(new lisp::Lisp(lisp::Lisp::TYPE_STRING, wstring_to_string(str)));
       break;
     }                                                    
     case OT_BOOL: {
@@ -101,9 +101,9 @@
         continue;
       }
 
-      const char* key;
+      const wchar_t* key;
       sq_getstring(v, -2, &key);
-      std::string lisp_key = sq_to_lisp_string(key);
+      std::string lisp_key = sq_to_lisp_string(wstring_to_string(key));
 
       std::vector<lisp::Lisp*> childs;
       childs.push_back(new lisp::Lisp(lisp::Lisp::TYPE_SYMBOL, lisp_key));
@@ -150,7 +150,7 @@
       break;
     }
     case OT_STRING: {
-      const char* val;
+      const wchar_t* val;
       sq_getstring(v, i, &val);
       os << "\"" << val << "\"";
       break;    
@@ -252,7 +252,7 @@
                 break;
             }
             case OT_STRING: {
-                const char* val;
+                const wchar_t* val;
                 sq_getstring(v, i, &val);
                 printf("string (%s)", val);
                 break;    
@@ -303,7 +303,7 @@
   Properties props(lisp);
   PropertyIterator<const lisp::Lisp*> iter = props.get_iter();
   while(iter.next()) {
-    sq_pushstring(v, iter.item().c_str(), iter.item().size());
+    sq_pushstring(v, string_to_wstring(iter.item()).c_str(), iter.item().size());
     switch((*iter)->get_type()) {
       case lisp::Lisp::TYPE_LIST:
         sq_newtable(v);
@@ -316,7 +316,7 @@
         sq_pushfloat(v, (*iter)->get_float());
         break;
       case lisp::Lisp::TYPE_STRING:
-        sq_pushstring(v, (*iter)->get_string(), -1);
+        sq_pushstring(v, string_to_wstring((*iter)->get_string()).c_str(), -1);
         break;
       case lisp::Lisp::TYPE_BOOL:
         sq_pushbool(v, (*iter)->get_bool());
@@ -363,8 +363,9 @@
       std::cerr << "Table contains non-string key\n";
       continue;
     }
-    const char* key;
-    sq_getstring(v, -2, &key);
+    const wchar_t* wkey;
+    sq_getstring(v, -2, &wkey);
+    std::string key = wstring_to_string(wkey);
 
     switch(sq_gettype(v, -1)) {
       case OT_INTEGER: {
@@ -386,9 +387,9 @@
         break;
       }
       case OT_STRING: {
-        const char* str;
+        const wchar_t* str;
         sq_getstring(v, -1, &str);
-        writer.write_string(key, str);
+        writer.write_string(key, wstring_to_string(str));
         break;
       }
       case OT_TABLE: {

Modified: trunk/windstille/src/util.cpp
===================================================================
--- trunk/windstille/src/util.cpp	2008-06-26 22:22:26 UTC (rev 2266)
+++ trunk/windstille/src/util.cpp	2008-06-26 23:36:01 UTC (rev 2267)
@@ -52,4 +52,9 @@
 	return tmp;
 }
 
+const std::string wstring_to_string(const std::wstring& str) {
+	std::string tmp(str.begin(), str.end());
+	return tmp;
+}
+
 /* EOF */

Modified: trunk/windstille/src/util.hpp
===================================================================
--- trunk/windstille/src/util.hpp	2008-06-26 22:22:26 UTC (rev 2266)
+++ trunk/windstille/src/util.hpp	2008-06-26 23:36:01 UTC (rev 2267)
@@ -40,6 +40,7 @@
 }
 
 const std::wstring string_to_wstring(const std::string& str);
+const std::string wstring_to_string(const std::wstring& str);
 
 #endif
 



From jamesgregory at mail.berlios.de  Fri Jun 27 02:13:52 2008
From: jamesgregory at mail.berlios.de (jamesgregory at mail.berlios.de)
Date: Fri, 27 Jun 2008 02:13:52 +0200
Subject: [Windstille-commit] r2268 - in trunk/windstille: data/levels
	src/scripting
Message-ID: <200806270013.m5R0DqSG010213@sheep.berlios.de>

Author: jamesgregory
Date: 2008-06-27 02:13:45 +0200 (Fri, 27 Jun 2008)
New Revision: 2268

Modified:
   trunk/windstille/data/levels/intro.wst
   trunk/windstille/src/scripting/wrapper.cpp
Log:
don't confuse wchar_t and char when dealing with squirrel

Modified: trunk/windstille/data/levels/intro.wst
===================================================================
--- trunk/windstille/data/levels/intro.wst	2008-06-26 23:36:01 UTC (rev 2267)
+++ trunk/windstille/data/levels/intro.wst	2008-06-27 00:13:45 UTC (rev 2268)
@@ -2,7 +2,7 @@
 (windstille-sector
   (version 2)
   (name   "")
-  (music  "music/silence_wip.ogg")
+  (music  "levels/silence_wip.ogg")
   (ambient-color .666 .666 .666)
   (init-script "levels/intro.nut")
   (spawnpoint

Modified: trunk/windstille/src/scripting/wrapper.cpp
===================================================================
--- trunk/windstille/src/scripting/wrapper.cpp	2008-06-26 23:36:01 UTC (rev 2267)
+++ trunk/windstille/src/scripting/wrapper.cpp	2008-06-27 00:13:45 UTC (rev 2268)
@@ -13,6 +13,8 @@
 #include "squirrel_error.hpp"
 #include "wrapper.interface.hpp"
 
+#include "../util.hpp"
+
 namespace Scripting
 {
 namespace Wrapper
@@ -37,11 +39,11 @@
   try {
     const std::string& return_value = _this->get_name();
   
-    sq_pushstring(vm, return_value.c_str(), return_value.size());
+    sq_pushstring(vm, string_to_wstring(return_value).c_str(), return_value.size());
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'get_name'"));
@@ -65,7 +67,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'remove'"));
@@ -94,7 +96,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_active'"));
@@ -118,12 +120,12 @@
   }
   
   try {
-    _this->set_parent(arg0);
+    _this->set_parent(wstring_to_string(arg0));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_parent'"));
@@ -154,12 +156,12 @@
   }
   
   try {
-    _this->set_sprite(arg0);
+    _this->set_sprite(wstring_to_string(arg0));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_sprite'"));
@@ -183,12 +185,12 @@
   }
   
   try {
-    _this->set_action(arg0);
+    _this->set_action(wstring_to_string(arg0));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_action'"));
@@ -222,7 +224,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_pos'"));
@@ -251,7 +253,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_vflip'"));
@@ -280,12 +282,12 @@
   }
   
   try {
-    _this->attach(arg0, arg1);
+    _this->attach(wstring_to_string(arg0), wstring_to_string(arg1));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'attach'"));
@@ -316,7 +318,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'start_listening'"));
@@ -340,7 +342,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'stop_listening'"));
@@ -391,7 +393,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'move_to'"));
@@ -420,7 +422,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'start_flash'"));
@@ -438,12 +440,12 @@
   }
   
   try {
-    Scripting::set_sector(arg0);
+    Scripting::set_sector(wstring_to_string(arg0));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_sector'"));
@@ -461,12 +463,12 @@
   }
   
   try {
-    Scripting::play_music(arg0);
+    Scripting::play_music(wstring_to_string(arg0));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'play_music'"));
@@ -489,7 +491,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'stop_music'"));
@@ -507,12 +509,12 @@
   }
   
   try {
-    Scripting::play_sound(arg0);
+    Scripting::play_sound(wstring_to_string(arg0));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'play_sound'"));
@@ -535,12 +537,12 @@
   }
   
   try {
-    Scripting::caption_add(static_cast<int> (arg0), arg1);
+    Scripting::caption_add(static_cast<int> (arg0), wstring_to_string(arg1));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'caption_add'"));
@@ -559,7 +561,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'caption_clear'"));
@@ -578,7 +580,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'caption_end'"));
@@ -601,7 +603,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'camera_set_active'"));
@@ -620,7 +622,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'camera_continue_path'"));
@@ -639,7 +641,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'camera_begin_path'"));
@@ -672,7 +674,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'camera_add_point'"));
@@ -691,7 +693,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'camera_end_path'"));
@@ -719,7 +721,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'camera_set_pos'"));
@@ -742,7 +744,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'camera_set_zoom'"));
@@ -765,7 +767,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_controller_help_active'"));
@@ -798,12 +800,12 @@
   }
   
   try {
-    Scripting::dialog_show(static_cast<int> (arg0), arg1, arg2, arg3);
+    Scripting::dialog_show(static_cast<int> (arg0), wstring_to_string(arg1), wstring_to_string(arg2), wstring_to_string(arg3));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'dialog_show'"));
@@ -822,7 +824,7 @@
     return sq_suspendvm(vm);
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'wait_for_dialog'"));
@@ -841,7 +843,7 @@
     return sq_suspendvm(vm);
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'wait_for_fade'"));
@@ -860,7 +862,7 @@
     return sq_suspendvm(vm);
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'wait_for_camera'"));
@@ -878,12 +880,12 @@
   }
   
   try {
-    Scripting::conversation_add(arg0);
+    Scripting::conversation_add(wstring_to_string(arg0));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'conversation_add'"));
@@ -906,12 +908,12 @@
   }
   
   try {
-    Scripting::conversation_add2(arg0, arg1);
+    Scripting::conversation_add2(wstring_to_string(arg0), wstring_to_string(arg1));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'conversation_add2'"));
@@ -930,7 +932,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'conversation_show'"));
@@ -949,7 +951,7 @@
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'conversation_get_selection'"));
@@ -968,7 +970,7 @@
     return sq_suspendvm(vm);
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'wait_for_conversation'"));
@@ -991,12 +993,12 @@
   }
   
   try {
-    Scripting::add_objective(arg0, arg1);
+    Scripting::add_objective(wstring_to_string(arg0), wstring_to_string(arg1));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'add_objective'"));
@@ -1014,12 +1016,12 @@
   }
   
   try {
-    Scripting::objective_complete(arg0);
+    Scripting::objective_complete(wstring_to_string(arg0));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'objective_complete'"));
@@ -1037,13 +1039,13 @@
   }
   
   try {
-    bool return_value = Scripting::is_objective_given(arg0);
+    bool return_value = Scripting::is_objective_given(wstring_to_string(arg0));
   
     sq_pushbool(vm, return_value);
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'is_objective_given'"));
@@ -1061,13 +1063,13 @@
   }
   
   try {
-    bool return_value = Scripting::is_objective_complete(arg0);
+    bool return_value = Scripting::is_objective_complete(wstring_to_string(arg0));
   
     sq_pushbool(vm, return_value);
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'is_objective_complete'"));
@@ -1087,7 +1089,7 @@
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'run_before'"));
@@ -1106,12 +1108,12 @@
   }
   
   try {
-    Scripting::save_state(arg0, arg1);
+    Scripting::save_state(arg0, wstring_to_string(arg1));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'save_state'"));
@@ -1130,12 +1132,12 @@
   }
   
   try {
-    Scripting::load_state(arg0, arg1);
+    Scripting::load_state(arg0, wstring_to_string(arg1));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'load_state'"));
@@ -1154,7 +1156,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'list_objects'"));
@@ -1177,7 +1179,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_debug'"));
@@ -1196,7 +1198,7 @@
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'get_debug'"));
@@ -1215,7 +1217,7 @@
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'get_game_speed'"));
@@ -1238,7 +1240,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_game_speed'"));
@@ -1262,7 +1264,7 @@
     return sq_suspendvm(vm);
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'wait'"));
@@ -1295,12 +1297,12 @@
   }
   
   try {
-    Scripting::set_console_font(arg0, static_cast<int> (arg1));
+    Scripting::set_console_font(wstring_to_string(arg0), static_cast<int> (arg1));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_console_font'"));
@@ -1323,7 +1325,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_gamma'"));
@@ -1356,7 +1358,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_gamma_rgb'"));
@@ -1375,7 +1377,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'show_config'"));
@@ -1394,7 +1396,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'cutscene_begin'"));
@@ -1413,7 +1415,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'cutscene_end'"));
@@ -1451,7 +1453,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'internal_fadeout_rgb'"));
@@ -1474,7 +1476,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'internal_fadein'"));
@@ -1493,7 +1495,7 @@
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'render_mask_get'"));
@@ -1516,7 +1518,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, e.what());
+    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'render_mask_set'"));
@@ -1537,7 +1539,7 @@
   using namespace Wrapper;
 
   sq_pushroottable(v);
-  sq_pushstring(v, "GameObject", -1);
+  sq_pushstring(v, _SC("GameObject"), -1);
   if(SQ_FAILED(sq_get(v, -2))) {
     std::ostringstream msg;
     msg << "Couldn't resolved squirrel type 'GameObject'";
@@ -1563,7 +1565,7 @@
   using namespace Wrapper;
 
   sq_pushroottable(v);
-  sq_pushstring(v, "TestObject", -1);
+  sq_pushstring(v, _SC("TestObject"), -1);
   if(SQ_FAILED(sq_get(v, -2))) {
     std::ostringstream msg;
     msg << "Couldn't resolved squirrel type 'TestObject'";
@@ -1589,7 +1591,7 @@
   using namespace Wrapper;
 
   sq_pushroottable(v);
-  sq_pushstring(v, "Player", -1);
+  sq_pushstring(v, _SC("Player"), -1);
   if(SQ_FAILED(sq_get(v, -2))) {
     std::ostringstream msg;
     msg << "Couldn't resolved squirrel type 'Player'";
@@ -1615,7 +1617,7 @@
   using namespace Wrapper;
 
   sq_pushroottable(v);
-  sq_pushstring(v, "ScriptableObject", -1);
+  sq_pushstring(v, _SC("ScriptableObject"), -1);
   if(SQ_FAILED(sq_get(v, -2))) {
     std::ostringstream msg;
     msg << "Couldn't resolved squirrel type 'ScriptableObject'";
@@ -1640,368 +1642,368 @@
 {
   using namespace Wrapper;
 
-  sq_pushstring(v, "VCENTER", -1);
+  sq_pushstring(v, _SC("VCENTER"), -1);
   sq_pushinteger(v, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register constant 'VCENTER'");
   }
 
-  sq_pushstring(v, "LEFT", -1);
+  sq_pushstring(v, _SC("LEFT"), -1);
   sq_pushinteger(v, 1);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register constant 'LEFT'");
   }
 
-  sq_pushstring(v, "RIGHT", -1);
+  sq_pushstring(v, _SC("RIGHT"), -1);
   sq_pushinteger(v, 2);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register constant 'RIGHT'");
   }
 
-  sq_pushstring(v, "HCENTER", -1);
+  sq_pushstring(v, _SC("HCENTER"), -1);
   sq_pushinteger(v, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register constant 'HCENTER'");
   }
 
-  sq_pushstring(v, "TOP", -1);
+  sq_pushstring(v, _SC("TOP"), -1);
   sq_pushinteger(v, 16);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register constant 'TOP'");
   }
 
-  sq_pushstring(v, "BOTTOM", -1);
+  sq_pushstring(v, _SC("BOTTOM"), -1);
   sq_pushinteger(v, 32);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register constant 'BOTTOM'");
   }
 
-  sq_pushstring(v, "set_sector", -1);
+  sq_pushstring(v, _SC("set_sector"), -1);
   sq_newclosure(v, &set_sector_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_sector'");
   }
 
-  sq_pushstring(v, "play_music", -1);
+  sq_pushstring(v, _SC("play_music"), -1);
   sq_newclosure(v, &play_music_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'play_music'");
   }
 
-  sq_pushstring(v, "stop_music", -1);
+  sq_pushstring(v, _SC("stop_music"), -1);
   sq_newclosure(v, &stop_music_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'stop_music'");
   }
 
-  sq_pushstring(v, "play_sound", -1);
+  sq_pushstring(v, _SC("play_sound"), -1);
   sq_newclosure(v, &play_sound_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'play_sound'");
   }
 
-  sq_pushstring(v, "caption_add", -1);
+  sq_pushstring(v, _SC("caption_add"), -1);
   sq_newclosure(v, &caption_add_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'caption_add'");
   }
 
-  sq_pushstring(v, "caption_clear", -1);
+  sq_pushstring(v, _SC("caption_clear"), -1);
   sq_newclosure(v, &caption_clear_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'caption_clear'");
   }
 
-  sq_pushstring(v, "caption_end", -1);
+  sq_pushstring(v, _SC("caption_end"), -1);
   sq_newclosure(v, &caption_end_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'caption_end'");
   }
 
-  sq_pushstring(v, "camera_set_active", -1);
+  sq_pushstring(v, _SC("camera_set_active"), -1);
   sq_newclosure(v, &camera_set_active_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'camera_set_active'");
   }
 
-  sq_pushstring(v, "camera_continue_path", -1);
+  sq_pushstring(v, _SC("camera_continue_path"), -1);
   sq_newclosure(v, &camera_continue_path_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'camera_continue_path'");
   }
 
-  sq_pushstring(v, "camera_begin_path", -1);
+  sq_pushstring(v, _SC("camera_begin_path"), -1);
   sq_newclosure(v, &camera_begin_path_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'camera_begin_path'");
   }
 
-  sq_pushstring(v, "camera_add_point", -1);
+  sq_pushstring(v, _SC("camera_add_point"), -1);
   sq_newclosure(v, &camera_add_point_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'camera_add_point'");
   }
 
-  sq_pushstring(v, "camera_end_path", -1);
+  sq_pushstring(v, _SC("camera_end_path"), -1);
   sq_newclosure(v, &camera_end_path_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'camera_end_path'");
   }
 
-  sq_pushstring(v, "camera_set_pos", -1);
+  sq_pushstring(v, _SC("camera_set_pos"), -1);
   sq_newclosure(v, &camera_set_pos_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'camera_set_pos'");
   }
 
-  sq_pushstring(v, "camera_set_zoom", -1);
+  sq_pushstring(v, _SC("camera_set_zoom"), -1);
   sq_newclosure(v, &camera_set_zoom_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'camera_set_zoom'");
   }
 
-  sq_pushstring(v, "set_controller_help_active", -1);
+  sq_pushstring(v, _SC("set_controller_help_active"), -1);
   sq_newclosure(v, &set_controller_help_active_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_controller_help_active'");
   }
 
-  sq_pushstring(v, "dialog_show", -1);
+  sq_pushstring(v, _SC("dialog_show"), -1);
   sq_newclosure(v, &dialog_show_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'dialog_show'");
   }
 
-  sq_pushstring(v, "wait_for_dialog", -1);
+  sq_pushstring(v, _SC("wait_for_dialog"), -1);
   sq_newclosure(v, &wait_for_dialog_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'wait_for_dialog'");
   }
 
-  sq_pushstring(v, "wait_for_fade", -1);
+  sq_pushstring(v, _SC("wait_for_fade"), -1);
   sq_newclosure(v, &wait_for_fade_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'wait_for_fade'");
   }
 
-  sq_pushstring(v, "wait_for_camera", -1);
+  sq_pushstring(v, _SC("wait_for_camera"), -1);
   sq_newclosure(v, &wait_for_camera_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'wait_for_camera'");
   }
 
-  sq_pushstring(v, "conversation_add", -1);
+  sq_pushstring(v, _SC("conversation_add"), -1);
   sq_newclosure(v, &conversation_add_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'conversation_add'");
   }
 
-  sq_pushstring(v, "conversation_add2", -1);
+  sq_pushstring(v, _SC("conversation_add2"), -1);
   sq_newclosure(v, &conversation_add2_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'conversation_add2'");
   }
 
-  sq_pushstring(v, "conversation_show", -1);
+  sq_pushstring(v, _SC("conversation_show"), -1);
   sq_newclosure(v, &conversation_show_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'conversation_show'");
   }
 
-  sq_pushstring(v, "conversation_get_selection", -1);
+  sq_pushstring(v, _SC("conversation_get_selection"), -1);
   sq_newclosure(v, &conversation_get_selection_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'conversation_get_selection'");
   }
 
-  sq_pushstring(v, "wait_for_conversation", -1);
+  sq_pushstring(v, _SC("wait_for_conversation"), -1);
   sq_newclosure(v, &wait_for_conversation_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'wait_for_conversation'");
   }
 
-  sq_pushstring(v, "add_objective", -1);
+  sq_pushstring(v, _SC("add_objective"), -1);
   sq_newclosure(v, &add_objective_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'add_objective'");
   }
 
-  sq_pushstring(v, "objective_complete", -1);
+  sq_pushstring(v, _SC("objective_complete"), -1);
   sq_newclosure(v, &objective_complete_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'objective_complete'");
   }
 
-  sq_pushstring(v, "is_objective_given", -1);
+  sq_pushstring(v, _SC("is_objective_given"), -1);
   sq_newclosure(v, &is_objective_given_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'is_objective_given'");
   }
 
-  sq_pushstring(v, "is_objective_complete", -1);
+  sq_pushstring(v, _SC("is_objective_complete"), -1);
   sq_newclosure(v, &is_objective_complete_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'is_objective_complete'");
   }
 
-  sq_pushstring(v, "run_before", -1);
+  sq_pushstring(v, _SC("run_before"), -1);
   sq_newclosure(v, &run_before_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'run_before'");
   }
 
-  sq_pushstring(v, "save_state", -1);
+  sq_pushstring(v, _SC("save_state"), -1);
   sq_newclosure(v, &save_state_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'save_state'");
   }
 
-  sq_pushstring(v, "load_state", -1);
+  sq_pushstring(v, _SC("load_state"), -1);
   sq_newclosure(v, &load_state_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'load_state'");
   }
 
-  sq_pushstring(v, "list_objects", -1);
+  sq_pushstring(v, _SC("list_objects"), -1);
   sq_newclosure(v, &list_objects_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'list_objects'");
   }
 
-  sq_pushstring(v, "set_debug", -1);
+  sq_pushstring(v, _SC("set_debug"), -1);
   sq_newclosure(v, &set_debug_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_debug'");
   }
 
-  sq_pushstring(v, "get_debug", -1);
+  sq_pushstring(v, _SC("get_debug"), -1);
   sq_newclosure(v, &get_debug_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'get_debug'");
   }
 
-  sq_pushstring(v, "get_game_speed", -1);
+  sq_pushstring(v, _SC("get_game_speed"), -1);
   sq_newclosure(v, &get_game_speed_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'get_game_speed'");
   }
 
-  sq_pushstring(v, "set_game_speed", -1);
+  sq_pushstring(v, _SC("set_game_speed"), -1);
   sq_newclosure(v, &set_game_speed_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_game_speed'");
   }
 
-  sq_pushstring(v, "wait", -1);
+  sq_pushstring(v, _SC("wait"), -1);
   sq_newclosure(v, &wait_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'wait'");
   }
 
-  sq_pushstring(v, "display", -1);
+  sq_pushstring(v, _SC("display"), -1);
   sq_newclosure(v, &display_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'display'");
   }
 
-  sq_pushstring(v, "println", -1);
+  sq_pushstring(v, _SC("println"), -1);
   sq_newclosure(v, &println_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'println'");
   }
 
-  sq_pushstring(v, "set_console_font", -1);
+  sq_pushstring(v, _SC("set_console_font"), -1);
   sq_newclosure(v, &set_console_font_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_console_font'");
   }
 
-  sq_pushstring(v, "set_gamma", -1);
+  sq_pushstring(v, _SC("set_gamma"), -1);
   sq_newclosure(v, &set_gamma_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_gamma'");
   }
 
-  sq_pushstring(v, "set_gamma_rgb", -1);
+  sq_pushstring(v, _SC("set_gamma_rgb"), -1);
   sq_newclosure(v, &set_gamma_rgb_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_gamma_rgb'");
   }
 
-  sq_pushstring(v, "show_config", -1);
+  sq_pushstring(v, _SC("show_config"), -1);
   sq_newclosure(v, &show_config_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'show_config'");
   }
 
-  sq_pushstring(v, "cutscene_begin", -1);
+  sq_pushstring(v, _SC("cutscene_begin"), -1);
   sq_newclosure(v, &cutscene_begin_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'cutscene_begin'");
   }
 
-  sq_pushstring(v, "cutscene_end", -1);
+  sq_pushstring(v, _SC("cutscene_end"), -1);
   sq_newclosure(v, &cutscene_end_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'cutscene_end'");
   }
 
-  sq_pushstring(v, "internal_fadeout_rgb", -1);
+  sq_pushstring(v, _SC("internal_fadeout_rgb"), -1);
   sq_newclosure(v, &internal_fadeout_rgb_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'internal_fadeout_rgb'");
   }
 
-  sq_pushstring(v, "internal_fadein", -1);
+  sq_pushstring(v, _SC("internal_fadein"), -1);
   sq_newclosure(v, &internal_fadein_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'internal_fadein'");
   }
 
-  sq_pushstring(v, "render_mask_get", -1);
+  sq_pushstring(v, _SC("render_mask_get"), -1);
   sq_newclosure(v, &render_mask_get_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'render_mask_get'");
   }
 
-  sq_pushstring(v, "render_mask_set", -1);
+  sq_pushstring(v, _SC("render_mask_set"), -1);
   sq_newclosure(v, &render_mask_set_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'render_mask_set'");
   }
 
-  sq_pushstring(v, "spawn_object", -1);
+  sq_pushstring(v, _SC("spawn_object"), -1);
   sq_newclosure(v, &spawn_object_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'spawn_object'");
   }
 
   // Register class GameObject
-  sq_pushstring(v, "GameObject", -1);
+  sq_pushstring(v, _SC("GameObject"), -1);
   if(sq_newclass(v, SQFalse) < 0) {
     std::ostringstream msg;
     msg << "Couldn't create new class 'GameObject'";
     throw SquirrelError(v, msg.str());
   }
-  sq_pushstring(v, "get_name", -1);
+  sq_pushstring(v, _SC("get_name"), -1);
   sq_newclosure(v, &GameObject_get_name_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'get_name'");
   }
 
-  sq_pushstring(v, "remove", -1);
+  sq_pushstring(v, _SC("remove"), -1);
   sq_newclosure(v, &GameObject_remove_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'remove'");
   }
 
-  sq_pushstring(v, "set_active", -1);
+  sq_pushstring(v, _SC("set_active"), -1);
   sq_newclosure(v, &GameObject_set_active_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_active'");
   }
 
-  sq_pushstring(v, "set_parent", -1);
+  sq_pushstring(v, _SC("set_parent"), -1);
   sq_newclosure(v, &GameObject_set_parent_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_parent'");
@@ -2012,39 +2014,39 @@
   }
 
   // Register class TestObject
-  sq_pushstring(v, "TestObject", -1);
-  sq_pushstring(v, "GameObject", -1);
+  sq_pushstring(v, _SC("TestObject"), -1);
+  sq_pushstring(v, _SC("GameObject"), -1);
   sq_get(v, -3);
   if(sq_newclass(v, SQTrue) < 0) {
     std::ostringstream msg;
     msg << "Couldn't create new class 'TestObject'";
     throw SquirrelError(v, msg.str());
   }
-  sq_pushstring(v, "set_sprite", -1);
+  sq_pushstring(v, _SC("set_sprite"), -1);
   sq_newclosure(v, &TestObject_set_sprite_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_sprite'");
   }
 
-  sq_pushstring(v, "set_action", -1);
+  sq_pushstring(v, _SC("set_action"), -1);
   sq_newclosure(v, &TestObject_set_action_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_action'");
   }
 
-  sq_pushstring(v, "set_pos", -1);
+  sq_pushstring(v, _SC("set_pos"), -1);
   sq_newclosure(v, &TestObject_set_pos_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_pos'");
   }
 
-  sq_pushstring(v, "set_vflip", -1);
+  sq_pushstring(v, _SC("set_vflip"), -1);
   sq_newclosure(v, &TestObject_set_vflip_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_vflip'");
   }
 
-  sq_pushstring(v, "attach", -1);
+  sq_pushstring(v, _SC("attach"), -1);
   sq_newclosure(v, &TestObject_attach_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'attach'");
@@ -2055,21 +2057,21 @@
   }
 
   // Register class Player
-  sq_pushstring(v, "Player", -1);
-  sq_pushstring(v, "GameObject", -1);
+  sq_pushstring(v, _SC("Player"), -1);
+  sq_pushstring(v, _SC("GameObject"), -1);
   sq_get(v, -3);
   if(sq_newclass(v, SQTrue) < 0) {
     std::ostringstream msg;
     msg << "Couldn't create new class 'Player'";
     throw SquirrelError(v, msg.str());
   }
-  sq_pushstring(v, "start_listening", -1);
+  sq_pushstring(v, _SC("start_listening"), -1);
   sq_newclosure(v, &Player_start_listening_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'start_listening'");
   }
 
-  sq_pushstring(v, "stop_listening", -1);
+  sq_pushstring(v, _SC("stop_listening"), -1);
   sq_newclosure(v, &Player_stop_listening_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'stop_listening'");
@@ -2080,21 +2082,21 @@
   }
 
   // Register class ScriptableObject
-  sq_pushstring(v, "ScriptableObject", -1);
-  sq_pushstring(v, "GameObject", -1);
+  sq_pushstring(v, _SC("ScriptableObject"), -1);
+  sq_pushstring(v, _SC("GameObject"), -1);
   sq_get(v, -3);
   if(sq_newclass(v, SQTrue) < 0) {
     std::ostringstream msg;
     msg << "Couldn't create new class 'ScriptableObject'";
     throw SquirrelError(v, msg.str());
   }
-  sq_pushstring(v, "move_to", -1);
+  sq_pushstring(v, _SC("move_to"), -1);
   sq_newclosure(v, &ScriptableObject_move_to_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'move_to'");
   }
 
-  sq_pushstring(v, "start_flash", -1);
+  sq_pushstring(v, _SC("start_flash"), -1);
   sq_newclosure(v, &ScriptableObject_start_flash_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'start_flash'");



From jamesgregory at mail.berlios.de  Fri Jun 27 12:48:34 2008
From: jamesgregory at mail.berlios.de (jamesgregory at mail.berlios.de)
Date: Fri, 27 Jun 2008 12:48:34 +0200
Subject: [Windstille-commit] r2269 - trunk/windstille/lib
Message-ID: <200806271048.m5RAmYGc016625@sheep.berlios.de>

Author: jamesgregory
Date: 2008-06-27 12:48:29 +0200 (Fri, 27 Jun 2008)
New Revision: 2269

Removed:
   trunk/windstille/lib/SQUIRREL2/
Log:
delete old version of squirrel, will now add new one



From jamesgregory at mail.berlios.de  Fri Jun 27 13:51:26 2008
From: jamesgregory at mail.berlios.de (jamesgregory at mail.berlios.de)
Date: Fri, 27 Jun 2008 13:51:26 +0200
Subject: [Windstille-commit] r2271 - in trunk/windstille/src: . scripting
Message-ID: <200806271151.m5RBpQmJ022183@sheep.berlios.de>

Author: jamesgregory
Date: 2008-06-27 13:51:22 +0200 (Fri, 27 Jun 2008)
New Revision: 2271

Modified:
   trunk/windstille/src/script_manager.cpp
   trunk/windstille/src/scripting/util.cpp
   trunk/windstille/src/scripting/wrapper.cpp
   trunk/windstille/src/sector.cpp
   trunk/windstille/src/util.cpp
   trunk/windstille/src/util.hpp
Log:
revert changesets 2267, 2268, and a bit of 2265


Modified: trunk/windstille/src/script_manager.cpp
===================================================================
--- trunk/windstille/src/script_manager.cpp	2008-06-27 10:49:53 UTC (rev 2270)
+++ trunk/windstille/src/script_manager.cpp	2008-06-27 11:51:22 UTC (rev 2271)
@@ -17,28 +17,20 @@
 #include "scripting/util.hpp"
 #include "scripting/squirrel_error.hpp"
 #include "physfs/physfs_stream.hpp"
-#include "util.hpp"
 
 using namespace Scripting;
 
 ScriptManager* script_manager = 0;
 
-
-
-static void printfunc(HSQUIRRELVM, const SQChar *str, ...)
+static void printfunc(HSQUIRRELVM, const char* str, ...)
 {
-  std::wostringstream ss;
-	wchar_t buf[4096];
-
-	va_list arglist;
-	va_start(arglist, str);
-	vswprintf(buf, str, arglist);
-	ss << (const wchar_t*) buf << std::flush;
-	va_end(arglist);
-
-  std::string to_print = wstring_to_string(ss.str());
-  console << ss.str().c_str();
-  std::cout << to_print.c_str();
+  char buf[4096];
+  va_list arglist; 
+  va_start(arglist, str); 
+  vsprintf(buf, str, arglist);
+  console << (char*)buf;
+  puts(buf);
+  va_end(arglist); 
 }
 
 ScriptManager::ScriptManager()
@@ -116,7 +108,7 @@
   sq_addref(v, &vm_obj);
   sq_pop(v, 1);
   
-  if(sq_compile(vm, squirrel_read_char, &in, string_to_wstring(sourcename).c_str(), true) < 0)
+  if(sq_compile(vm, squirrel_read_char, &in, sourcename.c_str(), true) < 0)
     throw SquirrelError(vm, "Couldn't parse script");
 	
   squirrel_vms.push_back(SquirrelVM(sourcename, vm, vm_obj));

Modified: trunk/windstille/src/scripting/util.cpp
===================================================================
--- trunk/windstille/src/scripting/util.cpp	2008-06-27 10:49:53 UTC (rev 2270)
+++ trunk/windstille/src/scripting/util.cpp	2008-06-27 11:51:22 UTC (rev 2271)
@@ -32,8 +32,8 @@
 #include "lisp/parser.hpp"
 #include "lisp/properties.hpp"
 #include "lisp/writer.hpp"
+
 #include "util.hpp"
-#include "../util.hpp"
 
 namespace Scripting {
 
@@ -63,9 +63,9 @@
       break;
     }
     case OT_STRING: {
-      const wchar_t* str;
+      const char* str;
       sq_getstring(v, -1, &str);      
-      entries.push_back(new lisp::Lisp(lisp::Lisp::TYPE_STRING, wstring_to_string(str)));
+      entries.push_back(new lisp::Lisp(lisp::Lisp::TYPE_STRING, str));
       break;
     }                                                    
     case OT_BOOL: {
@@ -101,9 +101,9 @@
         continue;
       }
 
-      const wchar_t* key;
+      const char* key;
       sq_getstring(v, -2, &key);
-      std::string lisp_key = sq_to_lisp_string(wstring_to_string(key));
+      std::string lisp_key = sq_to_lisp_string(key);
 
       std::vector<lisp::Lisp*> childs;
       childs.push_back(new lisp::Lisp(lisp::Lisp::TYPE_SYMBOL, lisp_key));
@@ -150,7 +150,7 @@
       break;
     }
     case OT_STRING: {
-      const wchar_t* val;
+      const char* val;
       sq_getstring(v, i, &val);
       os << "\"" << val << "\"";
       break;    
@@ -252,7 +252,7 @@
                 break;
             }
             case OT_STRING: {
-                const wchar_t* val;
+                const char* val;
                 sq_getstring(v, i, &val);
                 printf("string (%s)", val);
                 break;    
@@ -303,7 +303,7 @@
   Properties props(lisp);
   PropertyIterator<const lisp::Lisp*> iter = props.get_iter();
   while(iter.next()) {
-    sq_pushstring(v, string_to_wstring(iter.item()).c_str(), iter.item().size());
+    sq_pushstring(v, iter.item().c_str(), iter.item().size());
     switch((*iter)->get_type()) {
       case lisp::Lisp::TYPE_LIST:
         sq_newtable(v);
@@ -316,7 +316,7 @@
         sq_pushfloat(v, (*iter)->get_float());
         break;
       case lisp::Lisp::TYPE_STRING:
-        sq_pushstring(v, string_to_wstring((*iter)->get_string()).c_str(), -1);
+        sq_pushstring(v, (*iter)->get_string(), -1);
         break;
       case lisp::Lisp::TYPE_BOOL:
         sq_pushbool(v, (*iter)->get_bool());
@@ -363,9 +363,8 @@
       std::cerr << "Table contains non-string key\n";
       continue;
     }
-    const wchar_t* wkey;
-    sq_getstring(v, -2, &wkey);
-    std::string key = wstring_to_string(wkey);
+    const char* key;
+    sq_getstring(v, -2, &key);
 
     switch(sq_gettype(v, -1)) {
       case OT_INTEGER: {
@@ -387,9 +386,9 @@
         break;
       }
       case OT_STRING: {
-        const wchar_t* str;
+        const char* str;
         sq_getstring(v, -1, &str);
-        writer.write_string(key, wstring_to_string(str));
+        writer.write_string(key, str);
         break;
       }
       case OT_TABLE: {

Modified: trunk/windstille/src/scripting/wrapper.cpp
===================================================================
--- trunk/windstille/src/scripting/wrapper.cpp	2008-06-27 10:49:53 UTC (rev 2270)
+++ trunk/windstille/src/scripting/wrapper.cpp	2008-06-27 11:51:22 UTC (rev 2271)
@@ -13,8 +13,6 @@
 #include "squirrel_error.hpp"
 #include "wrapper.interface.hpp"
 
-#include "../util.hpp"
-
 namespace Scripting
 {
 namespace Wrapper
@@ -39,11 +37,11 @@
   try {
     const std::string& return_value = _this->get_name();
   
-    sq_pushstring(vm, string_to_wstring(return_value).c_str(), return_value.size());
+    sq_pushstring(vm, return_value.c_str(), return_value.size());
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'get_name'"));
@@ -67,7 +65,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'remove'"));
@@ -96,7 +94,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_active'"));
@@ -120,12 +118,12 @@
   }
   
   try {
-    _this->set_parent(wstring_to_string(arg0));
+    _this->set_parent(arg0);
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_parent'"));
@@ -156,12 +154,12 @@
   }
   
   try {
-    _this->set_sprite(wstring_to_string(arg0));
+    _this->set_sprite(arg0);
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_sprite'"));
@@ -185,12 +183,12 @@
   }
   
   try {
-    _this->set_action(wstring_to_string(arg0));
+    _this->set_action(arg0);
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_action'"));
@@ -224,7 +222,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_pos'"));
@@ -253,7 +251,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_vflip'"));
@@ -282,12 +280,12 @@
   }
   
   try {
-    _this->attach(wstring_to_string(arg0), wstring_to_string(arg1));
+    _this->attach(arg0, arg1);
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'attach'"));
@@ -318,7 +316,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'start_listening'"));
@@ -342,7 +340,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'stop_listening'"));
@@ -393,7 +391,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'move_to'"));
@@ -422,7 +420,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'start_flash'"));
@@ -440,12 +438,12 @@
   }
   
   try {
-    Scripting::set_sector(wstring_to_string(arg0));
+    Scripting::set_sector(arg0);
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_sector'"));
@@ -463,12 +461,12 @@
   }
   
   try {
-    Scripting::play_music(wstring_to_string(arg0));
+    Scripting::play_music(arg0);
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'play_music'"));
@@ -491,7 +489,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'stop_music'"));
@@ -509,12 +507,12 @@
   }
   
   try {
-    Scripting::play_sound(wstring_to_string(arg0));
+    Scripting::play_sound(arg0);
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'play_sound'"));
@@ -537,12 +535,12 @@
   }
   
   try {
-    Scripting::caption_add(static_cast<int> (arg0), wstring_to_string(arg1));
+    Scripting::caption_add(static_cast<int> (arg0), arg1);
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'caption_add'"));
@@ -561,7 +559,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'caption_clear'"));
@@ -580,7 +578,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'caption_end'"));
@@ -603,7 +601,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'camera_set_active'"));
@@ -622,7 +620,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'camera_continue_path'"));
@@ -641,7 +639,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'camera_begin_path'"));
@@ -674,7 +672,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'camera_add_point'"));
@@ -693,7 +691,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'camera_end_path'"));
@@ -721,7 +719,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'camera_set_pos'"));
@@ -744,7 +742,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'camera_set_zoom'"));
@@ -767,7 +765,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_controller_help_active'"));
@@ -800,12 +798,12 @@
   }
   
   try {
-    Scripting::dialog_show(static_cast<int> (arg0), wstring_to_string(arg1), wstring_to_string(arg2), wstring_to_string(arg3));
+    Scripting::dialog_show(static_cast<int> (arg0), arg1, arg2, arg3);
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'dialog_show'"));
@@ -824,7 +822,7 @@
     return sq_suspendvm(vm);
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'wait_for_dialog'"));
@@ -843,7 +841,7 @@
     return sq_suspendvm(vm);
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'wait_for_fade'"));
@@ -862,7 +860,7 @@
     return sq_suspendvm(vm);
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'wait_for_camera'"));
@@ -880,12 +878,12 @@
   }
   
   try {
-    Scripting::conversation_add(wstring_to_string(arg0));
+    Scripting::conversation_add(arg0);
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'conversation_add'"));
@@ -908,12 +906,12 @@
   }
   
   try {
-    Scripting::conversation_add2(wstring_to_string(arg0), wstring_to_string(arg1));
+    Scripting::conversation_add2(arg0, arg1);
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'conversation_add2'"));
@@ -932,7 +930,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'conversation_show'"));
@@ -951,7 +949,7 @@
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'conversation_get_selection'"));
@@ -970,7 +968,7 @@
     return sq_suspendvm(vm);
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'wait_for_conversation'"));
@@ -993,12 +991,12 @@
   }
   
   try {
-    Scripting::add_objective(wstring_to_string(arg0), wstring_to_string(arg1));
+    Scripting::add_objective(arg0, arg1);
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'add_objective'"));
@@ -1016,12 +1014,12 @@
   }
   
   try {
-    Scripting::objective_complete(wstring_to_string(arg0));
+    Scripting::objective_complete(arg0);
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'objective_complete'"));
@@ -1039,13 +1037,13 @@
   }
   
   try {
-    bool return_value = Scripting::is_objective_given(wstring_to_string(arg0));
+    bool return_value = Scripting::is_objective_given(arg0);
   
     sq_pushbool(vm, return_value);
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'is_objective_given'"));
@@ -1063,13 +1061,13 @@
   }
   
   try {
-    bool return_value = Scripting::is_objective_complete(wstring_to_string(arg0));
+    bool return_value = Scripting::is_objective_complete(arg0);
   
     sq_pushbool(vm, return_value);
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'is_objective_complete'"));
@@ -1089,7 +1087,7 @@
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'run_before'"));
@@ -1108,12 +1106,12 @@
   }
   
   try {
-    Scripting::save_state(arg0, wstring_to_string(arg1));
+    Scripting::save_state(arg0, arg1);
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'save_state'"));
@@ -1132,12 +1130,12 @@
   }
   
   try {
-    Scripting::load_state(arg0, wstring_to_string(arg1));
+    Scripting::load_state(arg0, arg1);
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'load_state'"));
@@ -1156,7 +1154,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'list_objects'"));
@@ -1179,7 +1177,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_debug'"));
@@ -1198,7 +1196,7 @@
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'get_debug'"));
@@ -1217,7 +1215,7 @@
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'get_game_speed'"));
@@ -1240,7 +1238,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_game_speed'"));
@@ -1264,7 +1262,7 @@
     return sq_suspendvm(vm);
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'wait'"));
@@ -1297,12 +1295,12 @@
   }
   
   try {
-    Scripting::set_console_font(wstring_to_string(arg0), static_cast<int> (arg1));
+    Scripting::set_console_font(arg0, static_cast<int> (arg1));
   
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_console_font'"));
@@ -1325,7 +1323,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_gamma'"));
@@ -1358,7 +1356,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'set_gamma_rgb'"));
@@ -1377,7 +1375,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'show_config'"));
@@ -1396,7 +1394,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'cutscene_begin'"));
@@ -1415,7 +1413,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'cutscene_end'"));
@@ -1453,7 +1451,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'internal_fadeout_rgb'"));
@@ -1476,7 +1474,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'internal_fadein'"));
@@ -1495,7 +1493,7 @@
     return 1;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'render_mask_get'"));
@@ -1518,7 +1516,7 @@
     return 0;
   
   } catch(std::exception& e) {
-    sq_throwerror(vm, string_to_wstring(e.what()).c_str());
+    sq_throwerror(vm, e.what());
     return SQ_ERROR;
   } catch(...) {
     sq_throwerror(vm, _SC("Unexpected exception while executing function 'render_mask_set'"));
@@ -1539,7 +1537,7 @@
   using namespace Wrapper;
 
   sq_pushroottable(v);
-  sq_pushstring(v, _SC("GameObject"), -1);
+  sq_pushstring(v, "GameObject", -1);
   if(SQ_FAILED(sq_get(v, -2))) {
     std::ostringstream msg;
     msg << "Couldn't resolved squirrel type 'GameObject'";
@@ -1565,7 +1563,7 @@
   using namespace Wrapper;
 
   sq_pushroottable(v);
-  sq_pushstring(v, _SC("TestObject"), -1);
+  sq_pushstring(v, "TestObject", -1);
   if(SQ_FAILED(sq_get(v, -2))) {
     std::ostringstream msg;
     msg << "Couldn't resolved squirrel type 'TestObject'";
@@ -1591,7 +1589,7 @@
   using namespace Wrapper;
 
   sq_pushroottable(v);
-  sq_pushstring(v, _SC("Player"), -1);
+  sq_pushstring(v, "Player", -1);
   if(SQ_FAILED(sq_get(v, -2))) {
     std::ostringstream msg;
     msg << "Couldn't resolved squirrel type 'Player'";
@@ -1617,7 +1615,7 @@
   using namespace Wrapper;
 
   sq_pushroottable(v);
-  sq_pushstring(v, _SC("ScriptableObject"), -1);
+  sq_pushstring(v, "ScriptableObject", -1);
   if(SQ_FAILED(sq_get(v, -2))) {
     std::ostringstream msg;
     msg << "Couldn't resolved squirrel type 'ScriptableObject'";
@@ -1642,368 +1640,368 @@
 {
   using namespace Wrapper;
 
-  sq_pushstring(v, _SC("VCENTER"), -1);
+  sq_pushstring(v, "VCENTER", -1);
   sq_pushinteger(v, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register constant 'VCENTER'");
   }
 
-  sq_pushstring(v, _SC("LEFT"), -1);
+  sq_pushstring(v, "LEFT", -1);
   sq_pushinteger(v, 1);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register constant 'LEFT'");
   }
 
-  sq_pushstring(v, _SC("RIGHT"), -1);
+  sq_pushstring(v, "RIGHT", -1);
   sq_pushinteger(v, 2);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register constant 'RIGHT'");
   }
 
-  sq_pushstring(v, _SC("HCENTER"), -1);
+  sq_pushstring(v, "HCENTER", -1);
   sq_pushinteger(v, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register constant 'HCENTER'");
   }
 
-  sq_pushstring(v, _SC("TOP"), -1);
+  sq_pushstring(v, "TOP", -1);
   sq_pushinteger(v, 16);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register constant 'TOP'");
   }
 
-  sq_pushstring(v, _SC("BOTTOM"), -1);
+  sq_pushstring(v, "BOTTOM", -1);
   sq_pushinteger(v, 32);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register constant 'BOTTOM'");
   }
 
-  sq_pushstring(v, _SC("set_sector"), -1);
+  sq_pushstring(v, "set_sector", -1);
   sq_newclosure(v, &set_sector_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_sector'");
   }
 
-  sq_pushstring(v, _SC("play_music"), -1);
+  sq_pushstring(v, "play_music", -1);
   sq_newclosure(v, &play_music_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'play_music'");
   }
 
-  sq_pushstring(v, _SC("stop_music"), -1);
+  sq_pushstring(v, "stop_music", -1);
   sq_newclosure(v, &stop_music_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'stop_music'");
   }
 
-  sq_pushstring(v, _SC("play_sound"), -1);
+  sq_pushstring(v, "play_sound", -1);
   sq_newclosure(v, &play_sound_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'play_sound'");
   }
 
-  sq_pushstring(v, _SC("caption_add"), -1);
+  sq_pushstring(v, "caption_add", -1);
   sq_newclosure(v, &caption_add_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'caption_add'");
   }
 
-  sq_pushstring(v, _SC("caption_clear"), -1);
+  sq_pushstring(v, "caption_clear", -1);
   sq_newclosure(v, &caption_clear_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'caption_clear'");
   }
 
-  sq_pushstring(v, _SC("caption_end"), -1);
+  sq_pushstring(v, "caption_end", -1);
   sq_newclosure(v, &caption_end_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'caption_end'");
   }
 
-  sq_pushstring(v, _SC("camera_set_active"), -1);
+  sq_pushstring(v, "camera_set_active", -1);
   sq_newclosure(v, &camera_set_active_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'camera_set_active'");
   }
 
-  sq_pushstring(v, _SC("camera_continue_path"), -1);
+  sq_pushstring(v, "camera_continue_path", -1);
   sq_newclosure(v, &camera_continue_path_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'camera_continue_path'");
   }
 
-  sq_pushstring(v, _SC("camera_begin_path"), -1);
+  sq_pushstring(v, "camera_begin_path", -1);
   sq_newclosure(v, &camera_begin_path_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'camera_begin_path'");
   }
 
-  sq_pushstring(v, _SC("camera_add_point"), -1);
+  sq_pushstring(v, "camera_add_point", -1);
   sq_newclosure(v, &camera_add_point_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'camera_add_point'");
   }
 
-  sq_pushstring(v, _SC("camera_end_path"), -1);
+  sq_pushstring(v, "camera_end_path", -1);
   sq_newclosure(v, &camera_end_path_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'camera_end_path'");
   }
 
-  sq_pushstring(v, _SC("camera_set_pos"), -1);
+  sq_pushstring(v, "camera_set_pos", -1);
   sq_newclosure(v, &camera_set_pos_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'camera_set_pos'");
   }
 
-  sq_pushstring(v, _SC("camera_set_zoom"), -1);
+  sq_pushstring(v, "camera_set_zoom", -1);
   sq_newclosure(v, &camera_set_zoom_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'camera_set_zoom'");
   }
 
-  sq_pushstring(v, _SC("set_controller_help_active"), -1);
+  sq_pushstring(v, "set_controller_help_active", -1);
   sq_newclosure(v, &set_controller_help_active_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_controller_help_active'");
   }
 
-  sq_pushstring(v, _SC("dialog_show"), -1);
+  sq_pushstring(v, "dialog_show", -1);
   sq_newclosure(v, &dialog_show_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'dialog_show'");
   }
 
-  sq_pushstring(v, _SC("wait_for_dialog"), -1);
+  sq_pushstring(v, "wait_for_dialog", -1);
   sq_newclosure(v, &wait_for_dialog_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'wait_for_dialog'");
   }
 
-  sq_pushstring(v, _SC("wait_for_fade"), -1);
+  sq_pushstring(v, "wait_for_fade", -1);
   sq_newclosure(v, &wait_for_fade_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'wait_for_fade'");
   }
 
-  sq_pushstring(v, _SC("wait_for_camera"), -1);
+  sq_pushstring(v, "wait_for_camera", -1);
   sq_newclosure(v, &wait_for_camera_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'wait_for_camera'");
   }
 
-  sq_pushstring(v, _SC("conversation_add"), -1);
+  sq_pushstring(v, "conversation_add", -1);
   sq_newclosure(v, &conversation_add_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'conversation_add'");
   }
 
-  sq_pushstring(v, _SC("conversation_add2"), -1);
+  sq_pushstring(v, "conversation_add2", -1);
   sq_newclosure(v, &conversation_add2_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'conversation_add2'");
   }
 
-  sq_pushstring(v, _SC("conversation_show"), -1);
+  sq_pushstring(v, "conversation_show", -1);
   sq_newclosure(v, &conversation_show_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'conversation_show'");
   }
 
-  sq_pushstring(v, _SC("conversation_get_selection"), -1);
+  sq_pushstring(v, "conversation_get_selection", -1);
   sq_newclosure(v, &conversation_get_selection_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'conversation_get_selection'");
   }
 
-  sq_pushstring(v, _SC("wait_for_conversation"), -1);
+  sq_pushstring(v, "wait_for_conversation", -1);
   sq_newclosure(v, &wait_for_conversation_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'wait_for_conversation'");
   }
 
-  sq_pushstring(v, _SC("add_objective"), -1);
+  sq_pushstring(v, "add_objective", -1);
   sq_newclosure(v, &add_objective_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'add_objective'");
   }
 
-  sq_pushstring(v, _SC("objective_complete"), -1);
+  sq_pushstring(v, "objective_complete", -1);
   sq_newclosure(v, &objective_complete_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'objective_complete'");
   }
 
-  sq_pushstring(v, _SC("is_objective_given"), -1);
+  sq_pushstring(v, "is_objective_given", -1);
   sq_newclosure(v, &is_objective_given_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'is_objective_given'");
   }
 
-  sq_pushstring(v, _SC("is_objective_complete"), -1);
+  sq_pushstring(v, "is_objective_complete", -1);
   sq_newclosure(v, &is_objective_complete_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'is_objective_complete'");
   }
 
-  sq_pushstring(v, _SC("run_before"), -1);
+  sq_pushstring(v, "run_before", -1);
   sq_newclosure(v, &run_before_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'run_before'");
   }
 
-  sq_pushstring(v, _SC("save_state"), -1);
+  sq_pushstring(v, "save_state", -1);
   sq_newclosure(v, &save_state_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'save_state'");
   }
 
-  sq_pushstring(v, _SC("load_state"), -1);
+  sq_pushstring(v, "load_state", -1);
   sq_newclosure(v, &load_state_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'load_state'");
   }
 
-  sq_pushstring(v, _SC("list_objects"), -1);
+  sq_pushstring(v, "list_objects", -1);
   sq_newclosure(v, &list_objects_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'list_objects'");
   }
 
-  sq_pushstring(v, _SC("set_debug"), -1);
+  sq_pushstring(v, "set_debug", -1);
   sq_newclosure(v, &set_debug_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_debug'");
   }
 
-  sq_pushstring(v, _SC("get_debug"), -1);
+  sq_pushstring(v, "get_debug", -1);
   sq_newclosure(v, &get_debug_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'get_debug'");
   }
 
-  sq_pushstring(v, _SC("get_game_speed"), -1);
+  sq_pushstring(v, "get_game_speed", -1);
   sq_newclosure(v, &get_game_speed_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'get_game_speed'");
   }
 
-  sq_pushstring(v, _SC("set_game_speed"), -1);
+  sq_pushstring(v, "set_game_speed", -1);
   sq_newclosure(v, &set_game_speed_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_game_speed'");
   }
 
-  sq_pushstring(v, _SC("wait"), -1);
+  sq_pushstring(v, "wait", -1);
   sq_newclosure(v, &wait_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'wait'");
   }
 
-  sq_pushstring(v, _SC("display"), -1);
+  sq_pushstring(v, "display", -1);
   sq_newclosure(v, &display_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'display'");
   }
 
-  sq_pushstring(v, _SC("println"), -1);
+  sq_pushstring(v, "println", -1);
   sq_newclosure(v, &println_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'println'");
   }
 
-  sq_pushstring(v, _SC("set_console_font"), -1);
+  sq_pushstring(v, "set_console_font", -1);
   sq_newclosure(v, &set_console_font_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_console_font'");
   }
 
-  sq_pushstring(v, _SC("set_gamma"), -1);
+  sq_pushstring(v, "set_gamma", -1);
   sq_newclosure(v, &set_gamma_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_gamma'");
   }
 
-  sq_pushstring(v, _SC("set_gamma_rgb"), -1);
+  sq_pushstring(v, "set_gamma_rgb", -1);
   sq_newclosure(v, &set_gamma_rgb_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_gamma_rgb'");
   }
 
-  sq_pushstring(v, _SC("show_config"), -1);
+  sq_pushstring(v, "show_config", -1);
   sq_newclosure(v, &show_config_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'show_config'");
   }
 
-  sq_pushstring(v, _SC("cutscene_begin"), -1);
+  sq_pushstring(v, "cutscene_begin", -1);
   sq_newclosure(v, &cutscene_begin_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'cutscene_begin'");
   }
 
-  sq_pushstring(v, _SC("cutscene_end"), -1);
+  sq_pushstring(v, "cutscene_end", -1);
   sq_newclosure(v, &cutscene_end_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'cutscene_end'");
   }
 
-  sq_pushstring(v, _SC("internal_fadeout_rgb"), -1);
+  sq_pushstring(v, "internal_fadeout_rgb", -1);
   sq_newclosure(v, &internal_fadeout_rgb_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'internal_fadeout_rgb'");
   }
 
-  sq_pushstring(v, _SC("internal_fadein"), -1);
+  sq_pushstring(v, "internal_fadein", -1);
   sq_newclosure(v, &internal_fadein_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'internal_fadein'");
   }
 
-  sq_pushstring(v, _SC("render_mask_get"), -1);
+  sq_pushstring(v, "render_mask_get", -1);
   sq_newclosure(v, &render_mask_get_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'render_mask_get'");
   }
 
-  sq_pushstring(v, _SC("render_mask_set"), -1);
+  sq_pushstring(v, "render_mask_set", -1);
   sq_newclosure(v, &render_mask_set_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'render_mask_set'");
   }
 
-  sq_pushstring(v, _SC("spawn_object"), -1);
+  sq_pushstring(v, "spawn_object", -1);
   sq_newclosure(v, &spawn_object_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'spawn_object'");
   }
 
   // Register class GameObject
-  sq_pushstring(v, _SC("GameObject"), -1);
+  sq_pushstring(v, "GameObject", -1);
   if(sq_newclass(v, SQFalse) < 0) {
     std::ostringstream msg;
     msg << "Couldn't create new class 'GameObject'";
     throw SquirrelError(v, msg.str());
   }
-  sq_pushstring(v, _SC("get_name"), -1);
+  sq_pushstring(v, "get_name", -1);
   sq_newclosure(v, &GameObject_get_name_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'get_name'");
   }
 
-  sq_pushstring(v, _SC("remove"), -1);
+  sq_pushstring(v, "remove", -1);
   sq_newclosure(v, &GameObject_remove_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'remove'");
   }
 
-  sq_pushstring(v, _SC("set_active"), -1);
+  sq_pushstring(v, "set_active", -1);
   sq_newclosure(v, &GameObject_set_active_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_active'");
   }
 
-  sq_pushstring(v, _SC("set_parent"), -1);
+  sq_pushstring(v, "set_parent", -1);
   sq_newclosure(v, &GameObject_set_parent_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_parent'");
@@ -2014,39 +2012,39 @@
   }
 
   // Register class TestObject
-  sq_pushstring(v, _SC("TestObject"), -1);
-  sq_pushstring(v, _SC("GameObject"), -1);
+  sq_pushstring(v, "TestObject", -1);
+  sq_pushstring(v, "GameObject", -1);
   sq_get(v, -3);
   if(sq_newclass(v, SQTrue) < 0) {
     std::ostringstream msg;
     msg << "Couldn't create new class 'TestObject'";
     throw SquirrelError(v, msg.str());
   }
-  sq_pushstring(v, _SC("set_sprite"), -1);
+  sq_pushstring(v, "set_sprite", -1);
   sq_newclosure(v, &TestObject_set_sprite_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_sprite'");
   }
 
-  sq_pushstring(v, _SC("set_action"), -1);
+  sq_pushstring(v, "set_action", -1);
   sq_newclosure(v, &TestObject_set_action_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_action'");
   }
 
-  sq_pushstring(v, _SC("set_pos"), -1);
+  sq_pushstring(v, "set_pos", -1);
   sq_newclosure(v, &TestObject_set_pos_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_pos'");
   }
 
-  sq_pushstring(v, _SC("set_vflip"), -1);
+  sq_pushstring(v, "set_vflip", -1);
   sq_newclosure(v, &TestObject_set_vflip_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'set_vflip'");
   }
 
-  sq_pushstring(v, _SC("attach"), -1);
+  sq_pushstring(v, "attach", -1);
   sq_newclosure(v, &TestObject_attach_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'attach'");
@@ -2057,21 +2055,21 @@
   }
 
   // Register class Player
-  sq_pushstring(v, _SC("Player"), -1);
-  sq_pushstring(v, _SC("GameObject"), -1);
+  sq_pushstring(v, "Player", -1);
+  sq_pushstring(v, "GameObject", -1);
   sq_get(v, -3);
   if(sq_newclass(v, SQTrue) < 0) {
     std::ostringstream msg;
     msg << "Couldn't create new class 'Player'";
     throw SquirrelError(v, msg.str());
   }
-  sq_pushstring(v, _SC("start_listening"), -1);
+  sq_pushstring(v, "start_listening", -1);
   sq_newclosure(v, &Player_start_listening_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'start_listening'");
   }
 
-  sq_pushstring(v, _SC("stop_listening"), -1);
+  sq_pushstring(v, "stop_listening", -1);
   sq_newclosure(v, &Player_stop_listening_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'stop_listening'");
@@ -2082,21 +2080,21 @@
   }
 
   // Register class ScriptableObject
-  sq_pushstring(v, _SC("ScriptableObject"), -1);
-  sq_pushstring(v, _SC("GameObject"), -1);
+  sq_pushstring(v, "ScriptableObject", -1);
+  sq_pushstring(v, "GameObject", -1);
   sq_get(v, -3);
   if(sq_newclass(v, SQTrue) < 0) {
     std::ostringstream msg;
     msg << "Couldn't create new class 'ScriptableObject'";
     throw SquirrelError(v, msg.str());
   }
-  sq_pushstring(v, _SC("move_to"), -1);
+  sq_pushstring(v, "move_to", -1);
   sq_newclosure(v, &ScriptableObject_move_to_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'move_to'");
   }
 
-  sq_pushstring(v, _SC("start_flash"), -1);
+  sq_pushstring(v, "start_flash", -1);
   sq_newclosure(v, &ScriptableObject_start_flash_wrapper, 0);
   if(SQ_FAILED(sq_createslot(v, -3))) {
     throw SquirrelError(v, "Couldn't register function 'start_flash'");

Modified: trunk/windstille/src/sector.cpp
===================================================================
--- trunk/windstille/src/sector.cpp	2008-06-27 10:49:53 UTC (rev 2270)
+++ trunk/windstille/src/sector.cpp	2008-06-27 11:51:22 UTC (rev 2271)
@@ -49,7 +49,6 @@
 #include "scriptable_object.hpp"
 #include "navigation/navigation_graph.hpp"
 #include "scripting/squirrel_error.hpp"
-#include "util.hpp"
 
 // The table (works like a namespace here) where the game objects will appear
 #define OBJECTS_TABLE "objects"
@@ -269,7 +268,7 @@
   // get objects table
   HSQUIRRELVM v = script_manager->get_vm();
   sq_pushroottable(v);
-  sq_pushstring(v, string_to_wstring(OBJECTS_TABLE).c_str(), -1);
+  sq_pushstring(v, OBJECTS_TABLE, -1);
   if(SQ_FAILED(sq_get(v, -2)))
   {
     std::ostringstream msg;
@@ -278,7 +277,7 @@
   }
 
   // remove object from table
-  sq_pushstring(v, string_to_wstring(object->get_name()).c_str(), object->get_name().size());
+  sq_pushstring(v, object->get_name().c_str(), object->get_name().size());
   if(SQ_FAILED(sq_deleteslot(v, -2, SQFalse) < 0)) {
     std::ostringstream msg;
     msg << "Couldn't remove squirrel object for '" << object->get_name()
@@ -324,7 +323,7 @@
   // get objects table
   HSQUIRRELVM v = script_manager->get_vm();
   sq_pushroottable(v);
-  sq_pushstring(v, string_to_wstring(OBJECTS_TABLE).c_str(), -1);
+  sq_pushstring(v, OBJECTS_TABLE, -1);
   if(SQ_FAILED(sq_get(v, -2)))
   {
     std::ostringstream msg;
@@ -333,7 +332,7 @@
   }
   
   // create squirrel instance and register in table
-  sq_pushstring(v, string_to_wstring(object->get_name()).c_str(), object->get_name().size());
+  sq_pushstring(v, object->get_name().c_str(), object->get_name().size());
   create_squirrel_instance(v, object);
   if(SQ_FAILED(sq_createslot(v, -3)))
   {

Modified: trunk/windstille/src/util.cpp
===================================================================
--- trunk/windstille/src/util.cpp	2008-06-27 10:49:53 UTC (rev 2270)
+++ trunk/windstille/src/util.cpp	2008-06-27 11:51:22 UTC (rev 2271)
@@ -47,14 +47,4 @@
   return out;
 }
 
-const std::wstring string_to_wstring(const std::string& str) {
-	std::wstring tmp(str.begin(), str.end());
-	return tmp;
-}
-
-const std::string wstring_to_string(const std::wstring& str) {
-	std::string tmp(str.begin(), str.end());
-	return tmp;
-}
-
 /* EOF */

Modified: trunk/windstille/src/util.hpp
===================================================================
--- trunk/windstille/src/util.hpp	2008-06-27 10:49:53 UTC (rev 2270)
+++ trunk/windstille/src/util.hpp	2008-06-27 11:51:22 UTC (rev 2271)
@@ -39,8 +39,5 @@
 #endif
 }
 
-const std::wstring string_to_wstring(const std::string& str);
-const std::string wstring_to_string(const std::wstring& str);
-
 #endif
 



From jamesgregory at mail.berlios.de  Fri Jun 27 14:16:04 2008
From: jamesgregory at mail.berlios.de (jamesgregory at mail.berlios.de)
Date: Fri, 27 Jun 2008 14:16:04 +0200
Subject: [Windstille-commit] r2272 - trunk/windstille/contrib/vs2003build
Message-ID: <200806271216.m5RCG47D025450@sheep.berlios.de>

Author: jamesgregory
Date: 2008-06-27 14:16:03 +0200 (Fri, 27 Jun 2008)
New Revision: 2272

Modified:
   trunk/windstille/contrib/vs2003build/Windstille.vcproj
Log:
for vcproj file, don't use unicode

Modified: trunk/windstille/contrib/vs2003build/Windstille.vcproj
===================================================================
--- trunk/windstille/contrib/vs2003build/Windstille.vcproj	2008-06-27 11:51:22 UTC (rev 2271)
+++ trunk/windstille/contrib/vs2003build/Windstille.vcproj	2008-06-27 12:16:03 UTC (rev 2272)
@@ -16,7 +16,7 @@
 			OutputDirectory="$(SolutionDir)"
 			IntermediateDirectory="$(ConfigurationName)"
 			ConfigurationType="1"
-			CharacterSet="1">
+			CharacterSet="0">
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"



From jamesgregory at mail.berlios.de  Fri Jun 27 12:50:27 2008
From: jamesgregory at mail.berlios.de (jamesgregory at mail.berlios.de)
Date: Fri, 27 Jun 2008 12:50:27 +0200
Subject: [Windstille-commit] r2270 - in trunk/windstille/lib: . SQUIRREL2
	SQUIRREL2/doc SQUIRREL2/etc SQUIRREL2/include
	SQUIRREL2/samples SQUIRREL2/sq SQUIRREL2/sqstdlib SQUIRREL2/squirrel
Message-ID: <200806271050.m5RAoRx9019044@sheep.berlios.de>

Author: jamesgregory
Date: 2008-06-27 12:49:53 +0200 (Fri, 27 Jun 2008)
New Revision: 2270

Added:
   trunk/windstille/lib/SQUIRREL2/
   trunk/windstille/lib/SQUIRREL2/COMPILE
   trunk/windstille/lib/SQUIRREL2/COPYRIGHT
   trunk/windstille/lib/SQUIRREL2/HISTORY
   trunk/windstille/lib/SQUIRREL2/Makefile
   trunk/windstille/lib/SQUIRREL2/README
   trunk/windstille/lib/SQUIRREL2/bin/
   trunk/windstille/lib/SQUIRREL2/doc/
   trunk/windstille/lib/SQUIRREL2/doc/sqstdlib2.chm
   trunk/windstille/lib/SQUIRREL2/doc/sqstdlib2.pdf
   trunk/windstille/lib/SQUIRREL2/doc/squirrel2.chm
   trunk/windstille/lib/SQUIRREL2/doc/squirrel2.pdf
   trunk/windstille/lib/SQUIRREL2/etc/
   trunk/windstille/lib/SQUIRREL2/etc/minimal.c
   trunk/windstille/lib/SQUIRREL2/etc/test.nut
   trunk/windstille/lib/SQUIRREL2/include/
   trunk/windstille/lib/SQUIRREL2/include/sqstdaux.h
   trunk/windstille/lib/SQUIRREL2/include/sqstdblob.h
   trunk/windstille/lib/SQUIRREL2/include/sqstdio.h
   trunk/windstille/lib/SQUIRREL2/include/sqstdmath.h
   trunk/windstille/lib/SQUIRREL2/include/sqstdstring.h
   trunk/windstille/lib/SQUIRREL2/include/sqstdsystem.h
   trunk/windstille/lib/SQUIRREL2/include/squirrel.h
   trunk/windstille/lib/SQUIRREL2/lib/
   trunk/windstille/lib/SQUIRREL2/samples/
   trunk/windstille/lib/SQUIRREL2/samples/ackermann.nut
   trunk/windstille/lib/SQUIRREL2/samples/array.nut
   trunk/windstille/lib/SQUIRREL2/samples/class.nut
   trunk/windstille/lib/SQUIRREL2/samples/classattributes.nut
   trunk/windstille/lib/SQUIRREL2/samples/coroutines.nut
   trunk/windstille/lib/SQUIRREL2/samples/delegation.nut
   trunk/windstille/lib/SQUIRREL2/samples/fibonacci.nut
   trunk/windstille/lib/SQUIRREL2/samples/flow.nut
   trunk/windstille/lib/SQUIRREL2/samples/generators.nut
   trunk/windstille/lib/SQUIRREL2/samples/hello.nut
   trunk/windstille/lib/SQUIRREL2/samples/list.nut
   trunk/windstille/lib/SQUIRREL2/samples/loops.nut
   trunk/windstille/lib/SQUIRREL2/samples/matrix.nut
   trunk/windstille/lib/SQUIRREL2/samples/metamethods.nut
   trunk/windstille/lib/SQUIRREL2/samples/methcall.nut
   trunk/windstille/lib/SQUIRREL2/samples/tailstate.nut
   trunk/windstille/lib/SQUIRREL2/sq/
   trunk/windstille/lib/SQUIRREL2/sq/Makefile
   trunk/windstille/lib/SQUIRREL2/sq/sq.c
   trunk/windstille/lib/SQUIRREL2/sq/sq.dsp
   trunk/windstille/lib/SQUIRREL2/sqstdlib/
   trunk/windstille/lib/SQUIRREL2/sqstdlib/Makefile
   trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdaux.cpp
   trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdblob.cpp
   trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdblobimpl.h
   trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdio.cpp
   trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdlib.dsp
   trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdmath.cpp
   trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdrex.cpp
   trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdstream.cpp
   trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdstream.h
   trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdstring.cpp
   trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdsystem.cpp
   trunk/windstille/lib/SQUIRREL2/squirrel.dsw
   trunk/windstille/lib/SQUIRREL2/squirrel/
   trunk/windstille/lib/SQUIRREL2/squirrel/Makefile
   trunk/windstille/lib/SQUIRREL2/squirrel/sqapi.cpp
   trunk/windstille/lib/SQUIRREL2/squirrel/sqarray.h
   trunk/windstille/lib/SQUIRREL2/squirrel/sqbaselib.cpp
   trunk/windstille/lib/SQUIRREL2/squirrel/sqclass.cpp
   trunk/windstille/lib/SQUIRREL2/squirrel/sqclass.h
   trunk/windstille/lib/SQUIRREL2/squirrel/sqclosure.h
   trunk/windstille/lib/SQUIRREL2/squirrel/sqcompiler.cpp
   trunk/windstille/lib/SQUIRREL2/squirrel/sqcompiler.h
   trunk/windstille/lib/SQUIRREL2/squirrel/sqdebug.cpp
   trunk/windstille/lib/SQUIRREL2/squirrel/sqfuncproto.h
   trunk/windstille/lib/SQUIRREL2/squirrel/sqfuncstate.cpp
   trunk/windstille/lib/SQUIRREL2/squirrel/sqfuncstate.h
   trunk/windstille/lib/SQUIRREL2/squirrel/sqlexer.cpp
   trunk/windstille/lib/SQUIRREL2/squirrel/sqlexer.h
   trunk/windstille/lib/SQUIRREL2/squirrel/sqmem.cpp
   trunk/windstille/lib/SQUIRREL2/squirrel/sqobject.cpp
   trunk/windstille/lib/SQUIRREL2/squirrel/sqobject.h
   trunk/windstille/lib/SQUIRREL2/squirrel/sqopcodes.h
   trunk/windstille/lib/SQUIRREL2/squirrel/sqpcheader.h
   trunk/windstille/lib/SQUIRREL2/squirrel/sqstate.cpp
   trunk/windstille/lib/SQUIRREL2/squirrel/sqstate.h
   trunk/windstille/lib/SQUIRREL2/squirrel/sqstring.h
   trunk/windstille/lib/SQUIRREL2/squirrel/sqtable.cpp
   trunk/windstille/lib/SQUIRREL2/squirrel/sqtable.h
   trunk/windstille/lib/SQUIRREL2/squirrel/squirrel.dsp
   trunk/windstille/lib/SQUIRREL2/squirrel/squserdata.h
   trunk/windstille/lib/SQUIRREL2/squirrel/squtils.h
   trunk/windstille/lib/SQUIRREL2/squirrel/sqvm.cpp
   trunk/windstille/lib/SQUIRREL2/squirrel/sqvm.h
Log:
new version of squirrel 2.2.1 stable

Added: trunk/windstille/lib/SQUIRREL2/COMPILE
===================================================================
--- trunk/windstille/lib/SQUIRREL2/COMPILE	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/COMPILE	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,41 @@
+Squirrel 2.2.1 stable
+--------------------------------------------------------
+What is in this distribution?
+
+squirrel
+	static library implementing the compiler and interpreter of the language
+
+sqstdlib
+	the standard utility libraries
+	
+sq
+	stand alone interpreter
+
+doc
+	The manual
+	
+etc
+	a minimalistic embedding sample	
+
+samples
+	samples programs
+	
+
+HOW TO COMPILE
+---------------------------------------------------------
+GCC USERS
+.........................................................
+There is a very simple makefile that compiles all libraries and exes
+from the root of the project run 'make'
+
+for 32 bits systems
+
+ $ make
+ 
+for 64 bits systems
+
+ $ make sq64
+
+VISUAL C++ USERS
+.........................................................
+Open squirrel.dsw from the root project directory and build(dho!)
\ No newline at end of file

Added: trunk/windstille/lib/SQUIRREL2/COPYRIGHT
===================================================================
--- trunk/windstille/lib/SQUIRREL2/COPYRIGHT	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/COPYRIGHT	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,29 @@
+Copyright (c) 2003-2008 Alberto Demichelis
+
+This software is provided 'as-is', without any 
+express or implied warranty. In no event will the 
+authors be held liable for any damages arising from 
+the use of this software.
+
+Permission is granted to anyone to use this software 
+for any purpose, including commercial applications, 
+and to alter it and redistribute it freely, subject 
+to the following restrictions:
+
+		1. The origin of this software must not be 
+		misrepresented; you must not claim that 
+		you wrote the original software. If you 
+		use this software in a product, an 
+		acknowledgment in the product 
+		documentation would be appreciated but is 
+		not required.
+
+		2. Altered source versions must be plainly 
+		marked as such, and must not be 
+		misrepresented as being the original 
+		software.
+
+		3. This notice may not be removed or 
+		altered from any source distribution.
+-----------------------------------------------------
+END OF COPYRIGHT
\ No newline at end of file

Added: trunk/windstille/lib/SQUIRREL2/HISTORY
===================================================================
--- trunk/windstille/lib/SQUIRREL2/HISTORY	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/HISTORY	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,318 @@
+***version 2.2.1 stable***
+-fixed a tailcall bug
+
+***2008-02-17        ***
+***version 2.2 stable***
+-added _newslot metamethod in classes
+-added enums added constants
+-added sq_pushconsttable, sq_setconsttable
+-added default param
+-added octal literals(thx Dinosaur)
+-fixed debug hook, 'calls' and 'returns' are properly notified in the same number.
+-fixed a coroutine bug
+
+***2007-07-29          ***
+***version 2.1.2 stable***
+-new behaviour for generators iteration using foreach
+now when a generator is iterated by foreach the value returned by a 'return val' statement
+will terminate the iteration but will not be returned as foreach iteration
+-added sq_setclassudsize()
+-added sq_clear()
+-added table.clear(), array.clear()
+-fixed sq_cmp() (thx jyuill)
+-fixed minor bugs
+
+***2006-08-21	     ***
+***version 2.1.1 stable***
+-vm refactoring
+-optimized internal function memory layout
+-new global symbol _version_ (is the version string)
+-code size optimization for float literals(on 32bits float builts)
+-now the raw ref API(sq_addref etc...) is fully reentrant.
+-fixed a bug in sq_getdelegate() now pushes null if the object doesn't have a delegate(thx MatzeB)
+-improved C reference performances in NO_GARBAGE_COLLECTOR builds
+-sq_getlocal() now enumerates also outer values.
+-fixed regexp library for GCC users.
+
+***2006-03-19	     ***
+***version 2.1 stable***
+-added static class fields, new keyword static
+-added 64bits architecture support
+-added global slot _intsize_ int the base lib to recognize 32bits and 64bits builds
+-added functions with fixed environment, closure.bindenv() built-in function
+-all types except userdata and null implement the tostring() method
+-string concatenation now invokes metamethod _tostring
+-new metamethods for class objects _newmember and _inherited
+-sq_call() sq_resume() sq_wakeupvm() have a new signature
+-new C referencing implementation(scales more with the amount of references)
+-refactored hash table
+-new api functions sq_newslot(),sq_tobool(),sq_getbase(), sq_instanceof(), sq_bindenv()
+-the api func sq_createslot was deprecated but still supported in form of C macro on top of sq_newslot
+-sq_setreleasehook() now also works for classes
+-stream.readstr() and stream.writestr() have been deprecated(this affects file and blob)
+-fixed squirrel.h undeclared api calls
+-fixed few minor bugs
+-SQChar is now defined as wchar_t
+-removed warning when building with -Wall -pedantic for GCC users
+-added new std io function writeclosuretofile()
+-added new std string functions strip(),rstrip(),lstrip() and split()
+-regular expressions operators (+,*) now have more POSIX greedyness behaviour
+-class constructors are now invoked as normal functions
+
+***2005-10-02	       ***
+***version 2.0.5 stable***
+-fixed some 64bits incompatibilities (thx sarge)
+-fixed minor bug in the stdlib format() function (thx Rick)
+-fixed a bug in dofile() that was preventing to compile empty files
+-added new API sq_poptop() & sq_getfreevariable()
+-some performance improvements
+
+***2005-08-14	       ***
+***version 2.0.4 stable***
+-weak references and related API calls
+-added sq_objtobool()
+-class instances memory policies improved(1 mem allocation for the whole instance)
+-typetags are now declared as SQUserPointer instead of unsigned int
+-first pass for 64bits compatibility
+-fixed minor bug in the stdio stream
+-fixed a bug in format()
+-fixed bug in string.tointeger() and string.tofloat()
+
+***2005-06-24	       ***
+***version 2.0.3 stable***
+-dofile() and loadfile() in the iolib now can decode ASCII, UTF8 files UCS2 big-endian and little-endian
+-sq_setparamscheck() : now typemesk can check for null
+-added string escape sequence \xhhhh
+-fixed some C++ standard incompatibilities
+
+***2005-05-15	       ***
+***version 2.0.2 stable***
+-performances improvements (expecially for GCC users)
+-removed all dependencies from C++ exception handling
+-various bugfixes
+
+***2005-04-12		 ***
+***version 2.0.1 stable***
+-various bugfixes
+-sq_setparamscheck() now allows spaces in the typemask
+
+***2005-04-03		 ***
+***version 2.0 stable***
+-added API sq_gettypetag()
+-added built-in function to the bool type(tointeger, tostring etc...)
+
+***2005-02-27							***
+***version 2.0 release candidate 1(RC 1)***
+-added API sq_reseterror()
+-modified sq_release()
+-now class instances can be cloned
+-various bufixes
+
+***2005-01-26        ***
+***version 2.0 beta 1***
+-added bool type
+-class properties can be redefined in a derived class
+-added ops *= /= and %=
+-new syntax for class attributes declaration </ and /> instead of ( and )
+-increased the max number of literals per function from 65535 to 16777215
+-now free variables have proper lexical scoping
+-added API sq_createinstance(), sq_pushbool(), sq_getbool()
+-added built-in function type()
+-added built-in function obj.rawin(key) in table,class and instance
+-sq_rawget() and sq_rawset() now work also on classes and instances
+-the VM no longer uses C++ exception handling (more suitable for embedded devices)
+-various bufixes
+
+***2004-12-21         ***
+***version 2.0 alpha 2***
+-globals scoping changed, now if :: is omitted the VM automatically falls back on the root table
+-various bufixes
+-added class level attributes
+
+***2004-12-12         ***
+***version 2.0 alpha 1***
+-codebase branch from version 1.x
+-added classes
+-added functions with variable number of parameters(vargc & vargv and the ...)
+-0 and 0.0 are now considered 'false' by all conditional statements(if,while,for,?,do-while)
+-added new api functions sq_newclass() sq_setinstanceup() sq_getinstanceup() sq_getattributes() sq_setattributes()
+-modified api sq_settypetag()
+
+***2004-11-01        ***
+***version 1.0 stable***
+-fixed some minor bug
+-improoved operator 'delete' performances
+-added scientific notation for float numbers( eg. 2.e16 or 2.e-2)
+
+***2004-08-30        ***
+***version 1.0 release candidate 2(RC 2)***
+-fixed bug in the vm(thx Pierre Renaux)
+-fixed bug in the optimizer(thx Pierre Renaux)
+-fixed some bug in the documentation(thx JD)
+-added new api functions for raw object handling
+-removed nested multiline comments
+-reduced memory footprint in C references
+
+***2004-08-23        ***
+***version 1.0 release candidate 1(RC 1)***
+-fixed division by zero
+-the 'in' operator and obj.rawget() do not query the default delegate anymore
+-added function sq_getprintfunc()
+-added new standard library 'auxlib'(implements default error handlers)
+
+***2004-07-12        ***
+***version 1.0 beta 4***
+-fixed a bug in the integer.tochar() built-in method
+-fixed unary minus operator
+-fixed bug in dofile()
+-fixed inconsistency between != and == operators(on float/integer comparison)
+-added javascript style unsigned right shift operator '>>>'
+-added array(size) constructor built-in function
+-array.resize(size,[fill]) built-in function accepts an optional 'fill' value
+-improved debug API, added sq_getclosureinfo() and sq_setnativeclosurename()
+
+***2004-05-23        ***
+***version 1.0 beta 3***
+-minor vm bug fixes
+-string allocation is now faster
+-tables and array memory usage is now less conservative(they shrink)
+-added regular expression routines in the standard library
+-The 'c' expression now accepts only 1 character(thx irbrian)
+-multiline strings <[ ]> have been substituted with C# style verbatim strings (eg. @"string")
+-added new keyword 'parent' for accessing the delegate of tables and unserdata
+-The metamethod '_clone' has been renamed '_cloned'
+-the _delslot metamethod's behaviour and prototype have been changed
+-new default function in the integer and float object 'tochar()'
+-the built-in function chcode2string has been removed
+-the default method [table].getdelegate() has been removed
+-new api sq_rawdeleteslot()
+-new table built-in method rawdelete(key)
+-the dynamic mudule loading has been removed from the standard distribution
+-some optimizations in the VM
+
+***2004-04-21        ***
+***version 1.0 beta 2***
+-minor compiler/parser bug fixes
+-sq_newclosure has a different prototype, the "paramscheck" of paramter has been moved to the new function sq_setparamscheck()
+-sq_setparamscheck allows to add automatic parameters type checking in native closures
+-sq_compile() lost the lineinfo parameter
+-new api sq_enabledebuginfo() globally sets compiler's debug info generation
+-added consistency check on bytecode serialization
+-fixed += operator, now works on strings like +
+-added global slot in the base lib _charsize_ to recognize unicode builds from ascii builds runtime
+-added registry table
+-new api call sq_pushregistrytable()
+-added type tag to the userdata type sq_settypetag()
+-sq_getuserdata now queries the userdata typetag
+-the built in function collect_garbage() as been renamed collectgarbage() for consistency reasons
+-new standard libraries(sqlibs are now obsolete)
+
+***2004-02-20	     ***
+***version 1.0 beta 1***
+-fixed a bug in the compiler (thanks Martin Kofler)
+-fixed bug in the switch case statement
+-fixed the _unm metamethod
+-fixed minor bugs in the API
+-fixed automatic stack resizing
+-first beta version 
+	first pass code clean up in the VM and base lib
+	first pass code coverege test has been done on VM and built-in lib
+-new VM creation API sq_open() sq_close() (sq_newvm and sq_releasevm are now obsolete)
+-new api allows to specifiy a "print" function to output text(sq_printfunc)
+-added some small optimizations
+-new cooperative multi-threading capabilities in the base library(coroutines), VMs are now a built in type("thread")
+-new built in functions have been added for manipulating the new "thread" type
+-friend virtual machines share the same root table, error handler and debug hook by default
+-new compile time options
+
+***2004-01-19       ***
+***version 0.9 alpha***
+-fixed a garbage collection bug
+-fixed some API bugs(thanks to Joshua Jensen)
+-fixed tail calls (in the version 0.8 the tail call optimization was erroneously disabled)
+-new function parameters semantic, now passing a wrong number of parameters generates an exception
+-native closures have now a built in parameter number checking
+-sq_rawget and sq_rawset now work also on arrays
+-sq_getsize now woks also on userdata
+-the userdata release hook prototype is changed(now passes the size of the userdata)
+-the lexer reader function now returns an integer instead of a char that allows better error checking on the input(thx Joshua Jensen)
+-faster compiler
+-try/catch blocks do not cause any runtime memory allocation anymore
+
+***2003-12-06       ***
+***version 0.8 alpha***
+-fixed a bug that was preventing to have callable userdata throught the metamethod _call
+-fixed a garbage collection bug
+-fixed == operator now can compare correctly different types
+-new built in method getstackinfos(level)
+-improoved line informations precision for the debug hook
+-new api call sq_compilebuffer()
+-new built-in api function compilestring()
+-new syntactic sugar for function declarations inside tables
+-the debug API has been finalized
+
+***2003-11-17       ***
+***version 0.7 alpha***
+-fixed critical bug SQInteger the tail call system
+-fixed bug in the continue statement code generation
+-fixed func call param issue(thanks to Rewoonenco Andrew)
+-added _delslot metamethod(thanks to Rewoonenco Andrew)
+-new multiline string expression ( delimited by <[ and ]> )
+-normal strings ("") do not allow embedded new line anymore
+-reduced vm memory footprint(C refs are shared between friend VMs)
+-new api method sq_deleteslot()
+-new debug hook event 'r' is triggered when a function returns
+
+***2003-11-04       ***
+***version 0.6 alpha***
+-fixed switch statement(was executing the default case after a break)
+-sq_call() doesn't pop the closure (just the params)
+-the vm execution can be suspended from the C API anytime (micro-threads)
+-new api calls sq_suspendvm() sq_wakeupvm() sq_getvmstate() and sq_reservestack()
+
+***2003-10-13       ***
+***version 0.5 alpha***
+-fixed some minor bug
+-tested with non ASCII identifiers in unicode mode(I've tried chinese chars)
+-added built-in function string.find()
+-the built-in function array.sort() optionally accepts a cmp(a,b) function
+-the debug hook function now has a new prototype debug_hook(event_type,sourcefile,line,functionname)
+-fixed some debug info imprecision
+
+***2003-10-01       ***
+***version 0.4 alpha***
+-faster VM
+-sq_call will pop arguments and closure also in case of failure
+-fixed a bug in sq_remove
+-now the VM detects delegation cycles(and throws an exception)
+-new operators ++ and --
+-new operator ',' comma operator
+-fixed some expression precedence issue
+-fixed bug in sq_arraypop
+
+***2003-09-15       ***
+***version 0.3 alpha***
+-fixed a bug in array::insert()
+-optional Unicode core(define SQUNICODE or _UNICODE on Win32)
+-sq_compiler uses a new reader function SQLEXREADFUNC
+-the debug hook passes 'l' instead of 'line' for line callbacks
+	and 'c' instead of 'call' for call callbacks
+-new array.extend() bulit-in function
+-new API sq_clone()
+
+***2003-09-10           ***
+***version 0.2 pre-alpha***
+-new completely reentrant VM (sq_open and sq_close are now obsolete)
+-sq_newvm() has a new prototype
+-allocators are now global and linked in the VM
+-_newslot meta method added
+-rawset creates a slot if doesn't exists
+-the compiler error callback pass the vm handle(thanks Pierre Renaux)
+-sq_setforeignptr() sq_getforeingptr() are now public
+-sq_resume() now is possible to resume generators from C
+-sq_getlasterror() retrieve the last thrown error
+-improved docs
+
+***2003-09-06           ***
+***version 0.1 pre-alpha***
+first release

Added: trunk/windstille/lib/SQUIRREL2/Makefile
===================================================================
--- trunk/windstille/lib/SQUIRREL2/Makefile	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/Makefile	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,18 @@
+
+SQUIRREL=.
+MAKE=make
+
+sq32:
+	cd squirrel; $(MAKE) 
+	cd sqstdlib; $(MAKE) 
+	cd sq; $(MAKE) 
+
+sqprof:
+	cd squirrel; $(MAKE) sqprof
+	cd sqstdlib; $(MAKE) sqprof
+	cd sq; $(MAKE) sqprof
+
+sq64:
+	cd squirrel; $(MAKE) sq64
+	cd sqstdlib; $(MAKE) sq64
+	cd sq; $(MAKE) sq64

Added: trunk/windstille/lib/SQUIRREL2/README
===================================================================
--- trunk/windstille/lib/SQUIRREL2/README	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/README	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,22 @@
+The programming language SQUIRREL 2.2.1 stable
+
+--------------------------------------------------
+The project has been compiled and run on Windows(Windows XP/2000 on Intel x86 Windows XP Pro on AMD x64) and
+Linux(Slackware 9.0 on Intel x86, Fedora Core 4 on AMD x64).
+
+Has been tested with the following compilers:
+	MS Visual C++ 6.0,7.0,7.1 and 8.0 (32 and 64bits)
+	MinGW gcc 3.2 (mingw special 20020817-1)
+	Cygnus gcc 3.2
+	Linux gcc 3.2.3
+	Linux gcc 4.0.0 (x86 64bits)
+	
+
+Feedback and suggestions are appreciated 
+project page - http://www.squirrel-lang.org
+community forums - http://www.squirrel-lang.org/Forums
+wiki - http://wiki.squirrel-lang.org
+author - alberto at demichelis.net
+
+END OF README
+

Added: trunk/windstille/lib/SQUIRREL2/doc/sqstdlib2.chm
===================================================================
(Binary files differ)


Property changes on: trunk/windstille/lib/SQUIRREL2/doc/sqstdlib2.chm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/windstille/lib/SQUIRREL2/doc/sqstdlib2.pdf
===================================================================
--- trunk/windstille/lib/SQUIRREL2/doc/sqstdlib2.pdf	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/doc/sqstdlib2.pdf	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,1669 @@
+%PDF-1.3
+%????
+4 0 obj
+<< /Type /Info
+/Producer (FOP 0.20.5) >>
+endobj
+5 0 obj
+<< /Length 202 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gaqco]+T]L&4QJD`Kj?1As\1(;F`;Y446,)+Ajos3^t[uHgsD<h!Pm>gnb\U9a7]Gg'lb.8<i%m6Gck:aC,4I$Y3;">D\'ai&]L<jo$'+oPFpk2J1mQa<<#0lIo4BRF5B>@hi?LaN,eM^hpgka<955IuLZ[1hqgrMi.9G?*q##rG<6_;NRu-(QK<hL<!Z1G2`sPkV=g~>
+endstream
+endobj
+6 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 5 0 R
+>>
+endobj
+7 0 obj
+<< /Length 1033 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasao997OU&AIm?pdS?ML-1p%KbMWs>/UHK\H)p_E>l/YSFrYRruS(5n at 4t)W`%prO2#u:F7/V<lV at hEf"i9doccg$7>+#!Mbk+C6&;gc)oQ`LneQX\5!3O/"CX7Q2U8U9\(sGcq4M\. at 8V<m0=29mS31's`&Hm-b!-i3.>e=Oj3i.\fqlM;)r82;"VHV&+R-, at r'4Fh2M=pf!aQf&Y2/(2]KZ_6Dj3?_,>KI2`F5.hR_Pt'rSQQFq0"[c9bsNrAprjeE589`$^*&09?Csl`.C7FDp\rATG=H!mM2%s<5)O%h3"^lCB[_J4$f#,mKJ^o3#A1H[V++aA7?4^;l9UFmlMq?giIKYSatfM%*GU?P/Z../\I_`cbS&_Mhk580[HKeZae)f_X6ag9VgDcS,.a27(VMi5pbpl:/MDU3b_:($<dL^f?fBVaJmS'Hn=S3fM/Vu-).56;LU7i/fp$W.(e=H*O0Ie$9OStD6i=FRGSrN*B+mm$0TZM`iB#,F[E9#cQu_FkdlrAC93e&Q+Usj-n/a.V)S!G at V%<Y.gUSU(T%HDJuU>6"KA?4dc;Y[U8b at hcpB80/ui<;$"9_Hka3uOOV1d3lgKfubo,P3Dd^dX1Z$8qWc.#EM`*jV72FSR2=QBp#iYu)Ll-@@Y2+EhTTqVd3GVeMQ'46=KE at T>.EK:5A=0C+DWA\.Mnhr>Ba_hql3bU0E(-G]ZV9brp_eY:gt,Vha3fWqRB(T=W#-:d*/>##J6NorY&pYYBOGLU5'HkF8@<A+k'IU#:!3h*'GW:oE;"Z6SGL=7ANhU[!5_td6-S.'=^X)5co[nlZ!#O`%PK]=k'8B2KoQi,!5<sF.RJ':CJf\F%R^_a"l)ido/us-$r"]:^_D\s#`^'JlE]qP?X7a3jU(n]'0bl^+Q!(i3p&nQY%1a%h>_*_FH\a at 8jIOjk+Z2sQF=c1(F1G#b7?9gbMQg,QgOAd[#s5.4);@V&uTI4Ph3s'nRO!
 ijmAHV&^/D=%Y=#W/"P&EKMnAo8E3g%;CNb1-)<$SU~>
+endstream
+endobj
+8 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 7 0 R
+>>
+endobj
+9 0 obj
+<< /Length 71 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Garg^iGoCd.c`?]8EV`b1=.gR0K1`91K?+0ZOMGdU/Zh'Y!=Te%#&:?HH*JE!<E/X&V'~>
+endstream
+endobj
+10 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 9 0 R
+>>
+endobj
+11 0 obj
+<< /Length 1243 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb"/lb>P*#(kq^0MI+G7OM5^;WhiWhe^Ri72`1u+?t9Tf!h%J^q>iVh83/K%Q%\?M(Og'ia'P:"r\$+kro!F+'C(t/-3!;I,*N$R<r#+>_b?!@[V'nQ'*"R$3q7i2*#dlOEu`Ym<03=9[e'&69o:VREeF9:rg.Y?8Z5Y7;U2qBQ*P/?(9U4LWhuV)22SES:Tfm*9?4A9&Z&&Zb,&C'<Yq^LK0UR+914K4ONsD1aaL\J\.<AcO+.tSX_9aG:;>&2nlIUc8&Hn!SuN<rm*Md9JNt6pZXq,-_`"h?`SWf%U+?]47au).YKI`pg]mF`3?Sm3:I\g*Q'"nr(s1r#*<n)7ae/!VBq/6,SiH?t5TnE3P.!b'l)Q4MK`Il-a=B9/__2#n!q"S\l=&rI`Z?akV3jP.8-4<,TNsMif5=]db8Nm^:8/p>ioj`'0:=NG47n"5!eF[SGbJ3O6e@#?l0qJ.C=O^.Yo4/ZZtiaIX]A;/PXX&ESMCYo;)2hiJn3ZLaMY*cBb1]B#1/L\>U33Ol^,J(7)DYc?gBq;e"NJ7nI(@>4p^d(C$mL34tXi]F;06jTN<(hg;PiQ*<dS4;:/uIdoNqd-dEQPif$<QJRn]*lN)Q%gT"LI!1$#_!!i_]]-Fl?I>@:p)?W6tpI(Jcn$\Yu]1%\A`W0Gr6a$Ln!klt^4DfMQMDLhE5a[;?^A0W7mL2g<PLV;6PBDIBT\U0KT80Xk+ at 84tD%TUg"G&gB\V:GTUkQr;#h3()iEMq$-t%QjT\\=_rnI[n>Z<4=TOXh+nlCT=g?NI<p%@UPS]'U6;dP.OL*ee"EU*c6oH%[S'J%3AW%c0,fo.$bBM6sUUBg5G+ at Zp@^U3f at T=Y0H7h>s5BDYQ\#DXQ"#Qc"sXd++$I,oIO/(1T(=)[IQ+,d4A6rN@(/kA0X5jsUHQEbI,PR9r,H6>Krd$Ci.iWt)V8._`7oR_NpWsA3.3!g\)NIIA;^YfSo&?'f[d'g(6d8L!
 i-"qV'I>Plg?!llkt,mFqE=D>+SR:g^fLKPU-`q(83no5T1Gq&DIIW,ntK0XA)iQ;a'FfCG4X[YRr2"[WYZe;+I]?*;^T+;!O+I]nKe)(h`*4.#D5bNP[Ns[B'<a4QpQDL^Fi\!dAZ0GC'io',&JNbuo<O)s)AEP,\j04D*"<R18!eL2=$U7i8kA]Yr*X3CJ%$[GGJsqjYR]VaYOPC=p%*nh5$Z0<mm<&ehjAouSPXo[!8,6Ze\,"8J,oT?u~>
+endstream
+endobj
+12 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 11 0 R
+/Annots 13 0 R
+>>
+endobj
+13 0 obj
+[
+14 0 R
+16 0 R
+18 0 R
+20 0 R
+22 0 R
+24 0 R
+26 0 R
+28 0 R
+30 0 R
+32 0 R
+34 0 R
+36 0 R
+38 0 R
+40 0 R
+42 0 R
+44 0 R
+46 0 R
+48 0 R
+50 0 R
+52 0 R
+54 0 R
+56 0 R
+58 0 R
+60 0 R
+62 0 R
+64 0 R
+66 0 R
+68 0 R
+70 0 R
+72 0 R
+74 0 R
+76 0 R
+78 0 R
+80 0 R
+82 0 R
+84 0 R
+86 0 R
+]
+endobj
+14 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 120.0 655.001 179.44 645.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 15 0 R
+/H /I
+>>
+endobj
+16 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 120.0 644.001 228.88 634.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 17 0 R
+/H /I
+>>
+endobj
+18 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 633.001 194.83 623.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 19 0 R
+/H /I
+>>
+endobj
+20 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 622.001 231.06 612.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 21 0 R
+/H /I
+>>
+endobj
+22 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 611.001 205.5 601.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 23 0 R
+/H /I
+>>
+endobj
+24 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 600.001 169.28 590.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 25 0 R
+/H /I
+>>
+endobj
+26 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 589.001 219.11 579.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 27 0 R
+/H /I
+>>
+endobj
+28 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 578.001 210.5 568.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 29 0 R
+/H /I
+>>
+endobj
+30 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 567.001 292.71 557.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 31 0 R
+/H /I
+>>
+endobj
+32 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 120.0 556.001 196.66 546.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 33 0 R
+/H /I
+>>
+endobj
+34 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 545.001 194.83 535.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 35 0 R
+/H /I
+>>
+endobj
+36 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 534.001 231.06 524.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 37 0 R
+/H /I
+>>
+endobj
+38 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 523.001 225.77 513.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 39 0 R
+/H /I
+>>
+endobj
+40 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 512.001 169.28 502.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 41 0 R
+/H /I
+>>
+endobj
+42 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 501.001 219.11 491.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 43 0 R
+/H /I
+>>
+endobj
+44 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 490.001 214.39 480.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 45 0 R
+/H /I
+>>
+endobj
+46 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 120.0 479.001 198.32 469.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 47 0 R
+/H /I
+>>
+endobj
+48 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 468.001 194.83 458.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 49 0 R
+/H /I
+>>
+endobj
+50 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 457.001 231.06 447.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 51 0 R
+/H /I
+>>
+endobj
+52 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 446.001 169.28 436.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 53 0 R
+/H /I
+>>
+endobj
+54 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 435.001 219.11 425.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 55 0 R
+/H /I
+>>
+endobj
+56 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 120.0 424.001 206.66 414.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 57 0 R
+/H /I
+>>
+endobj
+58 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 413.001 194.83 403.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 59 0 R
+/H /I
+>>
+endobj
+60 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 402.001 231.06 392.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 61 0 R
+/H /I
+>>
+endobj
+62 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 391.001 169.28 381.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 63 0 R
+/H /I
+>>
+endobj
+64 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 380.001 219.11 370.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 65 0 R
+/H /I
+>>
+endobj
+66 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 120.0 369.001 201.66 359.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 67 0 R
+/H /I
+>>
+endobj
+68 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 358.001 194.83 348.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 69 0 R
+/H /I
+>>
+endobj
+70 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 347.001 231.06 337.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 71 0 R
+/H /I
+>>
+endobj
+72 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 336.001 220.49 326.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 73 0 R
+/H /I
+>>
+endobj
+74 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 325.001 169.28 315.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 75 0 R
+/H /I
+>>
+endobj
+76 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 314.001 219.11 304.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 77 0 R
+/H /I
+>>
+endobj
+78 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 303.001 247.16 293.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 79 0 R
+/H /I
+>>
+endobj
+80 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 120.0 292.001 194.43 282.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 81 0 R
+/H /I
+>>
+endobj
+82 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 281.001 169.28 271.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 83 0 R
+/H /I
+>>
+endobj
+84 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 270.001 226.6 260.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 85 0 R
+/H /I
+>>
+endobj
+86 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 120.0 259.001 142.77 249.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 87 0 R
+/H /I
+>>
+endobj
+88 0 obj
+<< /Length 971 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gas1_9lHOU&A at P9n8Y3KKWesRgleV$dR2K`83JdmGer`M1,^j6$2sN;0Z5l'C8I3YH"NZH4C`H)D/MO-.#bjW+[T>Bn^2%a+<Q%5g4u8\P!eL\nK)6VqR(`2j'!%?JZcohhFeB.R\4NU\b77L;A<uNW8JKU2p/i7`sr8:A-7Q8HP#m9P/L\2:NcO#9H[=lG]'";Q:a`9Kdb.Q/.7(aHB_N0dMOAK]V1<?!9IgOX^oB@&Z$@HY]aVkUfGZ17CXP\En6#h9@$^)c]hSe^sY!JYXh at 75Z3Km.+1eV?"AU;`M!#ZnKP>?K1_oT0L)u?7'<'Uc<.IgYI(MXYSh0b7UseQ*4HA+>@ot>=.0YoI#q_d<c<"8E`#hgZd)-D)!fg+0':D]V1a8Zji-2iAi.8/<\4f at C:LI_k':1r!sqo)j>9RA:nfmE="Y]=WF]2C+F1.:S5Ptjk"\nDH/A/3%'Eaf\B&b/"qbE<Aj"^'9 at 6(slh5>g=^47!#no2XVcga.TRAe30!<r?7Cag#b!AOCb?e#V+'s.bQUj/U`=\Q=,5o!/7SoYPBMW7[YX5E1?psFs4^.)qYnD<UonVZ'@"tt at L9&CCeX^?7bYD^:!ddQJ]'M]C%paiN at 8?i])`?6d31cEs(o:V6]T";;Tf:c_/s at Oc6h24O4,=1E*<[*o1>LU%FfUH]Br5g^<Xk6c<:PF&lH$n`Om>OuBPH.:?g<UO.ZgL($sPC&N&F at 1Be-:1bI"dQ\P3,,_]R-Gq.g]09MsXgjV"]1>GZ2J7ZhGJGWph&\0A'BQ7^Ea[i- at JF\X6RMQf*R;fF,"?Bp.'LHK8,r^ZQ>M<6J\)!\Q:IU03Ya at FDimSA(MM0+Zi+>n^7Y#om:hK)RFBB:X,nb=qJ6YCaT.u>UW24(%@8__iKUmj!F:YFl!J*m_#m,Pn9Tm.FO0TlR(S*ujDD!hQN/CC3L,\uI2JA^tAI5M1_nLm$C8>#~>
+endstream
+endobj
+89 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 88 0 R
+>>
+endobj
+90 0 obj
+<< /Length 2083 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau`Uhf%7-&:Vr4+loI0eh[)=$,[h8 at NDb@D5`@U1ju$.3n>WNY!f\>rq]L'U[BPbEI^1d!Kt&>ms+b$hFB&6=')m",;5!EQ:9YFHf]Sb=+TP(T>4Zc_Y;J0(MUPS<dX;ain[?NZtaNl2rSd+o$#EYD\3=X?gX(n\>p.R^AYask)\7pQ0VJZ:H.-CDtTUA,k1rnN+qje3<\;K8CLZDb8c\l&3h$N(1iIk5rA[Gg\t$K]rH3F[^GJE at ci-o9W<TN228D;SX:$G&G]cQ,s4&8-]3U"@qHgsoOZdWC78]"0>5?NJ)%:g_,>s>E>UnQM%0&leZ at jH,RIpud66mK:";sXK&@&88`gtY"9NG/D-<j[.6mMtd^d^&iZRp^[2D.#7kd-7ZL!fjgSXpsJ+M^>[7X>(,W8iRljkFs at 0*)F(P0&W,^'<W[1mJ'd%iTPa]0QEVrJb#L#[!:CTU_%R^K(a<V2aC<,+]kX*!7MX;1FJ.UQc;X*J>AmeUY[3PmY+.*`-nC!L.ML_/a.Ense3C#tYg1aLhGCq#F8S"DY\`?$<Bpn5g-Q>F?hCuo!^JHsXSg't5\&#n;i]fn4T/ea.%7Nutf<pIqDbbC%M_[orr1>hi("INMFD>kE>`A+rM+ZndhR]WV`=7)So/K\9Q3!&!lmUfl5ZfeZ4p8- at 3XQN?Ld]PkpY.g0$#:mUdlt/'8.l!NPCDp5am!!2=_Bl>+3120L'l2HmRZqht$:0E]G,cmK<rmDNOncc4<p&/gA^P<.)>9)F-Pr"a?PgTaB<`a]@%O04b3`6;L-/T<SN.474pOQ=&f at JgD9D^K)jVXN`kmu0O/r!mC#;Or,7WrP2)QU!Tu#6fD>AFRpW%J"hLtL7C3.-l2gg:$q*9h;2^Q]("sg`7>7bc3IID(WRE"WRo%=Z=-`k6DI9SDRmW>MjT!9soB\5AEf\)>i;+(k%4rpWk\>*Rd)mtrZV8[",NO)%J\ZIoIJM%OLRa&PF2ke!
 7Rnrr4VKGl2*,si=!;6gr]QY[jFPV&RMa)MF9]%2a]Y"9tW6po'#Phg',SjpQO[No).J<;iH6%V?qVjS`(,/O^;>agHSb1W<"W!0U>knB+4'4aN9?:Dss<DbMG<V3g6)/4*NCe,g'Z2eU$/mX`5CR1Z5D0N<?/npm&H6B=G$PA0$&BJXt\`_[`#Vtrg.)9C:'9?Q at TFVB"*\:6iTJFI%!-s3U70X\XIR4/-PKf./WoHYJS7!l=-%8/_nC&hfU4?YU]TqYIL#orN(?@&DLpoWnGROB^Dcr:A:LLL+"IeF"d#`7G$2Fl9`(qb,:]*'B4gS;8mg/u\_SSDTT5Gm-Te]I^l<Ko/bioKLL*kR>+PV<%.R[:8:K.KYY'nBi$5?68@'N[b8J"lB8$Z*JF($YiF)^q8KBn5-(7DXZ(noEf[a_=UR]\RQr6dqe%(!ME]udD*1N(*T0;5ep:h=6kFfI$)<W3B01/g,p4O5g2jcPGZ?/o$CcMO]8['H#dZGM""L$"#S*GU0Z)U'n3]=AUjcRMS#emVtFH'l<uSMKLh7)**ahoqrZS at 0(mA at T!ApqiAJ_-&mEHND/8AIG7lVQaB5bTJ($pOE<O[[QmHWaL%^Fjnt/?ImUO4(!.LqV%&Qmmg;/br0d#mBhF2[Oa=7_V*_"1UbNi;;f5s!%H-%#Ge'Y?be'p7c+:mB at p^Qn,qCN(kp@"b0)J263j:Jfn%Mj,lKkkiklgiA3UVhK at 4d.aUR:'FRIUbkf4m(g^-d6rJF3jh*o\B/.b[M64>DG@;MMX:/N4YKI!la+%r#-]'@4h4C%id963q3e6(+#Uo-tgrGejS2;RLuZ]'d=2L"aZ_oG&,K2P?*S#W'TYuWs^[59F!96,BbL^$MEOEG`s3tg;^f&`L2Yq)<O(_@[pAQA$SE_R#f?\C^[hkA$a(dcO(5N)sErY(,boWPYG2Y$S;Gl at L8g\Q]kQ`tOKIbAu_B$%Gimq9aSiZ(h.2-O7Lg!
 t[qA%-C_-WahaFF/QJ1>J.r/7serVV.S,I/6]fiY.h^O/&mO7EF<\:nL49(C6c!
 9AqXa">C
>R?#Vk]IS/-=5g1#=^i8Gd=dO at K-Y0P:Zc~>
+endstream
+endobj
+91 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 90 0 R
+>>
+endobj
+92 0 obj
+<< /Length 1700 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gatm=bAQW(&Dd46gf5=:@DnKR/\:-t=s+!+[X`SRG9P_*,?0t68PY at rI;+fZLPeL)Llk+oC*%#BUZ%a(bBi^N/&k4%TO>=U(;]RG^ro"Ba?=RsN%dO0?ET at 4Y:EI-pWIKuol!_Wl#h;t)@tmfX3LSR]a"M8d<Q!2JuI8!7=211l/e&sbI^bh*m:PdMfVa_eSA?YKj!Q+H#@!)McuqRVme^*_;;06b?!+X)nKr8/;\Cc(=eYaVNi3`W)!H8oH4AN7PRt)aGP'1ilX&!C3\m/A&P#NdC<Vc_\bOp6,LD6EU%)m;)IIl:@,t!!G"t%Xl&]h3hntI."eiDU]F(#'jW!*ffFiXT)"T)4IN-H.t?"IiMH4MO87^Y&g0lOY1*?XW4&i7_g%i]=Z-#i_C%qs-7Aqu^c at e&m<]5!-`a<.9S at g'_=-NL`Bb-1.!T5*4Imgb+;,RYc77a>NQnJO5PaDs`$bh=-Ml9g\:o at ms(#iQX6P+>*e8VqTmHeL\li477j7aIBKEtb0PHDB^oTM[RE<6I&0Yq,lr$Xl0BoO)!16bT;8$,KFR>k!hK:q1dF. at 2h-GKm^dl884=/apD+9O1Sn^)9T$*[D\;8HRA4^GG2Y.3J4:Z4]9n"M0IK[P5&&[USOCN/N^Ni'KnjCLho:6$/D@/F6#5$1C1m!cHdi@@O+qCS<]_+MujCA3 at o:'4O`*gkQ0E_.0pQcOo2a&H<,-q9Wn/OQF%D9 at Z4<P`OS&(T,Ii+:]QC_V++oZWg`7R=`e#?SaUG1o%I]_o5OI+jPDBp"=L9;!a?G3A^3=6?-Jq3LlfPK2mYh99!0[QuhF_WS!PM"u"Y0,40(Y(-To;Zn>7$Pi^PZdd^/8IZ>#argK,<2unnoC?qJ$X]q9A/[2n]\*3l,IP=]6cRKNk(Z,\K+225AD59Yc&PcY!V]0?&.0oW_hQ?:!@,U@@"R++d\+S+rjfJl=-ZUFd&/2<&)32P\40j1s1ZOYS at dYWQ#!
 &-ZTA`sXA2SFe=?0h5]dS`gd^A;/h#nLWSWO4>h>]dNSA4t",*g`b+oFbA4=!^0Sps]Z_I5k?TsS)Gg=;Z/kS<,`#.=4Nd9BrHc?ubqUomoGqZJq>Zg91KU7CtYn#NL*,Y+,kVM<TigST0!mnoc`X<OZfH6BN,3BR*cg1$,l*dRKZRsVdWifq9`"<>6p[%h%0u/SSZo/q[nqiSV&L,TR35&/pb_5LXML0'G0a1n>j=M at MCfVjl3dli)O`hQ^KIU1i_CAO`fO#PCh$'jOp%PC#4ce(XXK%>\rh?Q-!O]P.W$]`&C8Y-^e;hYd0IBh6F52dE;MA:(q at 6>n27XZY#ftgmh][sQ(4A1b+fs;+/"E`2%cpK/[1c85Fn?nR&A*%\PO,-OSNiLTIT4k`Y-Up:lV08JK+PG;Gm.O1%qeT2#Ku)<;m"<)-S?OTePAs6)C at 0%B$q"d:2hjN`M at -O65+6OXBih30CMVpk:cn*DQ^#pKZPJD#7I"g!N`l1&WK-6:02^Jni@!VQunC&)M7;^'+d?i#@Q%U0/X"R:);e.A(2QN"ZKr@*XSJ:RVe+k>m;^O*89VDAAXHen8lVn,*^"sLmG*6rd<;N^T87OW.24RJ$DP5b.GYFc,ced/@3<&M_FDd&R'?l*_I_=O(`FCL)99!GriE1J"0a=bNp#?[SH/_E<%/GON7:naUG-'kH`QBahBM%+$<-s3<~>
+endstream
+endobj
+93 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 92 0 R
+>>
+endobj
+94 0 obj
+<< /Length 1355 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatU495iiK&AJ$Cki`^d7\ltaHYS'JFcf+T7(\e'Z(PsfAlk;2&tNk8lUsg63Kbgq:(\W-ORqVY2cT4.amI;nE/7'G,jU<QCaReSeIQgiJm9[FI1uk!PO+gSVXmJP_,BeVP9S=jSA1WUO3)f*q;01)<s]#7qAit!es))?Vr5jHni40Q!%X)[5nHrT/(TRa#E%9Ql-ii##Yo5CF5"jqc=.#[gFCQ.85-$3K?-L"_bHBWpJS0.(47?!ac!>H:W5Z at C8>TK^.MV.V4Jd$m[l^,,b"=JL at M5tj]kUJN%pg6,X0WFAbu;qj/;_%e, at 2IO#P@>^o_.E04/UG4Y$"SERteI!K(&LU:jj8Zk1"'_QoFM=te-\g]CfES$e-J@)X'EbQak$ie<#kcQA94f2Wj"T'fatG$K;jraO=CT#MUKV;b!1d[mHpGp3jflfbi3=g?ouqJUN6pSh"dE-Wiejn]3#HaHANdEjD>SfZ41H?QCb<n</4M_!b^p<B?ensnt at O=cqkD0K*mk=\s0%C;:8OTJr>-M'A[=G$]hY*<buc&f,5?>uj\X?e#_'Q)9G_,<WBMlE2-k&sc)*YZs+>b^8<!c72\)HA`]#=0Rn'6W@]$rQA$Wa]62U[hq#3#]^`%*099U[$Ee at _E1h@lUlAc$:>F;*ROT7j-qF$dL#)f:cCuN at JUt6ZOcgFi4Im=b/.e0ffGR5F_?;j)"^6Ds5>7kP-[U;a]`Ofbd\al3 at 1;MoPW,5b_DaFknlR>;RqFa:AhF-%O#GKH,WkoU_<o#D0%1B,^RM+F8Mc\'S7Yr#(/qh7/apn>\*T1N=/pH3'+T-gGksN'lEB*`6[Zfa?oJ5>X^#K;qOe0YIm>pF=T*PQd.!fY68icQp0l`S80kfurblgr+hbT6/$5Yb;+qUOQ6Ob&er\CPD;H1g at 7FE'S7 at EQjQBF]L?,!1`Buo::2:/m4XWRI+RS2gs('f^c+F[G#%_#4<r#Y:7P1e(\C0=b+!
 4iE>;7J``Mlc$Al"Wi2UeS6[PP6HEfPHfFUXdFiOo[0q?t1k.GTa&/l_$3s/Hk%Sdp/I"_%?PGTR:ZXOq253[uc)DcHbU73'Dop/_Y3&?>=l6=E=TgN(B6>T8k&H%4m!5Ui8=_ at rgDmIjfe;'m&RME'Df0p0E at 9'UB+_:<N^X#QH?^%5hMS1fbka=-.ROHenP4+nh*?G0,U0s$!D>"mYlk.ap)<E&HnK1h-mrQc`%%TOcYEuqWb'lENR./K*$FBcnkniKmq,tkQ(hsI:9Fn,0(7tB>L[FbP6k1ZK?M5."1`3!ZO+Cc!&.TY3$$:3Zm18d]c\#2H/76WPJ#Z?<*H]T(kGfE%^((b*(9(1'+%'-O'*~>
+endstream
+endobj
+95 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 94 0 R
+>>
+endobj
+96 0 obj
+<< /Length 2063 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb!;d?#SIU'Re<2&Gf;&881rYlJ<F9=G at 8RC1hm\LI.<k=K!d]&s]p&ocqF+nPZ7UZ(f$g!/BnbH$O[\H$G^cbHq#0n'IGHM6l!/\^'"KF^4H,S_,0i'>#DZU<m'2SNgbF]I=?ggj/;+0hF_N34#p92FVb$?s0llm$9Lt<Yg0t]VqlPk:^KDbLsMhfk313kDEuJ<;]58$$sc at U!k].HZjK(G)<fY<&@!_5XNjuG+t,_D<VoB^!eA$K^#2.D>O'.l;.eFoF.^mT$0on\A\!<b"_cDjdV;d*S[<!YY*`dT-Y1cNhQL4k/4gMmB91H3PV<\Ga^T9Tbq/GZqb->dYlo at dAtsHMjrJe%j0[,qYP2?QP.\:?.ThGFFR`QH!Ri5KGHM5]<!`l=/IF!Wj4e"R#ZQ2cUe\3J3n3nladeJ,$24s%S]f?ehhNU3r`o!B5#tWhN8TfGAreuqh'^"Q"?>=!Z!M8U+T0HrS/,^_o`9Hf!r`b`jB=J+81+r(rWYH\>n1l?o8hT[C^/2`?_$kd[leJgGKYb`PaLg9ffXDb<HRPqd[[H;d$EnSig%@dL-pm&@s-0An^^bo\mT0<u$"o at 2dc;QAQB8D-,hV2b)[B13S7c9%88fCq$KS'hA3ka_&)^,RoUTOf[)>B]sVbQ"]JV_0=Vu$-fo+6&t!rjcI&Pm$NrXXFkB[e\hZ<*.ckf`G<dXNbqh'FkoQ>g=F66$*\/CW%u5RR!)VOhWO-:h!1DsnFbA>Tl;j8em4J81#B-NDdn,\+M4YUfjXU8L2!<E$bPGQ4YsnIBgBq=^:RF:3Fud#A](rZ=)qcB0(S[W#>m4&-;(.`U\WS+AtDuY.UdisRd:ATG5hPhq*?_-!=;gno;oK4>hd]qUCkW68TUT"EJS2%E3N^6c[iYLNu%UWA?%mpGkDi+Nn9tMF_K!\[DVm[C]1q9/gThE`U_CH?)keHgmkrU*a^8f;oj[gThg%q'hu^qaDM%Z#rX+;F(7!
 b'fED+MPbj5<VuF$.4?>SSoK_[j,P9qWTMkuE$p0g=?.7L<7hDQO?,Lp=<,X$FVLHlRXgFRSY*fQt^^l8D4A"]>i\q18U at Xu)';gPVcdR/j(QsjunnV0r<-a&\OYD0Kb"IEa%aBQjBri4K,lMEC<9$j-9>j_n^`/5`(']-HK`QFP^9OWc"71oj:H]>e<^eAck<:CL0H#;"jR^=u`>`F#7$:>HlVQmF-^K(/BKGEq3!nib1Nktr=U.<ZUk?r-C11IPhJjN6_21),+/H+QL\MgW@?c8a*]Q!1r/$W8D3<&f?A*bqF_Z4tp>(t[1ej0rW&+KoDG5.G&]/i/pQ2FQ<$D`=-17W("$:Eq)l<C^&@@fmi;O!BMA- at i4D-PQ#(^J]Z93M%P-OM at 0<`/*ScE3X$.'f3PQeo;/>soO"9ML&>$P6WO.m9]`I_"H+=88C;+M0,p%KROD0bVLSHhM]W[m')Ua?q4,hSlJ4I1+4*^ekB5r]@qNu*VdS*3j99-ANe)Yl#iU>b.E"elgPg=m,LLkbs0Sj;q"8;B.;K at D4?p_'hB,n?n=^9p6H,%NV50`>[,&:GIZ(W%E"`bPT`E&D#oB&4^H4X%r6Q%cAp'73\XV`#3kJOap9#,c\)),f;[oDb!=T'K0=s":9GYpapa<1ipl.JC*oRSRehLrre]hX6'87PP".[0N#h('48qBBp0>`l!%L5RgrIJ>__6$b$.8oG26I=DKa0,^tPGJ%t'VU4%mL"5,l0\j$iu_RH^[)B_$oB&b>9L[N;2DFJ!5"#8Rlp5?%`>BDd8MUu.J_oMLca)t8b'OU9PjFP at -8jf&1<<'/uUZAVUY'IeHX4_nSm"Z6<T*)cXXb%II\?=5e"QR8$L7ROX=4Z]=Cc0RPh:?YC0sI?^^rl-T/[$+eRa/#s/fr]qp+BULV\Zf;\@>eg?AN4o-WS2oXNle1d$4m))9>_&Q,qC$N^>5MHGYSRSaEnDB4&(&ZNY(s:`cq-S!
 ,Hn>#?3muXUjH%f(Hn9KTR+9&/qSP(mTGR*BHB6hsj'h9!U#!:"Gg?+:<pCSU[!
 G.6'S&f3
&Q4(6ga(Z+Y-3n~>
+endstream
+endobj
+97 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 96 0 R
+>>
+endobj
+98 0 obj
+<< /Length 727 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasan?#SFN'Rf.Gp^sB4il!Q^Hg='WVG7edmU_q9"&?*:P12Csm+9R?PM"5Yp(X-gHd;S3EZ=bMEUUI$JYsR[4m7I%(Vp[@lKmc!?m+^YHag.&.U>SuCDTD2Tu/P%V9!dD'A3)&"WlJg!0u\+1&aFb!!JDP=1eg%0o1&3B4!hq[JBbF\74b\Q[?PJT(%sR^b67KFbj&50nEhFLs,U'\pV#KCWFgC6>af02&V`l400skgq4Sg+@'Q`O8U`Tq87$RR,7l<2?6)YKdEXH\8f;Fc_PUNErL>W7<_mf^e&4H5A1Do.Roh-7X+3=n>T,8Hs<A.^]`Y#68HAkb5X5r[<rTQ%/O_^/>t).#-';#Wk>R/a<anMc`Dh5(O/j*ocH]]a^fPDXj8rm5?,j7>0VZ$H,A7Se[iOIW*h]aQuL$!h9?JI[WA>'YU#X1bn>B#p=LX&cjNoZMs<D5OBTr(lib^80Y08J"+0--aW#$RapjN2(9JRIr4k_2d#)D=]0[%;($`fcW\O(>]f=m'V2EER+&4BWFQ;Zr4hS+f!QJab-_4+64>EbJ;YFih,\Y/clW%TGgo^j*>bgVq3q<GsB::37k.;DA;!q!ATWQoEqGlB8^,2aWEi1u'(C#>XOT&)D7Abhu`)2&crQ2.^fuNU[#D(9V+%-dg%g`Z$G+:fsJ!a`Tc<437e`cm:l%bH`?O83Bh*D@%_7ME(0 at 9DhpUlMWXO'28hjUb~>
+endstream
+endobj
+99 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 98 0 R
+>>
+endobj
+100 0 obj
+<< /Length 1445 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gatm<9=(*G']/^gclI<W;36G69W*g(9\X8_mDQUr$XjE1K>E[<4L`)>_I.G<_6E-JA'$cmmlM%#q/s=Fn/M$kLuOeJgM at OJ`sq_DqnZT,:uLk'5s1+=mE,7bJ',a`8G1uU-W,P[3(URB;rk*j\TBc:b;scias'hP]tJYt^$VHC"6SRXg9UEj[P;JT3"HU]P0S<MQUVBd%;D`H?etD22N#toPUBTO%7H)r3HGa$%',SjMK;]';q)Nn;KZK,8np2!3IX(oL),K/LLF=eGJM<&i%PI66t7$RO"qoMI/:QY0Ofmd60',uDaD\_b6VR[Lrk?bj29TG^(P')[A at cn'#W>.ag*N"\ojQp at k''(cc5AINUqVTEfTSEfu.Yl1[&24FG-A2m+qR:]d]2/jZS=7+S,GkJ,KE?i!>J?5n-I<esi,c/XPJ"K]1;Lp"LptbCM7(BC_/S`/65cPhA=]0H<aPHsQY#G:u06-G9!eZ(%,DVGYrUI#LE=0>jN_Zk:hpc at c@SUT_UR[4d6bdkW6Tb4Jj)MlaFcnnlS0JbFYO2^?p.8eMg`4j^mh-6pJc;E5U&mJLc8UHshu1c3Hi<n=J\9Kd[$BWGSK=r>;9:ggONfci7CB]iH4TS5Kp0jTH5<6N('pl!M9#h`h@=k"7--I74I#EcF0#Y,1X1R"2CY(?LNLY9rU$E#n\nCZ$pn8C"I!Ekc#.7)C[E`+.E[d at daDg@R^pTfCsJ0TdLcu>CK.'f"3)KUT%s2epH!-];3jn9I"^^E*c-3-Qp=DVQrduY^S:$F$]fB&"Xm+dRfEI511H"FL&;D8;\2u<NcJ;#7l35aO>JS\,?K-2;S*&R$3BfcC+HehLRXMm`Pm8A^SZB5F&gnEq[W#GC+9-.t6pc[_M.Wb,INa1tPF5H_o-q=NL;,Wq at N@5V]bJeNtXGXoNa`36WF9orV'sM;qF^#=_<XNL_Yd]G.e0d=pmR:91!U6QJ$g]/^)>e^Pp'Wk13aj!
 ;48NX:S-Zfj;d^lCf2L9$TVG689b`B(d"De79eDPXmg?!c:[>#?JgM>6H\R/$J8+:"PWo)L$6"u."loP1.l]WNfG2g@`Jbgp_0XX6j9o[eFR^-6pf(rN2U[_GokHF,^KOW[jpkkcL#/R7,Z5cn07+oZG]Q+qM2=6`n)CCS&2*jqLB)_^EH*,US6t;1mUaI<9)kAWgQ&`pHWc<Vfi)l+_=%D_)(QZ[WN&^k%Qau%iB^!I%b!@**!V3<tFXa[2VGS+N$C=<%;1LXniK`ueHaLss7pmWsefdBCZIPYqH>q)@3n4Ab/+D3s6586mMo3tINQ5P.oku]-,^-Hs`]u@%hF%#l6Iht;OHWa99B:n!GSG=D#^M^bqqO^rnGR&NYd)-l2fE=od]_EMp[55[X7@[WLtO5kr>sU08p]1Qn'10AI#s,>:7dsAe,csi(e(o`US>U$ItpNe"9~>
+endstream
+endobj
+101 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 100 0 R
+>>
+endobj
+102 0 obj
+<< /Length 1752 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb!kuhiFNj&:Vr4_:rRu4V$KoR.dL`[F/*Ue4P"uS5(>\4]I#S5^'R0f67K1*YU5t\o1TE-oNm\^)<E.n`4\rqY3/H8Dja0-<gZ1o87bnI#(;0FtsCkT1%Puk^?W9Bl^0@]al9)T<&^tZTK=RBk>:eV2f0;HqhkYDI=@S0\PnpFi_a=,d/P:S$s%LSW[L:Um6GuIJ,RKJ/op!%CmBC,O1&HAOX(a<oLM+EU63(`]bg\lIY)CSY2=KU/8%Z.5+84:@"Nu]_D]7F0gt(LV#))*;i,XPWr/_T at UDbr?'/&(Z,"MT$m1kQHb&MUZ!hDC,8ne7N&9I"oZTW8f13nHNpHu0U%+A6E7\H2MT+ZA:\'1+N]5/X]=)FWtHL at Zo*-^UsJE_S9$TP`nC.hB-V]^P/58,HK'>id`=,D(GJ8J7+_q6r4,K3,9/md+en_+*"#(/FTH&!5GWZZVb+4=,u(lm]jF#CaigMu(?@Ur#L"mY/RXOuj`3$GpZ0P.C,fktS?`"]IEMt_1bakk'[@?@_K5 at F$2&Lt"n[nh$%DoB*[+J["S!^WNIQ*M4a!12`B\"HDH4.>5<B;&5`GKf!^ai-9XcP%DF)">:[('ho(Il6Vs"\d/"g?jbJn82^piB.,>J2XH%iMS_Y0_PVD3'^1@%`9b+J:ro--\U$I]C]WEqVE7Dbrg&;7_-bX>YpI=/0fAh\^4m42-F[$<dLllkpKShAMVBl[4bX!()d2m`:[/?@7><=lu<%cP'1V7\qOJ2_8RW=-t at b3\Zdm:MolI%7Wt6PthnDVJ%M*sUgo[olDE]b#"aCNHHpa?.(,)"f2]jL[5/JrgPtUnuO?Q^"f!Mrf8o6ZSqaP6,,h*a/o_'F:"1NN+]d)kqh+4/`BiWW(g`e-^rcB&lX\P]NJ;[f,BhJkFS/?B6jNkfPUgAD"[JWJ^i\%at%X'[)F5iL>\%D#D4?o&`@43>7*GFj-<Zk?f`aSs$+ci/B0.dO[BpQ?n!
 -(_nju/Rsi9"SG0>V]g!T`)3<_Kdt.6N3JGb+1t:0\Q\8HF'eMomPF:X:5pNm2 at Xh)jCZhn7Jgc",JKp3!dJU%+(WbJqZm*f]8Q@'T2N-fY8.&_DQFVE$X>?%mZg%]56f8kJNRQPX`ZU7P)ae,o8+_;;1"b9q(B*3OToe$GC]>P0MV1l2.kKJB2QBL-P3i<=`tq[%B^b;&<Ldog3q"9_XFZW59NQ-KS8KRLXc1mtCO=b37@$:6%kuRZ:Wbjn3!PH;UZO*9A&tJdTpEuj9+4e.lOjr%D%CB<W?Jd.n:@PQ$>'mjZ0]\'_nOnmEu2aA=D'HHd5U.5>c+N2U2q!&6bPOnUmck]I609lUj'jMgNI"k'5!\WN,`21@]ASfb$aNFSr5;fjGi6p:sa[aV%(/#KtWMYk="Q2I]DQf#>'c'F>f7<,a)Ni7%3-9h`V3W=%IBtnitJ9RUZrJL5!6'V*k'TD4VUP,aO1:ZY8eU@/8o4RlM*:1*iBL(ek(R:GcPC&0[,-LsFk77RZe\]bS3^KjB;SbjcU<SdSs<Hc'`X?SD.GW')F7,&dG'?Va378tSr:W^Csg>5bFRoTp9fpB5'Dh_qNRh&dpZ$erE(M"'&.&GY%];D28Q]mAHV8J8oC$$R\WCh6/,*_$8mCKFX]fO8R31$nE^Bao`2O-DsIE8TsCn>1_P64M?;9:I\pHoGqV`!@KE at uX_V_3lJK-.=p4i3`ApAS2"FP3Qm(=>6A-iq>kiTJ4]kc`W7&Zd?HH at 3OA~>
+endstream
+endobj
+103 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 102 0 R
+>>
+endobj
+104 0 obj
+<< /Length 1223 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb!;c92jS!&AI=/pf?TT<DPj5;jj=X3\]$5l)!ch*)M5[E.TWIrUlGJOrP>R3-B7ujSa8:?*-:^qs!2?k9N;(^`]1D@'H#k!3.+J&?[?)KL(9CoK)cPF#lHE3'B>qGCs6gqGdP.lB+4ZU'"A?;p($UJhQ[mEq+Lb>g8T1XS7in\0*IF\G3W+j`GflG]IhDo_j"nGSe4(Z?,b]pLEZID,R>H#SRV;lR+?+R:j_ at 03:n&X.<e?KcY=eoo-O?Cb+q"Up:Q"GgmCP0nNWjGMMuer>;oK#?4(?;dF#[]B4uCq*C>dDW[<c[0il;\h!GAR;bh)/hHEG'+6Eeno!m<D2/p4hMOYiIRb&<Rj)VQK.aIcYW+Am>\E&rXSj8t.Vr9E,?,Na47h4d>ir(RcXc.+T?GZMd!oUb>8gl_-<G!C_qb#pL+?hYI\hhoQX"LYL]246Oiu-=F]#Tsj1^T at HIOIgU:@BsQZ!3,eKenE!?@TP);tq"<YIgNi:bp.N?XH<6rf,N5H7DZPCmste*QsD!AFTmU4Cf>#Zr3o0V;#dql+"]'(pgl"@UD>1-u^YLF&_';\.&0Hu%sRn'VPrlZ<^@`7>mXZd!B11`9;V5g`W,(5(7o\Y?S>@MTHI6T%4bDDpaN0fY^F(6U?9-L0aaM[/"tXQ8Bq.PL'nF!V`7^fVQLXd4UI'L'r:6OXOTRp+nNNfQ`d\tdYIeGH2n=Be,LPQiae>cohLK'-TcD5sr4?d*P)/+.^`k,ebKVnr'"FmCY+8E[OKn>\@raK:_o1so#>Ia\)r,Eb=Zc"s,?O6WEO)-K/)o._mNpk*Li4iiA78_.Y>Nj.?JcZ;$NISs9;,(LeheEg%BZ5.>!>j#NhgaZ?BjCK\*RJVBBFG08lBQ[mU$&`pQUYEf9c3-Yg[e2kC#@^@L!AsL2$ZN0WQe:IPn?HfHGF%!S"ZRYJA1j-"l[,8!?oW`\9K)Xh'*gk:JK#!Y4;;6eKTBDYp[it0DY=!
 \5C:/'@-fh+H48t:?*32QqPMAdL;.:YTG^m/L]NW:T$O:isUn<ORN(b=s<cPb&LdkE4%4&s"Tq6L5AOaN$A2ekSV-"#(c&]OP9AQ<B_ENk=A(cTT/[nY0KF!BM)*&KqPC3!(X3Tmq\<"mSc,,PPTHg_sDt7>lQO-^C$sKn?jbqWhKoHemdH0Yi'1N>)C*#7&;R<(jh2c\[i/js_Qn,=7T2Z=BFW at iP'(+m))NOUj~>
+endstream
+endobj
+105 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 104 0 R
+>>
+endobj
+106 0 obj
+<< /Length 452 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GasId3H)bg']/F34MlWRF#G&$5c&3#^h'K+38bck85dKYkc\n7A31>@AU2VBG<KS.N9S1[(dS9qBHRj((ng03!1WYULJ3Le5Ru^n[,[)P<fY#7FR$OO<Fq9SJa1O;LfGg3VOAnnYtVP/]qd[EX+`>)eP=RegFA4pXOAO`X0W%YV4bG=3!N`?]\[mS4Y48]Pg]^JN0hlBZdT(I1)P;aGO(0I](iR6I4X"9q:kVV,'?aMHBK,j*JE[P)i0M\6$^C*@l<VG*XbQDc"`XQ(,;uA[#kh)dP/65Fp=+b%s%)%J at i(DQtiL-Wf9m:)N':%5.>t/kT&KHC,lqtSlK9ifY1qS]ZVKpW]55f>K9"KcKV0\IDB58DGH._p?-.>)B2$KfM.@*MDGe^.q;%Jk+2lbY<)G(D%L!sX@&:#!N5kD:ZgBXqNoAl\5(8"p6>q/L%GU`D!Jh~>
+endstream
+endobj
+107 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 106 0 R
+>>
+endobj
+108 0 obj
+<< /Length 1150 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GauHLac>C>&A at rkG]X&P)XaCTVp$7i&g0Gkpm0$QG%e>b/T+1PFT6d3D9F9f7@[a40ORusCO**UO!T9Xbhi:H#a\r$+H,oOP0JptMB>:r#>2?T5YFH[2>M=mn]>Wp+!/KJ2[0U^$Vfardd+l9:D\J&rDU:*Q-8+&lN?s@/:PDD'O_\c at Jh9,j80"^,qr7;K(fMb70/]Pb/q:[qE;$ThfN9Gg<\m<^.VOoXt*S?^-$k(f0d19bJnaf/hb5TS.HuAbIUr<@UGf'3"!02qQeE:?ImlRf=pM*j,qCpGtLKcQ#-UN^9QZ3N)27hLMCl2<$#oUGi"]/q!(g?8I_);s4bk^+(g&X$TG*DTE[>><UJ5*S1#`+]R-cID:P3T0Qs2lPV1<N*?;WOfqPu5&9_mZC&[\fiVd;R at A]\%S)F0LB\nWDp, at bY*A0%"[bCE%b%FfCU<@_.#":3)EM:1R1uQQJr4%t67f-JU>M8XtZ[X#DH/o.U at dpU:mh1IC7i&X';@C(W,;Q>S$[f7cWFHjF9gcQe"..R?(FSLjAeK>tOU59-"'4Ias!$)pU\ptiEaVNB_ at 3YqQN91VaG%kr'IFVSB!FY0atG_<aX3"0K,b1r/4.YN6!"jL#lQhY;:Dug?ZTll<WcjhQA-[)lasd'+j>WD9G8e\!^2@`b*UXhb9Rjk/L.%mIT(%<q<,>(?%5dbKAQmj+cU'>\Nt@>];kF-Imks8qr86!PfP1rf8m?u;9>Oorcr]Ih2WH/He"?QKA\0d),2]%5Vn&X9rRg at 0pig=QA4C-PGd8E., at jQ26$Tad+esV#0l`mgI]bK5pg9J"fOQF`Y at -=hf<_IY8mRDNCWBKFhuVBO,r^%h?5bs^niLBn0W.0)\d?V0f6R,aGE><EL_[,eGcX,1aN/YL8JL24>\'O0hEVO^^'g+Rl3q],`,)>O3B at IpO<HXjhg/pl6-LKp[uK:%k9#,"u?%EBa/#Xc`5epl9\sA>8BfVmh,!
 <K]5`'S7ZBF=;"d\-G),,E-#FPVLC!gD`L.!$-Ta.>ae`H2$K[fd=-2IS[X[(FQ:V6tZ7M!'6%paQ%hcEis-[\[GlQ$Fmt\mKq='0\+bjO#E$!j8VYDZdZC_"YqlgoUe>PT5pKcf]:kfAQW]p@$_UpmH^Dp)BYQ~>
+endstream
+endobj
+109 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 108 0 R
+>>
+endobj
+110 0 obj
+<< /Length 1243 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasap?#uJp'Rf_Zi6chK<^IFNmSg\kB=$(R1l9uOb^(W]A!o#.i!A,LrUgmIL+<=ma\2oT4nn!lUFZ/rC at T=LmLY>]Ze@"8'.o#mbo^q]>J:g(779,9`;+>N<H6N&Ic^LrXSsq6Jm2UjiY]5C6Ch;,5%*e'@@M$MkA#A*]Q&42]IYi-r2dKK+o at sT\'0"oH+D-hbRX8d+to:h^,bK6PLjqV>^8M!Jt1"T[k/eK%:H7B=>/9-Inij at L[YSDUt:V_"VQo\X5c)gPK8pTD4D at kJu$BM#e:-WJL)B*a2 at Sbn"9$N^WrL, at H@#@n%=T?c4'Amp?UgS(,b5=j!3&U`L-kY>iCd[."PRI:RB8d6%FQ[.JH7I(R4t$1[F-H5WkE6n&nRCf\A#.AoAZU,##+HF6_oh,.+?LdT5:S`-Rh%[@P9f&W8Wh;8jpaL"&P]7W<U>^!J?T);#Xc8sP^N4kNrKd]pr3rap#ZHj4N-0?7^*:E_B0'50U/2CoE\mgo%Ver"JPV"9k'"VREgs"m_ at SW3,BlVG!VPNTS9?bp!r at q+.)Ft^]`2-l!j+6)^6]qgH<_?5"1"o:'q7&boW\Drl\)!g[Ym$(ObW.s]9D7t^PK+Kcenhuej.a#;MM+u,rH="kY;,.F75uok"4N5DSkkMdF+(;n0'$qRiE0b;_H'QJ/OhUYEj);:UC0p[9L?78AO33<b-jpTo5eCMERLXN<M&Ndj_8.9g\Af!N.2&^OrDdGY":BO2KsSDrqP4T5aRroX3CRff^J3`4QM^HD"JKa7MjO:+<H1g60W0i^1t;pXmV(_K(AE`2.ptunluf7":gcsi,N9U,!DC]fV_]lnn;ZO+pgKFf7CiPGfK5^CH*MeG.Z/;Bd&08Ichht9<,2l$@YR"ri#_>/DB;#l>YWL3_>:CXE.\M7?JieLq=iqJkM(cIRu^qE9TM>AX*`.aFF at a>gc12;*<p8^cFQdIFe0i<U<L>UR6%_)?u(^-cD(!
 *G!oL`ITg?EK8rQKI#H@#4P/!R%mZ_h('Hi1QR^tWYXRDp.Y38Ck0`U,(c/lQ[:_+/%qAU2H<YO;7k_[FT6d-hqpdq:\Q<0(P-7-/c8*ZcK-H5e?bRZ2)VXaINpK5M]*e5E8a:@.G%X`fcbRkS=l]sc,Puc7%pC*iSj=&_p)nGFgXdEokWpULN4$q3rk at f*,#tE-@(`Es&]*1Ja1PUAU>KJppmtOh+'[1(Ki1>`nX-OW/ZR-<)4&<Tl!@1t,~>
+endstream
+endobj
+111 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 110 0 R
+>>
+endobj
+112 0 obj
+<< /Length 1631 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0D9lJcG&A at 7.kS=D:=HV*GM`kmg?S,)^GN1h;iZ)X"ZAD,:.oAme?b_gOR6t2A($mOk'I'Y<I.Lsk)=#-1lKp7S+WcLbl7CC7f at aJ=a4:3o','@e5np*0$_:ksgb1kZfO"+=`jmC(LuQL8")$R;HbA-RHfFIi;EVGO19iH7q/YLX36TX:KC<2LYGN30X(0RO"G)>I(q7\tQ73,:j=I=fC,\=[lmMS;I8TOW9GDh[1*u")gdoR#OU3<V//+(P=Y?=7=id++AL=$O.G-]AeJg<R at 1'f7aMB9;;XE_.h0/diq!:r>ZP%t.V":'_(0i-k*C\G.F&>JV-sIWI6BUSV(@JofU+CS5%"RMqcJln%563i*6mOfLj2V;u]pW66 at a0p&I-``Ujm++kNcm)tM4u*1)WJ5\P,q1qO-o\^ih&M;Mq-)LMn,R],/8nt>h,[PN-*9+VHLa")4#YWnk'.o9oX$k[;"D+A=]pY]PkhZC7ZrI'QO:ViYgKPHir4:1>sID/&b+<CtO&P?PWsOk%IIujMm_tD%_k%m<PUce`+<beV>K8"8B%lI9Mjq;\-3Di'o,NB>d%mqo&uOKSg(M70(!Vq!kfI6bRGc]hoN/=i`=WZU.[\VK=e:pN0jd\a-1h3(rKRi9iE2=K5cOj?hE)OBO5 at 1Uo<'I_<6XQam<O=ZUI`^Vgig^)XYAF57RRq4BD7IC!m.p_$S_pe<!5dB/XkN>1-<\kJF:=_.2[#gDG!W_XX:#l(A"%.3+\BD2mV`.K$YT#Hgi&GjuK-'f,5jcmun?l6X;K?m6BD/nqiIP?iN/CK1g"tuLka9%1mqg^AbP?M$E$,YPdSAbS?A+b+JKHXe]_U"`:?Igq5P2=`0_u>XiqJ\?McLM)^7Ql#WOa>Xn)Yd7qJM6h1qa/3Q0GCE7EpeJL]"h\md2%K,b,!>sHiao<9I]Or6=L[jZW+9S&2[APW^#KN&A?X\LhI1cP`%hPE"R[7#3t.c:qk!
 5Xbs43tD-&[W>QHV=\d#+JQ60tf)k]__+YApo_c'TKf$CG'BWd*R_9F^g"]6p>KQ]t(\^G?lABPj\@TH3%cQm;W]A3*V&u)=[r]/C"<3!<OS>![;9"ua>eM&1WrLnWm3J-"4a]-"%LnN,$4j^^Yo,0<q+emr#h91_Sa`b"U).HX)4]AsQ&sF_/E=^gnN*?aMV*ujhX&7r78-M\nouiRDKOPW/HbkHuAN>QaZ@%%a_pWKt%L]UH'\T at 7JbE==kIG:t]KdP at f)"tpJfB+_8tMs_*p9_nYgLandlB<hV(hIVO=J7&A.5&.>OfYn>]-.Im"UY9:8dW@#SZ$`p34a[lbTD'6]CG=o$+7<\iq<$MLXYX4eD0AWA7=N at N?"p)q@>'=:d'JGCiZ'ZDb7E&Jde=ca>lJd^kt5)hu(>li1T;h`11'3*>%X0!Q1$hY.'kG_hC:<WBi2s7rM1Fl+5=5SZG#WPFQS%c-)5"+/PmA at YP-8f-6e8cn=!>0Fk`lnmEg[#N1!o/)^W]&NJ(7fu at .N-$AO>d6J'N.1N<Qm*/bO at +fo\dr+A.I?#cUelYSi]@6aIpQH0D822Se.+X#I!nq-SmD:oE[SQsj6FPQoYi0+#2^@^#@4DYI#@dHY*b[>rrEepnV$~>
+endstream
+endobj
+113 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 112 0 R
+>>
+endobj
+114 0 obj
+<< /Length 586 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GasIe9iJn_&A at g>j9Q!+dO$EnRklb`kQ*):`,Pj5R\:EhU5o5!e'Gs9o[M.Z]sfZ,41RtrET4ZX&>U?STFX<kA"Na+`m@,:K<7**Y$<)!+>h(q"Aoj)i!:r'rl8#m.pQH?o19?eO\W>"*Z,#F!!P[1MgZLpA.K^cl;d*3-co;\1m_#'dsUkW=:`4m88]GW=YQS!KIYu/3ZHB]G=`6+T-2XLCfqA<Yl6*7qJJ\f2!Tmu#1rJ2iat(fh_";Pi/GO)13d.803]IfgIu_n6N+.>&\68?A`AUeOarZ?/:Y*``i%)F(C+0T[qBamalK?oM#7B3(%9rR\%MJ4q]1dLm#alJkJiIlYUtXFD]'?A6_Ph"pZdf/"XDfbpu,L7R<%\`n+BH"ll3\"qG$+lpDJuY>d`5lF>g*C6UF:Tcf at id3XDI3S!;2b*;^lrCu=fC(5L[WQoaet<_gMdR]SB$m*bObkks'o5MU9OZd$c:5 at 1k\Y(hq,4mE\QZbr5Cp>#)`c[M+B,rfT8dG.e\gXCS<0KS_X[A0TrnIe67jJ2Q;8DI at o:Mk>`3GJctB=4t6R2IEUCE[MZ^&^uf5(`~>
+endstream
+endobj
+115 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 114 0 R
+>>
+endobj
+116 0 obj
+<< /Length 1596 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gatm<>E at K-'Ro4H=K!`9b"g!$4-^]r8s3601h!B5.Scgk*PdhVCCf6,[JfPW at -fm`0P6N+(XI%Qhmn.kp?R"m]/QU!=N'f)D8,:4D;EYu$9qg;%72qmo8-tfg-!qM%43$[$(_[8CVt:Omnqui"qFM^o*nb[DFGTnCNV9;(HK[2L>$9Wr\Ird24]=X5YuaXNST?L=@@B3d_.%\gUfZS7;]G;K13<Vj"01E:INU5YY+MS$)-^jjA%=J^>;=1QQ,iWbBZs<Bd3;e`,_X*aO;^XjTVW9K*5-4RPkYZ9Wi(AC)s%\^#+QicD*Et(3R%$pqonKNp[Ot4#TH#@TR0u7d5NT7Vpn4aIhH\)ATY#?#Rinm86]b91*9>C*im^a**n4_*JHL4TYm!h.MBP&e)PDXL/N5ZR\[)0"-&20:ukia7jumb+gS#7HNC"Wr0#n\Ql$-h-RZb!^2-D\<M5mXTGI(3eQ<H>iI_tWd*_RM;cgqE[/g3oMSgC\XTjo`>ln!BLWb+l,-B6TciX?]]hm7A0^350**.*aNbrt+EdY`,\m0m`/u<\C:,s^iKu;#.Zb'XLt0%`;]Qc_<EcXeN1Qj"FG34,MSX<igCk:`2HfJ5:]uE:;#;pBLg!Vg8LfgcD3h"YFC$XHkGDj`Gg#i<@32*52*"e[$b4f1X6SL?+=CorTk`5363!sHs'=I&BDQjANSf at 2l&Y[M'-\n'biGPWKoi@%rK1ub,Fo$+3PZ)_0%<.q.tW5a$i((20QK5B-7m at 0M-m)6g,3j#8Q^jFYj;-YaN:.fB;N!tdB[dTD$$Wg_^6)q]#`Ne?`-KKL#kPB%8?B!*p3EmfJ"IMEOaku--J&MSiMS6^kuAL(47,L8OWm]Xg7%aaKEFqGTrK12bP4tVV3\D7(gsrM9;=%-SpqT#PFmH0^dG]A50WCC:YI[<Qi8\$qG2J5o#pjp_2jU:G+)rB`W-RR`dP56C#N]Go&GbDS8fpM*3O!+qJkNXch!
 6b*S#HRYl^CfFu6\hh;i)2NXRuTc4R1(,l_kR$H.o2;'u2Q`<:r5X8BXN'Xad$5J&XYnR$I+YSKpTS/`U[-h!9?:^u<F^.B\O7D&Yd-0WF]4B_R1]e]CX2ZbOZ/m0/QlrU(k/uQ,/J%@pTnStq*,UW6Ve`Fj!;*2ZU]RV^CL><?EhHRLuB1eKnK4W>rBH`$T]ErFrNnh"Y!sJhre]Z,:@a4Wr]"O?Rji/bA8btkhiD*DMr:IN=,F4tC#&]OP_2@"0<VK<=B%-"*J"UInI_G\s2SJK)2VglNrh:(<,2O.EMWOnm';mhW,)gfpNQOW\q/&&?/D`Xgs,X*`7%g`p;7Z(AgOb;H)j5i0o'bYsDGX(iZgpWM7/TB54<';t at Q:+jnC[+jbL"?JEE7n!6"UuAZM4K7=QPI6/[fmG^\K_?Do;)=Og`orW'E9Q.o1(2it#'V"n0I;nROhS>s\`0o55\^;hPkg6_BQo_7TM60'D9H(GMiOA+rQmHRo^%^*lZ77W at r'+aAKX!<C`h!7$&.0UqXpAJP*7b\EKnH1/KF;HWe#i,'H?X*2f'SoV!9H67L;k=n70<qE+,I]qXWPT\K]8)9I`rr^a4]"J~>
+endstream
+endobj
+117 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 116 0 R
+>>
+endobj
+118 0 obj
+<< /Length 1842 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gatm<?Z4s_%"I`D0`'9#NG;&aMdd4a[0:FbL>+T$L,Ie[3(i2HYru;odXCu6Q>Frd''4("?:9M.O/+1eo#(+Zp,R<#Md0o+]PsFl"a4/H_[\$<Ar$c1TekLaY?/'`o%JA1VE[Zj^R+3[.38"5Me[>#9ShU(EOFkT at Aql0oCM=[<u6<^Vr31EpZfJ?I<p9erquB:UJ^XIVu)gIV\di5MN91n?/S4bo`Obt`K""+X1?'kq-Fmf=gQ7gJKFt%[WW#Ys0aKY%h$#U=MX8=!<.ob_5l:M5sp0BDoVkUH''&,c3>Np!8Q6.!C+cM29WHJ?DWKEIf7`d`,,#5rT*]34$<3;r3(9g^d%>_Lb4+(P;03FN2c3a!<0Q?$+D,R0a.h9<WpK.E;*&9#ZdRO*=hQldT%d`q;[5I5WmaD!<9hZ8Xp/+^fn+S6NV_NB+(<,)jVB&F(%46J:=iB!rdbKhdZbB,q-%Q!;Ma%(KHS,M]PO0)+DCiYUY(,_ic6El$I6^YY^U.)ZYAubnIo]g6c?%EFD00 at Y\ra'VoZ_oO:pHk#P0s^FLcf(<h\R^0oL'*AW5#keR`H*@XAlI#O+(&.fObV6HsgQ'S=ap4JLKlq5FEY4#+&Y&QRUW"s\n?t?-/.&"_G[]`WG-Z(<''RBCirm>H52UH>;XI1cl-=*_SalJ-&N"A-(THH/rcPM<aQ:JGcks%9hA.tS_"ggWC'c5USYE*A>H.UM8EM9n'9,mjCNgC(aST0U/47^!!R&/g'.?5_.;nS6sJZE1(.H<%<W]oTZC$[$>CGJ0u6&b^g6ss;#m+mb?eFd!*$KSQ-]dR!(QE1Nq(249XgoYk at JK3%h3G#YqoE%K.agM7oUo2 at ik7coLf3nfX-RU,#aa&7bJIL7Sbtf7Jed%CpL2jCK0 at W*)+ubPBW67i)<W+PNLU;^Qaf4;$')DE<UH;5W`A>6e\Nn&<FV0 at 9Cr>#;+,qlFHpiU<CF1W/7G&&H/8l4:9Lm!
 C6+k^5gJ^&!FO1LRn_D:5\`OR=p-ARX2LjG9]Wn,G>?nD^^ah_1q>Jo1!</I;;epss;4(;#GNqFKO,=K,2XQL\q\C,3K]ciS_>ge=XRH4sPHo1W)X%SDmK\h!`roMBNRbZb*RVFTG+E<'^*LPScUI][,M2Kp>9Gi)BB#'Qf:/[R-DVuIS6Z9UVs34k2$'k**XMEE8#pml7J4)jfr6PH"TQT?]"'#:/)kbpN)PEi$#,k)A!&Z@$+?.6/YL5Pbm7_ at 35Yh&DrQ"JbP.j.1de$$=%[C#kn?!i(_KLLpS&^)]DEB7_N2Kl+F`<.-":l\%OqC3io"$m8^@E#rQ]7/)<Xg-0,=fc=;tWQsNTGR9S^j`T;^rl+NLO+JVMk7W4;$M$<m"+u3S7eQ.K<%u9poUqCI[DD;hqA2,_4*p\t*P^8_/9&aH>-nQo-ds/W"eE<1F7#.,P6`eJceMIdlR*(RQU%RmGdaB)=cLkYOslCN]lqU4!G2ETm_E1Su?i,[P[n'3<9J3r)kgaB3+<)84Tf2TiLM/q!$/Wenc+&]HpXH7\@4\rUT(>rK)+Cn>Vhf"Ba>g>,rWZRZHHjpSo,AaO?<pE]rI(ueHMDHVo'81IaVYtX7X^lTK^g55-WJPZd9WS6;-_cK%m9PBmLTJN"WO9KC[lINNJ.&&4Fh6FQsnt^"!h>lL+5XsgKO!Tm=]Ebn;o8Y$V's7P9Adl(*(J8W0?EFD(r2P$B=p!i43sX",/jM9JlgrQ+o>7T at PL=!(FRajL?MpohMlY1_*gYi^f<44#l;ZPA?Mnj60K!iI+-&_Xm;r]9nV`g'=uo=>Q$I>/huXG:PA&Ibm8jq]Be15@:&b7:DhMK~>
+endstream
+endobj
+119 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 118 0 R
+>>
+endobj
+120 0 obj
+<< /Length 1681 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GauHLD/\/e&H;*)+UBK(@h'`HH<i44m>tcp>$sqOITU+pMG6/6AD*7/]QDeUhhe'q8u<;8+,0cHNoIbAT&\WOIg at Fb*utGfa>1X*`%j4aCfp1^%8<cj%hjUZ,MX2]e)_`+B#Y^r#kEpgcH8MG.1=fP9p$.-#:>.V`VK'jOio^;(#=#HgIeGE<Kh7<SnH'[#lfEWZ.0'5"A4N'HqZVqEr2u%F0+EsaL=5\]CeDh7@>OVB!+P/*Xg"8"Soe3VJp at l5ll-i3f0#kh)6]T[MfKL,aY"h_.V_E&=$,P<3Ma\$`UQ_KR:.!Z4'J[Q[!guHgC;HXaA[/>5'&6FcmQ;'NrSe/1XNc<`^;;Kij3'4FW-U120dkBVoT;TAg[KjNCh0`^s2>pfQsmqimAgau1l=&#]Xc3!)nrf+*o2eAk:-b;]Y5Y#V+`=[)j0+*4l!chhDPWu4X,B_<%">.fcjGOa at IpLet-@(CTsO(Mu\]?k2Z"t0baY%rQpm`hIgXOg at iKM!Cu7<r;O\H?6=em6Q.XY9C,QLQ$CA!%%2n1=($LoOVHEY^;M!8mUIl6XP5*ils</-/L(XtBV.hr4F^%PZiIaS$0E)-&9imq?HVe>8Z$Ye=]Fh)gOr(39(R&Oi*JmhmLU%549f6EU;7R>Zu$Ura6I!2i-\RT8N;/6`.p1S0`Ko(b9V8BI`36"4S)lG--c"X*j/GIZ!,6nT&!hcIk7Lkok0-)m&G*f=:E`e]L>l8*$TMm3oD>GW/sFOVf.>Lf,b(qJM%)7&JGUUPk1ba;6h<3^Kf#6Z+3't-aHkoOfR]/Y3JIYHk]dENBa#1.)L6;HmE0.IDb5:HI_)/d3Y6Q5,[kC2:*odc22f'AW<W4OtTBOmc')\&<4kb'ajc!@NV0NVim\Bge1ib44JZS5,^L/'uClA7Fj<#rSsf\E&*LM\[0jGqRI`@4&MkTtf3#EiO$i>P8W=N:(aPG/n:o`/[64RJr[k at ObNN]/1]Z'h!
 _i?p]K$q/?rS2-U^e*YaCSA/A]r=^G$jKd at KqL"42C]q!R[g=.sUjs+VD(-/5HYR at e]FZX3TlOA4?OiG'"[Tdk at ZFF#=SF*n.P:kD6;XeR89s%c:9CQk2.6PaB_o"PRC3a7"eoJZOjX at C;noEKo&TRbU?H7o,K3_k]\>-B7CEh/k!=X&R5Jc$<N]'c:E)U2"FY/PBMLG8Okc,n#6]m=5gB/`1U*opNe9mXm;X,M$5Ohd\V5T$jPS,'`DeGpp;c/DQJN$NT)M-M-.('+eGo_(\AT?WoYdisiYdi.Bh"aHTJ0U+9.OZ?hNMQE:+LUOm.S)^iEP;n09],kqV<DD"&cYrR#D``[X"5]`3)+k?-#]\doeN%bYJ9i-8VokJ>X"NUPm!W0aI0<)>YdP:b#U4]nB/4JCUFIM'2Gm_Yq%W.m&]#%4*BuaF^#k!#8F__.k^2_U0N,!_G#iMjkjgCdc=^B/G:4P6tkF`hd##eq%SjLJ'[P`^#Dj)G#bS+/(+"`gZpLo2`I(q^4)AZnotKhW-BJ&$mcA*8cu#)\E%NidT:Zr,K!+D3.Fe/BJuNo8KO;jmd"Na`s(TO.AGY=H+\iLm(E+=ZnVecf`[2,5$K82,/2khd0UjTmtR*Bo_JsT!P*<Zp";Cspl?GemC0iUKW:s)T`j]:_=o/pogUOW5Eh0\HsofSqA77nV>C~>
+endstream
+endobj
+121 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 120 0 R
+>>
+endobj
+122 0 obj
+<< /Length 1542 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat=,966jf&AJ$CE-.s4$52 at +HcoH1fLg!\`h(XkCJ#bUbmjr=^_?29q at Q%b%@1k$nqCuXV1*eDF2+7$4bb$OOmal'1Z)E_Yij1Op+U3KYtkpk^#diBHS0QL(ZfQohIi8]<5+m/;A(6k"m:g,0+WuE:Wj^G+)gu<a at qh+?tRU#pKH7d5&PM0)_S+?VC:rrX*pBnGu\#XX*6[AC;@'7%=9[W1/r%h*I+gj0;,qg at G,it^2LO>d"ZraI%Aju(FKWnMs?QBQ7h`0_8Li`I&'W/O4ZDekg*HX/UI..GW8/<BhQn?`M?KA#YLhqe,.#6qgu6'O>o^DLoE=_3:(lq\&PeWLZRkm=4XMad]O[#O"/:BTdR at ZRQ]!bQTu7_njOfs'2$YQ#e)NM,X\Sj:6<un[A;"Eh.(3rco-qG[4d^Ui9o+fO1KW6-MZP(<c*&+>C/lTKaC0negds]q*CkaP9`Q$2udFZN:F/Gfr;5MjhS_^VllCY&f_j8R:ifP%1$G5r5V8A%n(!#GH?pT<o*o/.=Kh, at u;\cSj0W+,@?EY(SVNq2ntjG6V#.]Ki!eRDa>JU*PX96OgO4K4o0]kLRmX4D_1W at A994T[PfCT<F0j$#+0->+g$J00Q`s4Im:JWUI%=c4pj)UouNR'$p_!u?L.h[E>VapBOI&!f at QoJeA7Zpb>)&+X#\_r^CoZ[]j\;peEQYt.kpS7$f4-!bsk\0o`d1%2um%)Z+[g`SA39TDNO`TR+UHcQsa._=0s[<&!MLu9a^6#8mjT#IB6Z$N.Iil\*>+re#YisN6Shk7)N+N$YUa/:aso?5jj+S^^I-HbtHWa<:fBEjQ5+DndGuN9>qi\8d?Ub_uqp<^,_ at Y%D0(,I@$]8M3%T!M'(crjh*tH9EuEN]PE6^8`W/tPLYkC2E?qHc\oY<-6oW94qMKf^g63-OPJ20FF@=K%koPA,=S7%%OLss?%KQOd(qk+'IVJ&it_e:A<;F@(CXIRJDI!
 `G>`1g;.15:7`?3#)9'DMY5=JJ^f94`;r]mX5&0L;t(8m[J%O-23#dsTV.XsOlkeeV[V[M[J=+qUW^6i]U0p9Z73+_EuqB4SJlYmm&!U,]_Y-i,Yc^J`;odq at I)ls5t)[#$M^!pN+40LDG'A-=3:K!j22F1u]6e'q9?tqA&'@ZIPX>S2O2,Y]YOG*HZ,=U\'Urej`RNe`eCWYm3MU2Vta8N_`9t#&mSr`q at WN"g(<>B/E.O&@K[hn40Kh'9%`p2,Qdk;IG5;Z=$On\r$klA0BIo(FhUTK0FfQ0^K/,QFJ(NtI7-p90^biYs2%;)eJT$T at 4#2[PeJL62/!A")`1*EGMhilTi=R at Nm!bj)-5!- at YbIa*4d<f1Ah/C,k/Y4%e;4gsQ=CS6aF;;`%$8asS0gQTY1j*6]6I<7[U9nh)?Iu*A at tqDs0omtC+2C+OJ1UU-$^RUKfmm-B1E??>$=&k]I?r"!XnIJ1W>6HHO)>amp;XC9TbI:hdSO:Q@[`Yp/VCfFMc"YP?Yd[=/`c$XXLCHC`sMo:[4e%P9>:IF'8mS~>
+endstream
+endobj
+123 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 122 0 R
+>>
+endobj
+124 0 obj
+<< /Length 1561 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb!Smc#]@8&AS+Gi0\%Y'a]_Xf3@)gLGuoBG#)s&K,rWW`eG2s2#Zkn+X&E[$r6CHl)!,,IVF#6qMF"1(8"WcT*sQ2/MQ^WmmV\WQq*XR030Cn[Yt%%/JQ-$,YY-P_4asjj;=.OVWF%P-0K=Hi at aZ)A?WF6h at gMCp+RYL?@p&8>91Cq=4PWsIXER>o0^LGEjNOSIX%pnJ3r9E$;lJA_Xd]7-k9GI_]?b:OjOJ,:M7TPN3ZG1/FFs:(G<JlkA0O7kY'm8)nY1W:[]jB.IsLIjRW<-I9J])CAqI6/%RJJL+$X`YT$uS37SOT^<?'T_We&kr:0[W8!=iLbc?VOL5>+#<&T"J$jA at SU"J"h>@O(e9`UVEVR9*G9,?7o23HCO=&kPj(0l&oX1HOG*MB&"-JN/1EJEm[>,Fero+LsRl at OQO=GXYmA<jc/!Ag_/(8kCA77)8tY"E#mb.P$=jo)2AED*3+>5?`;`G;,Z$4iqj&^<ct=8?U][j/3G%UJ&WD?7N',??j'"(/3q&Sb4pK^_k(0\)scWVi#]gp00`R;VT-oMBPg1sV9"(cTF;rirfJ+81(+-Qn>Kin7aZk4AdNJC'J)'[qj1pllef^=AbI(_le)!#[M'0:P;W&HgLQLs=>rFM1amTW!8GWhMOPXk1?Vc)Y#cH#e64T%[M[ge(3RSXu=9dsD=Kdl-P\r"HuCaDs.!!7U at 7d64%<`m36<WDoBpg#:<>fK<p/I%XC3Dc=>"OI&^247bb1\Lf?dOO`r2WcD'DolD'nGTTWq#b$6)"ep#'/s%-P(R1dY!%Ehb at 5U*bn9[rpJ?"4.=-0_O!=..hZOt)gHTHZWL@\N.?gYK2(MOGR.%UN?.?5!sB->_BK%d[HSAM:3S4ZA'''=q1AX`)C<u;Z(/BU$nXGWf]g<htEbDBB^A73<LegSB`&.KGUfagW5?3-reU4?g8l*qaZNu7NRa at MD#KS/\(^j^2/[#>s.D at DH#Ig:5I#,$!
 Y[/tOiW$9cCb7.*-I-=@;dieaE2?tMSk1'$%"?GL6*1LRV8%'Z0$E6\jpdX^/O#C9tj!o>.dAB1d^XW`&iHbpO$fhfu$9UDB?U#/Ke9hZ2SY)ko>Lkcma8!R9D=f;T.A$oQQf*7?f&jT%-YiAR-.?s6[Bb at nM3f%$6(F,B>)cs)dgra<-K%OT@!-L/k+[UP?c17<Z4RaR/lpZ`#`)cEs&37,iMMReDLO+%kA0m0PXWC<2$!Es/M/MAp(-rY0),3c4lXnn?:bAYn;Y-?3E!`"*@=Cmc-_u;4He#"p&_LY=cQb*8=TB,(Qg"p+JKnP`25Aho]2i8G'VQ#&-IaCRLQqardJhdg<)'?F3BXG@#XenLMID;%bWPa_"oX=tboVpNO#-YJpjG40*p2SaIU_9WT7$cInAKq at hb\l+i\&U85-ZfHfC/3cQ0.RFr:4Rtp%-?)=Md68-[`p<8Rh];0;V5pjgGc5m$3eh'F[1fmfXmsXi6")&La]'D_[u2jR3keDBtqeE?pcXq-W0""\Z/fI?$@!lS:&A]3U1+"]!C at 972]ZpE)f20:Z-;IfLi%mp5~>
+endstream
+endobj
+125 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 124 0 R
+>>
+endobj
+126 0 obj
+<< /Length 901 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb!#Z9lldX&A at sBkSSL^'a]Gb]k+(/BkMa2__(:eYUs?sY](kM3<-_P_e>$`Sb1FR_-4/Ap-%dJga/.;pG!j5p/&&_GUT$mjI&5a#d#2o#fSTOOr\k]H'nUCRV,l#d3"VN1m*I`Tm^$"$rbJEYFd()4CqcuC<7"`<ETXaUVpdf5%OhXKus=`+/\6[oP3QY:\JH%(Xm:c>]@ufOV5YJq]23f\roAt$lUr>HHWE6Wnjs]H*kbS4W=FQ0UX4g.PDsp0%I!S?eYh/[uid2]H]W`*0Qo_5*bAmCG+.=Hi)[1dQ"<1R16fRD&;W!cKG8mK_h_(mILCZ]I(WD35'_bjHdbKqgYdKHSTkaB:tq<6m3$X at ZB@*!(i2/PPO8l!M1Pprs33>'@ur?\c<5\J2NG?*P:+/UFWfh?jNT':l(n:WH6W:#^dTq*u])V#THS$U.XHZ&8u3NGd^8+B7omqR"/]H9Un-\XC$)`\FhU!a)RRc$q!\b4_l=94q?SdO_)gFR\#BCVL=*)`fauFY\#B9,K at IAN@5*@aq;^HMbJ&kh9LbmYoAqYJ=V.:QA[UbE'U.gPP-Q34XUfl^f6!l-jlnDQ)Xjj[r,7Bn^=f"Q;t at 6)+p`:[F3X7jhso)(6K[66VESr2Xk(?Uu,&M80;-#QO'%>@0tYjn!Jst]E#_RYGUs[rH_Y*C>!FP`Jk+Sa538mg;;YE?kk>lmuU^k;-8`oIN8S0m$CT:!&:m?^n>fWb$jU9P!adLkf)/d.%kp4l3`L1QoH#8O!;(u0"hNLQ!!9gBTKZUn!8`S+tHc!:eTb"g.PW1lg\R@%-23,36ZB7(5cVr>B4=>&H_-Rb'ls-R*:M!<<"el'.EIg/5_O4]?$<oQ#H)4+iF;uCq`F)L#Z[ojeA>8q?r*WQ:_~>
+endstream
+endobj
+127 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 126 0 R
+>>
+endobj
+128 0 obj
+<< /Length 907 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatU2hf$st&:X(TiQ"t#cTgFmT%LE,+ct=^]MO8Jla at C>dO!2Wq!2o4Vfiu^l\>8a]A.hlq<ksVkOIX"M?:Y&(fCpK-4$\#(a/dp5S/`:&4S?]!lS=4I<r.iG"S&Vn<sU`UC]ipQjPg[j,G$>hUR+1N\(-/-KW,RquH6l>lY*HBduj7;e+68Jq--<U5n!Do&dbFko`&t&(`nkm4OT,RB+L,Q?&8?RBhiIOtSUo3[(Pu[)Simma=ci*Z]0YZHcI]FXiPc=h%jlkf!J&<3l;dPZ;LfHk#h`d)/+F;!rM%)['^`1"2)>I7"kb]#1/D*<7W5$-2jt6Jgm42V%L<*&H%R?&?D.N$ii*1:38'Tn%`7^fh+3%S@%.PFK[>m"F at h5N%uikg1X^#<LQPa]T!t6DU;6OZrWJX2qV2Us7>C_n8'NF]YR(cUt3\:j2X$BnpKE3R^\WH1sb=h"MTE0bke,*2W4k91!ZT0qZ2[EqAu#p at e(;[nh<H!G^6JIQi,UUhmQt']&qgH)f:<9E-o^)DRt5kO,eKFPCO=]A(=Kc*eIq5LD"I;B%WFDEW+g+,Sg=Bs+PJWq1p:MqiW#)uW,Je/hM)b+`3\k.:4[hcnG3C-Jsr;hb0We7r&HmfKmW<&4*/ZA;W2>uE$(B#rLA]-(cLPGhW$-Cdd0BTLB&K^97[:pN^9[<0^Ci;.!.BW,;1-cqb?rmL9M)4qOUkY:.0AB[RId84'7J/:eCRCB/6<(N>g4\N_GPTrS&$&]D4s%$79#mNOhY7VD#OR/=A1Rd%![D,s-e(d7GB8[s8bmasaE/spV7n^=;K_qFFEGd'-AKTC"M(-*DUk79;*7_4TG4dAR1?p^k3D-0eaaBeF#8f*lZ="M5V;pt_MF$NelRS\8[s&&C5Oo)gPlC^a"_3Y~>
+endstream
+endobj
+129 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 128 0 R
+>>
+endobj
+130 0 obj
+<< /Length 1408 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat=lhf%7-&BE],=6Qmi2GH=5e75em6\i,&3^4$$MEnFX=/]rGP1jIFl[-'NPG1gL1'C,Lj$(NDn]SP>n!8mh?LnFjC^cAjRmds,(G&2JLIE-@,Z5tKQ-dp!(O^]$B"uW`DPBqSnk\=W`"KFBC.K`b1S&^-0/q:^+HL+fi$LM`F["76Nu0**j2>SNr#)_3Ccl/N(2dru7uWG*1%6g&gYbOd`Mr*\Z\QO.o#)%*RC)[gC'Kb*$T,gd#fr67TZq'K"pP'(`+6<P1i^B8LYmg6-&%;cl)c&Ml="qaKAatq4VnmT#Pk+]JQr"Gq5sH4,T'XXbkFF#KN\15cdm0G+jsm,"d]f^Fc!!jOZS at B&S3NAjS>,b+LM;6Ad8SS64F55,e.pTD-iMo!1X^PXG]"2&kl5_HdnWP-<89LM%,4Ms#m/eY#UFiVR'T?L\=s>*Y),u2<.<?:t'<T\0?NbO^cBGYR*(:4%rtF_#hD43(-oO^3Fdc5_(j#?,e4T%B54"mjmbJ:pL,JQ^ciXS[E_s37-G(W_H at Q_\Nmk:RG7'dG_9\iGfSg,H(Z42_uXaOH,6s_t0%Z,hT50#JUa;bDaGEhck$]1b>Mh6XVCCgW,Pc7\_4?p/3kF]diEABh&GHM.)[Hm5\9qU.WlGWd4Z!Qbb4[#d<<P5akl'Y8WSt=I1Z6<&#XAXZbn%4ubVFZc:lrT+@`tl>+9#&T!+9)4b2,qOJ:RNUc#(WcqV3c#;(r=/TI9Pm>[frBII+^L'a1/9GgEbqV$3WH*#j4hu%BqSMtb]H3)[>/Q#0B;Pq^5jP2fee84(80,`9LY at L/o/Hud"A<>\RQ4'jf#?Tnk9k8B0^!0I>qhnkEDYrW*6#4(7E9Lp\HH7hd$NJ$K$0!Ma'>7]hmdIL=VjP1i(uS^0'0)Pi)hP'^UPB&d>8S+cFI1kqt5pC\?X,1g\3Aihqe8n!s at ql6rqc^=r'd@*W</\+VO$cfm5e[qG9-1V8>PTL:3!
 [/ges>fo,%q&C%A>85cbn8RCfA&p&40KdmGm1TmaA="*%C#TpJ3oJ>8T[FO*r`g-"=rVcDp<T:iOlgHqpjo25khA9&g-)>i-^G7+,$Z;-/CD>J8Q^7m/u.#[f!X?$R/Sn5Xem>PWG+lsh@]=qY2%2qqD.8?Qm8_Rr,Ju8'\jjBj6H?AI61'+#c[Q?!MQEghHPO&Ei&d"]5?)CLA-2K7- at 4$u[*pR4lY-J];@lAR9!Sp_Cd(Tl=E^eI>p&/n-AT@)th#$#EdRR.D4\R+%7XD[k^d at gAk[QrdN/_ at lEH8-)qlT%9^=b%Tl-Hs:&-(uY2tWEaOV[9\l$cY"%`=KAFAC(OO%4Rrk9Tq>\bLLIWq>qBdK1N7Vf-7q,Q:d-d:VqCibn#6 at Bnmhfd.?&\rUo/I/^hp^b5Bq!_fhE~>
+endstream
+endobj
+131 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 130 0 R
+/Annots 132 0 R
+>>
+endobj
+132 0 obj
+[
+]
+endobj
+133 0 obj
+<< /Length 545 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat=h>>)jf'S,*</+VmhZWs!^Fl5OBKRs^Yd]M2'k[dCcSH%HU9m^'<<TukD38^'D:/A/dU\Re38h`Qq-6d+B;+1=LO^`c6;22&:Bn`.]g-b2s(Mf$a>N=FTAWHZR)7j8I"285TL7V7g5N3"JM-i2Im=9lTO<iC&+K7-*hEa%+Z:YASemrq0LGt6WDdf-c>;L,XC1M";1Y+I-Qdp at qC^XH<K*i3O'X+raAmI<3B8p[b71&RAK+9M\LX/)<M6e>@6r1>JV[O4J&sPbXW$_V_+OG4JMNA`MPHtF_58l(X-=Cq%ZTSDDR\A1L/-SO7`d6PSs)H+ji7O8gk(]H-,f&o^[E_aU?@G3&99,sdioBrcir8+dS2&5)4nIo>FFW#"Rh:Xf\jX03St$@c'*+E*"9ea9>=>39USuD/$5>58KX!?33)uX@>,<k!V^&PuS(3"Ok'A<LmOX+i`f^p?s"9/_1ch.Ekk!%K.$hRNM>nq%b8RaE*hl*WpIGZ3;s>P(ft4;+Et%nSJbb?fm]UXq-6.r%Mt(-G%Ub31Zi~>
+endstream
+endobj
+134 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 133 0 R
+/Annots 135 0 R
+>>
+endobj
+135 0 obj
+[
+]
+endobj
+138 0 obj
+<<
+ /Title (\376\377\0\123\0\161\0\165\0\151\0\162\0\162\0\145\0\154\0\40\0\123\0\164\0\141\0\156\0\144\0\141\0\162\0\144\0\40\0\114\0\151\0\142\0\162\0\141\0\162\0\171\0\40\0\62\0\56\0\62)
+ /Parent 136 0 R
+ /Next 140 0 R
+ /A 137 0 R
+>> endobj
+140 0 obj
+<<
+ /Title (\376\377\0\124\0\141\0\142\0\154\0\145\0\40\0\157\0\146\0\40\0\103\0\157\0\156\0\164\0\145\0\156\0\164\0\163)
+ /Parent 136 0 R
+ /Prev 138 0 R
+ /Next 141 0 R
+ /A 139 0 R
+>> endobj
+141 0 obj
+<<
+ /Title (\376\377\0\103\0\150\0\141\0\160\0\164\0\145\0\162\0\240\0\61\0\56\0\240\0\111\0\156\0\164\0\162\0\157\0\144\0\165\0\143\0\164\0\151\0\157\0\156)
+ /Parent 136 0 R
+ /Prev 140 0 R
+ /Next 142 0 R
+ /A 15 0 R
+>> endobj
+142 0 obj
+<<
+ /Title (\376\377\0\103\0\150\0\141\0\160\0\164\0\145\0\162\0\240\0\62\0\56\0\240\0\124\0\150\0\145\0\40\0\111\0\156\0\160\0\165\0\164\0\57\0\117\0\165\0\164\0\160\0\165\0\164\0\40\0\154\0\151\0\142\0\162\0\141\0\162\0\171)
+ /Parent 136 0 R
+ /First 143 0 R
+ /Last 146 0 R
+ /Prev 141 0 R
+ /Next 150 0 R
+ /Count -7
+ /A 17 0 R
+>> endobj
+143 0 obj
+<<
+ /Title (\376\377\0\123\0\161\0\165\0\151\0\162\0\162\0\145\0\154\0\40\0\101\0\120\0\111)
+ /Parent 142 0 R
+ /First 144 0 R
+ /Last 145 0 R
+ /Next 146 0 R
+ /Count -2
+ /A 19 0 R
+>> endobj
+144 0 obj
+<<
+ /Title (\376\377\0\107\0\154\0\157\0\142\0\141\0\154\0\40\0\163\0\171\0\155\0\142\0\157\0\154\0\163)
+ /Parent 143 0 R
+ /Next 145 0 R
+ /A 21 0 R
+>> endobj
+145 0 obj
+<<
+ /Title (\376\377\0\106\0\151\0\154\0\145\0\40\0\143\0\154\0\141\0\163\0\163)
+ /Parent 143 0 R
+ /Prev 144 0 R
+ /A 23 0 R
+>> endobj
+146 0 obj
+<<
+ /Title (\376\377\0\103\0\40\0\101\0\120\0\111)
+ /Parent 142 0 R
+ /First 147 0 R
+ /Last 149 0 R
+ /Prev 143 0 R
+ /Count -3
+ /A 25 0 R
+>> endobj
+147 0 obj
+<<
+ /Title (\376\377\0\111\0\156\0\151\0\164\0\151\0\141\0\154\0\151\0\172\0\141\0\164\0\151\0\157\0\156)
+ /Parent 146 0 R
+ /Next 148 0 R
+ /A 27 0 R
+>> endobj
+148 0 obj
+<<
+ /Title (\376\377\0\106\0\151\0\154\0\145\0\40\0\157\0\142\0\152\0\145\0\143\0\164)
+ /Parent 146 0 R
+ /Prev 147 0 R
+ /Next 149 0 R
+ /A 29 0 R
+>> endobj
+149 0 obj
+<<
+ /Title (\376\377\0\123\0\143\0\162\0\151\0\160\0\164\0\40\0\154\0\157\0\141\0\144\0\151\0\156\0\147\0\40\0\141\0\156\0\144\0\40\0\163\0\145\0\162\0\151\0\141\0\154\0\151\0\172\0\141\0\164\0\151\0\157\0\156)
+ /Parent 146 0 R
+ /Prev 148 0 R
+ /A 31 0 R
+>> endobj
+150 0 obj
+<<
+ /Title (\376\377\0\103\0\150\0\141\0\160\0\164\0\145\0\162\0\240\0\63\0\56\0\240\0\124\0\150\0\145\0\40\0\102\0\154\0\157\0\142\0\40\0\154\0\151\0\142\0\162\0\141\0\162\0\171)
+ /Parent 136 0 R
+ /First 151 0 R
+ /Last 154 0 R
+ /Prev 142 0 R
+ /Next 157 0 R
+ /Count -6
+ /A 33 0 R
+>> endobj
+151 0 obj
+<<
+ /Title (\376\377\0\123\0\161\0\165\0\151\0\162\0\162\0\145\0\154\0\40\0\101\0\120\0\111)
+ /Parent 150 0 R
+ /First 152 0 R
+ /Last 153 0 R
+ /Next 154 0 R
+ /Count -2
+ /A 35 0 R
+>> endobj
+152 0 obj
+<<
+ /Title (\376\377\0\107\0\154\0\157\0\142\0\141\0\154\0\40\0\163\0\171\0\155\0\142\0\157\0\154\0\163)
+ /Parent 151 0 R
+ /Next 153 0 R
+ /A 37 0 R
+>> endobj
+153 0 obj
+<<
+ /Title (\376\377\0\124\0\150\0\145\0\40\0\142\0\154\0\157\0\142\0\40\0\143\0\154\0\141\0\163\0\163)
+ /Parent 151 0 R
+ /Prev 152 0 R
+ /A 39 0 R
+>> endobj
+154 0 obj
+<<
+ /Title (\376\377\0\103\0\40\0\101\0\120\0\111)
+ /Parent 150 0 R
+ /First 155 0 R
+ /Last 156 0 R
+ /Prev 151 0 R
+ /Count -2
+ /A 41 0 R
+>> endobj
+155 0 obj
+<<
+ /Title (\376\377\0\111\0\156\0\151\0\164\0\151\0\141\0\154\0\151\0\172\0\141\0\164\0\151\0\157\0\156)
+ /Parent 154 0 R
+ /Next 156 0 R
+ /A 43 0 R
+>> endobj
+156 0 obj
+<<
+ /Title (\376\377\0\102\0\154\0\157\0\142\0\40\0\157\0\142\0\152\0\145\0\143\0\164)
+ /Parent 154 0 R
+ /Prev 155 0 R
+ /A 45 0 R
+>> endobj
+157 0 obj
+<<
+ /Title (\376\377\0\103\0\150\0\141\0\160\0\164\0\145\0\162\0\240\0\64\0\56\0\240\0\124\0\150\0\145\0\40\0\115\0\141\0\164\0\150\0\40\0\154\0\151\0\142\0\162\0\141\0\162\0\171)
+ /Parent 136 0 R
+ /First 158 0 R
+ /Last 160 0 R
+ /Prev 150 0 R
+ /Next 162 0 R
+ /Count -4
+ /A 47 0 R
+>> endobj
+158 0 obj
+<<
+ /Title (\376\377\0\123\0\161\0\165\0\151\0\162\0\162\0\145\0\154\0\40\0\101\0\120\0\111)
+ /Parent 157 0 R
+ /First 159 0 R
+ /Last 159 0 R
+ /Next 160 0 R
+ /Count -1
+ /A 49 0 R
+>> endobj
+159 0 obj
+<<
+ /Title (\376\377\0\107\0\154\0\157\0\142\0\141\0\154\0\40\0\163\0\171\0\155\0\142\0\157\0\154\0\163)
+ /Parent 158 0 R
+ /A 51 0 R
+>> endobj
+160 0 obj
+<<
+ /Title (\376\377\0\103\0\40\0\101\0\120\0\111)
+ /Parent 157 0 R
+ /First 161 0 R
+ /Last 161 0 R
+ /Prev 158 0 R
+ /Count -1
+ /A 53 0 R
+>> endobj
+161 0 obj
+<<
+ /Title (\376\377\0\111\0\156\0\151\0\164\0\151\0\141\0\154\0\151\0\172\0\141\0\164\0\151\0\157\0\156)
+ /Parent 160 0 R
+ /A 55 0 R
+>> endobj
+162 0 obj
+<<
+ /Title (\376\377\0\103\0\150\0\141\0\160\0\164\0\145\0\162\0\240\0\65\0\56\0\240\0\124\0\150\0\145\0\40\0\123\0\171\0\163\0\164\0\145\0\155\0\40\0\154\0\151\0\142\0\162\0\141\0\162\0\171)
+ /Parent 136 0 R
+ /First 163 0 R
+ /Last 165 0 R
+ /Prev 157 0 R
+ /Next 167 0 R
+ /Count -4
+ /A 57 0 R
+>> endobj
+163 0 obj
+<<
+ /Title (\376\377\0\123\0\161\0\165\0\151\0\162\0\162\0\145\0\154\0\40\0\101\0\120\0\111)
+ /Parent 162 0 R
+ /First 164 0 R
+ /Last 164 0 R
+ /Next 165 0 R
+ /Count -1
+ /A 59 0 R
+>> endobj
+164 0 obj
+<<
+ /Title (\376\377\0\107\0\154\0\157\0\142\0\141\0\154\0\40\0\163\0\171\0\155\0\142\0\157\0\154\0\163)
+ /Parent 163 0 R
+ /A 61 0 R
+>> endobj
+165 0 obj
+<<
+ /Title (\376\377\0\103\0\40\0\101\0\120\0\111)
+ /Parent 162 0 R
+ /First 166 0 R
+ /Last 166 0 R
+ /Prev 163 0 R
+ /Count -1
+ /A 63 0 R
+>> endobj
+166 0 obj
+<<
+ /Title (\376\377\0\111\0\156\0\151\0\164\0\151\0\141\0\154\0\151\0\172\0\141\0\164\0\151\0\157\0\156)
+ /Parent 165 0 R
+ /A 65 0 R
+>> endobj
+167 0 obj
+<<
+ /Title (\376\377\0\103\0\150\0\141\0\160\0\164\0\145\0\162\0\240\0\66\0\56\0\240\0\124\0\150\0\145\0\40\0\123\0\164\0\162\0\151\0\156\0\147\0\40\0\154\0\151\0\142\0\162\0\141\0\162\0\171)
+ /Parent 136 0 R
+ /First 168 0 R
+ /Last 171 0 R
+ /Prev 162 0 R
+ /Next 174 0 R
+ /Count -6
+ /A 67 0 R
+>> endobj
+168 0 obj
+<<
+ /Title (\376\377\0\123\0\161\0\165\0\151\0\162\0\162\0\145\0\154\0\40\0\101\0\120\0\111)
+ /Parent 167 0 R
+ /First 169 0 R
+ /Last 170 0 R
+ /Next 171 0 R
+ /Count -2
+ /A 69 0 R
+>> endobj
+169 0 obj
+<<
+ /Title (\376\377\0\107\0\154\0\157\0\142\0\141\0\154\0\40\0\163\0\171\0\155\0\142\0\157\0\154\0\163)
+ /Parent 168 0 R
+ /Next 170 0 R
+ /A 71 0 R
+>> endobj
+170 0 obj
+<<
+ /Title (\376\377\0\122\0\145\0\147\0\145\0\170\0\160\0\40\0\143\0\154\0\141\0\163\0\163)
+ /Parent 168 0 R
+ /Prev 169 0 R
+ /A 73 0 R
+>> endobj
+171 0 obj
+<<
+ /Title (\376\377\0\103\0\40\0\101\0\120\0\111)
+ /Parent 167 0 R
+ /First 172 0 R
+ /Last 173 0 R
+ /Prev 168 0 R
+ /Count -2
+ /A 75 0 R
+>> endobj
+172 0 obj
+<<
+ /Title (\376\377\0\111\0\156\0\151\0\164\0\151\0\141\0\154\0\151\0\172\0\141\0\164\0\151\0\157\0\156)
+ /Parent 171 0 R
+ /Next 173 0 R
+ /A 77 0 R
+>> endobj
+173 0 obj
+<<
+ /Title (\376\377\0\122\0\145\0\147\0\165\0\154\0\141\0\162\0\40\0\105\0\170\0\160\0\145\0\163\0\163\0\151\0\157\0\156\0\163)
+ /Parent 171 0 R
+ /Prev 172 0 R
+ /A 79 0 R
+>> endobj
+174 0 obj
+<<
+ /Title (\376\377\0\103\0\150\0\141\0\160\0\164\0\145\0\162\0\240\0\67\0\56\0\240\0\124\0\150\0\145\0\40\0\101\0\165\0\170\0\40\0\154\0\151\0\142\0\162\0\141\0\162\0\171)
+ /Parent 136 0 R
+ /First 175 0 R
+ /Last 175 0 R
+ /Prev 167 0 R
+ /Next 177 0 R
+ /Count -2
+ /A 81 0 R
+>> endobj
+175 0 obj
+<<
+ /Title (\376\377\0\103\0\40\0\101\0\120\0\111)
+ /Parent 174 0 R
+ /First 176 0 R
+ /Last 176 0 R
+ /Count -1
+ /A 83 0 R
+>> endobj
+176 0 obj
+<<
+ /Title (\376\377\0\105\0\162\0\162\0\157\0\162\0\40\0\150\0\141\0\156\0\144\0\154\0\151\0\156\0\147)
+ /Parent 175 0 R
+ /A 85 0 R
+>> endobj
+177 0 obj
+<<
+ /Title (\376\377\0\111\0\156\0\144\0\145\0\170)
+ /Parent 136 0 R
+ /Prev 174 0 R
+ /A 87 0 R
+>> endobj
+178 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F11
+/BaseFont /Courier-Bold
+/Encoding /WinAnsiEncoding >>
+endobj
+179 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F1
+/BaseFont /Helvetica
+/Encoding /WinAnsiEncoding >>
+endobj
+180 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F10
+/BaseFont /Courier-Oblique
+/Encoding /WinAnsiEncoding >>
+endobj
+181 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F5
+/BaseFont /Times-Roman
+/Encoding /WinAnsiEncoding >>
+endobj
+182 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F3
+/BaseFont /Helvetica-Bold
+/Encoding /WinAnsiEncoding >>
+endobj
+183 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F9
+/BaseFont /Courier
+/Encoding /WinAnsiEncoding >>
+endobj
+184 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F6
+/BaseFont /Times-Italic
+/Encoding /WinAnsiEncoding >>
+endobj
+185 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F7
+/BaseFont /Times-Bold
+/Encoding /WinAnsiEncoding >>
+endobj
+1 0 obj
+<< /Type /Pages
+/Count 27
+/Kids [6 0 R 8 0 R 10 0 R 12 0 R 89 0 R 91 0 R 93 0 R 95 0 R 97 0 R 99 0 R 101 0 R 103 0 R 105 0 R 107 0 R 109 0 R 111 0 R 113 0 R 115 0 R 117 0 R 119 0 R 121 0 R 123 0 R 125 0 R 127 0 R 129 0 R 131 0 R 134 0 R ] >>
+endobj
+2 0 obj
+<< /Type /Catalog
+/Pages 1 0 R
+ /Outlines 136 0 R
+ /PageMode /UseOutlines
+ >>
+endobj
+3 0 obj
+<< 
+/Font << /F1 179 0 R /F11 178 0 R /F10 180 0 R /F5 181 0 R /F3 182 0 R /F9 183 0 R /F6 184 0 R /F7 185 0 R >> 
+/ProcSet [ /PDF /ImageC /Text ] >> 
+endobj
+15 0 obj
+<<
+/S /GoTo
+/D [89 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+17 0 obj
+<<
+/S /GoTo
+/D [91 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+19 0 obj
+<<
+/S /GoTo
+/D [91 0 R /XYZ 115.0 666.009 null]
+>>
+endobj
+21 0 obj
+<<
+/S /GoTo
+/D [91 0 R /XYZ 115.0 632.684 null]
+>>
+endobj
+23 0 obj
+<<
+/S /GoTo
+/D [91 0 R /XYZ 115.0 233.665 null]
+>>
+endobj
+25 0 obj
+<<
+/S /GoTo
+/D [93 0 R /XYZ 115.0 127.26 null]
+>>
+endobj
+27 0 obj
+<<
+/S /GoTo
+/D [95 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+29 0 obj
+<<
+/S /GoTo
+/D [95 0 R /XYZ 115.0 514.701 null]
+>>
+endobj
+31 0 obj
+<<
+/S /GoTo
+/D [97 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+33 0 obj
+<<
+/S /GoTo
+/D [101 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+35 0 obj
+<<
+/S /GoTo
+/D [101 0 R /XYZ 115.0 655.009 null]
+>>
+endobj
+37 0 obj
+<<
+/S /GoTo
+/D [101 0 R /XYZ 115.0 621.684 null]
+>>
+endobj
+39 0 obj
+<<
+/S /GoTo
+/D [101 0 R /XYZ 115.0 347.085 null]
+>>
+endobj
+41 0 obj
+<<
+/S /GoTo
+/D [103 0 R /XYZ 115.0 177.98 null]
+>>
+endobj
+43 0 obj
+<<
+/S /GoTo
+/D [103 0 R /XYZ 115.0 144.655 null]
+>>
+endobj
+45 0 obj
+<<
+/S /GoTo
+/D [105 0 R /XYZ 115.0 570.14 null]
+>>
+endobj
+47 0 obj
+<<
+/S /GoTo
+/D [109 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+49 0 obj
+<<
+/S /GoTo
+/D [109 0 R /XYZ 115.0 655.009 null]
+>>
+endobj
+51 0 obj
+<<
+/S /GoTo
+/D [109 0 R /XYZ 115.0 621.684 null]
+>>
+endobj
+53 0 obj
+<<
+/S /GoTo
+/D [111 0 R /XYZ 115.0 415.7 null]
+>>
+endobj
+55 0 obj
+<<
+/S /GoTo
+/D [111 0 R /XYZ 115.0 382.375 null]
+>>
+endobj
+57 0 obj
+<<
+/S /GoTo
+/D [113 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+59 0 obj
+<<
+/S /GoTo
+/D [113 0 R /XYZ 115.0 655.009 null]
+>>
+endobj
+61 0 obj
+<<
+/S /GoTo
+/D [113 0 R /XYZ 115.0 621.684 null]
+>>
+endobj
+63 0 obj
+<<
+/S /GoTo
+/D [113 0 R /XYZ 115.0 145.225 null]
+>>
+endobj
+65 0 obj
+<<
+/S /GoTo
+/D [113 0 R /XYZ 115.0 111.9 null]
+>>
+endobj
+67 0 obj
+<<
+/S /GoTo
+/D [117 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+69 0 obj
+<<
+/S /GoTo
+/D [117 0 R /XYZ 115.0 666.009 null]
+>>
+endobj
+71 0 obj
+<<
+/S /GoTo
+/D [117 0 R /XYZ 115.0 632.684 null]
+>>
+endobj
+73 0 obj
+<<
+/S /GoTo
+/D [119 0 R /XYZ 115.0 209.54 null]
+>>
+endobj
+75 0 obj
+<<
+/S /GoTo
+/D [121 0 R /XYZ 115.0 281.78 null]
+>>
+endobj
+77 0 obj
+<<
+/S /GoTo
+/D [121 0 R /XYZ 115.0 248.455 null]
+>>
+endobj
+79 0 obj
+<<
+/S /GoTo
+/D [123 0 R /XYZ 115.0 662.0 null]
+>>
+endobj
+81 0 obj
+<<
+/S /GoTo
+/D [129 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+83 0 obj
+<<
+/S /GoTo
+/D [129 0 R /XYZ 115.0 666.009 null]
+>>
+endobj
+85 0 obj
+<<
+/S /GoTo
+/D [129 0 R /XYZ 115.0 632.684 null]
+>>
+endobj
+87 0 obj
+<<
+/S /GoTo
+/D [131 0 R /XYZ 67.0 725.0 null]
+>>
+endobj
+136 0 obj
+<<
+ /First 138 0 R
+ /Last 177 0 R
+>> endobj
+137 0 obj
+<<
+/S /GoTo
+/D [10 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+139 0 obj
+<<
+/S /GoTo
+/D [12 0 R /XYZ 115.0 715.0 null]
+>>
+endobj
+xref
+0 186
+0000000000 65535 f 
+0000052341 00000 n 
+0000052598 00000 n 
+0000052691 00000 n 
+0000000015 00000 n 
+0000000071 00000 n 
+0000000364 00000 n 
+0000000470 00000 n 
+0000001595 00000 n 
+0000001701 00000 n 
+0000001862 00000 n 
+0000001969 00000 n 
+0000003305 00000 n 
+0000003428 00000 n 
+0000003707 00000 n 
+0000052857 00000 n 
+0000003843 00000 n 
+0000052922 00000 n 
+0000003979 00000 n 
+0000052987 00000 n 
+0000004115 00000 n 
+0000053054 00000 n 
+0000004251 00000 n 
+0000053121 00000 n 
+0000004386 00000 n 
+0000053188 00000 n 
+0000004522 00000 n 
+0000053254 00000 n 
+0000004658 00000 n 
+0000053319 00000 n 
+0000004793 00000 n 
+0000053386 00000 n 
+0000004929 00000 n 
+0000053451 00000 n 
+0000005065 00000 n 
+0000053517 00000 n 
+0000005201 00000 n 
+0000053585 00000 n 
+0000005337 00000 n 
+0000053653 00000 n 
+0000005473 00000 n 
+0000053721 00000 n 
+0000005609 00000 n 
+0000053788 00000 n 
+0000005745 00000 n 
+0000053856 00000 n 
+0000005881 00000 n 
+0000053923 00000 n 
+0000006017 00000 n 
+0000053989 00000 n 
+0000006153 00000 n 
+0000054057 00000 n 
+0000006289 00000 n 
+0000054125 00000 n 
+0000006425 00000 n 
+0000054191 00000 n 
+0000006561 00000 n 
+0000054259 00000 n 
+0000006697 00000 n 
+0000054325 00000 n 
+0000006833 00000 n 
+0000054393 00000 n 
+0000006969 00000 n 
+0000054461 00000 n 
+0000007105 00000 n 
+0000054529 00000 n 
+0000007241 00000 n 
+0000054595 00000 n 
+0000007377 00000 n 
+0000054661 00000 n 
+0000007513 00000 n 
+0000054729 00000 n 
+0000007649 00000 n 
+0000054797 00000 n 
+0000007785 00000 n 
+0000054864 00000 n 
+0000007921 00000 n 
+0000054931 00000 n 
+0000008057 00000 n 
+0000054999 00000 n 
+0000008193 00000 n 
+0000055065 00000 n 
+0000008329 00000 n 
+0000055131 00000 n 
+0000008465 00000 n 
+0000055199 00000 n 
+0000008600 00000 n 
+0000055267 00000 n 
+0000008736 00000 n 
+0000009799 00000 n 
+0000009907 00000 n 
+0000012083 00000 n 
+0000012191 00000 n 
+0000013984 00000 n 
+0000014092 00000 n 
+0000015540 00000 n 
+0000015648 00000 n 
+0000017804 00000 n 
+0000017912 00000 n 
+0000018731 00000 n 
+0000018839 00000 n 
+0000020378 00000 n 
+0000020488 00000 n 
+0000022334 00000 n 
+0000022444 00000 n 
+0000023761 00000 n 
+0000023871 00000 n 
+0000024416 00000 n 
+0000024526 00000 n 
+0000025770 00000 n 
+0000025880 00000 n 
+0000027217 00000 n 
+0000027327 00000 n 
+0000029052 00000 n 
+0000029162 00000 n 
+0000029841 00000 n 
+0000029951 00000 n 
+0000031641 00000 n 
+0000031751 00000 n 
+0000033687 00000 n 
+0000033797 00000 n 
+0000035572 00000 n 
+0000035682 00000 n 
+0000037318 00000 n 
+0000037428 00000 n 
+0000039083 00000 n 
+0000039193 00000 n 
+0000040187 00000 n 
+0000040297 00000 n 
+0000041297 00000 n 
+0000041407 00000 n 
+0000042909 00000 n 
+0000043035 00000 n 
+0000043056 00000 n 
+0000043694 00000 n 
+0000043820 00000 n 
+0000055332 00000 n 
+0000055386 00000 n 
+0000043841 00000 n 
+0000055452 00000 n 
+0000044095 00000 n 
+0000044296 00000 n 
+0000044532 00000 n 
+0000044879 00000 n 
+0000045077 00000 n 
+0000045245 00000 n 
+0000045389 00000 n 
+0000045545 00000 n 
+0000045714 00000 n 
+0000045879 00000 n 
+0000046153 00000 n 
+0000046453 00000 n 
+0000046651 00000 n 
+0000046819 00000 n 
+0000046986 00000 n 
+0000047142 00000 n 
+0000047311 00000 n 
+0000047461 00000 n 
+0000047761 00000 n 
+0000047959 00000 n 
+0000048112 00000 n 
+0000048268 00000 n 
+0000048422 00000 n 
+0000048734 00000 n 
+0000048932 00000 n 
+0000049085 00000 n 
+0000049241 00000 n 
+0000049395 00000 n 
+0000049707 00000 n 
+0000049905 00000 n 
+0000050073 00000 n 
+0000050229 00000 n 
+0000050385 00000 n 
+0000050554 00000 n 
+0000050746 00000 n 
+0000051040 00000 n 
+0000051181 00000 n 
+0000051334 00000 n 
+0000051449 00000 n 
+0000051562 00000 n 
+0000051671 00000 n 
+0000051787 00000 n 
+0000051898 00000 n 
+0000052012 00000 n 
+0000052119 00000 n 
+0000052231 00000 n 
+trailer
+<<
+/Size 186
+/Root 2 0 R
+/Info 4 0 R
+>>
+startxref
+55518
+%%EOF

Added: trunk/windstille/lib/SQUIRREL2/doc/squirrel2.chm
===================================================================
(Binary files differ)


Property changes on: trunk/windstille/lib/SQUIRREL2/doc/squirrel2.chm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/windstille/lib/SQUIRREL2/doc/squirrel2.pdf
===================================================================
--- trunk/windstille/lib/SQUIRREL2/doc/squirrel2.pdf	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/doc/squirrel2.pdf	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,6364 @@
+%PDF-1.3
+%????
+4 0 obj
+<< /Type /Info
+/Producer (FOP 0.20.5) >>
+endobj
+5 0 obj
+<< /Length 242 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gaqco]*cD?&4QKpMCE&o3;_QsMHU9D\t)sA0PV_"go0+KHisl,*LLp9/;hPIK/+9qL3ODc"L/XD-R"&PP9?to9cdO^b_(UoJR,^t4fXaV*l1s(hf6dZA.$iuD"u).S!&PO>r7V:qqXVEI0U=0mG7sAWmV*Z%c at b(d,nP\Eb_Xje&sj6s,!HiU at qn5CB!ftO"(S1<h_MW*9Cj\rNnb-\mKfNPm4NS?`N\@Fk-J5M^Vn\L.AT~>
+endstream
+endobj
+6 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 5 0 R
+>>
+endobj
+7 0 obj
+<< /Length 1101 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasao997OU&AIm?jMiD2RQR$5]:;tE&kIg["UEuD-Bm$=fYr#;qX8FT%N]gm=B2@`POZjUY:mFlc(;QtP&*nUaf:o.a_$hbWVpC"QDZ!&WcUPt4A/^\o(D"kYF[0Hr,HbB<u"jjY-[15-[?teKGG8X)C"QQ.XK6U,2F<)Al>.F,?^hiL9A(0p,uQlZ!ba#)fSra1!o5t8X>VHqM_UD)*.I at LPH[!TO[X137Ha3alUK(>^lM'JC&*CiOXV(K>UD[I$))C($*\?"Q>nNVR*ga'%>7.,"-c1G=TV1>8-FSbKDG-H(#LMp2:OBs%dR3dpfUVjY\KFb/I\(LC:QA92\`c/[]E>JL\IHfOCc>Si+l&h'8r'R!s.6FU)Ne[R=4d`=\$tH`',!cD?C"G<=+08/@\h_Aik_^(sf`1((;l@:EK3A(b[nA8,sjWsI3919`Wr&96ie1MGK%Mj(4]g0IG!`4R;EfGD+"*L]V9dnFS0U/eK,P#&n#]gdTiYn]VYa$u8,/4E0s,F8(s3i9q\?09%IkK9>S6UtCNSANOI459+uJE^\fWdh7l54KURNN_VSY<gh6C*tlD,'9RAIH)j?<42)Z6Iq*9jCMueX/<mKVD#4GF1H8)nNMgjF%8O6oU.&hQJBKs)TC9n6pah>_(>lLa%OpeIf0@`A:`>s)M(q0/e?@FfL<-olFU#6VNI]$.7Rj9gTQ/m/4Df8Ua7K;OPGT^fKglR9QI&qH>S6Z,SJ\\N+iFt1Vb\E:W%g[llY;ik*1!*(,]`p*0`:1/am99`[/n9e`M"$`j6b(>aUA:QV0`c\6sb*cl7[nULiA\Y72BZr9C!K:E^5gRSDt5n%Q,A>.hJ?BOop0GOH:lW"61Xbico%Ea]bUJ__p(!oBTjd1Q'HArVF'Hr3-bbsS==c+fd9'E%j9X,*NbfrH#Wnm<.\lo6`oiU?-K#_#1=<;jb\.43?ShF=>[c at q)F`:;gnT+82^BRce;L!cDA)5?!
 PKZ[>p$!uViP\uY3i^DJS?7un0O;F)])3'2s\QKW&[iYS&]pZ]t,DKWm3gH4QjE]*aU5$ctllT?D'1;>oKp7rgFB-1`pX&Hq%3 at W8,r;iP<\.J~>
+endstream
+endobj
+8 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 7 0 R
+>>
+endobj
+9 0 obj
+<< /Length 71 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Garg^iGoCd.c`?]8EV`b1=.gR0K1`91K?+0ZOMGdU/Zh'Y!=Te%#&:?HH*JE!<E/X&V'~>
+endstream
+endobj
+10 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 9 0 R
+>>
+endobj
+11 0 obj
+<< /Length 1810 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb"/lc#]C5(rl%A=)dGlK*hD4CSj8IC#!]tBr9-%4Z#;5<aISui+aG*rqAij=gTenh2WMsmUKUQaFL,)qaeAG,b<7o0.rV\!f)N]r+b at tb8IS?qNk:bF^3,a,:DKB28?Eq4IO531LXLc1^KVm,MY=/Y')F)(3qA"Eb/I)=nA9O=*k^&laPA^DVn'b.e%`IOFT0k-'!;.Vohdfo26?^.OigjY=k;HX&=(-o61`O"PQA!F+n/"7/,2d"eGKd6[e+KU:\M+Hs+E]<Ph+Alir#+TIJ>ZEp.qndD\<B43;b"ma<B+3iQ8IZ6&R9;JV7^a)21h"F<7#n3a#X`9S,rE`%<EV,sXXos`C!Majm2#R(!M at c6fP%"8fS083Xr#sb-cUd6<r,1\3ZRp.&rZI"4*l31[!*!?>&+UTAM7%q7/dba*rb2SW+[6XLX*.U<3(_$_!5`E'Y>1UTB9Z=T`0d-Q!*>&bHK^X(FnZo[8Bj;LQgkU@\"?HP:`'<RY?M&Kl`W,fpX$i.,cqh^XU:^1T0&uB">i4g.)&p8;+OG,W6P82InB>iF?KS(dl6HA]J"0%35TnET(C].R(t:6"?=ZK0ek`O4M.op2"9M;OL;ef_p;OM;9_5*_4sH)B"G&h!dLb"a4T8Mqb5][6jt&e at d/R)\*Z<8Fo:f']_D*YDJNs`\M:\pWU#E\$(V=b2`i_-("I]Z,91WGM2:&(WfC]dcP;FBnk]%6p)kPB6.c9ZJK=Mp4kjW:g*B_g8RDg[n#A<g$!J*LsOq8E->=(6&cno*pELs,I#BSiE#D"3q_dQ:La66;CDjHRPkD9l&5J^<f!<RhD9FguL3?X%uo\E-\7C*V[EHLdpd)"283k0p\F+,]0XO`>=FU8=qUbo"d/2GG>Iu*l`]hK[J0!9jAH(l+ at nc5Em&8:^7e\s'rb`]0t6rIma(,qqfcgSBm$cON?ILt]^UZ"Bu at -/dJ10"fS^&%ndq&n%XddW at 6Vrl.I\.m!
 ]2UBhaLjrb4KHF-P6Y^`&!)?.VHX at Q<.J3cjo+OK-oK^W_iWQkW(:<U5iMD*f9m[,;X`blV!1^t?50l!'U?Pg\`p(=p3<uM2C9gUh6Ic2E(Xmi*%VZ(gjIMW,J8tqf][bZDGE"1]5;NKqg]P>a&Kei]33[bo4!ZDq'6Rg/Mk-dkk at LkF0kU:/+@"a9XE1Mk[S!&o0!.g0$>3-n*aq8SK]pZgYr5!$`qQq\TLa7migq"Y]d9?hWN>b#FleR5m2dX"LaaF`a.HAaL&+7iM)glD'HnpZ_JI[n;KI\uDDl$^R8E)D8[aiDJ\jd7pTP0B%0Z1P(?;#-9 at t$+TX[+)VR!R/0Fuq"tc33r8XhU\U$oK0SOjbB5E"+=haK$7a3Us>>(Bcck)O:aD),<;6G:UXI[?K-J[7b4MU_Q1gVi*cF:.!jnIA`&hS_6MZ!!G>Xg='gBL'R.J<fCUm]''YP5CB^&D:e_lLUf*>a0)_B^@hA%I4pLJD^u+cKX'JT0!@4CbmsKm9KDrJ&Ej+m<<1UR!++!6]pl`3kL*q,1oF[L!6=8R5gL at Er?ou(DOB)m+qr/0e8^@o-UFCmV,e<,GG?J.YfnCrOXili(cl at BkU:/+?;SO?G:$n6[N?FP'6n.TTP"_^TRVjBNUD4Tli#qmX+N[1B94,s2Mf5 at m:)Qi5\"[$(`U*T+;!bO7<E3Fe_Xnl[_t,N-;nZH^(SZ\JNsmGi@#67LSA%u&o=<_)b#?D';d\1gTBUFc"DOP>\c>u8\7%-3H70>CNaKV_Rc372ERPg^X;3Slb0Ke%H^QD&BePn%iX+l5Bm/!+&YAoQ2~>
+endstream
+endobj
+12 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 11 0 R
+/Annots 13 0 R
+>>
+endobj
+13 0 obj
+[
+14 0 R
+16 0 R
+18 0 R
+20 0 R
+22 0 R
+24 0 R
+26 0 R
+28 0 R
+30 0 R
+32 0 R
+34 0 R
+36 0 R
+38 0 R
+40 0 R
+42 0 R
+44 0 R
+46 0 R
+48 0 R
+50 0 R
+52 0 R
+54 0 R
+56 0 R
+58 0 R
+60 0 R
+62 0 R
+64 0 R
+66 0 R
+68 0 R
+70 0 R
+72 0 R
+74 0 R
+76 0 R
+78 0 R
+80 0 R
+82 0 R
+84 0 R
+86 0 R
+88 0 R
+90 0 R
+92 0 R
+94 0 R
+96 0 R
+98 0 R
+100 0 R
+102 0 R
+104 0 R
+106 0 R
+108 0 R
+110 0 R
+112 0 R
+114 0 R
+116 0 R
+118 0 R
+]
+endobj
+14 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 120.0 655.001 179.44 645.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 15 0 R
+/H /I
+>>
+endobj
+16 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 120.0 644.001 184.15 634.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 17 0 R
+/H /I
+>>
+endobj
+18 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 633.001 211.48 623.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 19 0 R
+/H /I
+>>
+endobj
+20 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 622.001 209.1 612.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 21 0 R
+/H /I
+>>
+endobj
+22 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 611.001 209.1 601.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 23 0 R
+/H /I
+>>
+endobj
+24 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 600.001 207.43 590.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 25 0 R
+/H /I
+>>
+endobj
+26 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 589.001 219.38 579.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 27 0 R
+/H /I
+>>
+endobj
+28 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 578.001 198.55 568.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 29 0 R
+/H /I
+>>
+endobj
+30 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 567.001 211.34 557.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 31 0 R
+/H /I
+>>
+endobj
+32 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 556.001 233.7 546.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 33 0 R
+/H /I
+>>
+endobj
+34 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 545.001 196.32 535.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 35 0 R
+/H /I
+>>
+endobj
+36 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 534.001 188.56 524.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 37 0 R
+/H /I
+>>
+endobj
+38 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 523.001 192.45 513.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 39 0 R
+/H /I
+>>
+endobj
+40 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 512.001 185.78 502.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 41 0 R
+/H /I
+>>
+endobj
+42 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 501.001 187.45 491.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 43 0 R
+/H /I
+>>
+endobj
+44 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 490.001 190.77 480.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 45 0 R
+/H /I
+>>
+endobj
+46 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 479.001 191.32 469.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 47 0 R
+/H /I
+>>
+endobj
+48 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 468.001 203.56 458.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 49 0 R
+/H /I
+>>
+endobj
+50 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 457.001 189.67 447.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 51 0 R
+/H /I
+>>
+endobj
+52 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 446.001 224.94 436.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 53 0 R
+/H /I
+>>
+endobj
+54 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 435.001 207.98 425.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 55 0 R
+/H /I
+>>
+endobj
+56 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 424.001 203.54 414.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 57 0 R
+/H /I
+>>
+endobj
+58 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 413.001 196.32 403.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 59 0 R
+/H /I
+>>
+endobj
+60 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 402.001 238.24 392.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 61 0 R
+/H /I
+>>
+endobj
+62 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 391.001 218.72 381.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 63 0 R
+/H /I
+>>
+endobj
+64 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 380.001 206.32 370.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 65 0 R
+/H /I
+>>
+endobj
+66 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 369.001 187.89 359.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 67 0 R
+/H /I
+>>
+endobj
+68 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 358.001 191.89 348.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 69 0 R
+/H /I
+>>
+endobj
+70 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 347.001 268.01 337.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 71 0 R
+/H /I
+>>
+endobj
+72 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 336.001 193.0 326.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 73 0 R
+/H /I
+>>
+endobj
+74 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 325.001 190.21 315.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 75 0 R
+/H /I
+>>
+endobj
+76 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 314.001 202.44 304.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 77 0 R
+/H /I
+>>
+endobj
+78 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 303.001 191.88 293.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 79 0 R
+/H /I
+>>
+endobj
+80 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 292.001 188.0 282.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 81 0 R
+/H /I
+>>
+endobj
+82 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 281.001 276.3 271.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 83 0 R
+/H /I
+>>
+endobj
+84 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 270.001 250.49 260.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 85 0 R
+/H /I
+>>
+endobj
+86 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 259.001 236.6 249.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 87 0 R
+/H /I
+>>
+endobj
+88 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 248.001 202.99 238.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 89 0 R
+/H /I
+>>
+endobj
+90 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 237.001 191.33 227.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 91 0 R
+/H /I
+>>
+endobj
+92 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 226.001 189.11 216.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 93 0 R
+/H /I
+>>
+endobj
+94 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 215.001 190.22 205.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 95 0 R
+/H /I
+>>
+endobj
+96 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 204.001 251.6 194.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 97 0 R
+/H /I
+>>
+endobj
+98 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 193.001 192.33 183.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 99 0 R
+/H /I
+>>
+endobj
+100 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 182.001 290.1 172.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 101 0 R
+/H /I
+>>
+endobj
+102 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 171.001 207.43 161.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 103 0 R
+/H /I
+>>
+endobj
+104 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 160.001 238.26 150.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 105 0 R
+/H /I
+>>
+endobj
+106 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 149.001 201.32 139.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 107 0 R
+/H /I
+>>
+endobj
+108 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 138.001 189.66 128.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 109 0 R
+/H /I
+>>
+endobj
+110 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 127.001 238.81 117.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 111 0 R
+/H /I
+>>
+endobj
+112 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 116.001 170.66 106.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 113 0 R
+/H /I
+>>
+endobj
+114 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 105.001 219.67 95.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 115 0 R
+/H /I
+>>
+endobj
+116 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 94.001 218.83 84.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 117 0 R
+/H /I
+>>
+endobj
+118 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 83.001 218.84 73.001 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 119 0 R
+/H /I
+>>
+endobj
+120 0 obj
+<< /Length 2006 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb"/l>Ar7S!/9>//+b[J&+r>Q\ihZK>'*#\X`Lb&@5)AO:4u2<8kW<n?U%gj3g$1D0NbbZ$P]4IbE7[P_qQ>[[@I3j`jLW9Yc[#!Am;`#@bK:=@M-V[6D$4Fi`jUMqX`659(Bshgj8A_ at J/3P7>7lR!eEUD7o&(sY=L at Vrj%j)4EV[6ls/^J.AJ*/ARdj*HgD[VJO%\ZK8/@h<Oiq"cO?Z?PNM^D6n)3M.qC7mp;;DGVaVj$X#^ZEjVRGDX_W.G6$OO!7&Z<V at h25DqR;g`<?gHkhJ,K#6et'm,V#.KOG,;<EoY%U2hj9do[s0ETQ?ok?Ye9F23ee at s)(#>Q1/oGg6rA`S060HW0]=YQ8J2VP$[])eWNrW.b1unoo\1bNr]<57O6fSHdpkCqE!`mD-JOF8&&mP#]sf<dXH/f^=g^@$li2hoHsZjcCIGS9'@G+-?<=0))Z77Qh\UM%M7h:WRidBeuu1XBCFoP:e at G8H/6,WNd^49&Eqm0mLICq%<^+b]dS+PMRtug.rFb-[giIj%LLi2*1CpNS[<\nUo8U[\Z5>H#j0>rTF7Y0p[E9$loK(]l\3`=s$>\)/2PZ`]es="%QXh;co5ZY34.q]_#Z,s&I&M_"uKch9P<=U<4 at h&"$iN9:p8nu=N=AGi8/&>WMm/UI")T[b_n)@K2FQ=k^,_Lp1,0a;-Vm+_4*`-MObDG+OF1m$lrZTiY!8*qmbHdJ5tqULLD2<#W*8WW9C\;@-d=9++jNp"oU`'KG%R8NVR7`K0UeM^#GSK`NrC]h0p-=\D?O=685):!aReYmQlWa,=$Pb"M.u%BFrE"!V:FPDm^>Q%P00H&0qMaHK$'blZ&;m'7$Y5`^-PaXYN-ad$H`udlG:1'`W!u]\*T$m19im]P,4iW"'NE at Zbh/^aQ'.6(g$1&Pm at f3,upt\Fp#`?%P>.:;(QSD]HQKCQ*(qlhXLg0>d"85F!SrJNsn@%U0/c='8\p#Y`t\VK)!
 >Q&86C(5soCG?R-/'loP1KJ\Ko*!lnu"jDgU=#N;?G!<Sf0N>R5MPFJUNB%7%n9aMBp124ZY4<qjK4Pl!D;dYMY=?rO#V%H at .7P6L>mcX8K:ujAtTSoTX\"H1pZT`;SNgKtU"PO`K2f'Io&_W,k>`'l%7580V!hCd"=9A$:oc0T^Uq-9aG7=V)-K>`IOj>TLD5#Yml7gfr!hC4BC^!RI`%@2H9ZOR\JI)_rk]CN,pAs)Spmm7X/Q at .dMo1lITZPSI4ZDJ_YJZ9"AWdh4'04t;:qJ/fZo]=`?to]F3XP(?s6N.n[M&=V;"8CkYBd,o^O=>WH.m'n)5:1C!_lJ)Y&3MY^#<O+B`5s<L==D=nh**%PCPp]8\ITcS[7P0+*"6>o$N/Wk=sK4NoRfo?%2fQ-;'-+%X&.>d3-em;.g(!=\c0f at QT.GTmN*+8$2`K97GWch,orI&3Xh at BI^S>3[XSu-;bhBqJ)PZ!Wmqe_cU^q[PJj%?'E&d_:`=ef1E6tYIKJXP!VQ*WS6Cm*":DL/r![J(^Y=[m7+'[C#)1fI&L6'h4,7gdGG.Z:4bql+6YuD4.-ch:Qp8=NjDTQ;ZHknKR.2?7oY;J,A51]@0jI&;14riN^F&&5i[=A9V2to8)AP"ko;"3Z2!)p`stlGJL3].MK[)b7;#jPpLW'N^eTsj-m6n$dn#[nl%IcG;AMi91u$"KLtj#;ES>Tc0t.>grQg at LQ<.i:lfc"8Fe7D:l/(&1f=6f>Eo.iSlsce=#W,s.d6,gmZtl6S<.)FfX=h>4PT\=e:p9k;=T,[g[p:N#$_rPrM#VeR#7sl=JYkr.k$<=1o:ZYc/bqFBAtVi;`XAX<U[dKq;)EmhF3k(gY:_T/Y!Ao15&Q(3H"#3tHhsc"r\[J^+]L8N6rBG*5i8A+g1g(h3VtY>XkR!j!7PRkiEE<k]-8Q&c0VpmeT*%kq?s6+I5#mhNU88:rSiI^#UO"l[$9Hh=k;=T%,HM:I!
 K,4L5]'\i]6(m#TDtS!kWb'qVNh~>
+endstream
+endobj
+121 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 120 0 R
+/Annots 122 0 R
+>>
+endobj
+122 0 obj
+[
+123 0 R
+125 0 R
+127 0 R
+129 0 R
+131 0 R
+133 0 R
+135 0 R
+137 0 R
+139 0 R
+141 0 R
+143 0 R
+145 0 R
+147 0 R
+149 0 R
+151 0 R
+153 0 R
+155 0 R
+157 0 R
+159 0 R
+161 0 R
+163 0 R
+165 0 R
+167 0 R
+169 0 R
+171 0 R
+173 0 R
+175 0 R
+177 0 R
+179 0 R
+181 0 R
+183 0 R
+185 0 R
+187 0 R
+189 0 R
+191 0 R
+193 0 R
+195 0 R
+197 0 R
+199 0 R
+201 0 R
+203 0 R
+205 0 R
+207 0 R
+209 0 R
+211 0 R
+213 0 R
+215 0 R
+217 0 R
+219 0 R
+221 0 R
+223 0 R
+225 0 R
+227 0 R
+229 0 R
+231 0 R
+233 0 R
+235 0 R
+237 0 R
+]
+endobj
+123 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 719.0 171.21 709.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 124 0 R
+/H /I
+>>
+endobj
+125 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 708.0 183.45 698.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 126 0 R
+/H /I
+>>
+endobj
+127 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 697.0 250.49 687.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 128 0 R
+/H /I
+>>
+endobj
+129 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 686.0 224.39 676.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 130 0 R
+/H /I
+>>
+endobj
+131 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 675.0 318.27 665.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 132 0 R
+/H /I
+>>
+endobj
+133 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 664.0 224.37 654.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 134 0 R
+/H /I
+>>
+endobj
+135 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 653.0 223.82 643.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 136 0 R
+/H /I
+>>
+endobj
+137 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 642.0 174.0 632.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 138 0 R
+/H /I
+>>
+endobj
+139 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 631.0 236.6 621.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 140 0 R
+/H /I
+>>
+endobj
+141 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 620.0 228.83 610.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 142 0 R
+/H /I
+>>
+endobj
+143 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 609.0 212.98 599.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 144 0 R
+/H /I
+>>
+endobj
+145 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 598.0 222.44 588.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 146 0 R
+/H /I
+>>
+endobj
+147 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 587.0 187.87 577.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 148 0 R
+/H /I
+>>
+endobj
+149 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 576.0 251.78 566.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 150 0 R
+/H /I
+>>
+endobj
+151 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 565.0 207.45 555.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 152 0 R
+/H /I
+>>
+endobj
+153 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 554.0 223.55 544.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 154 0 R
+/H /I
+>>
+endobj
+155 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 543.0 254.94 533.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 156 0 R
+/H /I
+>>
+endobj
+157 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 532.0 176.21 522.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 158 0 R
+/H /I
+>>
+endobj
+159 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 521.0 223.27 511.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 160 0 R
+/H /I
+>>
+endobj
+161 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 510.0 214.24 500.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 162 0 R
+/H /I
+>>
+endobj
+163 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 499.0 187.88 489.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 164 0 R
+/H /I
+>>
+endobj
+165 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 488.0 198.44 478.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 166 0 R
+/H /I
+>>
+endobj
+167 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 477.0 184.11 467.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 168 0 R
+/H /I
+>>
+endobj
+169 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 466.0 185.22 456.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 170 0 R
+/H /I
+>>
+endobj
+171 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 455.0 204.11 445.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 172 0 R
+/H /I
+>>
+endobj
+173 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 444.0 199.67 434.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 174 0 R
+/H /I
+>>
+endobj
+175 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 433.0 187.44 423.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 176 0 R
+/H /I
+>>
+endobj
+177 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 422.0 186.89 412.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 178 0 R
+/H /I
+>>
+endobj
+179 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 411.0 188.56 401.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 180 0 R
+/H /I
+>>
+endobj
+181 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 400.0 185.78 390.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 182 0 R
+/H /I
+>>
+endobj
+183 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 389.0 203.56 379.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 184 0 R
+/H /I
+>>
+endobj
+185 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 378.0 190.78 368.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 186 0 R
+/H /I
+>>
+endobj
+187 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 367.0 198.55 357.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 188 0 R
+/H /I
+>>
+endobj
+189 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 356.0 190.22 346.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 190 0 R
+/H /I
+>>
+endobj
+191 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 345.0 187.44 335.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 192 0 R
+/H /I
+>>
+endobj
+193 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 334.0 199.66 324.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 194 0 R
+/H /I
+>>
+endobj
+195 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 323.0 193.0 313.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 196 0 R
+/H /I
+>>
+endobj
+197 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 312.0 203.56 302.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 198 0 R
+/H /I
+>>
+endobj
+199 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 301.0 208.55 291.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 200 0 R
+/H /I
+>>
+endobj
+201 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 290.0 222.43 280.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 202 0 R
+/H /I
+>>
+endobj
+203 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 279.0 214.84 269.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 204 0 R
+/H /I
+>>
+endobj
+205 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 268.0 231.06 258.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 206 0 R
+/H /I
+>>
+endobj
+207 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 257.0 237.7 247.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 208 0 R
+/H /I
+>>
+endobj
+209 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 120.0 246.0 210.83 236.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 210 0 R
+/H /I
+>>
+endobj
+211 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 235.0 232.04 225.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 212 0 R
+/H /I
+>>
+endobj
+213 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 224.0 177.88 214.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 214 0 R
+/H /I
+>>
+endobj
+215 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 213.0 271.76 203.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 216 0 R
+/H /I
+>>
+endobj
+217 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 202.0 215.93 192.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 218 0 R
+/H /I
+>>
+endobj
+219 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 191.0 222.61 181.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 220 0 R
+/H /I
+>>
+endobj
+221 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 180.0 184.27 170.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 222 0 R
+/H /I
+>>
+endobj
+223 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 169.0 223.27 159.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 224 0 R
+/H /I
+>>
+endobj
+225 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 168.0 158.0 245.5 148.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 226 0 R
+/H /I
+>>
+endobj
+227 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 147.0 237.88 137.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 228 0 R
+/H /I
+>>
+endobj
+229 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 136.0 218.45 126.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 230 0 R
+/H /I
+>>
+endobj
+231 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 125.0 216.22 115.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 232 0 R
+/H /I
+>>
+endobj
+233 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 114.0 222.04 104.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 234 0 R
+/H /I
+>>
+endobj
+235 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 103.0 269.81 93.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 236 0 R
+/H /I
+>>
+endobj
+237 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 92.0 250.64 82.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 238 0 R
+/H /I
+>>
+endobj
+239 0 obj
+<< /Length 791 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb"/j9lHLT(ru)m$6R/o%);=Q>e3YPUo7LUHC8qqLm*'.O?01ApZVo.?n3Hb[$o()8%JQa)!!('s7_.k(amV`NuVTco22f4I'duLnuE9jR'EYI`5KP:9%N4l-s9+X]ck$04OS8L[\\F04f+NWo`3!`]'35)rrNH3kWF\Y.N`ZqU2MIUFKBp5GNtfX]G)hsq9hgJ14[5ZCUoO1k,I->[SRgT^#(9 at AS-607(0El06FJ-NjTnjb2BnXPH$nt)>`NC/bJ[H&B'$A)8)<BSb8%>nl"b,8/pTeGj%,;J:Ltk!pnPC83J4(j3 at gqk8p&]TlJPa!-M?GM'*AVKi@:e6%<ba7%LC6.:)@pPoWUg\l*h@,nrj:`rQ;GoT*7-LRefX($gk%Uok2:"Rbc0J:LDj8V$^:KE[p=gm0/_iH at 6#ogW[nWZnWjSL>F>&0N*gkDB5WFsZ7 at poe>fAQg#FVcl"<2a&@WS&VICAc"&sL?"uF"9LVCC8JuJV+6opj$f:$f2ss'Uk+&H?5FW at -k-!4#h,Og^j=)7(:i/cZ8N;&3#jsr+J;B'K8:be?c9Z-4rZ_P1+hWh4igZ=,r5/*Pqe9nd,=s*>n4:%NI&Re at oGI4,CUQe(.Yjpp,t at .6O*btFP50d3pr>WFKuZYfsQ?,qZ?uns3e^e at a\Hga9,?K36C at SQOA^1&.m3V;JTo^C%I+u\_k0if(`ChYf@>kfWRh=ZuE`=j.u:[q?3$a"&6>chf#h4O1>.bd/0uFaIE%G^*s38q4F/XX`m,dim_In#s9VWW^!MF\01~>
+endstream
+endobj
+240 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 239 0 R
+/Annots 241 0 R
+>>
+endobj
+241 0 obj
+[
+242 0 R
+244 0 R
+246 0 R
+248 0 R
+250 0 R
+252 0 R
+254 0 R
+256 0 R
+258 0 R
+260 0 R
+262 0 R
+264 0 R
+266 0 R
+268 0 R
+]
+endobj
+242 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 719.0 214.54 709.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 243 0 R
+/H /I
+>>
+endobj
+244 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 708.0 398.68 698.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 245 0 R
+/H /I
+>>
+endobj
+246 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 697.0 208.69 687.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 247 0 R
+/H /I
+>>
+endobj
+248 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 120.0 686.0 189.14 676.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 249 0 R
+/H /I
+>>
+endobj
+250 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 675.0 209.82 665.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 251 0 R
+/H /I
+>>
+endobj
+252 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 664.0 181.78 654.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 253 0 R
+/H /I
+>>
+endobj
+254 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 653.0 212.6 643.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 255 0 R
+/H /I
+>>
+endobj
+256 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 642.0 259.81 632.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 257 0 R
+/H /I
+>>
+endobj
+258 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 631.0 164.56 621.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 259 0 R
+/H /I
+>>
+endobj
+260 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 620.0 229.83 610.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 261 0 R
+/H /I
+>>
+endobj
+262 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 609.0 233.15 599.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 263 0 R
+/H /I
+>>
+endobj
+264 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 598.0 226.77 588.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 265 0 R
+/H /I
+>>
+endobj
+266 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 144.0 587.0 208.14 577.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 267 0 R
+/H /I
+>>
+endobj
+268 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 120.0 576.0 142.77 566.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 269 0 R
+/H /I
+>>
+endobj
+270 0 obj
+<< /Length 726 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GarnUa_oie&A at B[G]]$LeRgDR-:i[\&erluk^f$h'G2r)76,M*^=3orJdV[t]]Y^AbjZ&`9CL%sN2"8:o,*aP(Eh^k-nrCIAW\(-1b\b`a\^+,YJX:s3t:Hb*MY1WM``CcF9qgsr[,"8oh]?P`?"f7b4"JO'++i*c()"M&#57Xe&2d'@SZspI at s151\p$<r:`I'CL_.gPdD2\\85W!#7>6mJ`H'sV)ou[_OOOjS5:cXJ-e>?WeR)X!OZLG[.YAT(=^G::sIotd8u3KH?5I>Ot?dh%H/#U+m9^-EM05Z%u[1'd at m8Fh_J/IZ#3uCo^qV%P='?J;I-ce)2n?Df"0]5)L>%)_!J!KLHRfW(iU&`$>$QefQE-RGgs[WPL6jF<e<@(rg*H(F=W.:eo/edM/J2!8ot"hf$]*6/]Q?uc%AI-Vub[5CH$e:TYS[Teiff).PRcc-1nT$QiGug!!=tc^`c2kchk'hWG35-K:(5gG<uRk;;T at JPDDRf$)sf336qK@'SIpA83o,3IOSmfi(jO4]X99?)C;VaO+kH'QJD+0=mAph/&oHme>N^%mOWKr;'gKXg!o>VGLG7J/l_'91H4EF)E-L!L9$Vt=\I5XRD#jj9*0F-ouns[1p?IQ%ZYW,Ao6#rI-i^pKK\!ap\,G&Z3GfXn[\;KkGNDO1.srTF3.qt`_q=*mt^X>mN'P^(uOsiRuW-RnE.8`?f]S*p^\5kD&i~>
+endstream
+endobj
+271 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 270 0 R
+>>
+endobj
+272 0 obj
+<< /Length 1525 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasap>Ar7S'Roe[:]iOGPF.J#?*cNC3\8'!5V^JY9='59.%@//\J,e!?+/WS8tsNS7 at jn#S-sVfiQ&iseGK(&qArkDLS>&Yo5%l?bDB`^l>s&R7CEq!0abS?R]iiKo,h%E,H5p#:#.KkEFd+ at Fmc!<5$u^O+X_Y?Oeo?I>4Z*#6Jlg"'j at I";E8W3#QbMs at GL"6Y?4rJnS?JHL'VM#+u?N at e$VeO,h8?(0JoV;,1qL5#A02^0$1HI#u?,9XpLFG.DI$K[n=#7VS^kQ+njk]>>2;WCeq8+2u:`2P4'Rclqf!oU.SrB-j\sgaGjNHZ8(p^=?i]um4;aHPXiR`,9(og5;I6D.Mo7Gd%Il5QH>E>#S?UPMCb^Cak2ak&L>c;d[CLcT7&aV8lk"uZ)+G)/9W-s#7 at ZcMdFWo)p9Y5%OA6YC60@,'>t*GPV&<)J\edS<'u-tJ$>j at j2ZAbf`(YD0d14J/.B`F7SH?ENE/q`1<H,<WGA:[A!/>ZCeY3hTp&$G_,(J>d8/Eg[oTNRB':%Q,A9(X#K;`4.&p^3A-K073\cNaAnY>6d4-GF"0K%.g'6<.)^`@jUeibA<&@=DD(3X`ASDYO0MI=^n\,!#)-:+g'+k!c.uKN at T\h8JI/.)^QJ^_ZPO(Y"Vc1&Uc], at 5,U!=;P(K)):^[K/`Ce6s!dKZl'5AB(Yn%jm2aFXO94dA49Ebdi-I;j_If3^OkGQAD:9&[:i[E3!Z&N!/nQ3<V(*Yn:10tM9`sFdr#=u4WT(++WXUVgr7Y'Ht-`M?Ba:1VJPjpuNI":2i_Kd<FGH32(D&(]_Rlq&I#RCl[SnC;jW"/U(!dV5Vo/ESn$T_97/*P8M=n_K>;lCM4%UROa%GN.OA!=Dd65%L9Bh#+-o=MHlFK+!#2S$iW(pMU1B\k8+.RG1Pm=7(CB1[APJlGlo- at MF2X&Q./<73()24+)a1ugjCMrqGfabaN3>[B:#YU`]G:UPob&QE&>*#M!
 :j^GXA^##2[7"M#/aG!'[GegeWKXA&%?[&$23FLu!BgctJ7d0ulWlkn!rrW]imJWYkj8KNCN57t.o^uS[K!d_n99hC@'Wp"Cp1SV?\]??Z*PG9KGj1s/QpgNeK-cM:Ho'SJWpgB;=!W(#sIRUmj.XOt0md5di;Alnf'KJomlN_P9&r#an134Z^"egAPKDU*n;+\%Rm-DKcjp:&`?1R#,iWcR-rheAQ2TD4hZWjhHgTG\uo$Z-&"97V"?b[WVB6Se&DRAk;FW'Vj\HM#!%`1qkD`[An"5ideG6*(-ZgeqfJE/:!s)nt>no at RUF9'-BT7L+B5lPQ3$jT&f!f$^_jLYGm\$lI(n*Z50XV4/0LT^&LeQ_o81#MM#ZPB)]5MjD?mirW=K.(4g?5F.mio>IPW(ks#s1=jB[m]ctO<9#N#\4)!)^mWPDO!$9p^Y at m5lUcD.%7E!@Z9tU(fM]TLeghCBg2@@rX(T?Kq<pEFdpsfXX$37D"@JarHpS$rP.@>EFZV3lT[>Oa/JmIG"q]1!$GpHm/~>
+endstream
+endobj
+273 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 272 0 R
+>>
+endobj
+274 0 obj
+<< /Length 1670 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0D95iQE&AI=/#e_WXCPJ(PLDO'cBt"+@//D at +fLt$&/^q.)4WI$g@\>r7.>cI]*SGHL=nk=4jNN!-S0>rL1qU9.o.3?;[:ZHIC99.V7FdH%bc/F/3eR[f/@E2t5!88mU6*K^20$9TnPVc;gf>^$EE:2h/-*b7ks?0I#=)<]/ugm8"1$1:fIIPE-!S6^XC]dg&m)@M8P-(dn(-j+EbF+<"0OTjn:PHDMTbnahQ-%HHas$'fWFu26Bi*Z7d!k51jn0GV([%:PhrE:O4-C(kL/nHTu4]@)L1[0&cTsn$.%ShJq(55a(`&YnJJaW^_K=$BA=mJ\2u@)a%9*f8B<SX+G%!GiIs6(E\boA9=u.#!'GUPDl63Y:YRB"L1O at 5;t%^4,%V:Ebd`'3I/8)P^lp;bb2)\S:dY$)V8PBg<1Ds.8PP3I\TXA.Ot'5d9EKnCEl;&65-X4]E!522nY7gNFMOXii)<67cR at R5gH-AVqV1Hmr^J9an*a]a'8ADnZ-A9;P<1L%*SYJlh$!1%QB2AP8qVHM6)Y\l6;"+R;usbpL/%$dMaLMH7[X'"<buLM[(g#,]`KNno'dN:N2+rlY^-,:Xl=YD!5mMQ7Q>1krM/uU\CQ`7$,niIY/LJ%KK.M63]jm`-pt.9m;nkr195beUH...F/Os"9QRhJmkCRhZnA+S!<@*Gj%@%YQ"hP&R5D9ej.q+([$l-'(D>t9m#J*_-?l:km1PeiEhme]jQf,\_F<8tFXY2$6UZL8.3>HZP5X<q\LQA2YUJ8)-*)&'96JXW-';baV%,H1N$].YDGZr:j\&0Q3]#A1E*BW1!r&9Y<Ji?&Q04-!.b$e&73p!ZQg0=n]km$W^Rs>D9N=Lu+ue,Oo#p(3V;.<&?^?Ns2g'c>\cE+Pk,JLBnjhLmF]c!_Knq578S`:1-V=<mKNf[Z4]7K;8LYa*15dD#q.`G^?upHa;6jE7caj<:q$`J`Pptlt-DAP#=Et/nGF\!
 >?1n8PD*05 at CUALgnl^LfR%n#=u#_9*JVSsrhb'd<I(R2,bOaJ`L.YfhJp906uR!h0skG3qG$]2H?%^P;+%h4BYl9/-?=^Qr(3 at Ni[<<*(PJQ`nc9;#R=eT\oM=Z at mm+WIfDA-#ArirhM>$Y5pDkE]e$&*#RL5Xh%9&=#MGSTiZL\,005Vnq%$*VuHYEc]Z^Wb<1EVSrD<HHr"S?mMP43`]JEFg7>'@9*%07V2=mY3pbq<B-A^<SjL^dKcidF5b]?G/`;?3aqND]J>%?-.+I`Ps"Vp3&H.ND$q6'Aa?2]odQTT!l6)Wd=`&R76cbfAZ/"!S!\N!hSU%>D%PDUUj at gO="qWTlCE3d+BFVN+>IAG,+l at ee.&/2oA"?@;Ve=/S@%5p#SNX'+OH6NJp_gPmh=UEZh=")0_?He@:0l at crC)-H!'Y;CW4mWSan at O]iR?;;o.P%lPr@!e")[0EQDk at Ik1ZZ%oEWHWV0OVh?ScfEN&p6bLb5gXEtW7Z%1eRT8>Cbg+KB-CO8^A-6c[_`**4?jtM5s74]427/E6`\ZIhSfn_"98>EWg!NdWt-JtpaBZ!:`Jq[I;NKmho#F.L'dFMb'1:qdI^D=7b#rs6%`LAS^UI&.bMn^o/c2*ecf='_=SRMPZdHL$A.RODfeN'2Mmo!6GSkF>&Kb"mr$b at n;WW~>
+endstream
+endobj
+275 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 274 0 R
+>>
+endobj
+276 0 obj
+<< /Length 1772 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0D997gc&AIV:0RVO_ZJk*I.'Pt*U&i\0JKdQ:FUti9[Y^h/Y=/3VmmDqr3V(U<K:iO\i!d_qiQ$4HT,)WHTAu at .&T>*[hg)QQSNl_qIt-Sc4Yua4ihs+O2>cQ&DQ/"Bq[b"R8S/KE%BZJ8F:X\3Ft-9L+I;s%g9ILUDE06$Z=:Beae]FZbCkNX1lms/ju&E[DIp`("u/Nd3?fbTEHoF])g]Bl3`/FK$cLbLJ;24X=8VH&n](eu8a`2O.QD;"iFq"".=58j70/4PWb[Vc\SZk_QDO]q>mj at u,pc%Ne)t]4V^0@[V])[.KAMD0,Ztaq/&#\]cA1cX?<A7o,Ro0MkZ;3cSct(3#'LH_+CpB][F6fppLAHsntAN^<Zi\FbBK9$ZAej+A'n:,B^C0=CSiV*j;ZQn?-qH#'(9Y(R6KB)+,#r)H7GUr<I`0aU2!UH]7mGY_S)`-q#QerKd6PfN]?chnf4Qf_Q>&BZ%BQKf0j6ma[3K#dOG%lE0!F(>M:38l4S"2?Q;N\8.r&rF!$T)]eB(Zgk:7K53i8cIJSG;]g7_%'pc2,<IXa`?]9<DrP7fYcT^lhY8!fSa^b(Ee[%bt0Y3*e'LX4j9^_^;AA4P;8"NM.35fG`Z9$a#\HlcPWp5>oM..9-4&F&DEpC''pJ+*aKfP;KCHJ`bP-%O*2f6f6cFT,D!<oh^D:$BkAP`\.8HKCC3W[1p'VTh<$]1iYpOgmFYQj at 1XuS!Ll^an5HU6/"G,fu;Yi!2c+q2ti."S^^8Y$3JMNaUGG.",o=gG,d2D=Ig at BNniL_T'#6.,+p(6UGkJ@;+4A3^MEgt3m_`C at VOd^i]+a5rJaYu3rfdAX<OA$*akWW(,l\6$RHj*::?jGd4FWcI4K<6nVDqi2m+g"RapG?<WZb3Z"?Tiif]X2-.b&pPmA:Yb?]j6A37b1e at h"WNGpAK@/n:,sEZ;gPP/B*MTrhTCpaQng- at MsVH6HahA8Q0%u2*>P!
 ?@EX#$S5oZ[:=u]-iX\6 at Jr<!Buc30$TQ&=B6JiXF,5njSQb00YOg(G&&n&e5]6E>kn_qCa>;4OpsBhHp5"+Zc;Zbuiiqod6i&:+Z)_sdn7Pkg[Cb.6\3M\;J$LEu'g<O"K,^.j]e`(Q*\V^Hh/93\;$Ppsu$N,-kep&,>nT at jcC`cpfbEAb>3/Q7,Y]7Dt'JbaO*RD&:ers2;eOt_%Z1U17,[ff'S(%mRf\j$iemXM*JKu%W2Y,O><]P%D:NoRS7;Sg[EFM1la,3?`f>`7Qm at 1nd6YGV5..6&*I1Bkq*L13Bmn]A=,/*As(kcq+S>?93mZsc*s<(!=jNTWf6%#pF?iNO*P27U2j:3C1U>s8_&ld.QTG-!C+8<n<VBpC%<g[m_1IcD-nZI7RHlu>@9p.)/TRT,`Rh35LBWraq$ad$+2F^24dDO?+>,oT at PpjO9JFNcsiMaN<2'9GS at 4,7MFR6l8E+Uk3I"67Jrq&E?E?d at h*-!m3sXDSd_Te17u:(uWHmu4<&_^G at -+b">&c>U/_^7UUbkP*a2lo;`tSp<XHeHt3u%.iF1_s*<;;r43:*<CI]m<$tP/L]AkeUqAABPR+]m(DAqLdt*)[?Dt+lTd at 4C[hFcXAr!57)Kq34rY'VRp<<"<ocYT\]5R)NT:od\c<X8rCARe8)[D,k%(tbl8hmHnEIt#cH!*ZpVkshrd(HVRROq_(""`0e?"5SqX1Q!:CGpqVA[L.=RF>XT8sbtceqc=3k>@$JjfS.ql]kD$Pbl98S!KE<mWeL;6X^~>
+endstream
+endobj
+277 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 276 0 R
+>>
+endobj
+278 0 obj
+<< /Length 1556 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasaq95iQE&AJ$C#e;4sVQ<2NM8G#nfE0a\!kpZTcn]HZ.oE96a7TZ8mi=Q)NYKSF!X,#*B/ohabp.L9beAO%*7#q6Ze3K,B05])(OeKeUU;jN.#A%=OZUaUX at RV[l[0#pqTB>?X*k3CMmN0`]J.Ba#`WUY`^N:2%t4fLcG`.J=Gu*Zmbgd]L_k<<L#*+qOp2u$cHW at D2q".1DC'^Y76=GNXK^`'kYn1\,;M=p`(GrY5i6gCb^+hN;N$]Ne`e^.LV'e+-T(H#[jh(2bl(]2Osg\72I*B1*Krl:!n_iH)[Pid3BeH<6871j62nm14b>utH7_QcM/!#hF7A*b4_g#Z2f^Km$["h6 at Un$F0%3/'5$9;7HG7cNb:9PPli\;3>(q7$.1[%/[h!M:!dSK6I(gn>Y]"Fq`#ac'2kD7;3Od3.cu0^6-XZrd-uAi7paSB"U0T0)aG_;VFB-6@<iE#BQ!DMA5$"+F,t_\oo at H[s6><^Eeoq#7-/O\)nqT2R[>a?V&+I\e^?i/J$N1j\r>K[:NZtXhn%V@!kXQ[cJdEZ!l1qhh#Z$S)<q!pX^0bdb.%pie553k&>s9Pcl?9;lS%VF0<^,F1k?AnH]3U^hmn8A5oU#<s8eZDZPQV2Xh\R0Mid`;'e8E#S97FOp0Eud?*^_8Q%'(</+BeWt$^HThWYDN67&m<"?5C]s]DGroVssP]GV2o/L0 at BaO_QIs+g7?$)W)Z!oPV#bMqgqmASNuF!C(!+%<HgfFIcdp?#`mEWmSG))1>%F.1+\;S(2mh2r4j.VuT]E)6T:nbFC6MbN318Kn`D_DXG/^jLiP<l8.EhIc%/V04lIl&Y^"j&2N:B<TjLdG=@5Z8nHV.WU?n`pa)+gd+4/Vm at J5"5.2cQa&DQ'dT1ZGMf$T->cR0oG;ttl:j(g5)[.=`J;%K7*5pU)/bLT4:I(-XLL(-Q7$jAP\:>Pc%"3lK6B5(j.h9(D:-Q2RP:0,Y=<B?_#8^!
 b%K<cH%!1B>qJ)n2DLBf0$(po^[LI%t$l%eX1H0WS]m at 7-]4ZUW^p-\]Qc\7sVJq&SCn&f+Sh$m'TicU.**$?*/(;Xm5JrI5E#L%B`cqPY=RbO\/Bk4/H\q0+7=QNpd0(N##YPI&!`1=+FFtFG*;mr%[<*eH=OXQEHj%$N-)sp/]#"Mlk#(Qi5"[pPHH`DhCpD]+ at a8.M/HU4ulUTZ2<?L'Hi3VH(gCc(s`!b<[J<.D.=+;j?6*H`t^+j=]><;B&E08a.4nU)>#V8RHhi[*R!:D+=QSKLp&oi==7D\];tq?XE2<ujBO1C]Gcoml/sUG40NIUd;P1Ar"#r70ja^[Hj.!1qDWmSHaDDRp^3mj9YKW%K1:l`)^4<;:hJVkF4qk/NMPFAQV3rWtlOe0luP&uZ0uf%7;YC1S6(dX'>m7lg:X(k*]0>=bi#MS+0QDR)D4.9i)_Kc/jSpW\N=#]+Kk at JbG`VE8J.2Lk^4b^R##RV7(<^'Af"Dq9&b.>>*rrB#@.==-Kl8SA)ciRPO0G(F_d2#6YD66E.Fc9H at fkQ=;ull9+tIfPdF(Ei~>
+endstream
+endobj
+279 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 278 0 R
+>>
+endobj
+280 0 obj
+<< /Length 1982 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat%$968iG&AJ$CE,r3GP;%BAA3)k1D3C<Yg.#oi;'lC-OH!Ef'S*KjJ);OQ&.=l4*9k?=Lg:#<^&YlS?+p3(#&t5%A['lp7D\@k*(9:WK-CVsTSW0C>irk;++.4=U+I+Uj5ME\)Q\AmeNAX4(^6?t.o(Cu=XIR>`h&X3$/QqQ'UDT1-,G0=l2o^M>Bc%8hRN!6F=pITecdt'-$b^[g,?<Xi=kPFI+uAI7ln5ZXZ,;5RF,;]m;8NhljG;(H[jHa(_eU0?:aA+X%@W4WV,I+ at S>n"@ui7n2rWs,j@%%>b:F%-A>rQ.Q;f]:,FA at q`*lOi^=JdLN5IDQnBHHim\C#n/![?lnI9fb\+Y)CpKX6?$SEuRi2d*:jSHl*%Ge<j&ZKW=mBcMS'(39rcoMYl*NMaR6qI'.7S&>&C`)<s<r2amaMa#JJ>nYD6$M%2i._I\(tn8S[*X-hH#t`rQpHGYd*]&scn,*FCNE%PW[uYW<d0.Yk+ZAW]F)hE`B%\c2BsHeaU1:Y)"k._J8g93_><l1k5<R21jbnJJm.4p`R[6%7p7!]a1Xt9G*6(o^?)7.]p*b"_*PW.nccCs8XO.eU>TBNmX$`Y&QX1I"cL.ZQ3u?s]f.Ta)-()L3nR79=Q*F<Qm,T>Q<Xl4Ej[ab"FA1PR?g2AM"RJ_ at U,\6-9EE+'QRfiZH<5#1rpfl6WtjJPT]joi9dY3L"YBpY%1OHRH]e@=Vo at 1M/e640S:#V!Rh`srku;!Z36N[M*IA`1(GqC#aYH?LI?LU0"Nuoar-J08JSX2J1C>fE-:-n(rmb_Y2&imNpRKI3]6&B9XAh<BOCGG2c,ULVe`<YO'8IK"+rQMgS8'A&8Z-d_k_F>a(Li)iNpnIV&-8PEPY7HlkMQSd#.uBUN]`-DJ*gX+D'bqSK3LHZ(b1B("CSKZ:hS7]dP]hld3ufDpDB-_V&PYH9r!!,g^_Gmpo"!BuBS at E?6Gdc]pW>V4WNQP/6m at CLh!
 ,>Jb2 at 2_hj+A'q-h!m._XE3Dd+F at iJ;U]P)S3`l=ql:dA`j[tNp&LE\=!"GI^_in-#\c\o5"5Zh&S=@,+Lm3pU`[1Hq:I0 at 4&1I'6refm.H8"$l]P=-X1%^4GU]CYB4K!Z0G"-3(^%>ECQc!C-?f:/["oG409eP*D@&^FDl$@1'HAkuE3.ER7%P)+ON5lH^HR5M2h[UmVE$ELEXZSa=4f(V0]&YGT5A?QbCp0*-qfg&KJL!;$+RADjLj5!LpA>NjKanc.\?aZW($tHc<BLpMLS4P:tlm#b?C52EC\a at J5Q,c!ai]l!V8cnrh<>[<4RoH':Ulr,UPd&!XO/dZ-m+9FPaj at CC/K`?V,t3SQFd+fi6?E4;Vrn^0%=ZK,E1T^2E++&V at cKe%:QltZ(Yb5>%V>'6:+ah`\-JN7W^g/^?ZeikBdFNqc,7]AXTP^?Y?cD>9,A'&IZDu;%!kR"+D5V/+2p!WZ1kUP8*Omcf#4gPs,>.]j[c:n)00U0pAUmaK_Rrr>i4:\m0(RW`aYjph+XL92mLAub/ZC=Ji$/p1/#K<C:rqMWPE^$5.U%-Aa[gi,$[h,oo#F(`5rSjr.XQQ2G^?@J5;&=gjMQe%6YcJatam:]_gAGZY$em-#b&'p"f/m5l6mL>L$T(SK=>6 at A[t at hhF]"&k?:^k%,1AWD]djmkr,4a9O*2N;XsmjP$O7H\0Q/n/Ai&Qe;`t`aq1`ms,\>(M]t4hat[oBJW);km`4"MhK&g5YSSSW?aif0#C__6^Wt+$e9I.^6^Il[]Z\nJUQuDE.iR]Lb"Jpg-W;@>BK6P&s5=sHedot%1Z'=4H]KMoZUY7,o@*TVL8S[:IFisTh/J\21sk0T)M'^Vu$oU1&,8"9=*KtcelF9BO(4#>_6&cpE[7Z^XH at .<`e2/8)Q\8aPnn/)bBuK_3:P.p?Ku)pT)\h!hI%tEYo)fK#52OX,9I%gEX8*dh=:+TKI!SNDdR`FK?`\CZp80U!
 O:k~>
+endstream
+endobj
+281 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 280 0 R
+/Annots 282 0 R
+>>
+endobj
+282 0 obj
+[
+283 0 R
+285 0 R
+286 0 R
+288 0 R
+290 0 R
+292 0 R
+293 0 R
+]
+endobj
+283 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 505.14 689.561 540.12 679.561 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 284 0 R
+/H /I
+>>
+endobj
+285 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 120.0 678.561 132.22 668.561 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 284 0 R
+/H /I
+>>
+endobj
+286 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 191.92 617.122 298.56 607.122 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 287 0 R
+/H /I
+>>
+endobj
+288 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 161.11 505.244 231.35 495.244 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 289 0 R
+/H /I
+>>
+endobj
+290 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 526.45 428.919 549.78 418.919 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 291 0 R
+/H /I
+>>
+endobj
+292 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 120.0 417.919 139.45 407.919 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 291 0 R
+/H /I
+>>
+endobj
+293 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 314.494 395.919 352.814 385.919 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 294 0 R
+/H /I
+>>
+endobj
+295 0 obj
+<< /Length 1181 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatU3_/e!Y&A at 6W4C"<`+=t^AXY="ITeP7=_MRpC\8j(=Z&7nT0F\!,g6+&@FlKi'&(PPuX53Mn=7Z75ilre at Y`F0MP:q<%^VHEOJ(VY)UPr<*''a<DhY1T1/@/O$Eojupr8u%2c)^^8G+#B/G.$nD]ZoX0p*;n^l0Wu?(1Git_usMC/IIoBL%V%O_uAET9bBZWX>erb;:Z;rG'1Zf&enelX*B%l:Ab[uK2"DpO<A;drbF(A>ga[lOgP_YQn7\pdA.=MI6a+gWj6XsmCLKlLj,g2l)rrFF-0cgT#th!ZoL3c+fmjuFs9Hq!u:@4RA9gC`oi_b!-CJua<Uq^#s68Sb?W2(L+!(WaC?(pR4T7Q3df]g#KA<s>km8oLO^PQ43*H_4GpbXi+5&GoL3g.)L at T^(rZ.bnGA+o1mr+be90/g/EEsfQM:ks``Q\CV])R6`J9>NQAT#[FY+O"VP.+]P&s[=CbbW]hi*MYPkB\W1t6rSNo99uq1p*ehG6C5Ab)/5m,R2u:pN3j6qtK;i>uUAqnY(Z6%Ta,pB(]&)Tpk:]qS<VRP[UN)X;LdZ&p$Kr7>d/1/SuuH at 8"OcGe^l1Q5eAb*>)J]U'8$WM-VOp!q9K<A at 7\9FiA;_m)6'3qPZB]%^2nMW`t8GD=tfW,J3'>-FK?g+LumBV=a-IL_)5lOO,ofC/(A0g:RBY33h4,hVq(FB_q5<LoEn?dFHoiY\r`?a(eJOFQtU,nsg9l30ht"HiKO=DlNX*mB9_LuQGbk("cVV4m4E]@Z/(;\=FhT>!"K)*9uJ"+[pDkEERAGIl3oKP4:IPlS+kU4S6)'JHO75^pU9-]6]^;nI-<l3o2T/p3XsTqe?'dU)B`RrWcofTgVs\l&q'NH8N>43b/1og+''G+/OcML+21SuU$!5uG6/ItBR7'YC!]/MPWg!MP=3F'Z%V[X8q:K at 4\l_@(r$q;%6)8o*ker'UeR#Vb?<kVC/:U;U0G08d<<_7^!
 I=T1&iP'SYn'dD2!@aC$LgmBV.[39/;,$0?6R at 07#;%k3AF]\O7aYo)e_)O<IDH-ngicC``#C5T8:5u0QPHsek.F9Jrm+Yn at CIb63#l49Z@,RuR$9A$Cq==N\"M_C"_S&sq$iWLuLT,?]>2Ge8GmO6M(In]TaqQMA9AFchI5CkHul8;p.`d)A at r<#.I/?]~>
+endstream
+endobj
+296 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 295 0 R
+>>
+endobj
+297 0 obj
+<< /Length 1717 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat=,95iQE&AI=/#hXcH1grdDe>#;FBS6$*gS2D^4jYrq$_^!ZU65`:r:a)%jVc$XSDE8C)%MGnr.ae*ji-mohsjqaq93"((Tt*TTT3geW=sQqFX#EbDW!'icB%dFc*c2\;V)<>VmH;5c8(0d7`q5@:/S3+KMbG&JG&(h/Y">P[Hr2;ckKJ+,]NIBg/NG)N1u%a7jj5N?4')YLIRLGii!ja*_[jb>H)tl=;DQ7[`5a'>73d,;tTSqf'O5L5 at uj\IqNJ!c at 1dBh@Ub],0=dINp;nu`E`mE=JLs\%^-!HRG.%R`E*]BZpO(1g:4ckb'/Pe#*.d+VVrJF/l1YSf68<#>QX(-J)lEuq[:tAB7u at gnI_0jf>XV'4hA"_Gi_'t_>Cko1L6s1?SA9%2 at a^UlV!mJJb4n+W[B'p8mNkPN*9:WVOOT,amqJCO\4<"c!'K;dauuPmBAX@*am+L*Z]JXKNoaK[EXCOH+?C4FYt0PQU+.lhWDk:6GbeXHA>I""#ld#OqL=!<ODhtWPFuRJ[IXu9!!Tk'q/F3L#rP".#m9;[&DgsaI9NZRPmLsJcKjkf#.0nS at 5I6D%5g^ZAIeL,_5)@'meU<2!G&Kb>LG'+cB4uV(,T:Xp$!iD2hQiNFRflnbf2_FUak"f-bH<Mju_("/Erb\u^gtQunuZpLi7HZ/S.HV2J")Xq\=OIbmec'oRJGge(.sX;+(I;J at 7'd/m'M,SlLSYhH%g6J6)FcBU5gMD_N- at 6Jt*!B0fbNJJB\W9hM7 at j)0=hLX!NAbYB8SG<2*it0Rb)U)j/B1K1SfR'$W`GfDn at lR_G-epfH'(FI=(:uo*MGr)*&s95PBD2J":ZoKDGY&_#a_5+*F@@.nS&nO>l2uHP+AX7if0\W_ZPo46pLDptmLB4Z11QHo^mT\[&:\*cLSmYXI,Y<lbs)W_d%Eo;A*l']aFNCF7;[mPW\mUb]^EAqFJ&kS/]1=.90n"k*Xkc'$k4U2P`@!
 =Io!Z<4)g$Ct[Y5E_YuXp.DkbX3^dC;03-*R/a<f>XY,X3&Gd`#FQsOm1Ga-j2pdoLr=d*g>QSqc8$p!r_&fjFb0QJdMX?2VB5 at MKA[T^D?f+9gJ3V+i+J`*b;.4%DAE%F@@mmYs8],hiM)h`P(k+$#8l#%sA&-ATQY\j]P61P at g?8b\f!pQQdmBtT&$K'G?@1XSOaA``&,7u?pn0fWB`ZuPEjBNOi+- at Z`T:)i,57Tr3QO%cY_!)pC4o*01K-5%71c@%C at 6We,k9n4?p#s-(?qqL`A&Mm;,O_R%;e^mp?SFot/T at dd%M at TObesmDaCoZ03LUtpFH.d>CQGq?YD17&I6P$(]\<@1^):2IGTI8Ld((d_f<`;:PUl8sA;s(CGoO0C at P<\3EeCZ'Ss]<8<Ge?da0UblfS$pMXc7&U%34_?C>XPM`.e\sF8kp6D23+Z)Ak<*@7XjB7JZ?9B!R:Wo4U[^PsY:qV(7 at X4%++3b>7=WL#Dc-lIu/19:6;OJ)nK6/Tm,Fk_0I8ZGDCTe$ce!#oVChiRlUSN[>?p"s5='^3WC"W"U6"\AR5'bffedU4H)acb at 6,)0ET at W+SlRj@&le9)a;FS`u5hP&Rr-9A^'EI_[e:0'%l;c\?$nn^q\EGUW8=bDV/T\!516.%k1,#Mn)kX%GAI`BP02QY>*m,VeKu"Yl]ogb/-a_fttL"eeNDS,.R)>%M:WOC=HqT]coN9KWa~>
+endstream
+endobj
+298 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 297 0 R
+>>
+endobj
+299 0 obj
+<< /Length 1437 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasap95iQE&AJ$C#eek[)b(P7 at _5d9"^5:MHWe.n3*=Nc'l,$m?9O_q7K31E6qSHPFAh>>O.>CR)3Xj%Rb`GQ*qbBYXg4A`4jL"h_acj.FH^\_&C.u>_7O&bXkG[YWKuC8m!"AG7b5gu]hn%VdX1IaJ"A/<N)6C:J"B;d at 4)XC&gUYT.(>qT[`+g;afQ42&lPk'][$tr?ARM8&4Y4EGP"3\:-2b$8B`HmoJ1YC)DI=\$XQJ&7^ragcakNP*6"e<ios&PIRpD/6/4GOm1YJ(8:jB*]f6=YdZ?.HQ+6e45TckK\"eS'&p3-,:[!nhY.X->(tGQLf"majRZ]?2[9DCBk2W#WEkX'e(3QZkX`o;]kN`:<o#J"uFZl_&q0G%C,DrW,'W+.T&CB#NEn`o(JrLmF#`%fV__*!UOK,QaV:s'&86G71B_G>,<6:mL%5KJ]=$#3S=uOcWeT7d[]PrV9/_)JG)P3$Hb^C;HNO'25,dE<8@\?(IBkbVU-u)=CK)%9U=\M^7rc2@\V#Xt4iD<ft)4D*t`9BGu69cWP)NeNpWs1WNrO_`+]j!/GNP]p,_T8Z8S%j0mdY("U<\HA+i=PgUqYk^V][B8#A-?_:IX'/-mJcK"@[*%?VRD>_s%,:dHam^]BdPuahCKoJ3HlN&bbp+a`q+R.C>=plr+Bd:j11S.`ip"naIT(/C8\N@/rY;uZ2=>lAtglGq(LA*DHVSY5<*jAL]\8!7*]/r4tV?d+r^%PUMl)Nl7:NtT`LX_/F:<NI>rJKPg;o!!.!\H66[^YaSpo^;Ykn\]^1aPk%)M&!NiLG?O98IZ*C:(gOVA9N!\-?7m\$HVFcC1*(b_pgunXH".P^)Md.?U)JmRPM-.:9/i>mk)bm-\<'o-'X=CbJP9h,C9UY*%.`=e#Zd8NS5*IimCh=.YRReXc>tPl,AFn$*Q(_6RN`m6#:rjk_-KqTmCsX*n6!3oP(PP<X[YLVHRKbRf(/=h]M3/!
 )Rf-Ym)\gmlkGeGAGm^!oDB at VfXOUi<X"CO;[N[BE?=eOKd7TL;fDRO6$/R'Gc&P55T5m2-If,r at EB#fHC:)3N_4$j$X4fH=#U$4//k?qb,oMRiqWuA+.EmS4L^`I?3"QE!&S<k7SmC$h2F68$Ugc(=Q[j8AofeQqia(8Xdhe-P+Wo at PdIqnWs2_K"p>#o>$d+6:W#)R&S7c.;V-mBFT7f(s<f0W_YB$(["OQhS;CtmJ8mQ:Ug:N9ihZ5'P"3u`FW4:ut;K5c-VUJo1kMDPk(^WQ+L^\nM4'[DL[0Y^(gp%B&L;aOu;jV\LCY!/*=F-S[\aq%&$'41.aO0>\KYijKsaia^%9qT>Tea,O!0A+=9KTnmo]^*R$N%4('ZbL-[<mF>sJ at ak3gQI4=4S<g)k*")<;@)sJMFZoS('E;d?\<dh1RRY1!KD):%K-fI;fb>~>
+endstream
+endobj
+300 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 299 0 R
+>>
+endobj
+301 0 obj
+<< /Length 1348 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat%#>E>75'RnB35kC.,P</ICGggr;e4SQ+Q1?gNX[lnVZij8L1T=FPheQ`;#=:bXOXBd7q`@lO at m7"Bb:hYe/omM*1i])("?Wd__[\"3oNd'Qn#VSqoBc';m`qX[k0=4Kp#7O0_kIQ4H'E"L<l*',9+SojJ7FqBqm_Tke3YnB\W<LVjrG&qCBugg at 8]WQG@$g4ho[S!g=<UQo.UfofG%om7ObeS'1Lrl7\_>T'n4*dhr>C,b\OqYK/(WeQ!^KK39>-`DJ%kf_e,)rD!%et#pY]I6u#LMQWZMbM%[b2flTcjX]=ZH#<P],8MY[`&B$T59QMUtoT(n$s&M&V2f'0Ta:fShWY>-o;Ag+sT(meS#8[N"1!=i-&]R*/e`rHhgo#ttNg`P*SI4[*73LJuIU@*_;+*iSn`:ReKIBs<[.0"0NWm:ZTis^kHYlPepI;;?i?RJ at F)"l#Rp&OaRi.SVa6?o:rf-[$`Uq-dDdd[P$3eK0'HE=''4dVc-%. at L/bptE4Wh4oP44bf_m'asW,JZ+G&FpG,9:"pkU?Aq6-6o.Fn<d1:?B1ta(\>-r]JNET8P=&L>,,iY[%kW`M.:&8tA<cl`5MsWQ`78b>B)U)YIpH!WWtMG2GOh1 at A;[\$GWti?=pt8iqK_opp#5>A;-g/C$cG3<QW`Dcei7>u_>ElE;'aQ2,_0MN7cZ-LmR1fm3B#[&J*=GLZ&NdP`@9>Sc#_e/1.cFs5nsKjhQJX[.OsU at 6Wl[6jjPbB*uNoR,H:gs1m;6aY4JD'.!F(cJuSc]322NqXp`1),PuVQ8SGN84Z2$VD3D06eTTgj9o\%2I#CP][>aAeshgM`8^Zh6D_57^o,n=0DVT.CftS:S/[L($"=AY?35UrSF`meE;Ws2UWD?`t@?[/,n<*c4LjU$gsrs2$+k^i2R;!U&%%'-+?L=n)I](p`AFDh6K^GDA<*9$'ak8DE:t)$1h+UC:^fEa8dIQ2#9&X:74#%b1L!
 3oL38'N0h<IgqHrEmJP?'4EG1-=l.Xf[7qZ8nFfYT6rYd.LOK!>6][)noWfGr_qR?(d";K/,AQQKp`$(@L-Pc)iWS@*rC\9XGmJ860?SAub`Mp"Y at hHcH`i,hs7_E.L%m&jQ.Q!)2kgWOmlak"8RR&bl[4MQTNACT7B"`J^5F%S at Mnn$O77JLqFk-Pgp`?&&VI\OF#SZf*"@cOWAFC955al(MX]sPe.*uX6@'&g=rF4#_H-Xn/Zk-3MKRG?Zk!Hu54pKQ<U8dLOf97<=lcaaA0qJ-A)S9aK9.-2+1\nC!bTGgL8>ld"c[tjpD at P?&&uLG*G`]h[PUG^gXG3 at Y=MKorHKZ8flrp8n+dZX,~>
+endstream
+endobj
+302 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 301 0 R
+>>
+endobj
+303 0 obj
+<< /Length 1523 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatU395iiK&AJ$Ckb\KPAOPgS1m_Jn`>4AL$Q*Q.3!VpMD5"8";K<bdh>c?*8;SS1Y-M=M0K:<&lf1+K&+eK9?0G+GGg:[oo:5K43Ze3t6^_E'*[<Lbk$.$JCq^MEc?hd58Dp"0dHkCXl+5i5fSZu>X at C9J?37`.4KLo_Lht]('iIu4:@-5K;@^(;G%IO]0 at up4OuJZ5hfu\".\G3K?5/1"pYaYU1]M/'Eg5!9AE*`&^^$QZ=#?5o^?RR/m97.b_:BN`'$L3+2 at m1Kh3ODZaN?DZ)R2CJh4\4:qn+>]ceU<i]%e%>>J(lt[E&1D3*qHnj(/jRKjGjU=mtW6L at .];k=]5tDO:<A?<EeBD7m]j9[&5@/*+SmP#M[rjc9R'>TU>='Z<C_H077G-7i$Ed"N>f"JV!?,RS[]LKkP:?A*WQ!KE324i1[.AJB`(2tC.a=#Y;>ZutFmAAgj=4?T<!9N.*r\ef"e5XGA$+U%SLN5bU7J0FiG;5=qUXtniX)TO*4.9+MIQaq^N*cRGi.l`o21N3\]0RuQb9O#T]]_UkQ*]XE,nJ*\NmY-RB.O>TqZSGM4LMR<E[nr3I<DK81,Ul;`2?_4$<,'-=)-1A'"77nmX>PI(\m#Y_d(2>Aii1'noIWQO]?8\$A at 7_NHTh._oSAjHDQl(E?AP;\>`Lu.I?2d&Wfcfr#8"h1Kh/Q[R6bKQHG!CMb1=KU*6'(dgi%i[K<5AOD>5oQe0,[/6^:d)mI)-8J!kf_o(/..EP!d5I)cT*TFDQ135a/Rc=e_cC+kmnZ%ukI"\2j<Q-1('X2- at N>NO6j\\e<KW2_4LiT[>;oj\WR`X at l8oO46Ek;V6Ts+/&E],S=@+,:I38dUDIdM;;9KUc;;n\t=sA:O+_8m#K``17oQs0J-g5sjS\2o1$UP&J;YqMBQAKr]WI]R0E;,d6[kmP3oCh9^<%C?$<I?C[^->cql?mG%kRp[,R7/?+!O7,MHf!\%O:b+p!
 _XZe+GAMET*>'CYQ)JS at XP.+.lU(;0X,EP^-BJ<[THC`e at 1o$_7<hB:%8V!uK2A'"X81A@\Wg^!TN<-RO8LCgnbWK2(d_8LM(bI(rBj="Len\X3PNb/WGUhpFOF>`Vk]JS!&O6o8r\:;+8o.3e!JC0V.e<n"[k;+_=7O,=q98W,,h<n?g1/hlidD`p\Ani:XFILX.OuQ(Y*FBj?1YuZ3l'.tnju>I(3 at Jpgok;Z==ZBR;KCjl/rl26=TGMchkuV'(HkJLj2G;s/AlteOMQ1QV2&pM#h)I<'41<BpX-Uh!4/0rF^W at 4R]fPdW]O\ml`NZ4[R@@(#Z*7&i_9;9K"gK#F+*rC38tbqNd)]MGjR&1>O\[1j84l$722Tr?/t7j%p6P&R,aP>o2hXc"Sh)i`IOkpEZtFX]eCXcpWC(A%YLk$Pf16RJNf<tGd?gG+%c_B>S^7;bms5EJA:=eO>cg.k8`?a_^Wo$eD7urr)[g(e14&b?QOR9(GC2!&)h?f's/1>'U[@`EFE[aXXepRKEtRa]~>
+endstream
+endobj
+304 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 303 0 R
+/Annots 305 0 R
+>>
+endobj
+305 0 obj
+[
+306 0 R
+]
+endobj
+306 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 138.6 606.701 182.47 596.701 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 284 0 R
+/H /I
+>>
+endobj
+307 0 obj
+<< /Length 1061 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GauHJ>Aoub'RnB35^d;YWV('02K[22]<tP7]hIIgm=Ulf#o\@/82&]jhe.$%Tn/@udhF5l55)O8kJFb<7N\d=MdV4??oc*TC.'VSI`*F01HD=gE%BRC\!)(_G+"k(Vps6uPI\ctCRH&pL^bqCk&QrH8UOul at 1F?6$U=gn6aDWd<Ls2:/b0AZBPQ at -_&!iCD%Vf,VaIH$i)IC$gd*!&b:rL0RQNMQ"?4`;,A/VtP`nulb=-k<;mmPrCl\rMA&FB]gIA$oVi_VQeJ\Ol?jJi)GSfnN3BW.3f1H/WIZP*pA`Ni=>i.h"@o\t]36R*IEB-<KV`jeh8cV%D[d2*S\/=,A\Qm8+E./\q3_G9gn)&N=dkG*V%<IqpBFoI at -A[l.f?[>0En[Nt!2]Bn`1Y?B-CG!uI]=FhnRFpm`Oh-#8EW`2.-7?3i/\o>i2Y%tdd\sfSn9rU$2V(B0kP3[?pa9.J>SQa$h[;BEq3"(dTDtWqGs(Ld?a7%#i>c]Hd9'HC._"L=&M7k06X'Er]M=('1Yh[@e\F[lqq9Rs43(0B,UEC`4p,RLKW^AkK%k(@hmA4NJnB]@p;='A/`P$lfXB*B']7nX1H\"fe,XpWf4u(R&2Vo*;Ll/=)`h$<4q4[:sgK0&pT:sB=S!Nn?`N#"K5LUqZL0bCM=:$K3a_2F0b.X394p:Fl*sZ$'@QWJOhn]=.!q!K%o^"_Pq8Zk#F0<NU:Pd;KSIl>4=ibX^V`u*X-[dOF:!C).JW^QCbd&N-H=NV5bh=[(WH[j45ZFcg?%<Os.<5k::YE[ZU11p\`HI4+,qfTpD?D'=XG8lY_N49]`R&gDZc_?f("d>jVNNmK&=1Vgl6d&B5<_G8AYMopW;A7R_6GJOBtC,D:tV;?$7HCPq9`/f.pF`C[WQ;4#5WA-P<nq]'f>,1V8lAd!T'%[A`dCPgW^#lQfa9!(5?3]lVI&e-nc1IV2aR`UC=^m[/V?Nm4FEgJD&BSWOki"S!
 "K<%>$3khG;Vk_tOB&,F^T;I6\T#;DrE`2fG2a_kV46$B0.VCO>L2BprqKlTM>VEb&8`oR~>
+endstream
+endobj
+308 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 307 0 R
+/Annots 309 0 R
+>>
+endobj
+309 0 obj
+[
+310 0 R
+312 0 R
+]
+endobj
+310 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 218.85 538.542 326.63 528.542 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 311 0 R
+/H /I
+>>
+endobj
+312 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 240.51 408.943 348.29 398.943 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 311 0 R
+/H /I
+>>
+endobj
+313 0 obj
+<< /Length 1781 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0Dh/D%+&:aF]Tg#i'C7EfK7l%2[JHb8AU"EuDAKD1JVAu;8jAJmG!<(qJM3RG(89#[dpuUp7hYlkpa-/`)B'UC+1N]@,Rs:fGqjF/Bib)qZ=URCK,_i46%ba/=boOFG<i50o=.<jh"AFs?-#i50aB;@cGm6$mVYR1k^<G!YDMOSqR7OWT!i21>VJJ=I(kT>uA\rWXc[:(2 at -)Hg:1E\genE2Dh*#3XPG0T^S:R8][EYn-8 at jB"7C#3^+)r2m8I>#@];,,%!(!'$6X)"$=j at O778"icqs;,(Osg=r)bVtL at et4b>;VpSK5iL&]8f;NjiBD5F'dd72R.klkrHp5So;en+0KA=Sjrk*#s>?=e#>(oY-J8:0H?g6b.K,=TuY\&-a#e/`PU4TcZUGApi+Vb2UKlPJ'%%R3"mDSh^34KU:-8MU1?]d5!hrr4\[G1iWNe*[9)Qi[UVfS<+UCfiFQ##OqEJM']hN>ce0K);rfn=n`l at jDLLS;H$<Y-&tMgUA,/MOJhAK3'c2Hln]d+jQHfY<pP at QRs6G#sE6ap+Fa[_Uqc4_u3EK:^OgN_;/seEL;8*,=7?4d]*9t$K/XAZ*&H*ZtCSWgT-JfB.^Bce=K9PQa\.Z:SRAXb]5NcRA+',/]_ at BfVf9&P48?eFY[%/kejXONL&!uU$q)7#7i]>ee7[$92eK&+.IE.q\GNOR@`Pf%3C3t6^Ps@$#!k.D-1Jg9_7;-"g]C*2I[a_bY\d>8a2-CTM.HgeP'Q#pgg1W+sR!.41Nn8jgl!augh<<Pq4Ofs`D),DV40Jk=E(SErlQLXX(h[cTjU'FRloq<>"g`<'3;ojSU/T at P!@M6<VY at Laie@I]?<jpOpq/-Y`PcIcbMjH-O-/sk%?TMC8PeL_M\?;A3dW=\TR`SZR4[rJG>U^j3N/QkeWU(l,"Q=mr#=<<8Q4PbdI%2G!IfZ$/WdO2%;dD8ZiGg^=WCS/d%36P3 at +Bub$]RhjJ(!
 .m*%=I2I$=(_kB).mmoPfb6O91Z2An5daH!&FO:i)ndZ at p7*0at7U^D0iN^"^7#?ne)pPbG;(0!rI#%`?KeMMqOO[gdR_=U\4!0J*>Z=\V(MjeKKe8B>m/D38Y4f\Sr&Da;7W_Qm8M%LdCHS)dr0T.4_^6X'-7B<3!qX3rnD"iPW_D6Mu"f;G$-VLG/Ra04qB&F9W[pE^]0ZE)3[`U>)B:d?NNECEN;;pSL;S)uc%"\BaO\#C+,*DXp3*HK_m/V7U(Q,(\7?fB0f?HVI"u0b%`O!90X(3f67(-O^eJ/'MYDqLn"*:`7AHkY)XWp-(X_6h5O^/U?N6;6sLPigK-Y$SoC^>C0.u(4\BCYW`_5BP:ErZ#\TW8.O_VR1q_N_i$on<qH$D"c18urP1djVCtFNYm@[scTZ"H^,+`PPr#]1lRY4]nkGb&@)>M-b51%F6DVl^e'I)o(CW_FTQCH:lc7WP*Ot0rA]s<u at h0d':98O8jR%GkV^3+$WR@)#%$X+Ea at 2Ip+C4pI>96Od[T0SYtCs'T%/c^AoN0)asc/Fgi&4LB'c0BNq"rU-r2\^1okAeF%n5-,Np%?)OK+cbS`^/"$1]8(P[M%In#Z`C^$]YqcE>pt\am)&tO`O\(XV05TnRQViqdJh%!3Y%5,r8/B68m>_d<%cR\k7.&$jjLRT+:cOOMaJS*'hgn<aI+tB\Lte6bb@^HRrr"5Ep9X(AfktJ/:n27im#Tht9kV<W=$A;YZ-sfo6)adl'!8.-HT#cW(%(0erUnB at s!L*9%h&h&r<L-MiLB~>
+endstream
+endobj
+314 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 313 0 R
+/Annots 315 0 R
+>>
+endobj
+315 0 obj
+[
+316 0 R
+]
+endobj
+316 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 385.406 709.0 412.066 699.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 317 0 R
+/H /I
+>>
+endobj
+318 0 obj
+<< /Length 1315 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatU395iQE&AJ$CBROlP\-sH'AT$+d!aB(,[L;!X*gi=8e]<n(a\@A]s1OXbRZGg8P/8$\B]bfCE*iOJRTt?<$%`.(X*au4m0"_3rD8)bccdL9-qdUQjO;*5MnDa?&LEr6#]Xl>qd\bElFh"%=#W>;^*lXHe&^t(<'IKHKMk8,dp6X:>C;b<b'-](!i`=4%*>X8!h"D_qM\.2kH^4M(V1_5DU3q`"SW^F?$*/r:0.B!Dnn=n^4CG-e,FuVRAP^`l15`B9pdnSdQ!oAna6l2csBt,,RI'DiOmJGj&:\ZQP]fAPL6:;^s4^N$0 at SE"W at T]@tk.G92e)Q3l8snrLZ`:`8KRqSU=BV9@&K1AuSP\P]HQ%D9u3.e.%KoZ'&r_4>^>om$LTo+WlTMPLZeQWcNM&p=P[RB;sk`:PAuXJYiAg;SJ.5*]%7N^"bE8$HJ)S(%$P3jY:H2gI[%:`maMI'2(Y_C`K'8T:^p'AQWMtegfui;*%L_N#JFT!17Jc+/+K_(aY=XJ;l4->q`,Ub]Xb(EMi?;+sDJ5XnW32ni9OKL6m%%i\"[A;QaGW`^Nk:138?t?XHJs1kRr%N=!Q"dLr%\m1+EFn0n%[p#Z'!I*)cRaFRE:Gn%:&IAY*7P_0BVVT at LeW9P47i_@C`@\q!Zd:,&u at Ds1T:?CB!U2=78q1NC2)LJ at Pq_m%b?0&@c9adR5li\6\T7 at kO*?4XW>4id!ZKXbS79fmXch<XQ?uEm6/@WYZChLCoN\b->`6EY at 8?S*ZZgU^MZc8PH6'.`Q+Qq!V0UW26J5N->eDpNe&sa(=G`&7&3uala]R3RK64Tq[CqQ)BB6K@)N+K7U&K5)=_-D3)HJ:;G[0:4?29r_#lT!V%`U_'qq9<s6IQJ6<,Kk=M`/Ff81r<R%mFLtK%+<LO%!@!#(IUt.8sYtW_rcV,Wo=>W2g4dB at q21/kOT*,$8ABQl.^Nn'5pT$Uj>%,Y\9L$rG_bYF@/aHCkJ!
 guGDH5jNXfjQh:kG[m#t#CafT,spU0Vk at Gf/7/aCLL8ssm`\0KfDgFqC<q<%OJE"8_>3,W"6_5CTTm9;:iab2(NdIQ^<b0E"o[5qR]rMbjtPt:FkJi\:JME0TQcV;gDMIn(lkDL6e";ZqbMu)`PcL7&Q^1AF_1*&-VB/T!O],3Ace6g9AYHBE2G>)=KofGah?N4XoALCMC[SS.f")QiXc=4AcKKVBi^W(3%^`^V??f_2m9tlVeKZASX.0<I#0Ducg;^7KRo&&NG.U%'V>6'\_dTQeRS'<IAC3pLr))oQ7Z\dBkpjEYHHRq]F3(bdN0CP=,?N~>
+endstream
+endobj
+319 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 318 0 R
+>>
+endobj
+320 0 obj
+<< /Length 1608 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat%$h,!&j&:a.UOaT3t*3$36DkK66VqZuR=fnjT4TI!de86EsP"jAWC>&R?f8cDJ;As;'KKS;bb\o[Sch)NI3r]ms"=%a-QQp=K7`<1AO'%&BAq2<;Lc'[hDT5hA`7_+InZg^aa7dF4WHDjus4KKo7hgZK4;2N+WF"GA+/Zu*32<s\Q^W8M%]&Pr;EV6g1E9ulr0(V&(HG><&9jEB.L`p4nm+ah^.t/qZt<PD%0 at 5(?5-N%cR#XOVPrdN14j`,ms.2#KEG:*A'a6?_#KPG+#R2cYI4pp"UBhrX\bYSWW!2<[o*R32h9BKI2$s!mD%O:BiQmM,oZ:r=lXg,Q:9?RRa\>UfP]\r&Q]@b8L at U:!$q!]7MB&q,us/BG,uAS`VsWP['-Y!fhA`qCbp`PPLo%KB)k5_Y1CC#]hXnghrs-/J3D6-OV#%@+jWZM24i')85jSD?P:`"jQu5+EbAaB:IXqQCQ^j$8X"!KUPk_>)JCTRWlOf at 1,@?JpQhSh4bXXb<W]fXFL8#Lg^JkVF`hrWHmK8V7$O)@.>a!T&<^coj9s4gCTu+W)MV+0d_'!=<nWp?(LS'CaU;K2?7oC/5XkG%!N<jZdc>d]e8,YA=.P56B0_g),htI$2918FCL*+fDnj[!j(uVJ>;OF3Y#TEeUKHf(S8Z4JpS at qeNjN=RgQDT;!:)MCg"sir;9=,VZV4:h]RfW/D4\=I6ntNlLuYc+e\`!9309j/%#sN[[]ETJ(+`7KdeEK`oM*%MD)bi#&`YRPgm5giA1M7D7pea;F!+(!^-P,F*%,QVpq;OJ6!;MKMTfTWKMM58#S)hji)sq/+to1,M)Trc3i4/OD at cHk_DbM^Q\_U[$F$4_l%EE6+)I)6[V4/8@%X"CPK=d4JE+;j[,s:TX.0&-FC+dg/m:cX;NgMAaqp>;YajJ%Qf#XU\)T),2$fm!GPJM*c'"kJhs6<cE,gTl%(Iu/6H%i<AcYqq#8-?sE-R(ZdGX!
 JoL,#1fa*'@oL%d<V-*/@dYY[h+)h`5hKt-&e3eWQ<R"iSY,Ydde:fkpV at eqd3_[-F_.dA8gE&bKFhGqkCOQD!0<_FfS@[Z,q]5%.&A6C_uAj._:'?`Si[IH"_fd2AUmj(UY]7J9(aU-%7RLeAM^1l/`U^7NdkcDN-L4EVhL1s_P-DlX'e,ID,J8#pIL3`559h]&ko6rU*VtOYIoSW)X)SY4MRgih\NNR+:qRR[5gG'cu+2NW at l`X*FU?lU:MC8A0[d=^"lbZ`Z&p8UjYo6*pnU7hb76Ng;E\Mdp<1B[(;i]+sPjeq!NMN_ScADf7`YZ>))QYA6l%8r5IGV?Wl:n!+IF0#(Da79<h7ZU242n. at X4e?+G6e"_*]b!id?/-G./D`/GU)6if,+9,KoXC*KXX$,<C[!$UD*f)Ff^oiHNNTE8?VBQ&!^Y*S50b-NXl)T1B%1SrXb7"[_[D&6MaeB>>7#][#TAH3='g4o]I9;0IX`2eC+Me(ZMMKHLae#K'f]t'tI^D(A!TGcPMq:qd8'YHc$7O^Z>fp?X6n$[j_4gGR*!sc<&/Xn;-i<!UoW9)H>iqIhq4J9tVA]:42R6_cuuVD'_Y<j=990e!b^d>%g..~>
+endstream
+endobj
+321 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 320 0 R
+>>
+endobj
+322 0 obj
+<< /Length 1176 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0C8T3<J'Ya/h/1uHFVOm=LMF5f\C2[+_!JeK"i7?Q19-B,_htq5NR71^ZUaf8!n+j*Cqe"f,gACXSRg(d5Bh[,Ae(F;s at DX*E0WC;.8W\^el->Y*UXdGqF3R<?S;8IQmY*>6N!G9'YqW%>+LH3IX@@=qJh.t.JhqC]kCak/ON2&YUdJ*tKiD-jf/+<05O;PLO at WDHOW?&M1bP11=o&hEN#$5Pl6\LBNK$dH1u6)a87MZ*ST&Ml_]f at jNQ6rp@G@%N+c(B&7>1l9oY1o[,&jeu6Jt[[WU?_BSJMrMF51-+:<A&9 at AgAZ80muiJn56?U*g8Wr&H4i;$)eN*_UZK-F$:gk$[7j'F1sq_CmI9_.%ADL#f?mF9k?hVgN^o%=)N',pN/'9XFm8"l<INB_rWTI#3]g#9\"%bjaU)%kfW_Ftp:S>FB-A at +tRa9P)9aR^)bldG"7G3o0k)"d&Pi'=*3BA(D*YjTElT-.jc!c/]>_#r]i[<WEMA)kHWm,)_UYs,8OG&Beho at 4il[Y at e:&4E>[>lS8d)-r!*293TVrFM+-)\t(G*L?CU=rQ51rj71DM<g9!dS:4Rhl4/a2N3q+1CQQD- at sYU>KE,uYfVVkel=%9Y;4/!7J[%W!c[#7;9D90!1e+D0Q at V1eHoX?[M3-Q!O^iEr<\.i%fUg]U3)Y=SmP[$1m\TMj:'b_^_-/nCp,$8NU"lsJg?j4j/F6Gki-Bf,hS5!8G5lTVaX#qh/_3nlWV-K.nl1X3Z+Q%A`/m(>W^s-9B9F@]Dl]qK2*%HQ^V`c#AB2;WmUFKV!:M(9hJB_4Ospp(3V4kBpId=Bg:-lA]$<`\>DSYaP<4`Pj9?f/s5>PKQABZ#Q%c^:%$"667fD+AEb at ab3!]R-`lPH.RdG,qRr<!\V[$3>VYb"+;pRjpW at HJh*,?m(7eJ0tQ7&Q?<_nt@"\h=cp3BY9`&(\s>\f(d/kS7.d]F:rH#C\l/q:43kTlT5#_]!
 7f86XTOFe.)B at ptd*m&R*1J,-fZAPR'8aO;mP2-gZlWnK?m;^eRo[YNN1=us6)h4CY?&ChmrR\aTs,E+Me>NsjGU<eTdg-Ya\gABY&"DY0DY#0G$<,:.C7`LC0mq;*/HC>01HkaBNaKp;J]oL8aVTG^2)qLRq[?5Sd^1H<hQ"hJ3#KO!'oFGVd*n1~>
+endstream
+endobj
+323 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 322 0 R
+/Annots 324 0 R
+>>
+endobj
+324 0 obj
+[
+325 0 R
+]
+endobj
+325 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 200.54 177.341 244.42 167.341 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 326 0 R
+/H /I
+>>
+endobj
+327 0 obj
+<< /Length 1585 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasaq?Z4s_%"HU$nG8:`B[oZQJ%^3]h0';2p+S&5*noVHfLhl<O`HbO1csK:T5;[dj4I('TF`Q8,(Cdc3hPT!qlc]KB5$GPQ]miHRUC&Grih/L`JeF4iRjW<]Z9>3D)oe3DJm*K&ltLRV#os?F+e'/YX93.loeWi#0>\h?n5E$-#^G.rs%;(ceeS\Sh!Zi4'-l:QE5>WfkU%1b=Y9GmFDH9q/O?o'-[@a9IOTV-7!OL)ckB#C9@&8o,/9pjeHhqBaclaqGQ8!X:+ru23X;b3(/UI:#.Q<<,5!EWCn]s"umM.=+NBcL2Jr8d4KNEWJY,$WChE^?G.2;b^u1O$N=C\QU#r)dm1WTiom?+dd)_X^SY9P[a>=OJ?VgEir at T@DRI>;XcOeV8PbS\]Gh&5837\pRV_33qAtY/8YFn,<#Pn7,RSB$('SPaM,>2NTEh#FKkG$N2Q)=EMF`[F>O6KJ/4Hm+&O(S_CQj2AdJP5Lok9!^fB)V'e8lil$B.,*1 at VZKIPE-F16AhaUl8t%.XL-XXDpHj@;(X!kMF6 at i&u&Vr]]X1YUh9[RVfLp&Ss=L?O/>V'1C:"LJ$[(-D_q&TGkH/Kb\smjk<RY.WuB(Hrk9t)X/>L-L`rmgq"Jn"H"kJL2X8S7<@HA=1=7:[m,>U+%H]D9A6U$'`blMgFucF:^4qSfFQ<n+Md-6'C52$lL4T/`V=.tr$4>R0u\ba(E"@&<Z*iEA.P%3d?8Ol$D>?sgW!gZbcJ6WD^gJ4C?a;&m!)lEWFJ)BT&"@m;!$0NK4DD:Y[00neIW**K002oPTK6XIc<F_1q2paP+p%Ydr>aD.W\)sh_j1MNbPcMN,;3X:ZY?-.<5i@&(Xb^[.X/60209T!Wi7/ZD:Ijf!08bJe,H)3Uoq667EnbA97qnPA)$qjfYhqkG,D*dh4u,U6cK%ZWn;][ou-'#M(BK*ZW;qbo>DpJtn^go0URAriP3%9L(jV-.IMJQhIfE*R"!
 WbC\(f8*8#nXd:$i8%']!B="dGl5bFfjk"uIZ6a`d143$/@h[e)8XnOJ9]kt.A%6G$YIatpR$>c,Q$Noc4hV*71m7#j#=p at L"q&:f,!kX6k0bkW2Ul"8Q at 7R#/!2s at O%kPYX-fHV]K1)<cQc-OBAh6L-dE[mJ20KCFO*2KqhmC1*c,ajI9SXgrUJL.0$sYqAG;534PI_\)q<F3@[]H.qc5_')nS\3M2rF at F=EVI2FPjc$4j_Hdf7>RL$ciK2po%Y3bL`&@k,Z)S*RFE/2DZf[aB4J`CjTl>J5EHcUcPc!/dlK9Y]o",GdfZ9TZ_Bp_.N12=s-dFLYE:HT76^NR(bOT:eIg?Go`VT655l3Y(TW,-I459E!ZZKqj,Cg:4pgf27;`Sj5s at HX9Iq3Qge[HY,.ri]#l$R2;)(<9HD=9ho\=J)Lk7t3HCoIT7L7beP+R=</p)5A3:sG)=5BlC/^?@la48En7 at -,+'cIW1e)q%c#o*(5T8lmQ8+\TYQfTL:VJd&"uO'r"P?*]e8*OB]RkFPa^:7XoBnG5-U_VnPO=WL%T?_2\_>FG)a5B"UZ%^9r>DcQ02VP1i7M3/+2D%]<<~>
+endstream
+endobj
+328 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 327 0 R
+/Annots 329 0 R
+>>
+endobj
+329 0 obj
+[
+330 0 R
+331 0 R
+333 0 R
+]
+endobj
+330 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 237.19 709.0 281.07 699.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 326 0 R
+/H /I
+>>
+endobj
+331 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 404.65 688.0 459.09 678.0 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 332 0 R
+/H /I
+>>
+endobj
+333 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 331.6 317.777 401.86 307.777 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 334 0 R
+/H /I
+>>
+endobj
+335 0 obj
+<< /Length 1421 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GasIh95iiK&AJ$C#ei,b at n*7^4dtN;gNJ/?:nWedE=T?MgVV*r6W*Ac(]Eg!7+*&(;M>+eb\/'T$thQlkLJqe9Boq-q;,jNo=`$MHbT?o*[Zk#p'HV][lSf\2[gH!;WX`[Gg"0H^>Ae!F>P=1Ge``S][`Xs.D7e03fG876E2&lii8T1W<WRb^r1`B0>jLHO$B0T-]d%;D_/'m>OG#R<,.G-P+9-h!Y<>-,S46TPTEOIU6/%08Jd-"0hNl)]pg%g\]i4Ul3@,18Q&QPe5hue49+m0TX8#bj9=EkS]O2s<B4fbrdMhl$ug;?KV=eYc1)])WuSf'$gp!"'P2\P636lXQ+pZuYli!_(AB'=Jld(ILU"rG"JHH0b#KgQ9:"b$g[L=J[Lkc`[Xu2m&aZNpm0Nq$Z#bMo<+rRg_\==^m0!m-muKYs0Pi9RN.TPGiK_=lc%lhp`X6lsF>_J[J!_&6ANlJn(h"-32#eRs$$"G8d%s+R:^^sh:c4h_EM#[#aRt(s"h at sp47V-t3Gua(UGZ<BCLhfCWBMB=N;ujp#$<%,"8ZGXK1'!`^;9Y;#khS!%TYh.7/b3Z[#IUC6rd-E]jl3BRSSsFphS-4/U%i`m[A%*'GtH$NdkiVc3Q>sK3hPhpjif#.-f7cnp=6**9TC]Q at M.#=B5'C"Ct$)Qh;dXC4ID$_&`p"(t?p^h%#b9N"[iiODJ(YQjjnTE[+^f^o;DldoF1>iRkT3dpj>q)]pF3?s[^gkX5(5]I"nK<<!5+407>!l?dd1foIf(`UI at OOJjrho)6ekY%#`VbBa1:V,[Z)1=ngIkFJD'$DXR3GUeC2ZMER?&?6MC4l:b!C*a%cWC9)F at OWcZRY:lT40YJ.fE7RS[Ri#Wm)D8A%^H*9D)W@"D_gUdTdD9BLXB(!`Ff6;f[n*N6!k)Q5E&i1f#fZ0iD#m)Eg_Ig#JOAj]g1%J)/8eJCdNO6Tc$'DXS,SUi"'Gb+d4&(Pa4CCT8?!
 0$G+5fFW*\pF_ro]S at -_\Y,:ESpHP_ERO4VD!j0+j[LM!C at 3uGl_P&56<Wj[%m$c&0u^1%m]@fTMr=:QB!:4-+ugNZSKU,5T.CM,]E=]L=QA?9ESO1]B[fL`2:;5*C_GYgZ,$O$\02<=Q!FOm57a-60)T3ghW#bH7:m?. at .($i./PM'.N6-b at MW^`tglChep0HuiWJf at u9>csF,'pQ\,b/lQE'qW]#^1i0B5G.q$H?@q\B_&it_raPH)mMj+c*(_GYg0S)FRjC._N51"Sd&^Pcb;R^a&@oaitVX(.X4!M/AEH!R#mHdk at bfEID]q][p-@(IL%QA;#n5#2p:U%I;/\cR_ at u.S,,XPH>6>2Ch[6RJp[CJhm:Y0_<No,R1cO$e<IrkjU1.Q>0QWb:p;?9_-eh[5O`[io*L,j3DQ*BrrCo2S,*~>
+endstream
+endobj
+336 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 335 0 R
+/Annots 337 0 R
+>>
+endobj
+337 0 obj
+[
+338 0 R
+]
+endobj
+338 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 138.6 253.036 207.77 243.036 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 339 0 R
+/H /I
+>>
+endobj
+340 0 obj
+<< /Length 995 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat%"9lnc;&A at 7.pdR:iWqC3F37%[9bV0-OLC<4:3_JD2CU^b#9S_k^B5K/]&o=J&0 at FJ*<r;T)V<_Z4q1T&56t)0.-Xj6Ji#m[`#FI>;)%qU6OPC)UVe'u_bR&43dqr^JDJ%JR:$UoYW75 at WBA0F$/H-;.?QiagO*;F68;nbL`EI-dJ1(f@&7LKZAu`M3WnHbj]t(@L8*^=JESR\rHgJRNj1ulXg3HZOCaos&]tKu7n+qSQ6,\rUZ;6)`V#cg7\FVUoAK2.^mDf!BP<GmM(Z,1h4NS0?N^UM^cYCtVif\ONGN0]t/SP<OEM+kWA!CsCUrp"mj$4L%YGI25Y4=bJ.^)K(HRS2@]?U!l at Cu%rVn&gT*L?F<-n89CP\54:,fL0?k*D4,TA%%5]h("f;og*_-WaBI29^U=#`f^R0dm;l]-*&a.c\Eu*-kqDW87F6V,aZ%DMquE#KjG4j(WI:AOcD`TJ8aLDEW9IEX/S<&OCI0\5PsqI/\,`Jtc)%;+2?kPjbP#X*uE_OZ9&0j+S[l(1N0^TSu>te?'61M?bt+YQ,1H"$L:2W!+L[6[2Qt6o%0pnZeug%n)o<m*6N6#2EpK0X:VLoMTPs[N.sHFlUhlVVbCMmZl1"IBn\@/5[Zq#PJg!>#dV5j)pP+Q_#X+Kq#0oPP4mqIQP":1gAAP<`!`&3#4.Ga8a$e?(N9lqQCC`kn[TtoWp+?]\M(>-i4nG!j3.oUbec]@s-pm+5 at E_1H/J/\r^mhk[F`q;)WB:>HM<`i81^k#_)_;7)Ch!?@1!h^t`M6?0epEE7j:O"k-0c)8d0.*0c?l&0&VY[Qk*fP",aM]!?KVZf7ssl`/YV<3[:mi*ISPPe(;fR=2Tf6RYRe-M<!dZXp!MZ[mA9^3MCOdp/tWWq-)@1Y6];qr_M\fY&OlcJcLs!Gf_!N%,i!-U/s0M'GJZ-mforU]"CQnR%Nk.TRLrdes1LoTi@%$Ejh^@o1)p30#$-5Hh!
 >C/-~>
+endstream
+endobj
+341 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 340 0 R
+>>
+endobj
+342 0 obj
+<< /Length 2142 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatU595iiK&AI=/#en5C[#@DdZgD0;fL=O^JRT)\YZeE at 9\V*4.FfZ';=qVi+t7N1LRgjG^u10miQO4k%[iBIRto=@jZ:Jf2Z"H63o%62_uEub`>paT0leLSo438TfBc>`GLek%j1HX/@Vad>WQEf?4_aN-AA4/<*R/BB.tZKLI\n";1V,A,4HkXbd=t]CjF;E,,/[TJSWUd"Ce)X0i]OK%NV'7NDHTueguQo8GB_UsC\,^d=2u>#IBI6hZa/d'_Emp=]b,33K"gq71lp2FH\X7g"AjtE)Ek7WU1$h3.6S_9H^<tB01e3cpKC"Q:CX'1 at I-Rf5.<u3W'-m]-!l[$f)!=RUWId)'dMJ'RbXWcg'X2JYM>VSn-7LVWX%'r.%5+/TnefPQ^W>"8DaIWp.AQ)P$V/,Oh:Z^U!Agrop)o6<K;j5WRG`2W=EtgVfuh*e"Mi1l5pET\>6*sGouKgQBMZeG^BY_hX+DGA2VDb!onH8"%9!O57p42%fQ$;5%5ETqMO)k/.;l>RAF"GX.'8`YcArCrCBBN\KM<73Zn_/M;ee3e2S[u/rP at X3Op8f^,?_RV"U_KSJYVF"cGs<Fic#+AWU5`mGU%Y:;q03M.&V>&GAi)T530K9!D#iOn48h#l$4mRkf9me=pJ&GrU.Q_o(p3E[fmtaV&]<LEK at +B*XB)0/49BA;tl'o-c-[Z_gj0UTZHD-)7Y0Os54nPF,B%"+mt2dB#pkqn/0`Xk4AQhTuA,7/$=:<IG+GW\UNlHTa9]?F$lBBF$,]^9"gS?ke)4J:Y66QAW7&NC(HH8\#h=f_&))RZ`FcSWqDgPAok2*)1:m0%f6qdl$?@WX?0gdaN[t)[\0N'hptT=':FobTl&uUa-2!:IL?TX.OC[g]DL(e0&nc2*lGNTL;!8cc34Q=&Ik:IU7]E5f!GXB';c6B[(UKfNYtgqff at m3PZ5a&gcP0nWY`qVRYI(h="6BkrLIRJW\ZAl/@\Lke%!
 -VIaDR:&b+QRrDY_dZ,;'d"l1l9MiQmH0uC)^o(_ubn[)'C/&$dh;=Cg%BD8H04]hA%8A;BJpT$,&<pAH;=`+'r7U?W!^U%>E4Gs*unrt7d;/_Y?d-=HU)W1WY865G<YM5?0fWL3Nch?bA%dh>t[J$?PM\(mrm at MXNHgE$Lm9[TU'F0S7c<P!*r]FN/6T:*YGdmMT@,94fmQ"'a;N0F2r+[:Fd'X7V8U((K?gS<9mW at i?s1aQ"=Y/OmZJq`D_N&FdXO#b:dJl$J<Kr&%(WN50T3"H[)f8]^d)@[4AB't]A+NE]kJ\@::G9'f<uPC1?*hqAS4n'(P%*@m(N@]_*)X[i9rm,D'!uml<EXEuC8S)0RdRiETe66!Es[qRA at ij6i1AjRVm\/n<&!%%&Lb<Y%A<>A/D\35=tY$50Ph0d%!F/tFQ>`p0R%gb35OVUF at Bqn<B`!Zh?gTP5D'IF1^]c+F)XSZeUPhT8U]agcg0*p$V(5T';\UUob2"GQ96OL, at EOhYns([ldqS>!FosIoC87'JEDUP!6p1QCr_+R.;dS479c;_GsdO5<kd:#On5U(4Zn6]aKpe+-##YpI[=Hdd7-sR'sQII5Ya";*8^hK'auG2OI?ZYH"I'8qh7i_$!L%j:1'ue%l'FF5*</>,>SYh%j$`b@\.6XWs?@t!klaLF:)8?g\(A.(eSX?8#BT0,30:/FYVI.;i3m5&A05:NfemE1F0#oLAKX4"66YQ"VZ,`d'oPjDf*b_]e_`S(TlrW&Q0iq*"S^;Zuf/](,Nd'`N1G:.Sl;$=>j7^<g10K2>(2a[roZ(^t6.@%I;q6CYk?l?u,FM,f\=:D^(2)@@!7&>Cg)7\pom*bDtN8[Uj_?s"KgJNKH>Hh(Hq'r.mA!([q3oNuVu;=$!&#5TU2F(Cbk5G@%?i?Is%`Efa=3UY\uZSU,V77oVFdXD$'`o%dD'L`R?(U^:(@k7eeq0+,^@<G0lFGd4<7m[`;[c!
 Z-H\qUc]G]h\jP3*V+JgTjg6U)0.Cbo1+JeAE'[OQ)8SJX"XSlgIl2Qt2hZp.,!
 SA$UR/GM
9\@4&HB,Jq-3in5X&`U/da.:N#b*^W3sD9mH3FuhpAqr4V%82G^/d;:846mLR&nq2W/$2?'Oe<Y.+QY?O=c5QLl9*#k)m~>
+endstream
+endobj
+343 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 342 0 R
+>>
+endobj
+344 0 obj
+<< /Length 2208 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasa1?#SIUn3+NQ^`FI?$*3NUF<.S$/'pHg)!8;Q&%#$bXC]L"W?g?Is1X[fM'lH7LB''t`4I8_qtP/Np[3+`GV4!,`TGHg[We>'_Op"9IY1<VT6Q4!3&lEDDsB)Z]IN*iP95RuGOE"0lggn+Zh5Q[..he^G$N<DI&)?8Qt!q,??oCML_d2dKG^eX?)ntINe4t6Wg:U1D6E/ED*_4:E)Dn%<5]ss4+-r.bBL>Snh>:eFr"H*C2gjm%@Sb]d.aqYS%>i.WpH/rNWhLp9T.&-;64HF7i^S].X&T5Ic(AEdl]knACkTtYUrjK&p*,XT+f6Q[3b_1#:UeT,U$J*lgt-_.FqF"gQ*cBLq"JEU/cEq73mIH'U>a'6L5RO8deP/Ht at D<+i-'1YVJ_EmFAd*(=Lm^JB!&r0, at Wk^9Lp++rZbGYQrme_;%%3,Muaf>HOL:p=JSc6E?,9/i'aQRREP\0ZMS5We$>HNLXG2ao`igDhI8j6plRJ]"l?8m@*`\cHaWRJ:WntGd4Pl3+)<:+S1FS,3^\3h-?Gh\n0fE$1Us</+FR\qCtPC:NQ@`=F3VYeL^8XkPg/B:0.U_f:97.cI`RsPU/[\&D#6Z8Va&"qY/iBf+thV+aUa?A]3/hW4F+OXO*:M/ie`q#X2Y5Y/ucNF_&G-?S7LB`L/fs$B)]_]u#ZlQ'Y]j4n_ at 7b]U`BnSnu7Wg<D&3KA\2&f<uUnV/7IK`"d3BHr4&Ktef%NA7DeHBXIAmVVA0K?#>;4X&g8:$h.$IIQ%4dg+d$ekkFkYflgtd1#-_:NjGDrSS(]o+)VgD?jE+brP8bS=Q!G6elF?5-C4Ck9]?ZoVf=FVg8)%8HZlrhsm#:W<EkJn>oR)oCGiK;D$-*kO5<?+Ip+4mXhEAT_$Qde\g.Zl&;o2:RD<I+UmInRrKC!P-[mu$fbg'[W,.hYg)6@:$o7\M\u>F`L,.kp/_3t'!X1*f)gB4TL"d"A*j-`RIdnTf,\!
 IL at l$;E/f<++p%o-8,6`$HXmaWC$9V38)%NT<($.Q2ENh<;$dUh*kCZg[jG4U!:p;Eu5l>UjCl03:h_#'U1bNe1)cr]F(mG*<nlj-.a>[?Ra?1)(l%kCuo6S`Y6g9g"276)em&jMrGZ+nVJ2S*s>Fd<;$!KsRF>/"4N8^#bEcU>?<*R^-hP]aSG%(qh&_bn-)<9*#,8cS<4&1mK<_^7<B-aabdK8Rh0*p*1<*GA.;JMO#+4D;8]-*oB;H\ghJP9Vp\]%)COj\=g(W:JSpQFV!rO3\<=>@&1V8EQs>r%$lZPmUWic<n?i4ojplFJTA&77=_\8+)VAd9Yk-'RA;Cl"21CG#`?L0/Bt-=GEPEJQg><Dh,<]ZISk`=X]#2W#$BRjQdCW*WoafOIu#8Y%IL6'PQ4g?-*7+ZDB-;3[)qWFl[h#O[=@TV3&fEV"RZAD_WSm5+rmNVEl6pXA;uG1e=IgBEAd5U1E`,mjL6pd'5*r"i at U4>$$F$O&ca;A(8>[=TL1TN9BTi>^_JMn>LOm>[U?`m7NqG:)OCK;POq5;Whn6i#+,/=0rFF5AQ`/nmq@/=l2F\dLZHQeDm58P.KIjN$>hI0`"q\\9B68C1Y]#kbt:Xjj6C^t'cecDlqlAL*0CnY`*1Upm6307aEZ#rL&%2J2nE+G#C&mKl,gnT5'!NPltI4\&m:H5s.[>p(\'cuN@>/K:rGpmqpL?g.rHpZ^Yq*E+sAAGC.G]f&l>LdYZdOZGnWXjqO at nR*j2't-;koYC'aZ;%tX<G'J*YV'L5^#g9$aX$^bg9kaW8ILHLnd+9R,Snju[,6H]D7GZuR'fBkl<tGOH9I^\.(2!JdehEq.Yt#TQE/b6,D_Z7HAVd)V\Mg(;F)3j*?LgF'cggB=]>ai^i&i`O&0LBUI(@B[Y`sZgfk8cZa4h\D]%U'`m=6d&e76Hd.up/P,eQ2qfsm)"@8thrS"K,oFrI$C/>l!_Amt[?+ED&SZ(i@%!
 O7>Ep?_ET$+,-3b*lH9Z-*<J]Q#9cgnC1X$Y#s8citDeW8DVFVu%<ur-KG5qKB!
 3l[=5N:+
CcXd`$9b16ufo[KtJsU\S`YF]E1i!Y3"Rn at eP7/m<$m`\M*YjaVqWe'q/##gu549q?Z/YZc?53T"clF^?`gXrRr2K%<U7*Thfh7F#J5lgjNH"\nl/J+2Q70IhuGL>B`)P=o]hbi%"cBp"H;F&fToHB0#nqg=Ek*~>
+endstream
+endobj
+345 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 344 0 R
+>>
+endobj
+346 0 obj
+<< /Length 1087 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GauI6bAu;j'Sc?EKngC:aGG&IS[P#pA^NrES[b_^Kjk1p0fJ\NP>8"D?3uRm&D>F-e&b(ANm:)nd>*)a%PFX&5q]ZB\/;a$Ee#-2r?2DS4mBKoOQV:4k at QQqo!*7rR at YM>Bi0aEP*]\Aed4Pi2aQKd\I7gKnCc)UP_c&1::RoY1<m,uT;UCAZ^^i<2b+D^]A48>;5V4m<E/6_Ct;:V9BoW]m;+%[A,?If!S?ub- at c][('F_.4,ZuPjj,jFGO=m3=Hq?F0q=mCSrh\cp0\^>X&%`Ah#_$C9sncI^6<g]A5T1#)/#psX&@*D95b:6>JK6=>)#*:fr3pZ=F_RY4UU<b5kRu*Z<W9#2&jMu#EcBE at O(+1\6_S(I<brLl\NQ[[bq9ZI2809)dU6q1lUUY<WRqfn_(-V73uWMc"?3Z2EmA(:5]]lUe`1($#m*"Je7G!?GoR0D.Kg(`b()7"RK63V,`\kkc!n)@P.h3OKNl&T3G6jhnDP%Q#&,F-C56_<Yb!qPg,21q'ag`6lPBr0c'/\pmIF7[9dB;<D-b>6hS]DA5KB0g/H%"`7sm,I)$@V5,_M?SVdrXPk0Jk^^&EdOhNnEOm6NHQ2%:`BsE_^8D)T_!Xb`i4iF6`s,K7\UVL6S*hmPbf?55P-j9R+4bPS0HeCal"8'@]6SJVjb8u6PcsHDWQN9=14ZHj-]n/E";b<V**m at a8,$UUQ*b>(O)L*YdK0&<J&Z(&P<30Z9&WnUk*@+5aA,dl+MYJfdG40LO!0S:Z7CJND.Sc>t<"e)X]2q&E&ThG5 at O&\_W[QW.`9f7F93%L%^J^nYS/_DWm^Bp=*PCfl>.CQAQ_4#m at csO-N*%qEX#p5`)(1,<rMLH;[`ng:f'2JLSV:qkA:O6>.Dn&%>Z[q$hk'sl`&SrP6$*?7&EA:n5-c<RJWdp_hOio6.iRB^H7p\`*'D`)aq*1u^'hP';H`m&o\*=+o&e3P<cm93X+\9(?I3k0IBR!
 oNmgVI8K-.^dLYYH&7DRDkUE7$^PY5XDpc>nlXaIpU%tT$6HIQjs2+$nWP)+3_M5 at Qa;nOI.=F:(d7GC=86V`SE:VQoQ!WSk~>
+endstream
+endobj
+347 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 346 0 R
+>>
+endobj
+348 0 obj
+<< /Length 2025 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat=,95iQE&AI=/(r"Kc'3_-emK;Z'B_P?iU>F at F&%"_d6tF]1W$]NYs*[I9'M4"a]A!;h3LUb>1Z*0LIXSW:b@\Hn]\.UTjj!L#rljDPrlg.LR!9/frbR"MrO(:c<R(lPY%P5K-U'0Ncia9)%_+Nn*3WCm1/^$2e[P7.lOP:Vq"c667LtmBPA:,sD")&A\\=[64^7qEZ4gj^Uli%Uc^5qP"\/ncQ:[+el<'7-D&2aCjhZ>eM'N(M+AMcUF$p$7qf%cV8#;4L_[S]lm@/q\J^-]W4VSC>EZ5Ag&G7dBZif>>B>fB%`7]g2$@rgqhF5?LO4<q*JA%Cq4,.O"TE(i3ROne\oVTELM/":Kj$lt$3Ed89e;uoGPb4NZCjaQ+V)MV[f;L*:iRW(C"kaLZlh7.+4'IsBOe5d?fY*ugiE)atF^(=&Y^==DdH(P*_Ldfg;Ab(LbQ+Zpa<76pa^Zr`N0nS!%t+(%n;pk1!mAOJgG9WLK*Z][5H9T^"sP."M'_ZRSGjoSZZ!"_)>u<Y;:8V3pm4X&IuUT7UmDgFe=/WJ:<o4s0a)r4Fa'(%L:+XaQ5),PCYs1L72/'"ABLf6E=BTmB(VPomnd4D:&':^f(_uLj2ca<r'VGM'CM3I'gQcp_m-'NAH(]0_&:.FE?*c[-dM("9_JG?4ik3WX5doU7?aj(;@@8!$Zr_G^tCCLJ<uf/q_7-idtag?XK;q)kiLBDhN5X!OP'%cNGi5.LFcI#p:PWk!RZ3db]VGi<&&u,LHl?0aoI*X<dW<8OZ![-^b>d2KqVCNOHME)Z_pYfY6J<g>/GCS"uAL)-'=UX8Y?=t7mKiRru:">SdPu6a+>Gn&`_D<'7jlBjV[k,8<U2Yot;YoNQW-d3?LY\kJ9@#GXQB%j,qo/6l_`EZi`L.qm[-C_*MJXhd'9\6q<dAW#g:6S"M&W6,Fa]0mgjKZAGM28"."Wb(k5%@d&M,L)ohMOh(BsWaO!mFMS)<:#9!
 ;g'D[2qK'_NG.M(%rake+T]H^2bj3II/`GoDjouLQhGU2YTK#S%CHDL5EmM>B-j!T#ce/_=3C?-\eKO.r'V80RcWsUhh%8,uNb1^YNVKZ7>p5-V^bdm4U98eudiC&p7?$:cacQLM`EoSZ]pfs@^!T*&#d&_K0VTP-@;e&e^d],E8IKfp/!<F0ld2:\p2[d<=GC[J)5T'7DPZLE3k5=o5)B^:i^W5!_;P5+Q#+-](:mObI*YAl^0MOg$:5f4:,7tJ93 at ai`F>WBBed$7_:c7dU>t_$lIm6sD%cB/VG)Jg=#jd4GEa at b(I9`91T$].C;T/@9UNGM?!Q,V)I?]5q]%h+paPa/orI[^ch.mS^0:Zn&I\GF[cNgGTrF'@hJKPKE9-8"Kf,[SOVP1P6kp*Lm`]8%U?ApjSJ*J00TY?oB-YpsPf\7EB.@\b."NqiR"_&]:3R4"VIbrM+mDs>&@.ub0cTE624okN/76dW^qqY:H7jM.IW-F=^k>1PO;b/2EeZgtjRTu!\6WZSFp4+Y?fh at UhrG0R/Z_aJbjNo;6?Trooq/]^VG4rG_[2[p",h'dLK:JGIH+`piTB-%Q]iU'GDscoUBeiY.A+\WL67TZL;erkaD:P@((cu6P4*?Pk2?#d at 1d%9Z+,9+H]r[*RbHAp*$lU<gi0#(9od&C_1U>]hRaY\<bB*9TT7J]%%D6#=SVRA&UK at Sa7Uht6R4Y[kHd2a97`PQqTBS-igEeWO3dsDN at u48')lMoA&I^=::([j)k9i4,:X+nEbpE@?NFk'/ls/#*Dr&+\k7^3&)u"F,W?$IZ4HSik4_)14WlQoOs"8a5>g"#=jeU3UbR:?2="QT2`:,cVAEq=nO,PUl?E.g\1dq0<AjL<`R*Pd(eD84Gbad1JAcT[sCU&-ZEC:.5f_&%7Uj-q#r$?VKTD68D1r!lceQi,Dph>0L?2cZ3IhE7ejMIf_Z1dsm`j=LO+'7p_mW.8^V$ogu.M_F=c!
 I]H1![Xl?/_X^D0n.E`BhR\,*D?<p!lA8(%()m]!D5Firr~>
+endstream
+endobj
+349 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 348 0 R
+>>
+endobj
+350 0 obj
+<< /Length 2278 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasar997gc&AIV:E;,N$X@)=P8CIQ1cl@@ICS6GB#MPn'2R;C7e8D`]s*I6[,n=M/Rfj!V at h(Nj%HjR8f\UF.V(:. at c>&j+332)!]5li5]CO__R'G\6fNi>iX3Z"ih64Po[_GNugaI^o;<j8h]Xf?X8=I[AD`@Ekf9+P>GF+ZoI"'Z=07)kDHG.nQQ6#6?ZV#UgfA>6]U)BGEBYC*+1jn0eenT)nlS\S_T'b7P5&l"M^"R&.^?Wl3kIJ7WrtL/N$"aH\5(s[4Ze`>k*4>Z,f%CGik7mosmV'Mh-KbNoZ,Yi6efd)P#;Hme-7S/mAAmR-q5r[O_b--I[Co>XPk;g,h[<!5UkUUfj'Co<73)4Z,,slH_X2CjkWbpS]P7VFfla&#>uNqVXF3GH?^\F$IuqIp%jOGqn(2q'JmDe%)Zk:JF,26s%"@a#raJ!.3^p`4;/gZEYsV)%.X565VPs0V=,2OX(5W$Zd60.nGUE+l*I#)6>OY[OSf"R at .1.O]7EZ<LdZnWokP;48@&c:N](Uofl56t!&LPdim.`3o.!Q3.6I_SMU1(9u4gGLd7+'N?YqS.>B&E,V]]T"5]W2Oj22dMGFAg27JY=[*['dZ&0M6I%eGI#&OU7#b%NKTEZ_jHE[_'9i<)--"-oR+?5s"DXM7n_`L,FiE)?UN\q![X-rfI\9=:l1unK;r;WQob6=gk#,emiL%0MM+Sf8,L6#ea`,\)dGegn#T"a<p\J*pj!OFpZ at b,;$+Y)+;==e:fjGa2g;P9O=&srPYb3Af^.FD;^N'WA%iI)ERMb>2XK^Mq1Z]MCWE8'N?t)Pqc$%U3'"GN#mig[2q&.%0muS2-`")Bc\(d&P5r5rGJaNI3MEr\`:r(F2KL_?MJKOgJt_pqhq1!"lm,ecQH?@#HV-jdt1C!6)$CXT'mdeqRtI#%n>4sEHg:Z4)Xq0efiu/jqc-h.gTYEcQVH:7m"0Xr>4ClK7]JD$fH@#H=7%@c"I!
 S>TIOh$pqs5am+[<OSTm=Sgc7Ocm[&<p2">%<>\tVd2^[e>(,Bje?NgffLZ3Il7R'V'k?DbL>Lb'JdXCS[!S4m],U%WLT\]+!rAYtZ7>p?4^aq.T at 2+(em_C-*UWi\hkFt-SiuS7\OF7S?%]I3Il4n_+!=)AB]*H<!6K5+XL=7F/3d)'j_5i/F*-5;^IE`<MUJ.iB!hVUilrQ_7B2is^g@<*MYojJ*+D2,coC.L.<D_2E.g8/($nFC?ZDa;<.8HtlBd'Gd#qmF+j$5r&+Mo\_*b`QB/d(Vl=@Q!Pq\Kba/XUNj]B6RqYF3&&XdV4d5oV`>1h0cohhn9m.'MS[o+t.?SH"aE!0b*anK?dd0'SMbjV!pqqJ)q[&<WD0l8!/&5.%Jb.SW2,l%[2sA>mRI0bdnO"u+Xh^1SoA4XE'F\dD(p"mo"q7&I2YMT5O9D_c at 5=q'R<-/\%MoPTnekfmA$Y$N<hlsb4)LaSnI&'A9o1`TIJorF@;_smAUApgDQmFn>D",tMee6*W`aGCs``I?mbP(0n.__Be6$Y\>-#1"^@GDqWtguruk8Gk3;D`/5Fo]:UtZHf%\D4[80q8P*F>rF&6+UM%n\'gnYe:Bl?16pYV.cGXrPYQAt?NhC1KL4`LW8quN8s8uB.1Z1h]fu+a5ekH2#i3qe at k%u9<UtXE\1/>Q;Fs at kA*T6,&EN&q1HQ$*"[7FpTUCAa;MoJsNRfq#gO"9+oe2F""%W\1=gac7Yp;,k6V+T8XX>HQ3^]VQYRJp_%PWhNRCd?CXYjIN=R1CAN&J!-1M^U(-U(30UKX4e:U$VG_4Fld`7*l?lEMBSfQU7S^$)m%&u#Z.X!Ag4L1+GOqH])Yk_L6^>:bj)cqKFng,,TX725A+ae-DaYT8Ij2:c_kl\ZTX;$rl>['.S03+>t,+`W2G,gd(J5ZF9]%RmEnAlrhcYcql&oMJ[?>3nbV-5ZY_pM0^](V(rJ/EiMbNHiNS)V0B[P!
 l?f8O4ko$%#WV9h4,lSUX/H'@!!V`?`^t09Xu/[,ir#p4jo'\I>XK,`ftR*(E9!
 ;'h@@\s;
(7JrH]ko4#rG6NTu!s`&97sA!77*+$t!7GW)^!eOuUIR2KY)V6T1#6UQQU8>^4rd3%LbSg>+ooMhR;7m8Y%iUO<2bqbOp%d:>V!^FWkjp6dXXM!lkQK(3>Z07nn+OA?i/bl?/OfBpgAq>VB9C,$-*+cN;sg4<8A<r(#/2]oJ/hfpj5V-XF*$#sH;E/j5mXc=Db1AbW:DYr"so]J6Ds1I?Dg at B29cmSc&N85B+~>
+endstream
+endobj
+351 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 350 0 R
+/Annots 352 0 R
+>>
+endobj
+352 0 obj
+[
+353 0 R
+]
+endobj
+353 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 340.168 575.84 409.338 565.84 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 339 0 R
+/H /I
+>>
+endobj
+354 0 obj
+<< /Length 1785 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatlQ9lJcEoU]DuoTB>J)3NE]L)jH6_)e6EXTirNG+^G at dO%U>75kO-rqAR4Pk\cf:-'(T!kh+<mn`*Eo&B@,>L7m'Mrj(F=DTYS,(LcHTQ(=[,[_mkMrejHkLJ&Sib]ZW=0I'pT>;&iMn^%N?]PKQN0,qPK[8ODQnjh9L at DIlFl=XL%okJST5[--TeBre/bJ?HYjNp"3FRbQnC<"5j<V%>h;8,`fD;dqSC^KkC3<YE7QG!&cjf,$pHj_-e5E"#[W139OGIs(g3/4K7RSapF1E&d-1adE+e4`U)[q!CZ*S)-oPn<0Ut4R+"7dG.>'lgt\a8:4#/LcH5$SV<\@msC<1Ji%1 at Vf5ah&!q!k^Kg8[u8C[JMSmo:fPaKPB9:>"PE!IY1BQ3o6oL09n.9-GeJ=Li4fO!udu\7d>+>F+e5,Wd-/]X[AML%\1>B%T8&hbL_G5El<E64eop7)ib12B^h9&/)WpJL./f=5>#3<H0Z#L at GPT%pI<kT0Tu3"`,l^`_>2lLmGr.r')E=uPh\-'A3M4c$q<8#hJ$EBE$\Vj=oAdIj^@D_iNe<P6O7c<&Jo$G&1E6e.fp`pd".?`Q1>=FX:*Pu[KT,CK%6QroNNk`F/[^%D!J8*ZBG?G)"%/CG"#QKot-,niuMV5fg7`C^3[;8\3<i&N3OW(#DbPN'2mXq#1Xk*4Zr:"dYXhk+gglIZ&-1bcC.M%Q)D`W`=SVQF3Y[F'0`8AZIL?JbDlB7-rFhb%C])1]0rQk5'O?$OYGo:(.le3Tm("6VM%CqTuS4Z9iAjq!%9c:'40>A"7GT[B7'#"s*BH>#_+'\'(52]WiSLQ2]jAf;BQX'l'kfrUQi]0kA_?9,dg:&XBPFoG0iI[kYsWSHWskBs.LnV:lnCO]tNTjaFpBLW(C'.]PH"a:d<H`<2E<`(T&@:15MAVps\CnWKaK1f5d1;8L4tC4m_p&dKfjUWKI`DZ1n at 1H?S0icg;,sYao2,pd[!
 M42C^qT`B6dSQVTH):Kl=pHcFj&B.$Y;:95>8B%VDdY2-R7g+1kQ]-\%ea1[1eG(],7I;@WON]KT]!<MQrW6qi?oXjh-f&@#/c[KXhm1;:r_9A.3VUWni1bK\j06S!=SM:u4qP11`dfCBYI=p+m0hqg[Ep>;4*^IK7<e?f]"49ohVZo'%!jjhKBoX.-0q_YR+c>JT`EqsPA_rgP*1(?^hcHnmM@<['35jY1=;\EcR+()ISuYN8A^]Mf576'k&!VBV")L.uJ.5rrYQ;o_hsL!Wm&Us[e at WV79%@[pY1]9bFq at rQ].;:O96>u52(K[rD:?Z.[="KE=\ijf7=$OsmXHcASi at hF(Pb^mq*e6fW1cD6^'oc07U%.0Y`ikO at eAnMA#I5VN\HJb15UrUN+O!T2G&\.Xu-3"V*1pmX3'\Eif"&,\!`3klG at Xq%ad^\lK^9]eQSq-a$RaEMM&JioliqB7*]/JOEhD$1^F. at NWP!?HkE72m45`2ciHqabnJ@<D'AJQX-5!d/e85oDq_X)<C`e[LG4>!H7dkr8hgLOQZ at AIfrffU*SoP!Zgfq#*ll\[FH5a$f?h^Q=6+`PN/A(r<O81*3lKZ49?b#i?R4Iu4mMa!</:q=I-$RU at f,`?TckdLjI\H9(atVi6F6,<:acG+q"]Irq:A:&`n<pM.48PEG*:4&PB`IM?iA_h$Ep#eq[V_[QPZ:=J+\*o8I4d.fM]>"GYTlU>\l$A]6M*_5GMW_A[%dR0\32k$!2t0HOsEG(D]AUHY&0u at 6hF0@cohjS4/IeJ"T?cXT~>
+endstream
+endobj
+355 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 354 0 R
+/Annots 356 0 R
+>>
+endobj
+356 0 obj
+[
+357 0 R
+]
+endobj
+357 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 240.6 536.4 309.77 526.4 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 339 0 R
+/H /I
+>>
+endobj
+358 0 obj
+<< /Length 1385 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gatm<95iiK&AJ$C#^],EF;aVF`tl at aD1M#I5S;o=*YaO at eWiR)O)0HCs1KY>1auUkP at EJYLRK(jkOHgD&*qdE at iF8:Ku&)E$A89a#9j"aJ>36*j,foN#O>mhqsF?qHkCL,jLM5WJr`d]9ALXXH]\&/n40_^`=n80JeG5>G?qUn$g at rr,bJU#>ZCUFmH2]Cpr?<&E7?C2#YJ$*aYkZm`eq,.@>X0K&Qe>J.V">i<@U4]HB]%f2LReA(/[J/,Bg)FWnlHZpj at .iLZT4+=L'YR5@!L'Y2U-MmH8tI%alka(e'sU3US!b3HcH&"rjtZT!Dkp%h`kM__<@PD;CK6:3J[`YN)`cHM#%;fug=/lYbJ")NDM5(Ke^"MT3!?1K<_Q1 at o%H<-!. at E/1N44k<dXa#hU67E.KsCZR9dMa"%FVgT(U@(]WA0Ck%BHPLo6XtiDIiL[qE_7Il33_(WiM%Yk(8p)ItbH,\=qI,W,IS$K6i=S at X-]R.p<D?Ei*3Pu6BY)8E,D`4GC6*4O:YJdS)9jTrS1\A0-Nlm.+p[m+jcf]>nPGI\-,ncDW:G0/O/3PEl.c0W&h#6 at j?Ej)6I4$*gOME*du_EH;E4CKmbRDmNb8><&RTQ/""9#T71R12W:*SU-k$>q7FPH*#;7:h($Eu$K&]Sd'ir[86Mq8JRPH&<UtjXGAs^',MjL+[Vo?)IjW*3WY=2Y3 at O0YKC>%tbmY2tU7D+)7FhU]'$q!<JbB#<BW$JBd_'b2\(ICdId0H&RpC(`S&KV;pc(mRB:6"IX3LL[?YpJ.hZFrO>qh at A]"!15M*Q_Zr)5f2]/rk%h2QJ<o*b)2%NG,N50*OJ6HofF]U<c7=FI[/sl;")A7g=*q2rm)oSH53eAZH_[L_A0AZZa"Q/@J^5G\h,^BuZXQ*7NUjG2n[tG^>gBfG;AQS]t(BB%bIEpLRKD$fRZQocQB2^42U6\npn5aeRVfp6h&^MEHBYc:Flnj46H2qW>!
 CRPG,P-3iUZX9S%q!=E;5in4->g+AnqpOnkq'd.a*-nO*ucQIDaGfMVkE2G8.iYnbFEQZfmfqNU1>7+RqkRqu]*SR(R>.)LS<.Djs,l_R(F'ZJOb%M[<u7SNkF;Z)Lq&qf.jEI>NG:<YV#_Erq=>,gMS+ej)8p<W-m]Ks>U/7+c(#^AGZNk+_(d44,-G]>^Y.Falud=i4P!b3aP%]4frKurZjn\u/1o`)Wd0uo)uX&gZ\)"EN8GWo8PIE^g]-5\%M1U#fRcmKTLh;l`o]4#a"k9O,)>9u:H=)&g:dqJhgR!I0Ycg0+gl7[d@,OSh at P@M?;@9&4n\,'t7Yb#Zg,Yh/CO-,eUk?M3&85j-N^<?4ZqQPdl1bj-=d8*+l4 at 7<s6mA\r59T(^GQ~>
+endstream
+endobj
+359 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 358 0 R
+>>
+endobj
+360 0 obj
+<< /Length 2241 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat%%997gc&AIV:0RTi9lYn.JcOF'N8Xgn-H7370LH&CT/_X5MM67n+H].mt%RnekD989a(XA-6qD^hPj`cWPq[_r0pQ.=:XDbbnk/O$<nFJ"k(<e2G-j_8ZEq4L!J%r!$D-:pAGnYI4G"0`\@aBeMX/;`DMAZn2S+3Coa6F2*hbLmZ(;HGF9JB(;BsHSH>.@`Fp&1`(j_T5>G$&NJ&<:lQ]/m-!.u``5mn,sT>KcJoebPeJdp]@%6%L\s$Koc3r*sM(EW:S`r#"B\TW;X6%&./C,9JFHIq(&^=hEcuEtSmW]AhNQ+d+Z^7c,#h&TIr&MQhZf at aUq.c\@[h.:Ugb/MH]3g?-%'m!c#-&luIu[jGgqA#m$U?L;D2,-MI/Y``%(^2!!L2=EG-_^H60D[+T!6YmqOW0X)TfHUBp5B0!UpMP87bk)-H)rghPSKW/6hpf"a=ku1Wm^0 at oC$lYhd_05!&"km#7Zi2.VYQh6"fE6]/0<k%D+?o$Hn3.HR>LuRa<3]Adr7'HoDi)(f1BbPl#o-p\%Q4.rH*/GPt3$@-;/,t9#L9F%7q*UiWZKgO#5&BTZ-Z"=R>*Ydlf^5fbG!fja2dNWcC93$1TQ&--s/ScV8gO2QX=.ND$_#*TLq);mA]ZgPf.CF%E5HS'G-`'YKu$[_->5gt98CTg>,R<[\I>1&1C-.NcV at --Kt6(i&(^OfH_\7:@uopKfQrY3d25XKh(5i:1'XnqkoJWEs-O!-tu+1U,3$f)e_\UKF)kb,[B9a&!;<B!DFiGD3H%g%GZ9U)]ohAh<Bn6W7dC`Oal'$cZFR.p:C`/(bE'=!.pg!(D_`WQ>#gfE?27+bHka:frGp's$FW0XW3V5RR%M(ref'PnPH17?F1\f.&a*>29M$jU<<>]H*:]i+8itcIHAg&kd2$4<6u,?I&8OhQ2Yl5?J^X&SB%q`).Z,M5-[kFbdg!>o;4Dp:d&(m7Mqr,,12\?;]XA-m2=sTuQ!
 ?YM?81)TLXY\.>frqrsn$\iY9Arod(37V$:Db<@`2BlT0\M>L#4(Cd#(J,_Ca?e\*2hl<&gFZaQnd$P*atZ'M`6?#Kuhk!q9ic<o)bAY@),p&bhf=($R6Nim</2kh;7,eh"9A!/O8?JjU4ah at t!l6C4(+Lrck&^^WM[B"Xmd+AY8Iu`^QE\F9Ga at ANYU=Xl`Y<VdOg`KN:qC(o)<9)s0[j&Ah*>u[&3eLPpp at -FQgMfhoFL[gcVfsgSlG:["FLeKMG/l^g]0P5Ao_Ofqf*1\2'S at d[]?+eb%-Y(\L,*%p@[KehY;a@>TG\i_9*=71WU&(nh3A+(J#Gh<ZG1G#D]LJrYtrZ(=Z?*MjV&(o?FtW;fFndlruY94#U8GpGr(s5SomrleXh8U%5It3am=;r.RR&heCU?;Pue`6?1ZK at noe(;YF%K%G6V63eJX>72k20kjEgf"\-2S)nEL4>!%OV2=o,#/:1FtcB;T\S0ST/7QM>ESSV5Sm>=gbgFLANg,h4CT2d'1&"nrb<qHCLdF8E%g=-k^I9u_]dlY!14b"L=#kY<dHE',K+`R>aJ'&$S*atKh/cRjB7]m at Kh,X`]6Uth"4[Xa/=RroMtNm8_<6#.e'aGo.T1Hag$a:&CDo<ut&_oaPsnb?MCng25Zd1KW0"Oe2*p7J@(/tBGG_Y%Ce1#S]dTd'FK-S%sQL::cbnc">E<5ksgG$q at GG3t-W!Ks[7;4K#**Gm=hO`Y;<[P=(ZC,s[kPYsou2*4j<Um.qo0Z``![VJe:=O$WZ5iZ72,8>Bo-U+3Mb%3[iQ`aK?Q#b1[dsN$QR"M+ccUfh.Ibs5+fuj5/M9J=Sdj![*jRO)L/tCAEYeIF'1U$[$Z2KjDO5u[`%?N&5.,n2RNlk;Bl9 at 8-0f;<'Il5uqA$sraW.Fk0)P0M@`GfW$G`-a`E+SpVK;FRfA:N;B.CJJ::XdlQ3rEP[[%\H^SM3$^;.r_RSo?JhneQic$nKM4i!
 CZ^J^P\2>-H?Ir\SXC:,\=,/@S:o,>EMKk`NU-\KLNVdZt8GbYD8e`Q)^NTR?+!
 ,Is-T(eY
15/\IfZlhG0!n\@DX]5UkW;";3igoVV\ncO)()ZB-LWhKs[)"]]6tgm4Ji!0ANbC8mI$^dWNh3=.p<&C=UjobL=L^m@[,Gl(N+rH#`Gbr)96n3ek at 4KSDsT4W)^cZG-/5k2!ne1?/M63/!P'o$upsKmhVj[+]VD_hJUcZV%Cc-Q\Mg7!s,Yb&M5Sr<H?TipQ~>
+endstream
+endobj
+361 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 360 0 R
+/Annots 362 0 R
+>>
+endobj
+362 0 obj
+[
+363 0 R
+]
+endobj
+363 0 obj
+<< /Type /Annot
+/Subtype /Link
+/Rect [ 154.932 559.821 209.372 549.821 ]
+/C [ 0 0 0 ]
+/Border [ 0 0 0 ]
+/A 332 0 R
+/H /I
+>>
+endobj
+364 0 obj
+<< /Length 1701 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GasaqhiHeE&:Vr4&`#gDe*U$8ri,9KoM/JeIAg+&;BM>k&;MN%2WV*U]2@,Y^"?`.%c10_eM3\a@@1sML4%j\IeYp+_[&Zrm;WlC:Fir8e3CHtW!BX7!LU!up%kj$BncJpIRHd- at Da!BQ6#.IT,o!#SuEAuPZ'TmIUuO@,gs)p-7p`><F$Vm?kbTb-gq-`LNh"0KQGO%H1-#'C"(V^djP&s$e[3+pNl_;$:nS-1(?^A6'*HT(rqZ'/JDBW8Ya[mlYaUa+,uhZD@/[,B\e1#1ZGp:Of2)d at pR13V@k@"c9?T8T%K,%M1'])[u7&-D^%XN)7H],<X2Ft.D.&u+GO&ed^G at rL3Qd"2d1M`#_Bnsins56PrH8,b\S at K`RM4((6!DY_^cu9!_!mSIp::@0n<j`Y at gn`h<+*-F$3g at O523k,ic"qph>L[]\Du85O4J^1hMZF5`_<e8TiFgQd/5dEV.S1IqC<2S0Y)#N^TMEGLA3sM?O[R-l`o>6>E5#K/6sOkM/H7KkKJ($+!VOSrmFmRFI871K"XCnMCQu82.j!dkj03`ZR"-B&OUEK at G.7LM%_<1?3(gQXj?/)dcfZ1kQZ:Mk\:J68Jd9eVGY`C6+W_gKQE:aJ)t8$Kr0B'?^HW.Ss$7VdRt'@l<@"R,WUel.i\G3%^WF^"En[$`U^AJ+qQ=nhVm2T`-8M[*C<o4i,g2ejGNhS at cueUD/>?MBY%;Q\FhsZH.Klk[+`64O3=r"tZJTeTZQLGJ%M;I-,gq^>_%YMJhT=l5@,%[F^p1]>%,&+Z at LpAVE/SnKaR`*O&3MbQ5`Z6to3.a"UHWarI>P8buc(Z^o'lX'@Zpq\ZN%XUHSk*uX at G`t62Cp_Uc3)n[2s2p4IKa&0;%HoDeTElG70X1<`Z at 0TP=$HaIJ3[Q0??&gWBBn+P]n_,t5'lLZsr8=C!pu[Zhd08@"U6mYsW0jh7UXGWY-CuLs`c5;L`r<f^Nmnkf1Hr7K*]b!
 eRDtV(+Y1\JrN)CH$,0Md;07F_fSjdiaHS(U\aOk0Oo;SI9(b0p5qk3+29VX-D`=::?#XiY6Z8<"98=g5]VcbbfEPpp*9,7-J+nc1VEStW^j)1q,Ne at Fg#*pUaZdu at L<CDSdT.7)fg)o49k.q)jXe_<7;qCbQ-$g$kM/_g5A)&f_9Idb"F%@:3D-#*h at b$@[CW0TL]%`X>B>RI4i6V=Tf_Oh\(KQLrnrArsp!%:U_2!5gObPa<=S7197-+tV"!&mXI*9D:@)bnkof[0QC+0)3:r3\6RrDm6G#>_ at U[JD>kua!5?UTW##<s;DW=kt=+qtX>h:[UsZM$E>^^3NY0/BsP"4US$9A]*OG[RPOI-q6qp!-($&lUjefaV@(Kq!1_hDcBVYh+YYd3:g`(Agih%9q=m/XcP+bP/E.L`7foVHQd^I(92-:sF(t#>u7I1!&aU2a[10Y22ZscLpd1,>BU>o^LdhUD1,"%*)PM`H]#KO4T)>a.2]/Wu&"LMOuL>.`K4[@!Z-28:%'eI.ugN7>(0ZAu'/aMo!:L9VF-2.mq4'VkB179Fg')MO?Ue^_KU?Z#[6b2"&YKF_mpCl5 at GRZJ4/3qnMIC2^`<6(nY7jXC;!@D!&HL=5WXg2>T6MeHI8aD:=Oj23N'0>lDD5]X<+q[jOetbhW2dZh6sZV$_-2:(%H*0u383`t at ZFRi')`36Iegrr at 5\>p0~>
+endstream
+endobj
+365 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 364 0 R
+>>
+endobj
+366 0 obj
+<< /Length 1653 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat=,>ApT$&:Vs/5j+t8PrRQ%c;>[0W`,m^:91Cqp7^`'=hG+ThuoNS<;""M^kN_/G*>CX,(G7.4s#dZoCh2;a2mdUjuV8qL$K^24NE.?cggq)R(,?O&nbE1IpHY>=3cdIp#O:kQ-B?'0#X%H\$Q#N`2/[-8Q=]S+J$XNpi5"0*UhlRCbstP?5h(\n#k;'21rkfm'/B)>a=+7$ET3B_9-CqIYZ+[PSnBOIu?u"e"eSr0:9MJq@^PEk=."[,GX^#e((2S\s/18kMKZ\"T2]d):%\Zs%VF(hp1<o^o_mWeMYe;P"07f2E;tA96Dn2jhBLnjcNW85cEco?c-Zq?IR&$,)B<XL_ at B>Xp)(F-gUZ8)TuV&!m&n+!aX at Y.uFk/@<n+i_U0/-GJ%Xc7\%kE"`FkpBC"hMQXlcRD2,]Mi!/t9-l9LQRj]DaCih3!DC6.H3%c0?1`%N?"@tqu!?/e&.h=58),ccW0[q6U"@F:CaJO8LPat?qT4.r=,&n1]:j+aEqatn2&5//iV;#,`W(ILG<f/'b(PuqtI,>:-9FSod[l!,F-(ckkVb_Q)Us+n$d5G"u_#CLKr>so^9;dFAaG+[AmE"keb?!kCA@]D(7B$h_PniO+6YY5]].Q3<=YrTIM4JJRG=hP[V2$LXPOZF&AXgG)[_GuR@?@dSB4_,?CAS?90P-2P?PfnV/a*;s]g$9ums7C.[bB!>os=k[>a!C\ZHE0_<:u#h+`LW5?p4A9"L]B0T`:Xs3P[hCBc>7-;rFnd]9>NZ at lJA*!5%ATBMZc-A,DOIiOGt_K8LGL0"Cn8#Z>5><h+&h9.d"U*/fQ at 9UgCM?tcBo8?PCPM3];n>7bHDlNiX.YD1Sg2Adf)Ym7%CK"I^i/BZ&ZLQ5GT?V[:%qW"=Y6o2BlXMC42\rF)qCS^AEYt."KqS#!L4,'BS&f at 3P?4I3pNFdLCNZp,=k%1J3DO$^aOG4&sbV,QLZkeR!_/oF*Qo?Z(%M_!
 Z=FE9<EeWV*hA:qlpctp'T2Q./^h;sKqYN__"[\DpH'H$aMW\UW2Y`'E;VqeZc"nA>N::It<ZJa%hcB#`el21_&gZMosNEJ#[R5YSjVOA8Pp&@b&*_]Ht(`T;9od*n%7ZS4DT+'fq65l[9Y></EYJg%aB'PkYB1^Qo1QI9E!/'ks2_VV-EKq*tcjm!5G5`aop4DV52$5R2J$jnD;X!%,aO>Z]cK8iXU)'.W%LLh*0JeiKI'kdo2ob(O???J'*;5E0]Ag9f8tV2)N+dBo,9#Mri>[?9dI+fE*Ua^<!b^Epd?Eps*+?Z*kuON6,BWd,QqXrLLPZh1KVr5GGT*:5IhlLl]K#<u*QR7Q"GCB[[CZ^"]jiW4/lfM)@t.3:lh.ABcNe)0eY=pd0YVc_P%9!LUBKfc7]C(`nDKYq)7`G$O&m/=1G[Ik/ZA>CfU?;Bb>Zs##uPeY7X^=DY3SiD*('G\lQ!f:d[Gt()RPV1g\<[s#fa=EEpTtGD`?fL$QndKW`H0sbZ=5g^47Qqp1uKO2dmc_%lA6D9.%l<nKsesHsmSY_c at a<1WRmN4`k6sc2h:\(D#Y at +S52#fM>i4Y]aI*$>4kYgVr at CA;-YkCuImgF#3bsZRs8)Y(?n'`t)Wb5o`3SSWb/*?N3b0=D3Ec.8'FI_]rLp~>
+endstream
+endobj
+367 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 366 0 R
+>>
+endobj
+368 0 obj
+<< /Length 2748 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0E969.'&\e-DW-#:M, at gLtfZ@R1.]I6%WH\qXX0!((5n[XaeFI%-Z^(P3OPO;'3L&Vs.]!NeO$KIIBKYq)o?HG_LC;]GcJj+nj"0m_m_U\CGN!ig)7uJZj2LV0n]P47o)$CYQ\6Q&*62:=20+n]V_RpU1$NaUA"o:0$$2DN at m\a&14ELks4&Ne%a%sD^!IR0&<'U at bGNm/(`.WWc8S.#`:Iu[):+hpM)h&^m`0 at KG?Sk(Ct0;\4t8:!IkKJ+dUe`DqR_[s*FjIP2EiXL\p;(WPAiSNd-[9Ogs?_>+-";\Wj:G&3XoS+6pl2"Cg*Ag&%Wlqf+qMabMp5)7B)*ld4BXpoJZ=[Y4's9mmSu%7-KW<Pf8qfOEk+Eapt`01R0-Aes>b`DViW8lB'3G2rF9AiC'FQolldao,/Y(d0E\E>)1ph]=L*[UqY"3.9DT!klV"#7&27;r;8RUP\`B8Ojf5NeEdp875OB:f;Re<M!6S9::KAYMuE3J')74eC:hc3?ETJ!0>=Aj6#BW/7o`+rK<_4+9h!uHf21S:\tnHVZ]=i+24)=C'm&&U-Z at LKH`<48r:e[Q.7l#+coPa=En.+WL-dMB,\gbXM?m]&@VF]-.*dZ*\XE47e*CbY_Gm?$pT%oDG at _YG-=7F.iU]A0KfDdpJ/d*Eh5KA$PBgK+-iKKSN)*HAWGPk-^2N$b>F":_<\':j2A<&ldthDGW`S4V:t->Rb/0=_F=c`]pY3N2Q:TJ=?VL-=Rh(dJ%)/fmCNY?/LF<dlOo0B#%$f>.e?khBbY2:Q>KY+`Y-.Y$_Ytk_KFmHr6.B8aZ[,UdRgR%?kcAj&e5<q6V.s"ERHo?22Hm]INHC_r4 at nMKnuUWPns^ZRie=$h>.9D52>r5k&c3_IcIhHY7^7b4S"$;9D<n7u*!F"/)c;m8;\8jTkkBi*F=O=Td?)Jmo$fbt<>!p"ChoLu8A>l#\KE:j at a%<qkX*f2%&CXcBHk<^M3M!
 94%>pd%^[I<4bs?Mg_=n!Cg at H)3\uec.f_.foUbqsreCt6$<Fmb:+)+i3#gCG?eU;u8=),Il]ObIH'Y!I^i]?1HT:h"d\iCVnLo=;%<eVu3UNuU!4;+nT<G48Y%F=.m:q\<7gKP&J#;@nJ..e:*rnNG!9%@N:DMcHZr`]ui<TT>S=pk<@s+jFH/fK=S4LtstYtpPI3^c^SpP!bHl)J>L0?Y.u(Y5Zj5]\HpMZ]mrR$id#i!oai"SeZAG&=?`f.NYJ,W5=rkZ0rOXbbG"lqV.%f0JSXcZtVU\ni5fFUd'EJ;.c<l_??WN?Eu+79&lOoD/(?Rj6A>)Q:s$O_L8))of7qrmYE^$mU]YCEeLE^c59jZ^3D#]-&1SOc7C:-HcJ!hKK[T9;BAB$sR;G.5_iWPD-N!S3!I6&5Z%<@92Iejhae+$4&6;+R\YC]m;3Gqn1_VFs4juT7pCm!2up_,Dje&PdVnc:W21ZaH!Z at +,ef'6R>6-1(B!=+^qg97PW\p6 at D-gPP%Urh;$TQ/rF.Z&UG425\MCZ;jlrFX.!tBDCiH]S,Lqt"$G at gJ#]1^HY/^'FG""_]Xf?b7_"XMPAU66:F"g:;ka*iJ8<Dq#eHT;"RF at 9Vo[6 at gG66l3eO;KN*>,r5&kSRIW)SR?uoUVq]sF(Ui6j[cgu-r+u5d]$@QuhF!9rH]Yn7l&@'V]#.=oVOE1h_[tl``R.dae93f%'Vom6:#>^4^"*I'3S at D;(ID[iQOjDL=YiVqQ8(=$3&RHB=UQ#HHXHeUomM"5*FJJ6:`)>+!eYW?%&iR_*_+1UKgUB<K[d4%'O'=d"W0*=E;66\O,%lS7Cp5t:4=2\T.hpf.n+Q"_kTMVBX+ZfBjJ5^uRFkDKJ3+(EDnDET#tt97o%lX]`WGHK^t(CuY?^.PEo"htLdL&T.>Ygb#^SGU[/!jK(mjD^`<O.p!;$(i7-F"RZ"H$n%O1c16?J;:1SXm<$uf7>F%,;T/'d77C!
 /=.W4EG`k*AXXA.'o/oh[p8YEfXXWeO6M-IbYNueAMcq'UqhKr4<D%c;ZR$aCB!
 %*6g`k+f
qXP<TKQs]f\S.jFr/ReVZe\5c-#@E/^L`o+CW"(J6>`Jn#0NVeE/(7G-1T'_(Y^4'`^%ga(,bFBAEX8Y3\g/RK\c(qk!RL9qL@^UdNenm8k'5\T;Z[*HE*)FFlL=YH>0FJA at BRYj5Wo+esTr[0iFQ]:t at 0ku^6UF9&SB1I"YnSd;O1LdnG9NLr#Y9mN%,J#-J\LYG&oJuGe+,Cl!-*$k_aq!<[+D*e6BV^7^C84X`P>g`Y9!@8`8<&qf_8c^Je(WN`7!YE98d_*2^K\Q`kJ6H9`U-J2O^@]qDlkb&1+?KQ6Fo\o+!460AL8?W"[@>+pXi(a5aXJ77WfFZPn2uUKAgnpO1&u9XRXO2Y2INK+,(Z)=)7bp<gB&uK9JQ2t;l?ni1<\C/akjH at 5*7NnkBmlJ'BnrL+g1efiWc*4,94a?*?N`#ZM4sj]k2[?=.A/eRu&7P'WH_:I\1e?P-0^UF:>Csj5\6`eqs=3V"p=K2P6<$Fg53/J+IRYaDfBYgtHK2[Q)nBk'laUKu_5Bb?E?2YlD[IT#r&<I;c.REq4tf?)Eaaj]ft=10VA0P.=Ztd8682$PU12U6A,9cMuc'PC%<=^KBDMd=6JVq$m>-LOXK"mWg>HgQ#uJC9bDHgW^8TZaWdb:./hLaK\l"p5d+(?ANW)ls%#%o92Uon7Uo&rfqW]mQU\Y"=W&L8CDtf at UJQ0~>
+endstream
+endobj
+369 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 368 0 R
+>>
+endobj
+370 0 obj
+<< /Length 1105 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatUs9lJ`N&;KZO$B%Q0BF""89q"_N7VZk,\CFU@^]IPr:&Q5=<Vc+>`<J!"CJp=#]OmP!IHI*ViGgcC4G=jI_=qQbJa]]FaRdqHndl>]9As at laI@%ZDg0[p[Rd\R\f4[c3V#@Q?[qH\SelZX-(4;'N;o-uC,dhV2',4a2N1-",O`6'qf3I,LDU*DKMfa3OVqO+r,0uc(3q6^k<?-LL^+d6Yjq6m\)7CnBIqSZ*iGp*kZ/5Mj)ga3?*u:q]SO/$rhs at 1=Z4`^T`c4=L+2G/)]/%a)G5>]AY*YRb5^u0n//AQGHdT2aso"nK<_I$[e)8)J6:8nXEbu02A(MEV7F\7-9_U_WopRnn1:Acft"gR-CHHs'Xi!a8n4u>`Wqf%=eeGjp':[&d`UQ1ra#G#em%6bT#A/giP[$J-7H)6kBNNL=YW[&\#`nZlQhaTQs_3j<Q_<oUUt43n8R$j>ZeG`GbPnh$Xi-\o3]-W:[E<-S-;jaj"7l4@@6H\'sapiWa"Z0m^ZLKA[gA/q5PUp^=X`Gg9$t.0o=8>"BBtDb>,OcCNWAeF,%9C?P1eA$$'!q1'NB":gSJ[Sn\Vc]rV!enFirg.r1l$6f+Cl[X6%'HuXMa`0E2hJC3,X-?eiA"6-h5/sF#ZL8#8bm3!Se(g at 4so/+^98[dnjR;EUM`quj#Wo9rkA,/4CCfA6Ffn/O;BD/+7]M<i-N)/KPBZEHbl_7'n,Pp1hjk0o!cSs1M!"6<j_*i(M<QDDjk#E)Q:cEOr8YjZsCQXDgDXST4[.oYO@]M)/MsMHGB+CZCKgL.ZpKtm#Vit>oKlrJZXA:TUb$%lBD\Bke"-.\a?mcPf1aQ6G&^2*qTn<Vo'#BNZ:O7hY>DZb1!Jt,,Qigp57#7<<ikWE;,!H5t*(5UH#RWQpU5'#cPm@^"po'5ZiW=(4+!YplVQ[06X_jYQEek'1ibY,=gpclg1ign1N>jF/oD:9rU=Tj?rk6kAUN&g#lHc!
 gUNu_^O6K1!'>;pSiln5d<Bf>b:r:J\278O+\h.ZZ<=&4PBQ at lAna-lUfa!-%19sB3R7to:5K0G:$<?89=4d_[8Lc*c"5OjjW`!F`@3C046Im*6jeG~>
+endstream
+endobj
+371 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 370 0 R
+>>
+endobj
+372 0 obj
+<< /Length 2006 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatU49lK&M&A at 7.#e;2]*(Jhk2X$hB[-757_S at 3NH_>5u<\$gL8`$OGoY6aPOIDk0`RujP(n at 9V1E8Tm)=%1clJ^@9$[n=0M74t;HuF3DGeX(Z?5><RbP[1lZ*uc=T5Hk#rqDt-+(cD6Qa*0.[ss9%[%cE5m`t^rXaZVf&hib9Hd\4b'81u^c'E/`-X^Yr(PAD<A8.Xu9CMRWRmp+F9N+*XWoeT$l_im*D6n$Ri?6k=PDq/4>/>RU2UBirS+U,tdn_$20)L'<l>:*8(Y))\/F2,G^oOaPpH"Y)r1t:nY:gF(Mc#_C+clcG@*qZH#Z35O:/hBa`J5APh3V'n[\?*JhJXuKC!euu&oU4lG5_B:ia"JPJLDZ$>8hM9S9Fdt-*0mRe_c_$4"!UW3B7A5q5qMH.d%#^Ck.e0qs!h=NoA4.<J<bh5/KdA.)'Q:Yt)>gd>,o_Yn@:=P6^^qJjB7-&d!DJ`P-U5?U[W3ei6tp:":i<\edG^?IuLC"IIAKZfYA-6.PHG7>rhlm/0Db)]!Ka\J>(BXh1"17jr'hT_'KO.`j2VZ/MTU:`FMFjuPEa0gbQWcXcSp at 3eCRCD,o6/ru4M;HJ%9(pigR0,2><j:>JE`'Z@>c;@qDA/SabWr^>!9bR'c2GN$!Z<!Gje2!)4>mX`g<DC6dD9L7`nPJ1\1GMbX?-d*3$@/h.h;e;ujgH`$U1]90N%gk:q?f#UQim,/ND^u5dh37QrZc1%DLfZFBVbl3_s/gD7+sTMenN1k-:m/lU'e1,j$NC-^"=sY/FbISEAXPRLFYeZ8 at TQ$.niF.U3LL/K=s^mqM\qM`Gm11S5$R-V&K&3E+00S_#H+m)oYXYg?UjIE&)"DS[#:)m0n%5JC:bJ]QD8IZ';8n4 at BViJY(U0U#80sAr?==&"5n%;;uV#!I\W7*KGo.0GHAo>um*\5fWcO$=G/:M\=:@,DN>agdt.ZT4"X8c at F7qnO^+h_)MS>EX4.6#\/!
 >KRfi-&NSMf8W]STAlOAl0_T0[!/t_Cn')?JZl=d4f)OD4;+0=Gj-QN-WYC"s-cdL<[LcZ&o\lK9\p#<OrP!?Bq+KJ5K^&IAA&BVT]g;1Z/Zlu!hM6>iK,n1`m*AB,UlqBfIMiFCp"7]4]DMuH>W<-6+%Wj9lroYLsR#G_l$-<jY?-qWN5!>5,9:'goSgQ)9eO'R4<19bBk/P>\A*Z"qGIEglU&d,d/7=Z<RYdS]+qG8>>PDSi75L$pm`SI5a]`4jNibG>PK415D=,sX3VG&ME_NXYAbT^r3.4Joh#tP.<%X,1Z at hl!]O;^+_ZN9"R\:-81lr$;JRV?`J\ON/(RZG,Eu(/GXg7[hOS[*!r$F*%3=C58Y_Hl;'"O)B=:D!#&uE<H.G6%TV:$Xp`mg/33EjoX%8NL1:%h1aT4^h7^=)"BhNm;oJEDUD/4d,n'[e]t$sW5N^,.Zhn2"&ip6V.+_a?)d<F7Q;'gMsdK;()30?]<UCJ_Ajf8_9&=Cr%qS)],T\dX`McEIM@(3=_bn,eaB;N*ZbQ_>%<1LeE at 9j<;iW#7u(>nkFkEbr/OW.)h[[(MSO..PeoA'76=?VK<j/qbX8ksetnV6hI$i!"3>n7kiM.G6/15k0/VlM:r<nl$;BUq_7hQq#phRt<E at e(m9Xg0!D>)%2e\Rek_Q-Bb"of<4"c(/dXeI.9f1m%mQfIk2MginL^f2l4):?%?iQ,g9'#l%e88o_WC$LDNn0W?tY9g&f[KQJHH0DC9[g*5.MT:"WlP`)NL\H!<YHXhcdkn]!?*;\k()6UP$'*B;=:hq'aiC!-?1[42nBf]$l%0u2@,,@<N]"8IKs at 9K,GJ6stU6N1g!^:_cD?1EDGbOFM?!lSXg(f&Gb[X>$nL-g(].d40s?NlDn^M[2g)1MO*?t1)7RTD_^B<%@=GO1[HeJJ"HY5DgM+H(BD`q$k)[DFGsrj[9h)WM.1--ITMB!JGlR3SG`f=M^R$+GODB!
 $m[Q,C("GmQ`>S`hO(sr<L7Te#*~>
+endstream
+endobj
+373 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 372 0 R
+>>
+endobj
+374 0 obj
+<< /Length 1972 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatlQgMYb(oK?Pim%k#M0Y1VSAjEu:5R6piW3JP16U4;OX]?'7Ofk/_rV%=iU.E\=K4.,tJEM_NpT%XS05f\/$f=>. at _'&=(>B4HiPD/$n,n58nc37k at bE=3\@fH>qPrYX9E*EQ\li;[#l[0BT2AAa=C$cuX2U]hjf^p+>ep4nN!3?Q1(=B*-q$oV.D?r_fj\:8G'Xs#_H;Eb3=:pHP)iuE<Ss#:C2jo5)19,.qlZ\WB,X]+?!S0[f9gU<L,AJg2psp)OQ1IX1e;tAhD<THQt)+)E3"O1ran8LDKWH:/O.?dV;ri$.mpI at 1BKM1I4Ul'pW4b>LH"BNJ/-OGXH+t#)dK"_`HTrWM<gTOR/,:B>*;V1<mm*;7lU:g3`8p(X#0p)<O=[jDFS+H^s3Y)fN!'N2#M&X>,O]Q!is.e%`?82WXYm(.Y at CAoHP(5H(HI[)/rfCn"cHu%i+!H0mF1W+]!04ZDtp/Pd#<G"G)7[.)\+2BP[/!F:Qcc=GVq_3O_sr2<F2YQAaDlEmf.pJcD$jHVPO$UB3dAa_foddIpT!/S#,r,BcOa9=P2%b7ql#+1s@\Zm5NO/LF(hT;@u$+L;PPFX97L=5l2/Gr1ET[cJ5?r^p]$]tDbU^YP>J$1_&Hr8G@&,UcX3f^.@%e6o(&H/@AjTca)Z1DE_G)*^El2j-06-Ao_V00r0?=6mmB2c*`HSQ)@H60W[jUGPE2P/!m5ON+'b/NJnYrWhOr>;6TES[%9!I[!)u.LcW^+!<).pEDI5rE'8b(-ht"'_02F8=ZD.3j3=dU*LSZ9ZeNr2trcsmHn:iVD5kIr"%eYmX?;nX=8mi14-;<AY/&g7Y`^;6Ob_W49nl_1f1KI)2P\C!D5XRWc(621eI(\]&2r<818fig6ZI#0,0h<cS\XYS?tbQ"\4X!j`m/h-jm80aX%9^q+BeQL3 at OiTJ&>qp*H7S7 at ejXk.&6S-O#NY-qAQ',d;Uq#W&6_SCblD4;?!
 *`#jHHI"S]AP]J`A=eDY2DHCr\0#]^VkF&#)B+Insa01^/K=jIq?K$oUO/U?fhfg_oE>j1CJd2#p*#qhig"^qfO)7^+qk^6Xo*ZTkFalp<cILluX[>mb#*sdXJa*4n$cPD-5P!DagZZe@&I#3]Y-O-6)%4QJ1X]V>qj#!LuWYoaOC(Mlg%/PGGQg2 at 2H71W8$L'RRN/q'LI[mrec`#I*h<sga^bFaXqB5GYoc"</0A%rt#,6l<H;R-gW,4=7UhrRd&&8fYh:]<qe[U].T7dI:'J4a'-I;54&-V-/YJ816=.Y<g1P8h%!$Ok&H]<I"gic6$aUT>&XAZAX<"Lo4b-UU6f(]GMHd\#JObUoe?%+R8$4Uo$JL+4T(2aM4[MnKAN5=g9`/o`7f$J<*r0f(?O[f<oft4<tjc_Q0-P]Lf\ssKl,qCcA8n2d=6Y7j'=p5*+fZ[616p<rs2l'T?rq`m7GGME%R7`Gb@?=1r^)O!*%#(u;ORF%[<AI&cjITjjX;cLu+^c`?_In[>"#!/W\SmmLa?`H3W!F/;Qr*\c0o?.cA*]`ZGmG71D,[nHrr%JG at 9$O+(HYNBRA6e,1K;D:FEt\u-SN]4$(cD\]PL&td=A6l-,])CF`"Q. at CaFQkpG.VEZ68&B)@KM:M-!X]'l%=YS=-A;mf(BS1Rno2U&&?%tq;;mRmdKh`#s#ZM_es2 at J5hN<GdWpWW*DEWPd"*;REKcK9Gc1p(<L*j82!BHj=f':VlDIT,cF'o9mYW*lbEbJq_V,a-mpbe!].A/GH+J$_O6>#C1*3N8XsOZGo8\m at 9ud=1'q4ct$p.E\u<qi'uVa:HSPaIt"B?&'FNSTa2HM7%5iLW&o[e#OAo,H!b?r"&N?RUmmjMm<7'`:uapO;TZ"hC^Iqb$R::1"+-u+ZUId at U/?C at WV(o`TuWBOYoKd/;n3F7S[U.R7n_de$tbk&IP)AVWGegiEI:rBI"XRRaOE31c)`~>
+endstream
+endobj
+375 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 374 0 R
+>>
+endobj
+376 0 obj
+<< /Length 1121 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb!ks9lJN8&A at P9LjIcI`JqY'!>GhO4`EblM$&YcDrTR^c,P\%ZpffNNh(E1-V^%M7XI]Rj#?!W1XFngX2X1C)Sco;_.pRfKA?S5U&Mk.,%HR!"C`4L%`,VcZ!B$9]?U3M4STu!5!)P,ZtGUIOO2;E.#U^"QY5%Lm&>=>*$kldC$3dbRZCsu(dQlsgq:=0)YB"pE-Y/"diUt#3d&&Z/*)!F$;k;?AgOKn?9<enF8'^>r2pTjpGintpO0q8ET"#B_l$Gl+TfS;f1+7$;:n3_'SdosCf>@eq`Q2I8dpNQT3>,K;:S8sR1aPRXIdko/tfc_Oem1+M-sjV2"?F!V.'Z_Ke)n"]bs>$Fj]2dm at SBZ86=%'HJ;De.R`B+DmI9#]bHoR3L)hJ!7>HN-Q(dkFem^.gD1Eh7tZ-q-b3uf(]G-hDTb at U$n1O2^3^aY'I(C:Z:#.gKG3--$ki=d[ikr)SZ?!oQ;7Rh%7sG\;X$T"c6FY9gT4&1Z-pIod9s,>ojGKe2d at ikc/o!h,(RO-oZ]Mp=4&EKVnocI`9Bp:MI6K`r*l3 at Lk7=Pd4#,G5]B2jDuaBu&mm*[3/%Ca`Jo\UlV5XSXKl8$23TCfY3s4[c^d>Wms-daD+0`]#OaPE?Tc<.K^&kQbq%nN9YcS2&"\',^?GEO$K]7LH-(8(GqdpC)=JGk`MP>2>&#mVCU:p:4')1kI!OBSUo27WVAEmFKTZIG'%nc%?;Mp^RAN7LGEn8X98Y's['NaNX,sZ0q:h5f=4t<adZq!ja8&sD6S5%NNq,o`n*<lq<tQc_/l$VPR49ud=D+p!H6b"DoPPYc>F"BH&3</hY7qYXoi<K9Q!h$I:^]!<STc;9Z.,kA\,=iH9C>$gcQnQTG!gJpR\V0L*i3TAfUpH.g9.cd;KA*'l5TOd;0Q=2C`PI\?n3SYna5)BbLgn%%UABihRD;WA_FOl_o+K]R,;Baq7E]H^ho++2+#s(8=qj>Jb6)(a<a!
 bsc:8@(W37\R0OBeu2:',*<2C;I,dB_5<Pf]T:TMI\mOq$'=+W\&om(;D6iA9UY[)WZHruAO%>kg\lC4FN#LEtJb*TAr<P+"QpinL+Gs!#2KTALQhYb/\&MS2qIfUtN%Aj~>
+endstream
+endobj
+377 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 376 0 R
+>>
+endobj
+378 0 obj
+<< /Length 921 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0Ba_oie&A at rkGU_Q-/^7R#dGtk33V6 at f\%48,MmA%ME@<;js1ZulMmfI^-kHXq3#)2N]bti[:WqGNR0/Bj!m>hC^i"l-EXrAAe<9nW&-lU2JY2NZIk+iIF9auC?@SIEhWqh`<'MqC-99`8Nc_;'/r/&UKsrfq75h["W_KMP*V]f(hlf!HM0k8f[q2ai,L^gCGh`snc&Jsu[7ZD*W@'Pp4Y-7U>BBFqi`c!\T1dl7,V+!UGOcNqiAi2c;?_XQDPb?Q^9pO0B0`*oAaMV2\?#F`5-F>!BGBA)''[:;UdcR;,/d]q[>L^M%R0%43Kb`k(OGNH@<'X`ftpF_i=\G2a5o9M.u..U3R',k7bc)HANsc#8U4Y_-Im-+@=UbD[]DBNC:S]_J./A^&L)r4T>/_$jMb?\8=<3Y$Rm?q43Hlj8gc'n!'s<C!6(#f_2f0VlhQ9BPe9`^_]]^;)rS2M#C\KTONR&,^ET]+ at ZhoM+XEQg;#Kf('H)Yal,m"O2GF]T.'XV^=67RX4^!qLjaZ&P&kY^*(qkW`jD+Z)b)!i0nEr3<mI?j-GZ#QU'(XESZT4%FcP-/"H4$i328-m8c)7Sk-;rE10.Q_ODGsPA["m)0Hs7ghL!o&inR+2</aYHbJ$!D<1YeSYC.*E&YIB`T0!._9h.4O0CRgW5okhCe%[6.o>XBfY,[Glje#n"rdI-b:+$P"W&)QrrD0DfjJ8"uc/k6T51qJ_,W0m1-^&gQN$V:SBP8NCi-+VPfD8(*Ghj1V#pA]u(NWKJ3'N,"a5[;[kb at hI5Ia"CLhTGO&X'LON?0Ga/:T_p.A3I7hFQ8\_?qk`4^t:MH14#f=]n9AkmD`k@^m-_d(qK<"FHD==(_RW--I70Y9E/h(.c46 at Vh^fL7sr\8$(iDH[r)OU#>TQ*oEUO7KNS~>
+endstream
+endobj
+379 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 378 0 R
+>>
+endobj
+380 0 obj
+<< /Length 1367 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gatm;995i-&AI=/E9rn=*rH'a9j^AY3Qu?:gbu4!'27Ck0H"i at HiEs^0\?pB4ekm(C!%mVj.j>/q9*[IFgq1O$%p\2iWR1VLdM5W&=PgSbuZ3CD"H9 at Mm%q'&6_6LmKlC at T=uTPCfGR\V]UTS!s=?UZd8OPj'YpkIm8UI_*>d(]4[RWVHY!Ldt9))2'oTLi$f#&/J%\/CF;80]B<(a7<RXt90?ZN/gg1/c>/n7PRrqLcKf,,_%Z-N01YMW5(HGdDuaBu=9DOk,Apd`$6i#&+"p-UkJJ&r5jP.Z(*\\;@F0V"?H`@:C>:#e\pZXJjWs782*^/2lf;h5Wg%9pUTE8B1$<]H7&aqGePUQAhQKZ+9airLA1;J21.F1km&H(LQHB6ZB"p9%aHKRcIqb##??jGIHB1D(Ip</@`Y;etojHpYntK<>P>VN+6b`ffT>7UhEc8<IgLi6 at QoOfT=@/Kd#\&IQdC,'^]K^p"8ISgL)SRWiY2q.G,_gh(r2]>d_<R7g<*]<,%mO]TAn<:`na%%^ZFm9u9IL#HiC08 at R._&W9"`==h*ZH"0a%q[Yh/6Gkscr^9ftY at CXXX,AZ=L,+h4PCW6\_p/'=!?E'bnPHF0RNcX[16g2<_T1:A]Gmb9AMF!^Id;@@rM9#\CUbA9I_Nt?+M2?/emEWTU#C(K2Pc`[DO(,fb1`/rZhen(s6WD9L4$I],S7W)s&Ng`N9g?td/g6q<hhF0(>9>ush9GP$Mg at _W8k:F'G//BT[0aM8GNq$S+l8r_=2usFXj%\AL[[p\Z[?J-;e8WQPZ;8a"KGp. at c+ZV?R#@VO"MiE*kI8Juk]?!.gLi^rldG57PNLo7JPjUmIge3=IqTZ\(qdr?IXi"4&D^gIpOfa4PmTlMCmqjk<a8j at g/nP;h)7#i>J7%N*OS^iW%Hb%ZNU?O_nY30f6N#.&.k42hFM3)*iVACjs&6 at UGp,"&ATP_Qn*<g_T1YT"Lt9\lLC=&Bqh!
 "qAMIMrl//m%Mb>Z0"/F`mAsgU_ at +7\,IL$lZbZJWBc-ai6/12#1bga[D91+;B2[KVL+o,f4Bg8%Z<R7<n_bPk0[oJ9oaiOrl8V51Abn+/+aT0rlJSS3/LT;3`#P\?<22AHE4(Us0(bEl:-Y3efFM6ZWD:h!F5];?)%c3Sf(`,(h#o5*d6('slN(8udIP7V9+C+`3ja7T+N(A^ZrRkR=[5 at +R=r(_Y>^q57RX6!2mL25oR=0:`Dd2S;^[s,r0h=gk(c9jDr5372[J#Ool#qr`VtMIlH-/aZoM at Sn^3H*,#4Z^WV at a'1GA.-'Xcp-<o+t^I1NVe;[rZTlp9XJV`65\P?27(94"q*EhmJM4f\R)<Z,UeE/H$*CY1Rg~>
+endstream
+endobj
+381 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 380 0 R
+>>
+endobj
+382 0 obj
+<< /Length 1290 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0C95iQE&AJ$CBR<keBGjY]ok9I\JDHq-m%Js7Qag/E11_+L9.E at fao;."P[k4<3E?YVK3B7OhgG%Rbj^(f])@h;JWF8,]hQ63]u(2(^A`o$3'b1oqZQ_g[lJ^Elha]sl at UL']FR:JUGN;UfN[NUR42!uc&MJBg\dlKWJ>o8<Po8B3&#q4:/DSO%W$4I#)AW`lfNOEUu]KCq&uPK)%`<?Fqc7TF(EP*?iZ+cEDbiXo?P])Q`UmS:sYopC^<(+69H6_+G$ClY=''Lg3_q&;=-E=`[;IUR_nZ1<u%JtdRt(d#n$X0_dQHKkO#hms7>sq\L<>RgRIL]p#?W-PFO)^+lXjt9%,WEN[a_*5]YCI'.i;sUY?MdcbWE4AQ/1ojFU1S%=9?I>Ld^[WiD&NXj_g-As/^pippnCp0X1]dKIrCFq$CeHGrlm5Z&5NmN0b,1.\@cG<]3W:<\!jlChb/HTH&OBGuj5g;`FCP>>1$&NdYa%6Q$bIfr>]U at pZ."\hiCPJ+m190Rp;m+3AW#\04['t4etUM-sP`mBHZcmo+2l6MTL<aRs*,f(m#>g0L%4hBA7A?l at gFo<l67WGk,=3i4Qk_RiX[$6h<lJki_\[AhS_==<XF?l9&@?k]/`!H^N2H]:HhWps>ioo.g?$eP3eUQ>]q>]?KZuN=+[Y4r;[>M"!6QP,A2D<adi"eeHH+!#C$Rgb75D?Z(MoP\K;B-j+-JL,tA at lF#2j8,j[*'+=ASDi"Gff&8`mjdR<Ms"[qK*.n\Emmgleh-Mk:Wai0:Pi.$Hh2\Ci'Jm3^#7]0QhhYXs\W7J;/1(8lh3T2BqH50u9NsNdYLtiAE<62-BXZBfis+q>7`0,`/&H"X^1%\OBu=m*rb?&RjnA+k'B30*Hk<Z8<+.q2L@&h'rJc=;m&>`J[(QL1UQ#W&1Si\5^%74k33XLYtk+UT>NqaBF19s-3&"-o?@Ib2MZ4^7dTinY-&'b,hEf2?0R#m,>!
 HbpArN7Ybb[qDPM=. at M3e?W`=2BXtn!O35^00D3SXOd.=O at IK-Neo:4!%:Q.s/A.6*GJ2i%,YkUt*.4.YW#![TWF(mBYC'EDqB03>?\8T0I!5<c!DT)[t&W6L^2m]G<4(:^/DhtfIhsn=J\Fn[uO*tbZ\*l)g.fH]ed=7d#]+*=9FV+2&DK#4G1+MR0TO/,aR)?]ROiWMRcd#M#61H%debAK<C3RXj^3]$5AY+>K,e98F^96l_ZdB<UPqrlJhN]3'ceLVj<ZYFfi:G*c&<U+$E!FnbOtO4,3/L/$TD=DKP5~>
+endstream
+endobj
+383 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 382 0 R
+>>
+endobj
+384 0 obj
+<< /Length 1506 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat%#hf%7-&:X@\+lpTKcmkc=CHrrl-3HA<)hrZcR>6<Y.9d`C\eO6_/,I$T-rM7c9!sES%XI&^GPCXq8A8:]mXNA!jLLkg/f(%b?QdCA5NEqo$KK?S;<"[<c<n%@UQjhKO80R[al[bfGN\nkXFCG1W.u4hVoYfH9'\S%XWPY<\)KZs6t7-d[`,`giG*!PS;;o$F)Y-#g_*8F't.^?32prQfP=6=KiP at Sg22QKGD$SpG#li?>g/kf`@P=k5SVuPEt)2:f'B=)AtiLMr3E]DJW8njZ%W0A!2!m&;MkQl/4!F0ftV++T.tX;!Xnc`0T21WZS]sbV0eUF0C>Oh'2].-K=-<]Rp/M1KO-r at PU.Q+k4ZPY[mMY_5 at RJF>@YI5Q&=[k=M2bWSHWmoGJB?,(9YGW9'dO]*^N7uM[(\%.=:mL,-=]^]4n'#q5dZl/)jO2Lgi<de;C!"nqW])p-CN(EUsCY`Em?Jra(&:";t?rO(9.`86fNj6d5X.OBT.o,DM"3CNs&p>#LT,"qN"tUgp'/737O<JYKA9P![>F?/-)a+_4+^BI!dd<u\OP1]0@#a6#au7s^W19&R!Q7F<\I=:8:OApVJ0PR-s'3?Q5g\HFA^.HdpmEGAL<\q/]jam891c"_M\2Crc^_83OKBdU^HNAM;U`[fce$%p`ePMqDpg'aU%6g]8joeKP-d#AdFHK^c*=du\!9f:$3%dd=76'lk8N+h&L]#Ff9XQoe"Y5>_teBEkSjdO;kR"=R=IaY\G,B^E$_BGPo>0K7R:u>%97KAk2nZ0iPY,>5.V3h'r!0*ZSXN6;ZE.[%B;u`[9=#A\TML(4$oE:S"D1HPsh!@Eg1u#@em?H;oBs`H1*"F,?Ds>Mh#CS$Ra6n_rhp5rPCEW9FEjR7Y[8^iXUM!7>489hqF'`bIO%X>4qR$(iQ^M6&G!&'WjHm at -:ONmcI_]@Y5B8bR5=$VcciDP#;^Cpm1umu(g1`]e?.WR$A?R!
 3`YM'Jb-#I1=bjgOR)G2%9K\#^g^!u;'F<0NE"8;dPZf]:=moM$_];DAcb<:>Em>kUUmsf\3ROgB^p3IbohWF55df%CO%`)Mo3D.>^p\,:VmPph0QU,(`S53\E2k6Al`XlV:1*4`B#lJNg/8ojWofSemMo-u,S(bZ/_qn1+Q4b:*U'r(MT"Y=iOodSLD5'V]Ae>C#rHk_/ciq-\$p'4lr97-T:'q<<EL(18C7mqN/j^drC;P0si1UiG5CX]2lAnXGkLg-e>dfXYTWWL)dG]1["`4QGe3iKY?8 at RDP7a6U.PpNghN;<"%Hg5DI:aXJZg<LNb#:[8VpfLQQfL8"jSi%pAJ8^sRD^13?m*i&/I%UX_TaP,2RNV]og at j'9'-&k;U7*W8T[!#<`"Oi<=dqC20uK$O>(,jT(*b"Z*%f&pAXf;pp=@T<)<;?PpAb8jFlpQK+TJ+Z1rb;DJa9]E$NX*#ZdD'g"Q.^ibIAXn+%n0E2O#VM][2BI4i%'"qOUaoG't:o_\~>
+endstream
+endobj
+385 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 384 0 R
+>>
+endobj
+386 0 obj
+<< /Length 807 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb!#[9lldX&A at Zc1d9SKXf=#c\pC56jOPchV?bcdNi*^,=eq72?\*&>D"AD=d.%9jhX5a&b<oS__7'XM0S0QUBn3uG^]<%0#+/@K,=*I7+PD<QF&VFbhWC<*q9rdRIY6_/K#7e?#)mO(>Sm4JdUp5o?V+?_S=:>V(4!Gp.IB8Lh";hc>Kcrt/[R:0cFpGde*muU]^/B at BU]sK;0n`V.N7A:k*DZaR?cX783?N&fq6IDm_djVbC"087IH<'P_3F at cMBtidh3#EX[RE"hfdGhD;K/e\(s6h4Fn4h\MenX[=$M>YH2cJOfOQB$GjP>KMg5)qQ&[!XjV3C#f?kud=j5:"*]a+5E:)UV2dYAQpE3T:P4jg"\"LaHD'ei'lnPZRI-[*m*tj<!f^+%ilD/h1WRPsT:]S)]ASO6nl at Nc*:sH1\S0jE:;\dY78<8HL<*XWh;(1Ba1e at sG!dM(1NWSghmaW/;Oaq0^p$I/,$Z.cfG)<0"5`<Al+paS]+bhc,'#N`APlujH:`c5kOEYXWi.ej$T/bF:JIP[G]3[$D9"HDEj\XH"BdNAK:q`P#n8$jD0RP:r at -ir:b;MO9lW at +5Q*`&)IFXmbOqV><!\Dl/ufF"?_<4gBS3q_K/r\l1VlJa4V;e&B3%ToNNSC/0OjF26W8[*$0r!TX*'HJ8uugJB-DRNA`p5L2T8lS at 1IO_\#a=KQu"?@^mO*`KqHD(5`PT2"E0(1,rJcL0FRu_YE?NH$DbM!@$t9g!Oo4'6Aol>jMY]#aa@%0NOk]4Z<XTq3lS!&f7u<+Nkq]6Oo>C(%3]r~>
+endstream
+endobj
+387 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 386 0 R
+>>
+endobj
+388 0 obj
+<< /Length 1372 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau`T9lo>Q%))O>kib^HW^M8<fBoq$mB&1Y`I"7(8n"&5]b2&-s1X^g$'6CPb05#i\I];Yi'!/%S?Mh7YCGV>)#/ZkY;Ur5DaH*2J"[[A?C:u8%l8-Rnt*:Aai!iAnDJ`dp4&KOa`MEL-I'Hm9Z(u(aS*II6B_?&<^/AO>2=.#K5<["qK[+Chf=e_P67qse?!9,]$TGa3a!m,_A^*G2Q^BS>_7RM&qkIr\\8S'g`]4R:fOV#'P'E1d,=C at _F_$I_6KS5iCVJY;g7E//\BKr%3atHTt-?-f?GG5Gk0Al?Ef&:8fRa(`+8[\9s>mH$8tQTaD_F.Q45!g6<175T\RgA8'VAq.,!^.UCW7>e<r,"]5#h%D`>1f:NaQ>Z\c0. at 4N'R`+:+'P*Le-jS$pbV at u.O]r(Xa,P6l3&1S*<).M825FDSZ!gb3[7:HYjJr699<3m3Z'R_']asd8k9:Kg0[Xto^ik<)-bPr3S%s$"n&t&cb?A9OV8'a_s\99T/`Qat?7n:O=`E6!XrOX^:cCg8#L,ec)];%+Spb^pjjm/@J(ai/0>=P)kTJ0+=SU6'6BhTbf<=eE!G62,tcPDMjN).Pf%_*7NAE1!Bd^Vna"]Q`7gTi]RIF@=U`LBo'I7;O@%?gte6$_L:`%c?O*,BH?0P91Ed2fJ!(TJ4#A[hQ\)EO0D\"u$E%#uSc=?EgW9BdjK#-1t"U$c(&*e,2g5A1Vi<ZsOJQFVjFPM/(Ume1TeQJ[IuO08)Q:6mEuI"5Fr:m[HB99aqQ)(BlY]u>T3k]ms/N&mb$i"fYhI0<Cc,6Ziu]G<f=fIl&)(bGZq#RL'm$_uSu<in_#IPBG!"MIMl5ZMWFTIVLk3rWWD"[EWE at I-L0Nap1efh$@d:Io#+g!c^(G>T$kJ"FWO)s0^ci6]LXRI![=4;?g4[6iige;UDrEf$7sQ]"i.FjNfk+A-sZR2MX3ZaVdlK)gq#qnq.L1`;L8!PVCX+VMdU[ra!
 \8/f+aZ_EL:Q#eE!#5H>:]@]-P/kj"L.%-'ibj6gk!VYQ17eoC7o,$r)YR-`b at 3G[dl;nMT_LXlWd&KPPf&Aj2DjW/+MX)i?1k_nRCBqViO\Y]FCi6S$FY_2;?n<I`@bNfW(Q+,AX4jHL!YH\?ff,WIQ]*dR,dSi!(T.9:G^+`5nGG;!&ZW2]%$kbO7ch5YZJGAY*QP1?=:,5lN"NZj,oQbIkEge.?bdDGgZX]45qC3a0jSYDj at CS<]a?qVq&LDIt0H,f.T<a:.%n1F\.sVOC;/r:JGZZY`a-`RXpR<8u^Ff/o/9,?XqKQ*IB%8T=gAJY[\t at 31be-E.R%5qIm;[+X<7W(lfs1_/Z(his8*5Ros,5NjSaeZ>9E,(Fk?0#~>
+endstream
+endobj
+389 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 388 0 R
+>>
+endobj
+390 0 obj
+<< /Length 1273 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb!;d;3.J1&:Vs/5khQeBoc^*!W(B2Y#>-t.;t^)aU&&hQXFQ%ZJ/_n)\TBGOBB(d<OL8t*^&KOqdqsXHs&+OqDIk at i!8,M=9Ms at 5[GT5OGC%qXto@=`*4=rf-Mdl>&T^Fn?I7fp:bh<hkbBV3a7UnRN+V8]Pa at TcT$d[-jTn@/HtUY[*ZZnZ*tLU'bdHUK/$8K0ZN5WGc.ZWr<E@]Y20K-C=BaA2Uj6"jBu+5cXCI;HPhJp^klISZp)n6ag>kG.rrqNMI"uZ^u=lF7oirZ@*D8BYn,q2Ws?ff.O^.:_]Q4Sc"/iX`[E2WD]FYZd\SF4HE/M"!+["JR+"_u#7gD:-BhikGcs8<gHT6n*]&VYA4.VD.laY(-OOk)RN+>Ap,4=&+5%UWJGalLEAAP"aJ';oQG7*!MJ6<,>!_TBW`]+Gg+3E\<n]`%:W%q7=odGBIr`m_N^nu=$4(hh-Ao1c*nX>VL/c]^(7.C:B$&_7B&T04)+Eb_a:GUNa,sa5"(a[9iIKr)cH4*o^6)*'Q:-?u"go$"8=m6:kpdJREZ).sH`]bqR>&QgXqZ3;R5>B&q.=mtPmce0ZsDi[bCH-A<Lm1XEUL2H]OJl``r5Yq#'e#?FR at qMCm^pr*SGBH9UOdEoXX?p>mNsRjSZE0Sg/VPF.$pRnXu,oSE<U#'l_OnT_6O?Org=*[X[(g6Bl5aB8tBV%"gr4R!'^C:&:F3ZR*4BpCrZe]e6HK"Eer\iC%HT_N@&h3B&9X!EW_XWcp7/jdqcbi-I]MnG\efW-'q#\%osp8b;Zm[t?<f^#e+rS^efCkRD=ljgmGI9:VmZllg=`!@Yj/rUs\[#_>lqVtBEanR$?t"!)VZs-B2*s-M>h<n0,FmU9^_kddltrbBA.9R9AcdsSZ;h,q`:7 at dDAV'0)Ldo;0rnY"eI&=+2ulBmYIO#nUdX%UpkoV!1U[XfGN.-):aTfjJ23_W>VdU7"$-XEdn)"+KC\1i:=-#,!
 DBqE;5F^Fp/L>.2#s[@9J>0M_R+bHgaQ=Ym!e=Vd"!B'oiMk$)#TICh5.PPW+E%>Q0>?$hPt'q0%3c09/UR*6 at 5Qpnaej=s)K:^@Z!`IfA`V_:,?1UYb@#:bCiD"b6T60os22M9W;>sP[-1PRdo3g4uf]mDDdG3KR?!0TQql04Q)QDlgZl]*!]!q9KDY>;jil[&*Qn<6<0QUJoUV0m"ta:SZ\=T#H!ZG+Ef-^"q!V:Y?.\i)2.Ub4`,_X5TKo&Jcm?=W7&Ucq775<9%1ckP^dAY'U)~>
+endstream
+endobj
+391 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 390 0 R
+>>
+endobj
+392 0 obj
+<< /Length 1468 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb"/'9on$e&A at sB#e at m3mP6!Z at B1u+8C7Uh>63R>?pVu#Q]3OGPjIe3k^P67dc*f`Cc+Y&.e^*:d;V):oJeYtqfMAr1%MQ0HnW_\^:.HWcW>VK_aH"VQls'4dY%:6=UWp4GMWEnPg3Jkccc\p9)=Eqm$?>0DSuRsi_WJYp?'CNCUbdD#mJ0]R#4KTd\:u/\r,&rgS+98Wln"l7Pq:`N#<re`XcmLr8a]h%WV#YLJ'7W6G2f.O0%TXa/"?p^F`dfBH>cC0#lPq%kU[T(8/p8hJY>sUW:E[O-7HVq/^3]YI-fp!Xt"kc]t]+>$pHf,\rDQ*0&"0KGY;j,qE`mls#f@??Q&tiA87t`5^tZMuU\>[KNAHUA!3;7C5sD->05(->NclLE32c@%Y;UYYW%2W/\e0g^'uh#?DcB)i_od9\[2;6sdHI<R?]\A4]1P/ulM at RED@DW,1ldZ?#\R:0MlOdaAu%\-#.ceMPI<Fgo:;CejBoS<MXUj^^d;Y at K9g465Ip7E$,ucD;rnp3`DG3)NA>Y0qL1Am#JFM3h at bgp,\t%NP?hT0.f$6Jp7HT>n'ZjKCTUD)<bP?KdFJ!Q<]o1Kn>0Ji7H.F;-hj=Li at ASc#$_RPtZ1k&,&-^HBggE7TE;8<K*#$mQbn1JHd<9F``'JN#IkHd>;,5YLh48.0Cs`4Xi;o!htn_`6o_HsuZRAGN;6&k:jD<AUniV=s.!jdetDAo'q'@f*dKVDBtMJ`Ef0)lYmH]G+>+T1kppMK.qB2k(uGhh,)[GhFd]\U/BZp0d:QG?-CIB*B?X at .c^>'8+pR`C(KS at 0^2mQ)$u(fe<I<LFCMdf*0U.4pWAIKXTPtG&@1Yc8\(<'&'-]\=;SYo??NI.eiUjpsC&aI+%aDp#b0tA-pB&ocAJ)(!CjIqq(DWV'pHo*&:I+.RJrO>lS^iJhqfD/ut+h*ge->I1mKm\p9WBop*l8e_2[M=_hT3XLjF^!^btTB:,i<m(q!
 f5"3B8MC"Sr8L!D+eI.tNtGWd\lF!7'n[S`s\jhkd%-=Po,4GhCJ1Qmth3`1ODV&:\.E"pGCS at .9/PuD!/p&*RYH<>UZ/%i@\XLEMi=/\I2lJ6 at Z;^Ub+VPPn.C?X7*r25iu1T7/tKhJEl.hoV!UfQ]-QF*):]gds-ZneW^V2TG`:?K*`OqA[nOAi%.A#*8IWhtLl7qmQTO*<SWqa)XPL at VY%4aPn7jhVg2:i4J\2U]%C=+:7rBVkR]5f7ZG[i6#^j+/^P?UGI-#)3(KU0;5L8Wl>%MG4QF&I%Amej.V-9[Bph%FA5:!6t5SQR*48,AmY2OU:546D^P/O$'ugS#OOq_+R^Ia1r*Kqu:S-1&Z=(GZYGfQ=fK98`65"jU#W"hdS/:-!bmQ5G+ at 9LI-qD23I44Y?$g3q;Sm&qm6`pXO\dCOg8595:!)PImM9VOm^ot!O8(]YPJbdEh<-O%B]5`3)>#+HQ:]g~>
+endstream
+endobj
+393 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 392 0 R
+>>
+endobj
+394 0 obj
+<< /Length 1415 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb"/'hiFNj&:Vr4JaVX*dN-:26KmH0XjfO6Wg'tj<=X!]GDVlBftI at QCTq4O(..`Ee+KD<C#p3pp?1s)5FbN]eTX6S*XVb[gDs at HG?PS30Rq"cZr(^=lBB0@?+f(H>#i-Jns$8_LBm8YDtf/ENdKfKiKj+j-.d8gWsA)<NLOj%IHD[)76uBhXn+kZFc#7.&&YF\;Y)YjGj"fDdQ%lYjNGo*l$i\]YjFaCKfj>MPc^F)bP:*SktMU,aW(!u$%:ODGJ^VN\J at eLC\Gh7m>fQ[e>\ftJC)*"=j[3`V7LWF6)XF+nJoYS_-#o;XkCGH+7b"`#cB0",["h.Es'K*D*.($R)FHBD?m>kB2L8XDS,-BY,l.MDD&$D2'@?Y?l`\B%W2HlT8OKso9(nh5'NS&c*Jf*OBD%s?7M'2aL:(HD5pu[SF(t$X25h at 1Xe-V/[iPKE+`/j&/s]d2KDe1pTAi)lk+JKnfofu\M4dV$H>E-Gd<9jN\XA_;l5I/A=YM*(&G@/]@9i-Y),;_-$?2E)%_K]E\/m`_D:aSjG.H,)3WA/eAd*gclW&h9A5(rN_/6.8RtPA1>e:Pia;kS-l$S#IiALkD6F/%L5&&a\(sm8dMU(YWI^e'7XmNlN&F2E6/$tNUNu:A0WHMna;6O(6T5fqZ>Q4K<K?S9?6,c0qJh\5;&Y(.gO/&6E2flUIdtb96KCJBU#,CG./4riUKJrdI;V1CB6+h16-kY,c*M;2S)P4I'Q#&0IH$]0;haqQk#Jk(nB7Did\O!,fG2Ba'Y?\Hik!GR<e*=uB63%MjQam/E>1=M=I$keK0md"&!AP'7^`SUXDJlH=:(l_X-l03'K%'AT'7_'QRhhE7sP5"F2uN;ElZFQB[lc]?P("fVF]@4U](I,W>5885iq#*oiule:=X^+>>CoR3%)CGm99'.U$CniQ7#__g]q!+ at Dg:hCt#X0DH$%aKCA at p\k5JaWQl!O2HPO at SneH.4beX[(54!
 #\(8a$;j=b_]+cMT+;IPH)j:Z93o:a18)U17&-<,]Dgn;b;,n1thl0nfT/1PL0`f1/,>=!UJA#QS]R%#2bG<!)J!Ha7CW%0Nh[^dHdmtH-Re<nu/._;&Q)EIN8//:NO_lnb\V;o?!IU\:$mU/M7W`@McR3q7&*eL9:,V^9!@JH]@DSUbVXt?8sDG\/pe!#a1oYr&?hdhB7>^2CU[XOHYrI?5If$?%c`*I'5);b5Q^0t16"#6?:P&1"Vd,M[\%qHW1j_[5@%db;?h8fL(0P/s\?HY9"9FClGhNG'u.Buf!q*/57j*X9^!Z1Iiq21R-UgN79q8u\)H%pg&FS4[3osaneX5,srL`^t at 3tBK5jPFnLgZm7jLIi.XUM4OV_Cm`-]RI]XWFdMA]n,G)_jfsNO)FR]$iS-u*egiH5FBX-p]~>
+endstream
+endobj
+395 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 394 0 R
+>>
+endobj
+396 0 obj
+<< /Length 1022 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau`S>Aoub'RnB3Yjt2XeADK"fOLapdbZl*m at dLC$RT;Y^l3!WIm4SP5,=kqe[-c_ilel\h`3lDDSsGKcN,4J[S`DECp[IZAEsalKXQf.J7?Alpk8&d<RscS`AY#reI(--n>fU`#3?LeT,:"bM0aknW7UHN4(autcfLo%HTNqWH1Yd9SqQ,"].9(&0TqlEb-P=ufITRe)Hd(7b=Hu^\LM(HlD#4tAQC3&UX]tf-lk]\li[@-a_2(2gL*XE%d+X*#g$'q#JFN&*U;R5\XhGTW*42keFSJBe>U(_2r_$IC?B(g+h0C\+.%3]m>R5/aGMg!fb?kZ(6lDrd>j\%T!Z6T"?DdHS%95$+qA)W,&a'UWWE$(n4+qU=fcnmIY0LqL94<T4K4EO<%5%t7jOB2^I5/8?uQ/\b#N)sU]12 at O&Mp6r_/L4>P4TT@[m(h45<Duk)6HL7PJ>$V\AYaO"?7[%+O^b2N#)AV4%IfqFH?GAnj9D:F5!Oblj-2\85B-OS*091b^*?q4hW'aL^[AcTJt7K8TG6'*h>Q(OO5<.Pp4!31L_ie0/-#nMh;LWmBssQ-.7$k at S:U$nZL2B)=+aiXZ+/=Mm*XnCSJQR;5,-TU;#iDfDU'igZOL'=)FdaD+#VXEO.-Bn[6q<_0$]Dfc/s]M`R,+\:HhrZ/F%nQa\[SW.8]s&/_XXo$1CAk=V at lXetBok7`F3<u2:K&XG;brY]-Rn!-JgFUl.(K3-AZru[Xq'gX?Al"W\hB#>_bJJHo(WDH,0#hkgGQC1_G=1%0,4rk>q=Fr*?6Uh<T[JsT[d_D$K7;5p"E&6;+kgSBT>@W'9,V\h@&meH?f>a:-:Muh9h31p?.&'8WC,ld67rlCq)1ZYC.M:/HoX;W0;OBeHZ;lnk,]/C0:kb_s#=d^hhMF22.qp4CN(31V6eb%2=n&#$5^Ih^GlJMbgjYtX1THg-BSuj?$ol3L-pc]l1Ytd[%oqaQO.(k3A7fMhhq!
 "8oW at 8gC#?2;iB<"QhRMki97HrbBL"i~>
+endstream
+endobj
+397 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 396 0 R
+>>
+endobj
+398 0 obj
+<< /Length 2663 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasar968iI'#+6Ekd7d6*%p-3`[=:(9R/*_`jV&RC<HdCOMhGo1&rans*d3kaDSe8*;b?e#W*Iu#5!@ep>8)dM'"db=YNuqceQY1baZ--hj[;fa.:/T\J'bIam(SUho0'NWg\jhaZFu5FlkK(*`"Bia/#&W%8YHSfU;6hpEgQ*kEhD4:KDtED<$K9WX[ITrJ$p$!c]2 at hK05hY4e9"q*^f1F^<Ug>Y(I9=]q,"b%2d&%CbKfb at _Ke99\M?X<rU@;Db^<AG/Ku[O+sRSgCHQoud3<0Zfh"]8#^_M1-ttkFAG.Cb%mB<a,A+m3t+C>DeCA<,>L/>f`?KYdXLZ;>86$W/?EMWH(YpE?l$qBNX[2ArU+QCZ+7 at ms2bgfl@DsW=s">H43\bU0r*g?CAlae@^n$$l\E=H%f(5d'`?>KQ0m2W\!V/=X0RI9cPrdX)fG'@*(S_La7q:PoZlp+*^Yl[M[K,n)<M6Y at W3drd'VBa?82_-;KSXXp1_ldnGl'W(P/`rlcW6Y>&E/XerR%dD_Kl7L.7)CCOIk<?,&I]X"E?4F^oQCSl-MXD2cV>C9 at M>K>sO25Y-MItOa_([51P2Ke#qFb)dsCI$Y,60'@?T2V?B9X$f?J/4ZQS8>G^"VR=P_\!JooE,/_#0)U^0qf.T==Zo6&^BL;%jQ2jS>D=lJ_m+Y'rBp/P<*lWI2b<djJlb#c8:>jR!7X9MW^!=lHSblT`bVfb!>/c48Z&<[ZU,m`eZr]QD+q8dBl#WgQ63XT*$D7Q4%"E*200EMRll;LTE-M(@+Vh).??um%D6&!-s_b59Se:[3H1!d54!+lP`&hIe]%`.n"^<]1.Yq1Kk at JfeN0lVRcJJ#NsHgA0c)Ge*(fC,Khme&m`3ehrnU6s5c'"'p:X*2LT$!J>CD1<IIO"1A.6$,*C6c2e6K#*6W8jCfQXT.9G4rST-f;53bG15XCbm9),3$Pu;4`g^oufW`JKQ5cD!R6MgFR$,W!
 *c&u[47e2kp.Kmc^f3\sc]rUqXDf&X4F-=sI,G)[>JfD$UI=\BFQXB?&APHOJr>/<mQYVAo"FrgXjo`.j9'+)(k*><pBoUuFT0h&VdlsOTdLg$oU?.>ltS!i`,;?9`=0HJQm$q01N-S:u,IXRpM]DJ[*%7J0h$K2*_MF2E+/Hp)N2G6e::8XhHk`a1_;1EocBT?`g5BtV`q`kr\GG^"1JKUZf?pl/'R4R(i>S at 5B%Y2e1a#2uYoa]#G?U3hNU6h*t'j7[8%98\!3[a8u$i\T*i%ed\$>6:\Xig23&?>HikKt0G9H&'*L(a>ETGdQiWAL\NXW\=D)Tg(P/fs\q/Fq9$NI0J#!rD0Qe"8Q0mr/214tSsJr4$"55!Q,%YK,>\[_(Fc8]%G)18Z0I`ac(+P at QePg=]<(J3]sWLqRH>Wj=U+e]OqS2@:p!>l[.-#(Rub1\o1Jg3s9E8ArSMk\6>VZHSBb@!b/=F1leXl>\&3?$bu+9+abn_WZK(#.H0:a"en4$L9k%3G771\4[%TcmW%f0jQ/WUtGO%M6QWnMAegO^faNm12RYqReXm+?J at OQ:WHbA_7sslBf#$j692:q[jLpZltP$kL5Q](<N3o<pWL$hfX%>!I:iY.>X#=OR.NmH,stL-(o-\<Jue#?WH.S at Ge'[p%UlFr#m=:L%G4Zc_p;I[fOM3.<p=/.^6g(T3RseT&U=JNbfa`V%2r-T^3mog,2`)U5Fr at 24]Ti],Lk9M'jmqsWikW2CFS$1 at 8Ed-G-XF*;F`_5Kt;$OW+t6ZJ#srS$VR-50=]GV.HIlo',h#W8nC<Yk-9'`8E;1*A._XO834MsCm$qWqb&r6(\t at n6m*f/UaSg$bdL`HBn7=/!/+n%H27p#XhaOuWNSbg;Ii at eni-#;m<(/Sqj/-j-W+*/M9c8h/mTBXFkcOZ"S=2M&67"t at I)"f]AA*i^3Nu=hBJBSeR^dUe&4+qqTaaZ[`*6YlTg]`@8dfdc!
 6)MiI(EU2rieL4X'a at P:r+tX'gV:IhSG"R^YW6>5ou$*/l4KVh]hT\%<!;*kNk!
 `aENbe%n
">PF0Y4I95qnqG]GKT[)ghtV3&KlKG=7fpGKdJtBEXZ?]9)JC^,p?m=)$>0mX[Vg];RrEr_c-V1)$J5X0dOF=jdbC:,q[CW#KbBcCZ0Hj7"%>N9mBX%)h/7hiOc>="R(^V::hQJGY[HTXHl8NI-tKa?_V&?T'q7%sfONiH;L^@0PmQPViCW$,aDtB17tB.4<toNmBWH^YhnZ]&C5!/b2eq;OFV\.c6@)3kN)a(ga"1<WC]n#?SdX%ifM4\a at BtOFa(NN>dC"1,9Xi9G<".IipNb%Nk-]QB,B:Xq3V!]]%I,RunG"qnU4N*8=?Yj<CT9jk/T^`![eh8<rcb9KnLXG<VY.<P:t-?e[J!FK,$=m!uGm,*%ND.Z_Ar-)-VNp3?W0pgp^4/jCmOo[dUNWq2Q3rK!H&O/$cM[@Kp)enSll$-hF/J0;;E.\^9I>nEaqqH&pu5=R=Hp1?U_T>0NcDWjKNAt<ejo[NI/duN$VkggQjX*<FNIoOnIrnCn:U#Ip?S[d"cQ!.-;G3UCm$qun9YmUW=2Yj>5@<WUUQn;BPhr/4W:9pj63[/^KD9)#oU#;.%g&9V$Ps$i3SR?Qr=E"JIf0(TEr@`G)K\QM7r^b at m~>
+endstream
+endobj
+399 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 398 0 R
+>>
+endobj
+400 0 obj
+<< /Length 2108 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatU5hf%7-&:Vr4+nR3$C5.nM?OQSS(+kuW*S/6b92cO`:"r'Iad$D7l`gD;-^,7*Q=N&onj8q.G9=R]*fnUil,E=bcjM6n_T83!/uZ7ln3%,.^6\tUH3k#eA_qOrICd'CA0Z at PJ&l)Ej\:=P+^)s$ia(DhgWHN/q3C^-S,NaQ,L<9l)CueBIaAG],UFmtPeH<RZtA<Z7,I#l<cqoMbt:&P;iX%^4'\%q(#NhJ3TH)M$`(XTA>llqH265j,Z:(2Ji@/chbI4sQKM;QjthN;Lm9sS3Wn8u(QRg<B(:D^33g\AFA_qoOr&W&8[2PcLs"#dKcME)8t`H@<mn(LEk>Rb!V3VM(,LYMLH4[S3FjS4JW$u9p8-Q#ir8NJl:?L\)Y@'n at 4GAq<F5,^L%\k at g>iP1?gmAa-\C2WBu^`t!G&In[?t1?UMTo?+^md5^r6_8bjr%T-Q!.G`?eje\.XMg0,l`;Rk%,'Tb([npB15s/h95JJCZj[0gO?NA^Qs*WD4E>iH.K#>0`_ol"n>>T:E*s:S58T*r)E`M.>r9T0j at 55UFR'"0,AXhL51jp>a3Fn+OTJ*d0K[$e(JRL:j'Ws2>J[o^lk5m]UNpQg8Ee$#6gZ42fuuNp)m1KbCq0q!9N"areLG>.;E%i@"h`s6JurM(Fm,J^&*LM_Qo.=.>1[,q:Y9O<l0H]d2G$8Jqe='IG(`jSmoq'>@;5bCl]@#pQkTUJ"";FQ*L50d)I@$%)&5Jh/%YG:C6niY>*ddZeFco.?Q'j/ckh3,;Mu+I,2.8?C[u7j[):\.:@"oBAjk[qjA8PP*XeF?NNc#GDX9R`PV_,b+M[%e.c<YiB+gQ*&/i7O0kGd?>Q;f^^>O]\@I9B5br8:1OD#M]#FL=%GKGnN=9:DMKVC>%28V-ZL9C69Z>FY3i_11JubO?e5OuCps"OABV+HiVShDT]<,+#L*ON:h$+Fc<Z"+C,N$QFtJTKG/^aHZ-F?f'@)J&Zb,!
 e/3+:MpI</d[Y=hsffX(%"Xcp1j51gs$Vltge$o8t$Q>q:fDKs.PU(J-OYo[J:)A at KA96B&OAdl$.>/SoZSeG(aHmke)^DoOXS!\5<B<8KE.IpX-GV6_>Q/b8$$<'RV^fP.)lY\8N`6Y^t;Y%dK\$!N.<kDhi#'L&S4ijM[Q-9ai<aqb+4=eisX^-:0!kOgYHX3=-n>PTZJrX<AdoA["ma*Xa7pOa>%-&u%#;jJhV0Pr#H2370")]SMSX%/(G2&2Xo<>JR[DqXnP(g<XY87#Q4k6gmHf0&87TFm[o>^_+/sbu>f^02l*36*C[r2D^6=4/"[@G.j4\#j5*LD[Q/K-]0AQR-FEe at B>LDBC-h-kW4Y6Y6V?4fd24,SH^:lgu,mbHn5qISTeD$^Yi#1NXf5oPaR98DQKEW99/G9H'N!"g(A'J\q<mCn2kZ7*HYo`dWGmOrY/!3uSjfMk]GME/s6hVafcGPhKr)bip%db-G-Fka*t(Z3`c?L<En[_d<I-46s%8pH8P%i6ms8Cc&EK+EqG"4^EYH8dm\)'l>PF#9//UNtWX*;1ZK!hXU9K6TdaD+\TLrArQqop^3!FLO1o!*>D'JpKA(n`mS)ASDApTcK5&&4mG'%m%V$_ZA+)d&[Io;q=h]%Q at 1K-IC.SicMU_6\hmp'TBjNm("a[RcV'1RO;D,YX5`FJS*AlNeQ"s%Yo2jiOT7\)+bJNj;GVfRV*jbD=*fp!Ks3t4UZCe;%LWgY`HkOW7c.>3^-;.%3(f3pMC3X-jVjTBt1>PB>d/Q4tRg-fj4";a$PnD9^hLJS-(agJ=dSa#B2X8$:De3:cQHA_,q-*[&Yl.@\>TN(k[L(cm/`F)N+Y6cd"Zbk<R<Hj<mCt6gjKAUL;/&)$OhmdYk)]6KBC-4ce;FZZY`iU+Ag8c+*Ef\&X#X&r(tQR;^j.p<ZT_)C96-0^8P_UbXDb?.<^GeqqVdh"-Zrj,@>3gZp"lY-[uZQ_eBhm!
 G[7ZX*p,XK6<7:2Fm]ZoMaKOiFY"r++IEc69cN<qlP,e2qsjt/KL at uK_Z/t(A.!
 39E"=[nO
#2Gg.Ie)MbOt]tbiei[*")GVs%s82`fS#h*kNMQWPAI5N\KjP`R`Ie37Q[u~>
+endstream
+endobj
+401 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 400 0 R
+>>
+endobj
+402 0 obj
+<< /Length 1378 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0Dh/hR6&:`lHn70ngl22iDg*]6^8kU>4c#l'AkJi#\DN. at 9Rp>gA=0dZ/K4W-32gNKI/89<Xq^I7cn)G67RL3"?LjH),l"Q#Is"m0nfqP>.5dQ\_Vu1NJCsfBU6&0:T`d*qj-As($$0MUU+<2_U+Y(o?*bVIV-dOcc0?BH#@CkS07QHLnFaRa at k+Q`Mc?@($U5Jqk&S$b&2+SdkrW]jST1\VEM4o?%j+b]Vj5_ at W$7&4RF3_aVTj`OM\:,0q`/('cgmq%g..t8_?_6Y=lSB/0XH-tB*"QfaSs\;7JYc?n+0q8bhH)5<c_$W]:H(N6O,JkX\^O?hnumg1s)F4aBS/!GN7VF.DL\Tr6CCM7"btS0ZY2WQfGW[[SDt.gpnbrI=c0AWO4,LC4,PW#CqMe/2O#)OmGDE#b+o[8"FBDA%%oHX-9T<KUKo2N\d64$Y,gR](c<*0JC"LQJHUKqQ#GT1W7q:^g2&uJF*W;Vko,!/lr15uOSBpiFP at iWNB:2F/Iiu#LD]2CGZl^ZqjJ7ifbHn7\dFXs"*%8KJ8$p#V]]nS?J<q-NM("gc)>foJ6a7_H0?/JR$In,j4kAHL0$,pS00$,E1o+k&C*YJ=>?F=E*S5sIK;oj0'IUKEJam]_e;@Eka!L68LK,WH2`t6Qf=n!#PM$aU^TL]'>U]:l8m3l9r"GLnYQq)+09Er\V at PV6_"n.i at IEAEgad9g*oSKQB+YZ`71rnfU"Qh"EfEX&cI=4im)p%-r>`_BG:?kmPta-!#CBtpM=>IesdSq8X(Mmp(F9mo*M5Gfb%p-i/tCka/KpI?Vu!+^'UI>mnf8T/VN at X)O;o=Xdh'>O/$P?K]mWU/T;Afnu+_!#F_;=CBI8&.*9?=,>6&C4(!l at JkYG\UI.j_C&P2fPR93?0T[SE'35ZtpDFXt-#c.o4]K&gLV6Zc%Y<1g:G&n(l&[g!TD?Y#RQ at 4uAj+,o>B/qU=1l9ojo6%T3fS-S/#J!
 ]Hs3eK#_l.2a3]RnanZZ[8%^151PKj5B=l'Kab:Lekm;%LQ9A!q_J9C%I0E4A>4K+3P2Li=3%H]Ik2X8,RTfmh1'M2fo&aWb[(oPschGU%?+->qE,, at LFfZ,h<#G5Xel1C#8T?IB2hXq^GT$EmW&UrY4B(q5kSDht/K]@@'mu1BDY4n\)3-VL8XI2*d^fnfm3qjFsH,7]2-D+OOiSL-9SeK>][p's:9UCn_cK@^Zr4n_[b5J*7j84f1c#nL*h!nsJco:`(M8$FC$2HhJ#(;KoXV":QT#_q?n.h/FGp=nXFbAOloj^A^,D2rr87s8=X-CIlM0b5r at 8I'"pE>'ocrm5O^X?Ea$='bRf(0]-Ri#1k3i*ZC)bQb(bbGHmi]$fD,31Ed~>
+endstream
+endobj
+403 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 402 0 R
+>>
+endobj
+404 0 obj
+<< /Length 2157 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gatm=968iG&AJ$Cn0iWgL2Tu7a[tlV3b]qLPWku0GT[V3fh_eRP)_^(o3DnMZ'7d.l#^qOG)=1e]@[q\2lhj<GB:[19ZpOT0.^UW at 2g![ZOPY$bg:CSco+pOj3QELro&%rl2Bnqp`Zl[a'&)sEC]>pk#nrnce^8B5:motDVtKjMr+#H]t@\d2;M-4R9B*.*ODK?2/@L;2C3%[eQ'8rI!o`,AZU>E^_G!51\+=Ob,!2K"Z=02asM*rN]E`(`j*c+WP9OoSIe.*[Z_Opf<jA_(n-?QOpR3I#Ch+&iK$kRi at -/E"Kq!BkOBgn-N>$PaY3<[8SbW$"RE[sG:'gYN9/q-oF4?N]Be"<hl#30)B5hWL%Qpl+RXoFknpaD;oEgu$I&Tbn\3Lpbk<@A[*fpa0:teli(mS&p6r"dVQ)!5B2+O5d0,5_j$bhebW,TnP9J*A/C-Kj:?R.R4^29.?AA12Hrr#@mg4kJkF&gF9=&j(I);.tA=GlWR7DHHh)BJWpo[j(c3mo"WsB`>_#m5ZeF:g!FgdWkL?:VhXO*>3c5 at _0;Xe</Q1A`:pbp1rb2D/T.X^;\JNu`PRQed!<%_7RXO?EdeXC/odmPuM07(>0dUX?c:NL!2:ecA_l4cP2bF62YMFeh`Y7O#Xh:&+4*gPZsY<!nmT107I,c_(/ObiL88+.T9VGN9N5+X&dT5!)&5q,rQ40^_^^]d0/)'roW:A1.(@dDU>ddX-8BjtiFU)r2tZDu&*3RUqa]riar,7"n'F%pLNC.\ibK]<_MF?b_1cC=^bF!?'dPTM#l84$[J at e9[Qaf^M[Lo.7?V^aX>`g`fC,_ajs)7E8"Fu$b6;YF*hHV+W9V8;R8 at 5TZ#!*I3&_hN[&=kbmTg_G*)JMrQ_ca#*!8u5$7,MSQ1)uXWBj"F22eW>1"9B`8+6"R(?+^\6!X=)?If:t-?4t_SK/n-Z8A7[XZO<KI$+"Kb<Kt-En25`W+W]J4g-Xfn5oV=!
 .`0oV3_b%eU:Lp,jbdKPW&mfaahH/Io-79T+%V<b^Uca%*.*<8s;:+?"):,,bl4U8R02/MT"&%^5;*[.:89BdEOAWg_1>Vo004B83i`u1$o,*9LBXL]I%+N4A]i[NohfW0%k5HrDi1d9j"gO,;M*?TQWNf9N>%[fiT):KB0Zt&W;45/($MLqdO6*Z0]?#mlBBV'/;/rUM9YT#o:hTBl(O1N/k+k`-K1D/XCTc$>ji'1>=Oi?lt'[`r!B'JFJa=($H/C_KtP>cR`:A)^sEh1:Yg]:5+6?S)2m;o$I\b#X^3hbf;a\(>_6FW<FQ$>.0X_1_YqtIS75MY,nFSG#%b_PN;`-\/,GYGaT>RQ(.-f+sJj:h!5%Ya%c8s6.Y8pPi@,63cBc9*p.jfigPjGGfWV?J7=dBfU=T at sYD/VV>u>7)@LF<L_3LJp=V6(YHF("kKF[FR(3(dp%S#ZPnM_:6&h0s)qB?SkE!dS<;ic;`7\VkG[5/FFPt,FJ<;4Gla9#.EY:p^]LH"hdDo9FZSIbVQDWk8?^^eu:Y(CK&=ugsZp/-V"DK=r/SRq3c"n2j'/;mN&KE&b)YE=*X0nehL79Id`0.pP:OE>!@A/r'cf_]^H(.7:82&VZ<JB9bOfL_OSQ+/[%$M;<r?sOIYs<>g%?Vkqb&i"9H`TH<iCJ9X1,sM-8joXgM[,F1g at X11ASCK4^Wj<b,4a4t4KHZ!<in>MR[KO1Ks100B,'eQ2fs$9Mu?3GKtPTpC\R3'O/Z[j!q,.Z92k;!mbN4%*c7hEduY7<u8X\`lVa7=8M9W>;9T!pD)(6sJG/G[gQ]\1+_C,INhU7uBL-LlgK)T(n1Z<h(0^.#4./U06IZ52C7sa999\i4&fEH#(iAchF.%qEntb0I)<i&F_<]LX at Jt#]HR=YWCmIfqkU8H"`[u4d6Q`J:]T at A['ocEI,HFPRdsZoI>)4U>Tek6]$@`Up]78UA2Y+cDfHt;hB$T8>+epP!
 P=S9/R6DYB*T at m:/*eU- at _9nV`a,6=Yt`"jkIa`EfL_nHP[0W_!<%VOjrpIi=8!
 YZ;ZqR:k
,YRKUBM at WDG%EE?$qca%$5rAn8&@?Y?bA:imcUegg@]sNS^9 at plM(284BDXIL<gFDeP<4JbcNJN2[4JdiHuk-\u>lhgo%];_#FNTCaf'"VDF~>
+endstream
+endobj
+405 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 404 0 R
+>>
+endobj
+406 0 obj
+<< /Length 1643 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat%$lYkN9&HA?:6D"J:E+i+u'1E;96%XAqdDk^b&(;*2&f#2G7 at 02.kck)8Ug?1*;Oemq_E6WEI_7%n:YUfXNMg2*l.S&0d'\W:XQe^LCY1HIe'SWc?u:8;rg8E:JBtVr>F3dEnD. at H;qq:,:p<(b\Q5ho`;WFZ^br%/qj>hTnn11 at b<5SdR?.mVq%>@Zg!0Bb[?=hjo/K;j3,&:WpZIVZ,-bF1`&3Y>eOYA,P%Wso3s8tIY+hPe(m8gl";st:o'a)A8W_JK,V&j#FuYA;h94RKZ_-](IpHtNf:RQiU-p&h+j4o)du2%/Wb0(uT":RQ9aJ$D(]6(<@tPo5\adK&nb\[oC$*`F,>6oJ9YQ_*rV;*K0gVD+U*$!/X6"F:@6=S7OV3sm,,=[3rr'S$PqP6DiS:@'3MnY0G^$Q%=.EiW&s%RDO*")a)K3Q&b&UYdS.HINXbg#mj-R5k'A6<`:eOn;Eq01P02!^><r^OsNRa<\5[*rj%J]C=.ZZMnBmEbGW?N7!ElElf,g?A3^g<\"q+F`kc\eTi6cl-#l_c"&JU.4r#R6q)4Y_aj,T8j83\\)TZ:O<i=lUMb-\8`UZ`lt;n:o^=EOP,2H9%3ih&06.SK1_rLk]WZBr!^SY1>=#;te^0b+"3O.Ja6_P,3C`dYPo9lrat;`jrUk^&%TeS#FZXok*f<j3K+L`G4qQ=:KV3;!rN:-m-i!I$;^?].D at _RWMjfE`VamMR2_gf3(B].#2uo,b*Qs=]ulP`Ce\?FG?9Z_mFhXKO4I;%'oDBjV5Z'.4OtJC=3Oq0$,.Klf5H31a"UI9N[,gInl1nr@!OM-BPV1>\.oE]2QCm&9YAq6Ve:g=E]K(_)R1f,/RjB23o`n^:B]m+O;ofV^ZFNW\QRJ"(HLG\!nLVAMFj-Mo,!H[ju.-$2S33]hCD`"!LL9J6OlF8EYC^UERnRTP?*0>mrD-bBuO9W$6`JIWe1407r]^_+ at WJ<UBg+G=.!
 2(PE#Y[e#T-h]JU;f.\AYVmhnh4B8UI$Bt'uGfEQ,O*3;IJ.F.X0Ksmu4e<(b!9YnoZ]H68`,%J4??u5&I+>(EQ&eFWSS>A<i=_RjTH#mQ9kb'D+!o!GT*M"d._m,>6WlL"0*+u?$JmJ%[)0o`AHFAf<\$),7>h#a#kD56i@`IJMCO%r6W2\+I`)XW at l%'UJq9l2U\fSJ0TV0!Mrbe3^MK6o!lnBS6Y6DAq"ik&>%`7oWQRHrrI*7p0s2)TrMN)5/$"qqB_O!+6rC+V5iXou<#8+W[-)lZ]o[L6\%0r;RW5^7o.fYCuS(,=cZ<iHh=mS/FkMdshfRXQ at OgJ$D'N<s;8B'>+64nPSEhV[LYl[&W\7"L'`41Y?bGo at Pp$=[p1pBMM]+%.)5!,l*.].ispc?(TQtC7Yflq2BZu_^*oP=hDOX.FG[]I%XQ8.f_lRhQ=XFji`NiO5),HIAeeWQ8%OW:</Zu=ZQA78U2>g`NZmXg)TF%DAJe>cUWckF4J;c\;r2k6i-[C81'J>+ui.o,ImAW;FUhqC?q^)R%dURi5G3U0bi8+OiuD6_^IMsp='+Y#4e`8VW?>0@".e`)MAMbi*q35`2)>'!@RiT<"GIFupqRRi;j1ZGa#]P</a=FOHdA2Yc.:S%,"JQ+2[~>
+endstream
+endobj
+407 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 406 0 R
+>>
+endobj
+408 0 obj
+<< /Length 1923 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat=,D/\/e&H88.+VYdYZmdLte;Kgh6Q.qdLGV::\&0m1!H$;j:g%g0.;?"N5>lD^aeIf1rk^bgm[ecM4HfOt4aMV:>)nRDf<_?T,MTdo_Nld'fErU/>Cl/cRon.!p%RC71RbRYl^\[lBG_ at DYQhHdT!u[=Sh./q9oc?*XQ^f^Q=jW1HBjWX.+hB(56t+W]J at d#EoJP at +JDs1aL$>tLY?sSg#O at +d[EM?C^l%t)TV)@Ph^')QD[lS4`B#/#4'WheI.KY<`kX/P-(N)h_#o)hMdYWh(u36Zb`-cRu;2dkL8toea.N=pi:`QD*45F0#)n,*M:&>NhZl^!`#daI,mrMPg^)b(`-?lJMBmkGYOB5$uE6aN1n](NT6Is6Lk")oXH`FEL,]+`-\;"c<c5?2/G.!`0SN1Ka:k5_!2ZQFi_G6-B%%A'-DP`H(h/!boFcf!AH-a!UI=Q<i-eh.DM#GTbUN;.l-s?pr&!+rZrQ-PQ;=eRWTeQ?\H?T,.tV")bh[2'+c?`Z=j=?1<rf.&eQf0Sj"J!6*[2;NYQ*aqZpDYPV7r0WPkNglbDR"NPJMnLC&=UJgt_#0D7`/&J'0*3K(9Lcrt40]'8m9^<^P`WWM?2>#Q!Z^fiE8."CY\8-/*ja2XPgnSfl)>K!M^3L^Iia.TJ1+^/`c<B>JrC"49I29S`(/kTG#iE!9uFSccki;YfV[EZ[Z/O at b%&6!+]nH8IT6:+oJo&lGV/clQoNJg\b\4TIuQK;5rcB]g^gEQQc$J'.NNYCsR81MTU?#*HO3Z)>VH at +ddl1P*20bkSSijaKu&V$`.X>a?Z9t]7R%W#3^.f(BgJq,_'BP at H?ajLS7)bPp>3r]St#dPUr:Y\i<3R^:t-J.l+6A)BSX*.CQ9gq,Rf#-2!Fgd=KlZ-K:T$ojS'\<kX(Co3!m(7n\!SK=qq]Z/1']Q?6+T'MKb at E2j4ieI7)0mK@)_WU1IL^&77G/AshXu,mQ=9BfIhc!
 7.AVuZ9g=k/oo$&/?GRD`!^".p9JQIi91*d at WlWsne9IMc0`RfT\"suQ4*iYo+S3V"l!)om->"Nf):Qu\=e>66'FB,cB^8^J^2NAQlAudbjMQ]0n8.-iiql^RL#+)I_,,uF/PluiiS'^1 at jVo+R\[;XLngZ6BZSmk5WhjN+1FRg2F^M/eZ6;IUoB1NZ59pLrm8OQJH/D%c(q,F)Kree%N)hHS"7AV/k#Gi)r)K$31uYHtp?c?@pG""32i$PVO9#(sg\0mgmC9p8nUN7;`F7=NnBbSt!12FnN7XA%o1CIOlmLV*@s4S(3Z2l160[bVFImefb,_2O!B`,#OH'ZB(Ma#.hrbp_rTHVolVQFIdNYe,7JZ=hV61>Hi[XU"MCNH_#DI>4e+4b9W48$G7I)\0-Tj;`f5[m`"nd(kJ%JVb;,bs\MpNG*;.6m-;%GtS58N_YqN(C>)sSnI$=<Z'P)*F(c;8D,Vr"-sTCl[iLej5l58MU at PIGISZS-`\/olA=p@?_";e/%<2=h!rX4cEroW*WC[aa=C0_+ERd9e+Z?=j0-CYHa+PV(ImR]bhUHuqJ#gKi=*Z0.i(1nbtjY=st&@QMb6TK)?h<7fU2X)F>kh+,+&qkCH=,qXR)gE_j?=1bG2-M!gMC4bT<d2tG!Q]Nme/hoX1?VO%_7hYtSRii>e;,n]!N52Z6UqZFU0H:]>pa0AbQe,m!ITT_/nqK6&Z&2JKR6gWiZH3-?4:gDt"R:.k)..eMTH`qaicJ%S9TJPcYZq\Nrr?/]LO at hZCO5^=Eb%Fh4VWu1W_=EYAl/&;&&X`"%HV,1Xe/<7B7KSa$@RSOC7TB?T)kb8o]W"HMHf_rJ7.'d8MO7oShk/)FE@(gg4,pAeb3MXJ\7E2TSt^jNGl at DI72HNr4\9,gc)nYRu<MjeL(bAOXc#sCJXs2g3-fX~>
+endstream
+endobj
+409 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 408 0 R
+>>
+endobj
+410 0 obj
+<< /Length 1395 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasap?#uc!'Rf_Z at .q_,3!quCK(d<UP-29ndhoB=W&km9Q9St93!,Ul3rSL^"tZ/be+&Ae+'83.HZb>o5"C6p45YWJYcVRrYc[Qu>.4>pbCN%k;VM3d>1(XlF8-q=qu5'0op6DA4deUnO_.#\Hakh8Y`)plf>K;4%NhG.V_FM:4H at EG[['r+M!"cqYEnUq2T]%liMRm[@``ZaBn"SB=KeG)5h(jQ+Q-&uY1ri/n7`XT?ss1CfRgMee#X+.5$SiE,2]9>r5suF70)@sKEqV<)\>cbdH"MN)5i+;LKZYNQ>[;&WtXo*2>2MtJ-bqW56]dF&/nIA-("nCEV(sNL6$a!34K-AbnD^3SdH\tm(!,l]uVmM!Cdl=q>8'?)?hI(`!(g;0QWl/%_mN(]>3_K%<c%8Rm_=E57U$_/qef3<m2b"=_:.a@,U\#"[`][8M63@(lbH&"s.4m"5MJN2T^!*/@Z:YlXN3V7H/V1:m4HL#faX)K"Go&0#bVEbMu;$;D&)ZEPX<&,kA]W#;.@=WCsJV.osU!!L-4WWj<I'01;P]A?X>T7\js-LfDTRLQO.IJ]6B?1>+J"FqrYAkiV$;-rV?ao?#l+Hs^X%%@_Sg)FT*[(\cgqKqtZSE!RTMU4pgL[\YaO-QOM8(YAlcFff2sq]adZRTf;mc3Y0MXHd1-UAF[T,=,5o?FWi1FJ[MRXG\)pEkO;t^A6sRQ_c<Z-Xu.8?lM!5Sfrffo>2<Fd.n#5KPJ*Q&#f9/%E'].O[fFgmFTT'5$d/"CWWtR!+."tAIo(sL=C)>c?B(eRlm"@DK!r^e]Cb?(4<g?nmgc#T;pT"0.2Fe$)-DiWMpFm:+@%C[A\[>YN,8/`QtC<q=%&Ppb\D`K)9K$Bb_YBO*=CKgM$.3eLnG\,*h>QFrP=dk5U3:_KL<UeQlr^;d+,95Fo0#HicG1N6!2;o:3M4o"I8Sq!Z9u[*dR4/=44VQh3Kd)I5_j at O`6\:Q#ncG.Q!
 VnifQC0>M<6$6S$cu`\d)P[uYHZm\kd?Ua01?bi1H4UL#/i=A4:(<Mo#p["iL at Vu+]2m]rA:<*@l!]lI?bn-<5A92<q+ZrOc6j_50P%lfhs<;J/`Q\G)q=.](_*R!#a&FAkOd>fO-I1`eASstrMj^Z5H:6;^n9!nb\]W1UmmdX,PgJu(Vg&R%@aVZm3ET-+jUq,:E?IT`L,:3)/eu at Vdck8Kp2Bf:%`HTZZHRKug\08j8eLrm6%lJ%K]].b$d`Y-9CgohI];GP;QSe0W8:E(Ojsqj-S- at m#I<:d?Xr67+p>H/00&KZl5r<hg^=/)sW=&`m(Ne?=AP6uX20^*gN]O6"&G\k\#c[-\%Zis4S]g+4O2BLX.g1pF6crIblAX@`5rLj>;Lr&-^ef=Q%kYSCXT~>
+endstream
+endobj
+411 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 410 0 R
+>>
+endobj
+412 0 obj
+<< /Length 1080 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GauHK968f@&AI`dHmCM)O=\S9k1%W%8NQ*ei:Ko.*>*tpe?9,sP5b=#&!.o_V1B*mBeB&KmC0.HNB7u*+W>q4C at 6*B2/e"%."4]SH7lRt%ZmNtU%W![`Y[?o:3,lDbu2*/\QjLHLNLM"%@maHG/47Bd8WYcC at 50^L9l*aciqlb^a>lce&fLPqKVH92'sjpH2]+;fdWC"Dl8f>]8)13rV(7$d,o at 0\VjAJ0eS1Ziam:Q?(!o4Bd2Ip/LJ.EQrJW$19Vp1iR7Ye*&5nB6lSU3.lW]6qC8uR>-=JW'7MMI!=])pnt\N=+I!Tj/u>qt<k2 at Fd8T>NOd%-EHGpRS[&7P6K8"G?T71,t#F>l)'?Y%1d]<4D#mb`W0tp[*lMj`6jssg$^/noXcVb\'*GhCP89`.L<7+(DC*<(GT*E0r6;aCT9U#\]kTi60+OI08gVj*NJ9AJo8`>$;QNPZkI=sSqXsnXb,V2iFUN3o=6,r3-5/;+i19S!DA](c&a=aEq!t<[WUkP8clSB5(JI[4o/PM[gnV6^fC!#E)IfO'42BZiGZqut)aZEA"'B`(VK\6SqK at g0d3WK[`pKo,a(,4M>GG1ljFFp/S?1oj&"'Rs6l at MdAcSeL++!RHM6(uoX"fpM&C4k:8kApG<B6"YtCZYE<euB+sX]H])]BDoh[S:/i>mfFH,=UA/9+qsP(q='hBs()nl33]8DZtP*-C=eRC7f%^!='m#e229N*up&QlD/so2?BbYKmRG56mi2CC0J*u1t;4Ec4Ns6Q+?S:<LbKf=dT>sJn-`C(?8I4KXq2'>H?e+q[jO'X<B<\iHB#"+Yg9]rEuG`bYK*0?4e8sL`J`*Jq;ateVLo/-#amna.-A2Ngshmm"GcV2;AeEG[!D&-&aKehGE#SZ@[_$3jEZYJ/&;ZUO33+;2X[.M7L^Kk\,cX'iEMcc,N#Pa<pE$p#\X6Cq.UUT.=oYq"n`h9,1\>^[ktP.`^u8\U<%q%pB!
 'l2hb,1Tic<3/I.KUNE_kRh%Zti4?b at 7hEQY5iLDJ8eU+<LCAOIrS?nmFUj0l:>)PHm(a>'fZbWM5&7'&I$Y4k*KE~>
+endstream
+endobj
+413 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 412 0 R
+>>
+endobj
+414 0 obj
+<< /Length 2458 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasa2gN)>_mQFq98#MP!(3QrqT6@]sl(5?4VK$r(NmDfXM72*YU0!\kBrCu;O9A!CQBN?(!"a,r#_;Q&e^`KRFQP6h`GDrq>0M.krbMU"J*&OU9GYiFr7U?hqqq=Y(F<G7+!5r]r:T*jqtk=#^Ko0T0>CTdcZVI$^:@h at C\><2rI;9PcU^m&12e$J6%=qsKV;SSA6t^n'mFkK?M!L9D7i]ho3:+gU2b.a-]=S&Z6O$`'gr'!$3<s#A_OFLn5s-N"+QC&W8%Pph`9Q*4!6I,=d,_5R1 at p>Xe^sem")qbX'8nCXcV(TGb`%^EM*5u?4d<HS;s00?Zfgk9imWjF(C9AmQLe1:m2$Eas3rI at B_RlL0e9[rn?kQaP%'@YU&beA[k9IF9k/aqcSd`<&D;dW6`nc?W"K*qup]`j-NNj2-4sU6)m:ZQL`Nbgpi$Y?8aB<H9 at K;`u&%?Z(ii7NG.XZIW6WT#I/[6<DQ"%p`KmT"4%G,fm?'q'iY`qO0WK<VW<rq*/1@"8%Ys9\(dtI7V"juYrdN/?B4)NLHFVjnP:gWT.R`9[./VgHfpP\(Pu)RFs#u7q00XEq3PIVJ,&D$E^FYo=uBbjn_u>qg'qSL^UR%m2tA.dQQEJVrHHT<Sd#euR#M.kgTJ]@Z'obk9qa>]6]klN/t0\DM&6!2+h-<(Zlk,Dji*3(OQ8Zab$rFc::N%aJfP=E;+A]"[/16V2b0HtXl.0//qm]Do,$DhCh-A>_o6'cgbj#^\nZu<Cks/0>TcF_-jX]gST89pV9Ff?ERSd6 at nBca#\VcU8'4NN4+c8c_=Mh@'@e$q9q16?mmbIS1"2O4b54+C&'E2I/gR^VKfmh0bk1<<d_VhEUrTeO%oPeg^1J,!0Hh8[KLnXc*V_qcqM)M_BK(#jGDJGi]hmN+&BhXc*l'.ggI,574V at C8JB@0^/_6_sfYio19u6 at eQibQr^g#+HV9hgGgWJ4n.UFb<Q(XCih/oB-DZp!
 `L8u1XspC?P'A()-u;-"C9i0ZA208NHh@)DBT;K!V]Xb"bjKhs:VO>a`#-Gh/V8%Y"fnLO=+etp1XiFRf]I%,7i4!]tM7B#-i,tBHr=XB)6#q7nJ.r%&$j[bf!k.;d^02ItoKP4,N_d.>Z<"*f._]D'e):?GFQ[F!hYS&c-c7gBK>p$HsnpFZ6&:ks]MNa)2h!fac/G']&"nNKa.e=ptZCn:_'(t+.%fa?9$j'';lm^t&p6erlM[6U]iY[4cH/MLsWnhci!p0Q<Fblk%0Brq?60r#8QqMXURrgSC=[l2\Tt"!=n<97BX;LM>`sJL6^,7Lq/o;S%;[cBe`1B0#cKnKKE!'s1qOCFK9F4.(F5c18T=+hZ3iM"n,ruiK*/qeI6-ORbi'07coid[\#%DQ=]A>_EaW-]>]$5?hO[/%s93Ra4Jf'1L=`J2K*DWL at IfK"PU,Gr$H".BpJP;uJL::!KGh2AtPY\IlBT.r(h]@,s"D0u4kA4f?E4E+K+nbBaCi3P)^Nk3W621BWj8F0drU`8.P_\;ibllL7fH")p(E[6:rF[S#(%]ZH<sJ%JSYGoNAmhV8Ud]^NllGj4*#m)qQ#3Tg_"?/Z?r>F at C&8+3Z`BdedDWi/@.d04[X:T3$lI3RAjV_r:l#[*DYc)tSph[5fAq"".Tmkc`I?mjc1KjEQ7bEAIDlU-\3BYB'=#c4CW:b0bMN<8*#W8E3Qc!OhtLTuTuldql(m(eO(ORa at Ub*2m/VdKXuQd^QWV0F8bc[K2g+4e4k\*%Gd0)FnL>f&.MW+m3mE*'p,5=FlGXqFVV7+0Pkar,=0E7qo$S[[/eQQ>]?X/WMi[K]?$nkF!Vd_0#qOIMh-3IqGG8ekN:!Tdn at O'AR3-ZF4:n#<<H"j56U?8=`HK>HLu[F,-jj9dA8Cn,mGlF_T(^+eqW at sG93,ZW),Uc=%rHu4`Ho8#"fE?dLLtu%3IE^FHGuNSFuflY;^b*ckPYYt5X,H*=!
 lDNa+83.75h:C+TP8J'i/of$?HP*Pi-9\Ah;i/*%B&P&mTNJFQ<4:Eg#[0Y-gT!
 #_#a#H(`
:L?qV:a^qQSn/L/@i&8RuW`*qL,1/R,%uGdYl?YrQ48G"B!#&]#si1MBR%ok"F/=@#TDRFq5kZ3s[:@\en>mqXl]ce7PMc*GLaJJS$Y]Ug-r)Z0U\(;Ke[OpB\CUG![teBepd<je<9TXiHFalILhVhU*Pd\S#b`ic:3UrS-4FO+AViqeGum]G6+!(Cn[.>%inAX8IY@=MW[VfS=GoGbkl\FC2&d?WD'1^'()*ItTlo%(rHU7<$/$j"SiX8WH>!ht!4'(,l?$c7+O3/$gHef,PkXD$Vu3co/Rt2o?9CXlWtjoZ+Z(it0aFXL6ieY.g8fHd&*ETaqs":rDS`;=iK7lJ_$GC3j-F,;4Y7R"S,Ya"Z<k2S:G3PV at l_Vc,'Toq0$a`]hEY^3X#o]F\(2JWo^Z]jcV7~>
+endstream
+endobj
+415 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 414 0 R
+>>
+endobj
+416 0 obj
+<< /Length 2270 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb!S-?#SIUn3+P'aMXHUM5"ok$&W3Z;Ck92dFR&F>m.N.gK\:2&LG'BYlDG48;\d_:',6[.J1J=*q,T=,P>elFT*U*H*61f-As*mZomnK/puNso*$mhIE+uMPP+.gaiD#J<>EcNO3[Y[JB8IfkN.^C\1Z%9U'k/P,,5 at M-$_j4q5Pp6jU*4DokQA]iOA-r"&t2UaD+`k#/fnIQF,d3a_o;TT/<UH-e%6j>0J,tb]$".Gu"7VHlc#=%QkB%?KVp2)E]:@,3Q<M/Y!OL#$Ki%kk)Dq&//U`>%1m8;@@-50Ye)k1n;jRO:j,oMn1C#=u@(_ZN[Ja)QU(r at k;Jqg'eifk&XQSmG8bnS[Z`KQ3?X.ERQ`bM[WaTgNI!IX7D#>nZ>XoB&MB,L/U,ugtdKq^eeSBRKCOtd6dIRiD^B3&><eU-A:U\JT*A,#Vd8L+uq<3et-^s^7k^HfRQg<1n/jPZub[X5Dt=cDS$-Ap)C6pd`m+3mR at I>]>ILicekO(/Jna#`m-Q,Jq!Rkrmt4iY?k"TA*gWDJ^pT&5n=Y<jLWp]SCUm3p at LE`[ZOF'cHfY0C.<7;(H#<_YmSi^_C!H#*C&e!/Lg-iJaM]iY=)]+R2)hS7^koZ)b4D,%.ldc%54`%I6cCYaUKrsrReUE*Mo_KHC`nRA[aR'@1r)UAr+X4etkL%QSus_99M>U.Wq0UDM2TI&O0S\MhR]hPWGe#!_tSQ7=sG04Z1H@",&/[XkH&=nPK4a/T+QWbjn,Xf5o[ARpZBsP9 at _H-1Q[W+A[A6nOGWUg3o;5:-&m at A9;ite?iD at N-:_c"'[BO at OL`sSl<\J3-:>_=X,YAn&mHa!dQ/S=c"85\>@_=iks?:*:]S8FX>+fWZ"m at 8<"I1a1n&pOVWVV*6FX,/?c0:/XdY^ZCn"2.X at I+Xj4#q%HGO>BM#85BW%O;\?>.UU94;#KTnbk#h2-_/0kUfW`Jhn/8tELN;$b"3+oRF^mGR5Jh-!
 /<0',>H*>";rR"<:jZEc]0J-m%.lr`ReKULL$Bc)QDX[8mISpVqb&6P2b$<5i6L/nRnP>\U\6F3PTB=c%&ZVlek\hcUs$H/b-8+[EMjB9G[2'T*FR+[g62bD5V+qE$rE>UN4_&Y<d_);V""1]6Q`bDd9nZ*Y5TFKl85Qm.KA[A7&D(qtmP<d^7VT6$c;bs.LAQ*/r5W1l'>)HO#M(-La/XT.kGDu!_dSPT\1tf-Sf>mX#?[qiip$N#&I8b-p-(CYJhqsMod>#_BD4]uLD+T5QZ3J[a`c82f##XI"?tq,_Rd*Hj.P'\<!"Q?Di[GE]!t[9<Q*_d"'h!+Zo!nemhIOoLiHQhb>?3Yp/YHj1+gJQ68;sVqMGdDrPt-.H-'hc at 2Age\(&NPoB`-SUZoa`>:C27WGtnq=92^=.JV=G0e2QBaF=OV?_/aiOP5S@]'?MVj7[l9/kCgE at rHh'JL4UZNKCq.I9A%RhPnU6+BGiJri8V6qDMrO:*:NR1P,7V-8Si%]X%[4,_AMjl$k6].?dEdk=7PB6<bJ at ._J[4BoDu#O)XiDd7E8-JZi&J[DM#HGY;!QE.o:n-WXfo"'6d-e$IkI6E_Z*%g_-k/DE"?a#,rhjENuL9l'S%^^UsL,W\;gdT8q1kqa3bbiqP<e0SK'q:(((YCoiXkI2NkWp79"V1IQol;1U2g%Z$WM$]A!AMhP,D3CB?`Z\joMH]#\j_hhZGr3M1=^KXRB9hF6/rB7e;-j=2sYL?`nSr7tD$,;0.#^p?uT?CS'"TgYSr?nB@*4T<k:P%e\9**R,g&9q7d!1!IJT_,Cgs=WV*,%!Z#'9]MTNgfrE<$eO7JDl9SFhu[)92iB_u5`'.FqK0rEpL(Z$`%pO:$@@=2fqu!,+/T5O<GH#M9+splN-Siq6C<GL0*?fg$oEeG=u".!'f1HXjiaWWBqI+!c82[<)ZV#P@;t-$r7l%d9Z)n&*s^7(C34F\8rjA:66f(k$Ha)!
 #4_\b75U7(@'m;5;aIREb3a9&+iSJiL9jnkRsR2ihP?2 at D/;3f_eg-k&+h<g@^!
 ET5DVb4R
j.YjEJ at gH,eEAEQaALbP4-ITa0:"5;(EL at jQ'X\`(HQf()=>*'dM)W at kIot.\)1Sg1N(Z^hRX'g&\/R=TM+$[U3QDfD'ph*Cq[6o4Il9g:Kju5BOK'B)OAPLue+M^(krO3P(D=SE,_XB\aoC'oK7(UPb'I8+2LF9hZiEO$->>P&T3iH!d[d<;h3k,0aIES!Y%mab*Im8-=&M6%N)]U<mlU(NUUIh>~>
+endstream
+endobj
+417 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 416 0 R
+>>
+endobj
+418 0 obj
+<< /Length 558 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasal?'CI+'Rf.GjH2JA$'8%shfblWFnDA3<ZeF'5][;Ne$)Oprd>I&2H^3+Ge"p,kFS1`mYg#j],Zq=8#SBO&ZPqb,4cC7 at U%'N(hWsd-hK:OD)\bQ)Uni%=[oh=lLT5UQ%pGd*a?;ghs\"7Rtldla3UC5RJultTR\):C$b3Y`_O/&/'[gH]*8%cM at YF_^!V0uD4/@&)6&$u\,_-mdfH.X]L9,^;Rj(e'e_'<g6F49Ios+F\o at mpaVq_kAfpFW2e)S&0hUqmr_50R2lkT+e at _*_AsJiK+>o\h9>?kPFJQI0Aj. at m-7E[F)rS`CCL+%"!5&P<&6sOL\WNi7HYRK1nbW*Tpf$?uS'hQ52cW%XH[7Hnb?X-Vmi%NIW%PJNq<4\1"_h>5q38D at p1)\-gC1Cd-C%Ht=fNotN&rR$]A:'Zm[lD2WuU<u'sqm>Hf:&N&8-s]iX)NnnJe$A&Y-&>q=XJW$)T*kilFLpcnX/WpViqHi[)Rn3'0c7Qt0:\lVdtGEEP at hG3967$H2SZAVu\nNR(glLfed4S;o*JF\'7IMaT,q~>
+endstream
+endobj
+419 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 418 0 R
+>>
+endobj
+420 0 obj
+<< /Length 1063 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatU3>Ar4L(k(RKpb>=?lYE#,:M\Kq9J($_g6XNg))Vs3'']V,T0ML.S7$#DeX+:Gms`Ouk:.<RhGQTUoK3J4q#Gub!!B%s0G"@2i-IS/R/k&Ar,Ss,i?jb'#VLoEd.`Xj!f+Vco at Japqd:W2;TX/1LYt)s^6]ED'U7bmgX/!9M"tVhk=B1=E4'o0O9!RS3*SjlmHQ#8]TtQnLYA8C&:4hiiX%m\PQ^Toj5;C at T\.j\\<oN_6ZWf^2;3ZCXDlkq=bX&@[d]Wm5/@!!;)0Iec.IZ5Za/`cp!7H>Uih(p1,n;YLX`Mh]-M^U2\b:>kPW,kj4p)dmrbb0cF9F,:SZ%mk3i%O&&UiHNO,)a^[)t\95R+B_4Y-s;K=)$4Sf41Ec]+[ht2%1.1KrcMHD_iIPDmE#"kA<R5BA`X%8]CkPNcc91GDp2PCK0;DUE5gp at buRZif)'>r8TRM1)m*p`[DQ:=ZU:b?5/DM*r6bX7JT?;tR?Q8e%qofgGHI"a\Dl:`>A$o[BCkD>AL,2QkQ3[ViLjKu5>]hYDM8><Ur6H?W4&F8$kM.XqrU4^N/d/YBminDdJAm6"J`k9RT=6VRIS%@2I+IQHq at u;Ridk'#'(0VYL22CqZSAfh)%*Nkc^?)+3mlTbihDe>#1Nht!bbsg#S$T6R-umhk"`O&Pg@[oiL77a_oLAKHo\D]Wl[pb+f?!RU7M1Am>6,\>X.4+gRC0^rGgI1P\NNVUj5BWFHl\/pN)'e`aM)5&%qjMKJal8&7^r\[BMmiXh@:B#Uhap;-_<auCtE%;eKW^=")$Cpb(Fh^Dh60Te4HLq5kccdqDEDm_s,N3,e[%J"eI#KJdfhH9"=!C4VGb\#B]*<8iSr<rNaAQrAm at FA;n\c*^AK:)-bN+A=T/.q(aejo2hAZecS">/hkaU6.B[Ui;EP(qQ,T=a=;Rk4E"M58t]k`GIQ-VPK\Ir`Q3fUhCjeLT%2imHPq/8G.'*5%!,Em9L#!
 g.oN)L>]lo),-YM0l,H>#+GUMs?X8k=j"N1%8m3Gu[Nsl5l("]NcSDQ"LXM<K!gP#J8nCT;d~>
+endstream
+endobj
+421 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 420 0 R
+>>
+endobj
+422 0 obj
+<< /Length 1558 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat=,D/\G_&H88. at I9CuUt0=sYBunMCA+g.h.k]?qrMju85'q/'0A&smG>$2$j;B=o5^j11#n[7#+0[d>`X3'^.'.Lr4j8rH at bhG"(&eCJ-TJW9EOF1`#C;A^FiQs`_40>9gABc^V/$eg_U+I=Z^4M=2_(Xr*t!OGl-taq"F<+hn+bu`o1C%0qpf:R"d0u2CI8p7`(GLqO'#^2m<@!2to95g:ntN?'d\BX"Zo7!"k#87=ON-:kkAa<\lPgZ.ghSR$?&L-b3)^C;r]aa>9eI:V9dChoI#]G#g11eQYm7)qD;FGu>rp0QCs?jCD;U,lcYk\Qo%dcncd#5Q1LD*.8\6So/J\%5'XD5QO-p)Hbl<*q/N7ms`#nj2&rn2gcVE(u3pUDLCP')"h3H&W$sQZH/*>:lGK?Wei\#h=n'BQ6F?ELFCuIJ0pf(/d_d?;*,LpfXV'5qO6df/;1kfnmaOIqYIS#2T/`u;%3C+8 at qSrjJE[-5'#0HfL9sqPJNR2f\JeQU$U3`:)dA4/X,/lXY*8C.e<=Rs0i*4W$WNO+/s?_CH<iml:/BCX3!S:C:,C#*JUVP(9FH,U\VuPq.Lqr3]q,aY, at R:H?/nBiTZ74Mm<G[=hCEH]*[g)q<e:a^oYL8PSe#PZ#`DGC]t/R$g%/R1c6>s.gZ^K`N/3I=r,2qm5c\k0[jFtU-5*/"X3IDK8+,c:#tBk(<q*E:?T<U<G<mZPc)]#&AA$:["+>%if)N=Wm#_9-6"fMPj2C.]TKg_(1j0]LSlgX8iW#i-W'1:L+9Vg4HF:j5N#I-M'[FWo:"Umfl/>DIMt63Z^Z1_9O!O;.'E2=d#Qaj?Tq=aKX864A\M;R>.US3YM=3WGEFFTjk-TqOqT!FM#*jb^Z6(m7L8dOJt)<[0gWnY=SEEj>VkG>2M/TSaRM08UQKaA3EC>FoqAaG'rFseGuQ=Fm]<?+r\C at YTLR,7Zon"9U?'13'ht\#QI3,I*RR*m^&;!
 =b53^]-rdVP)c"Z::H'i3tl7ABZZ#Om6WEK+9%MN)], at SK_df2F!Kjh!TS5h&@:nk(P<9`r6XbaRoK((sQb]b/jFAXbR^*qUVM+H"p-1<"!gir3=0_=(L)-BPFWg\jY'glrK.p^hBH:QaJeZ?'5]>X at M'nHB==RLA2X!um.qG>u9nTr$16M7,glDe;%:DT7rTOpm\r2l&"q5n&r%O=o=C2B>Cb1M<qc+Pu7*T7snaMnt\i@$FrYM%YV:pFLPA6Hq01lGg4=Ks-`=uA#d:TCh`&YfuN at a"?YL.r.IX"UN>:=)lH?II4%GYLh#L"eU_a;f+hHbqEf%<aC.''_n9X*TU=<\qCkMn17$7S^#E9a:CWT#"@.$33PE#Z%r[S7&:)9>gA($@j4 at 6)G1_C.1a=D[!*Ncrmg\q:)\jG6>@<Jq>4`T<\!FqEGJ_2";7/51@"0W",[R`30<m%RS-ib!^?DVDA%Bf)55<:e(=Wp?bJ+]T_T+p[tf_MJ<kn&qZ,c#P:pc[KmI(9_FGW?[gcKoER,r2%c$r"c,Np#rmU!"RAOu%i'DT(o703<+Kdl~>
+endstream
+endobj
+423 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 422 0 R
+>>
+endobj
+424 0 obj
+<< /Length 965 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gatn&?#Q2d(kqGM/%A8*io2W,gXRd]>,P,!'=sZURRl]hX9k]\FP;3B$oll_-AAga'G5ECpDhCeE%]&E`AMe2$X>&a$s[F*J;u-Ed"/,4oN_Tmmt;YCa)Du/d=r%#jW?t;:FH&aCS=rKf7hG4"(%W.Vft)A=Ht^B5-.b906oHr`h$Bk*6(Q$ib4m at B`=7:s*/BPNuTls)ieARoj^s]&$,!oYB6J!%qUHYrY[*'WHB]]LLILCbfYa-<pAs0T1dS1H(F%RH;n6a`l0Q'j:mU\_ka5j%'*Bm4KaZC,1X_rOm%',B,P(BOdD'`)7tXp-H_qNdMf^dBEkJIr)&N&s(Wn(mBL7./_3&,bnbe<YqgD#;Na*0<B,6+a=@?k#mPNCH0i\KN&us6h;C%FKTO:h1k81"$^<2'9$2mllBH:fZPd+TZX_,i.Vh0)WS*Q'[b^&GH(*e\7'eb[h at Jm[i5>N)Qs<ASDaV4,i3A>=)HCW<[Znl-)V#A9cdTN'S&saV[_0.c[Cn\]5+Ykb.QbHHX$/rTT!p8Iq+e5`#\0M5CP]%D[\[S?P.#(X84Vq9>TuiXg1TE`1n]@U=rbHq;7>QFE:qip-R8[5l,#Er(dQLMnd\"J>m^C::2g2b6i8^RN,t-[D'tl>$3JqJFL17cPneJnD"&4m0r'9G%^>E^]dM[h,MKd at hO*ND1\!A-S:rnf:4COnD\Q#uJe!$L&6 at X[fFMo=>eh9%V<Nhl3:_I4=C8G[WYQQN1V at Gt(9A,<!G1FV_i(VbaZ,H-Z;/i'n`"n&GUDH_MmF7U'ENs"0Fk>u#jT3M#GL^kK`)aCo%i\Jpi7unfr,VB&6B#gC&E4=Dq_:+Z*<dn]LMEqpgss0Wm*HX)K83Kln5Sce*TANgm]8G9MT'Wf\@k/2a0-oHidOG^#ipe?muNL*W;mS2nJg<0=Y8mo+hH(9#2nPj74i(`IOoT1shfm"'sJ?Yl~>
+endstream
+endobj
+425 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 424 0 R
+>>
+endobj
+426 0 obj
+<< /Length 1342 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatU4h/h:0&:`lHn6<e):b>oB8+,WqC$'H"k0hcD9=_T15QjftU9^GYs1Z?.f%S3`oS+1LZMWD,If+#,Q]9j.;\/cHpThcZpRXn-o?@Me37o`k5<q4%ZF0H"@`&maF3R^)2>7%>ZG2>Op)E270o_,99!%'FT0GKq4?S#$rUOsp9d5)UE3X14kRg4EO:HqMEoS(bdT&*rbdE`1YU.kUD"PEP7%&E:-AZuD4T"9:\@3<')SO=E+\p8u;%V;*Gb;UcNfk%E<P(;2C$,j$p,Y>h=:g]\$&\$&(>o-Dp4ZOF/Qk8EEE-AMh42Qa.)qOq:5ZUL$9eqd],nXO>WE!Fl*sN9g,^8SI\O/Ki\[>WXDp.=;qP,'P[&i1_lafEc+[>Cg#HlpMld&X;V?-:[+Om^`[h?L\-C%\0OkOTeMc#gbpR)iXLbPYEqYAg@]t1),14auro,+fLgc4kak[IHJ&U#5IG6,5+kXh*?#nO"e.gE;=>IkY<do at GK-5D&LT)$V,puQI+u3]PM.lu;"4hjM at 3)s84E&UR9i9?m_1bin4Qd[N??6`K.&#h*3V;MAiEUC9Fe&>pr6h1]pB=Xm;WPFUF04:-i;mE19Bo?Gld^o@'`,Nc1im4Cod/>79bSBmje=?5[Q*;>1XQ4Q0*l*N)og!4*4=>MY at f.B(M"O6VOiHA9YIg`gS,'4k6mDRS)Xe=)BhK'LI/>AO>F^0gcR0Z`*/G%3_ruGBej)NQ$2WhNifa?&d/L$:WLOKfb1lIRN5n,$Hlb]BJIl#O)>.3A(&lb/-ZT`FZc:IO!'03n>UfPcu)S(p:[%0!6JV<7pXJ7"qk1X#9b(V-hsXs?cbaf6'@s%)+)o*kuNlS+R9&_FmR9?4L,IV'W!B.h'c3o`AX>KLFf)19%.jk)LAn<\>d(*4,Bp*+)^MPlc6X3g!/Du?sF0RLQH[eSe(ITE(/J(Nffs2Bl[<ETI@)"WdQ-EADYn'S:(`Y-^<Jn<Em"GZ_c!
 VIeCN3hnnQCOQ(coW>>rtoWN;]"@\kFr*tn"deQ#b4l, at cBVLpDTo+]QKfQ+#O>Hj!Rs/4[PLJuWGSOIZ\[Z5!!?!*s-+oXFN at 2_%3@!X3V>?AfiBT.<#qt9;A_#8m>$t;UI.FsB>q$uS&,\kN?\6!,SoH6_UE;+U(lc,EPJj$5\kDj\6i/Xr)<l<<@%N%-"^$kD51%2Cjs%5E7?V)".f0[Yt+]g2i6fcQ)8SY532Z1__.S=Nr.VYe:C^9:LR5?R*mUhs6g<"SXIS&0qr)R&HKVi8R1FOT[k?idp>\!A/)B-Mhq>]E7q\tIn^_^6qo4lqL[tFLaFV6nilY\&/eEA`s83[-(UCU9~>
+endstream
+endobj
+427 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 426 0 R
+>>
+endobj
+428 0 obj
+<< /Length 1376 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatU4>B?8n'Roe[i6ds,-j"DCIG/ekBfb(<FmQOIohL7o_Cu#O#]Q!\g&GA%"?OOX-G+1WinSYJSb't;=j:hcZfd`flt4>I9ZuqBcu]^JeeVUI@`5Ullinr67`>b><'_R4B_5O\*+%-YJVB[JnGA9?JXYt+h!,h`_a"F3D.+6LSo:]Nj2\f[IOIe,.'9N50dBc>ho=q;ckg[ach()8J"Z%,._Yk<:`lOCE/,5*#Va0Af#C)3p&*9Znb)>Lrq=OE5Hg#]cY><!L\93d]cZu*LGir7R?$pGVu)XHgEO1RUm<d4:5g(8_8c\+.][7S"FLnfn;UC>8AR=g;4 at o_"P-Ql\LR'(76.=Q.t:Jd[n[GR2E5\DAZ.9:8Bkt%-0X at PoMrhQn;rW6iG/Ebf0uQlV_j%lGUC9@\m^2bN85silA+D+E%s*MJCM0cP at Am[[9)C_^^OINiVVBkf.X2P?LWPtOX at s@7Y$6nV\*kbQrs2f[aE8S+=AgQ;cbD"e/"%i28l)&dPrPG%h?.LXW.!35(bd[)Im at R+!D)!9S;s[G7M40Srp$b"jd&aLCS4BJ9%l![#eD]3"^,"^aW)W[=/83['!gl+()DhlN<MTFg5X5CON&(gu6MZ1=%3=</T1fKuEpQ5;6!d=d,h;Z&+J97N=o*[)cR=,]`;&Z:ndYAT9oEDU5"eo!7FUaqdmGk8;jOjTi3[:1gN.<C0HqX.>ksQ49l;+QRJUFB+-l1]rC,>Sjb!=rt'P<8Q%)i[A6BhBcn]Vi5<XX/R%W6Q'iMBJ5i69%,<th<Gs&nXTStA7pp]'NkiN/EFlLYdc25Z6N%cPFP>XL\u_97/9"kkN at l>fXr_Nq6Kd.TOHlX at iUtF#D2=G_Lq*_L9k_."C]cEL]1 at N6ak$LaIY^c2Ld"qHNFXN:mA4h7:#7ilEN?NqI*/.5GKT(n'<\KD0%=KVDF8t1cc)=,p()GfF7im8-$;$lfI,\dS.d-<6<7JhsRF at Fbm!
 >IqSR at 5$iLR3dS=8)7;5=!A!B]]5/aGHQ(G_]j/^J*pX:Q&1aF/TLQpA$p,X00gERn9=]It"f&Y4*8IM9]@`7N9bOSC"Lp/X^1Hdd"0Q8b+*lmiV^#%Ga`V$1>S.fk*$EilHOV4]$O:i[$6>1RH6Kf]o"$d0T>&k$<TCVraMpT0;4!2FbE0i>(rd+$RY=i<Ma&O73(<CVkR-e&hAh3Tn[:1[h64,Ikq#qbKq](/0$&eq*X3956IF];r*s(C7[R]g!3$[p+k.sK"!"T,KG(<99,GUG8+Fl5h*Jk1RmHZMfA(k:LPe3uY,)o)Z?L*Hik<CotrtY/Nf]V]tLFWQUOsg4gY<,bOHP-u]M at Ir<n?D/9qKKmDcfOU"l.r\1VdF58l3%~>
+endstream
+endobj
+429 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 428 0 R
+>>
+endobj
+430 0 obj
+<< /Length 1682 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb!"q>u0K?n at cR\O0In]j2CasSe_gCS at I#LA[TtZF>Bg_,FYF\$+nur5MNI/8Xe)Ee#>!laaAAG4<H_W9g2j9%e<lNRH5+.H'f_p'0kO\?6YJ.lFSHfAu5+N;,bupZ1H?R-1t-A,`RM&bLa+)^sCL3oN0W;\SJX+Zm5etbM+Kc0NQ[dG5cYs^C/5I[kZ^+NRC at d*M\VI\(@O#]b1r%:J"rii05uD:!dpt/M[+q5YR:J&O at fV_ID*EW<M6. at ZRUmR\HSnTp6P#cE`aU$SP[a<"D7;'(Z$r)]p!t>[LlHFQD,:6.]^Z[@6N&qf?Jt5E"(76:LQP5LNhgeMkq7P#R>SAa[>djNF`hT5O")ZtW\9=`E at W^ljt5(k94Z^V.7Jff04sO:VX?N)8jKdP+6u%sKeTl>g/9m@*?g2L4R#>%nKlRE2(S($)p!_l/bpXs^,'5`/J0+iKK^#uX?JA2]EDL0+aFJ5WH"P[iuC?)64hm&TH+^)Q"7],uP!-gRoplJ>@I2b69!o:69V90q;^ilK)e[Oi5(VYS%Dhu)^(mIf;sc-?(7pHM%c'AOnae=Hi[ebP8qo.Rjah#2M1nViV7+;83DA`)dIC-IYb;hiBFH=a>*ZX-Gp3NF[e=Rc%\Ce4Wk#CGNSb;*7`P"m2!Y)4qu5'`u<F;Ek8jLMNl]9D"1-D5$9[0:%S4LR,J*uHG&_"5ac\Q<aVN7%k7%sm(&jc4PbblIF)B<52;Gm'ME?$2'?LLAu#luDs:j!_0]=;,[+g/,dRn#tRb"3u at -l%hI:<k=Q-4W-DH)o<XE\@Ij9f-3HI=k$5YP9qK=pY,itWFh7qZC%h,b,]p at Lo.Un5h@G>&;ZQZle8Y!F=B/uPV+*?Y`NN+73ro80<"D*Me6%Vl0LR+56kn9FauF.HdI+ffomV.KRMBD>-?q"BL26a;A[pjlY;F+51>VeR>1,Y?mM7062*%-%L`u_SU.Ohq0d02N/Fo$6W+q;%J=&'_W]!
 rOSLM[H(6T+g)\u4d=W at Es8V)Z88i.]Q&#5Dts84r:N%E^s`SDVCW*)n`;(.mZ&Uu7ulW''M9IJ1PF`,Mg7\-7h0pgS!!1_SS7o\GqE]E`V21ku^-']>-neRI43sid7M9h4nn at kiti2+)!PjQ\MEqI/)h+5,Ti"gVcX-Qp#IZd&OA-2hQCQ5ToXoe9(3:9lZoZR7#Gs@[&@0;-6.3fg/et?TkYnB*thl?Sk1lILLeB0ItQ"s6`5[D,`Jn\uK>"Pt#S[PPPqpio/D?W5HI_P-fLGiRD'>Vjb_B-8!)Y26E-:1Sf"rfK>;#/K=";70e)S!,n5bM3sPRa`oe-#HNF4IH'ZrM:]Qf;N%[tO2RPK?I/YKju[dJVW;h[t7s]/Vod8!#4Ln;n[L&B[b]TmYUTi-W0Wq-*t!I at KD(%o2GI;`BTjZ7.&4aL4I`ke7VK6gipIJ-+%L$jJDf`kYl`q#E*rgA?8#NNWa=9&7EAD1k*g+bLU2df7MMJ8jd_DgQI04>BX-Bq"6Od"5YV!*IV./2Cj\q5UNZME^a^a*"XMkp*h&!T7Qt'\H*P<S_g"0Y2s?"P?VF4L;"PgBW242.J3:6"9fhSg'')fEulP-BeGLG:kXI`*n#:TWH(@E#C;Yp4\B`4qNChjq!n6h_)%l)_/.D<Z)oZ&7JG$?]uS1?5!Mqf$YdR-2e(V<m:I~>
+endstream
+endobj
+431 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 430 0 R
+>>
+endobj
+432 0 obj
+<< /Length 1687 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0D=`<=Y&:XAWd+^TMU?K&A at NV$_Ml,,.:#bP5>qBZWZA@^`F?&UcqMofV,DD/K/W*!$SC-+Jr(-Zr3P#.M3gT*aNjVP-NjYFfQ37.lb?[NON#&#PcE(SprABSXU2DTbX2sPDViUSeUnmiQ1[5A6Deo.fQje>"b*jD5,ARDr4jKVd8lddUdYt%kl]c-nh'U6/0I;^U;Gs!$XHA at Lb]bV5)nV.H'k!:(bjE;r]YB(9\(nO:Qi09IVi5EtKr`"5D9nZV6Eamt,`/3![H<a2?Ag!uU+_+oGGMD+`b_"mndn<"78=rU%XdG]d!uZ"LNDb at 0A[b1O_^rXc$M$)4_7j:["(\Bf+e#qQ1:Wr%`$(-?^DXg2+Q:t'JHFj%hs4f\V25@`bO4bROZQ+4.$D4Z:RYf_RutseE)o/XOnk:VKl0G1b;-`[&V9K?<s'uH"VjYo;4&p?-%o-RW;?)$]3*3Xu7GjJ3V*ClGMm1B2>h!NeFE6S92]2qlLcWAUKl1P%)>j$rmc\CDH%@b>8cU>FT. at DjmKt7d.V;8<OL8>a&XHJaq6949ClP'gY9X[OQamG1j_C\.*<7nc%M at n]U*lX]]khgAoOakHD0R at phq8b7L$U-+'H"U=@Q1?!F5IdN5u88Gm"fdgH5A?;@MuRciipDK!sG,N&4l;C[j];@s$>W[96""J_ok/`MMM=@'Ar3uX2.eSEk]C-CFX at dA]]Y6"Ip/*No<jl+?2>YS99W`$=Lag3rFH)ZD7_ at E\uY at 2[XMH\-_IWDb_Jh at k-#?&M-*#mtUJ/^U"-QR7gPN1t)Mq:5QH!Fuj7ljkif/7 at V(q2(IP0u;s5nr!.=/bIY[aAdL^31-L23'^P`TW$IOnrhhlf7r1]8)0rc[Yqs0l;DsO-UsG$$WG.TAG)[R9:*S^2tX-XuEHMr]d\sGRg1d=@)I8"2)s:S3b9PdXkLE*knAi=[W2H">Fc9^^^0Sq]i],Q)>)sJ"[V%eU4,i*Zm!
 .R at Si2A<*P7Nl-,`XB,:-Zbfr3i%l1sTRYp],Tf4o2T at ZakR]lU3M+!H'O!"&K5t8ik+J5_i\'klc4p;&*/odfqgXHYJnIRY#%Ddg-P?*oan5luGTilOAb'XH at +ZK_M]EOf9_&6X(L7n#f"lBPt*anGA,7PWN/3.gMrjS9_\r,%Xg3^0ISqlcc1p$5E,9s;7]oe0O("U#OZ at hWeYbo]WFDY4!c!YMH?jV`]3/0(\ig<-#%UBqCpj6?"#Pfu/o,On-SS3aPr+ at j-_5&j[SS3aP#`JeoSSL%q'LFVO3Q5?*%g at f:-og6.$>t^UTcQgq>n=,.m?8^>HsOVL?$6=R(GgTsc(TJ]M=lTMUs0h&O:O*4n-7(D]G:;.._7:*kRf[P'hP."8<.r8osPLHju6 at Q7L_-dXn<T)X,4QJL:a;jO78ftJ:aCPn:<fo%bK's35mGSX#3Jeo2-(2MUo.J1dg'gV.,<-jdfOPr5R'$ZAKm`,%>CW[GD!hb8]:!aJUIs(^$&.k[>=d*XYLD.4Nq961c2IP,a.dPMjc_3$;5V29FQN7#?)FopRcl'S"%A;)28l5J<Y1OXM3?.a_gbT480Rn3"W*7J*jel/4LN_+t7dhdnX"4qF62r8+^_YWQr^cN<j^H_fQ9E"W=<#jS$3IfAA&H[)4Qp7t,Nbmkr-HbF-#m">o]6<]F4D<YF#(Y7[~>
+endstream
+endobj
+433 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 432 0 R
+>>
+endobj
+434 0 obj
+<< /Length 1136 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GauHKhbVu\&:X(TOiJXT'E<lPC_R2QU+qo6V<hbe;b5_&UJ6UZ@"8.qf86%T=]:FUJo#N&h>-KQ0CIMh2k9N3HF>^"6"C)PU:q-XMo`:X<h*=!hG*I_1k`CGonYAS<%JsS*$PE-g8Vm9Xsrkf\So=^GV\%+>Je7/(.:^iq1-'-A7b`'Vbb'*QA*Fq*A&.AS0r[r`)Ep)Y^Tc>YD0(d8L\W;`q:X7VTS,d*5XI=l/C,TFp9bo/mtnXCG>M]0=Nla(ZY%)o_n?r3i$redXV(cf=*]2Y:d"37`4b84MDa"J'@<k5*`sSm at 6,E,S]/\B9oC2*QcLsZN\gIiZe4e?:f(Yb7t8gk;^\[,]9b:FNUQJJ-RTj0qNjD-+:;3p%-ls^34=qbWg!(D6F.@\RQEE3Qq%YLY\AZ91lG^7dSFBJ2u-tXHP'XbbA]@97PgK%>Wjs3bPLD5N](-,g_:VD^=m<`/jsu"BCqsF8Es3NDdIhFuL?(?(;`AAR`X#CU@@3h1H:m%$jOE2(TQfn-]Xl4g""FW/oXZ at JJ&F:p7m9V&5KJR(SI^O[5me&TF/Ng-;h.Q-&r^(@d4";fhlZ"HUj5,s(-s`uH*Y(HCD!!'N2i=V*dZ!3Q]WO4^Vc^KNE7jRl4^<)$F#c,n=(dL#Gp-VS`BH5B3h?<Q\/p8Y&)`rX,"8tc\qlc-I^U6?(-$?f_]0$Ok(D:3EBbHHNTPS93]XSB0%Fr*Fk:c,NZb"#3cNA3mn09_1K/Bl<=8ldP7O;=%bf`pT/D9!3jX"A51jKJl3EdJ*OVM=9jb)PKF^Ojj-\ngP?>6Ai14nDb_SW at jereUi`%2-u:-&3l-%r,&R/9k(0%gJTO#(q(YnS'E1N]WpT)dkP'+n:C$`9G-\jESIa\hLgUV$aCWpL?7Y"Aj`-U<-Qd9QifHTQG[h=8_>,)Yl"@V;h1i^*<a]U6V-_H\=iXPl3<T5&7Eeq<t[gRa=l'khA.p]iYbM_t/j=Y@,!
 "sjUh=^MOH(,@^DeD8r<_rej9^HS42uG^NZA@)/))s4BB'J<]&%o]+DE'i?l&iglJVtAaLC8>*h at OJ\-LrD:f;-iDMqFE"[2iI`e3f?g&,_fhD=\MF5r79LoG,N2<0):d4aV;<S^0Uq^XbAu5~>
+endstream
+endobj
+435 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 434 0 R
+>>
+endobj
+436 0 obj
+<< /Length 952 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0C?#S1G'RfGRn7*u"M*DZk'9e.f!f;&R(PYbt\nb\J[`#;f^W6.`m&!PDF@(D4dsKBNn\+*H\X8B5Hk68]0EAH at -iiud"9SNh!9*K\LbK5LR'"2cnMX#U'CZ[Z5%tQp/ZM7D/u!Ueop at nN(i]h<GR&7NrciM_m:n\qr;?N:"MEk_#oRYgRHp at .X&R2fR@@E[I#r-3W^:9#n94B*eRXH(eUqjm+_`bjUsNA6eQh6Wa(k#no5&8EC*h-!;"<A67^o/3OjT'XGV,3)Mmm:OK>Ss'\M9TmTR0n'4=@,VZ75Lq<H3I at Q!'H\-hG`HZQhP7L"!#(CjW.XS+XGRD:[D2=@lJ(Y)Vf0D"L^$F&`8WEl]]&eKTMPj:X"6f;"7l'o at VCKBZhg>/d0*R2pj;<g9Ka)so]5V=!mX`YF<IB[9/JICB+B@[+Za%C)jkk]49j_?'%sqHW=G4GF0<biLrtQ$iR8hPh=fNbXWa8jdtr6N\=p3ulWXKqIfp>siT7_oS`c.3]<n*ZaPYfP&lf_`F*X#R[W52T<gA'd=J/@S"8fLj`lJ2?J(VkFF'Din:6#8]W#iKZ_N7e^-m6]P!f8D<$D2[>\*]>`p`#ZaF%#]=48-PMZob&8Zl0R_YeFn_lh:dZV/aFZLV&ioj]pf$-CGNn$t.lmf0tT$qIm6)msh\46X5!Xe9M)R(hX`?(ej,I#Ru",DkjlC!T^F1KT)db1`>LCfRk_nefa\bcmn)tdRY!tI:!)kf;OX8)5D]4Tr_B8=M&4AgBos0Z3]MF8anlJKL>bt!)Em;a4(.M+DO1Im-nn`!Ds#]7]/*#1A#B0,[rrh+pWpqH0Y*odV2"7G4HnkA$a[QbeaHj3Vk_b;-qLi$K71=sch2.'EPJ#TXn%7c]U$U#dS'L<Ga.dt,YR=1UJV9ELs-f&7%6K6L05>_Kqf7<*eeV9Vn_t4JH"`*0~>
+endstream
+endobj
+437 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 436 0 R
+>>
+endobj
+438 0 obj
+<< /Length 1438 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0Ch/f>L&:aF]_:pt+$&9)OUODFPUsjFgdnA]dbGE\(=?,q,3"gD;rTbteKGH-:OdhA<fOafdbA-d\nqY3NrQg=Q4P+Wiq93p21ZWf?LE,Baap at f\KUg$$q(gjZ`TkVAdolSuS.Ou!H4Me)i%KR7asl(DhPAiVhDmUcon0O<e,5QQqp0Hs&%<Y\q!H57$,+o!^:uSPO8!iu6e at P?<Q0lGl-n1DI40-'VYmYPnQi4_d>IB0'd+>^DWo<6kHodQGbr-L(Un)_hNfu'NWhAf&?qrZ#@a5+1C-^]+tr-eW5Q0UGPQN`_<?91QDH-rIL5#K(1de-fJW=KD2M#3r1g8OWa(MZb,nhFlIr at .1MEh+b0g`9.-!OZrp^I/-4*mHC`Mg_E9(j6",O*J^22&>PHm&_N82:Abf<A&Yc3@=SIkj1oOV)XH*/V+I<&LJLpr;q9/i-AW$EX+(c['\4I8$d3r/,kp0dtQ;'K<X!JLShKA$GZL.%'W)29VaB5!3?)ee=0dYYK=+TkK/VVYMRKj`etaX'=W4iZ,TMXc:\f at q]cIh'.'_.3So#Mu"bhhA9\jk3u[\]E$:7:1UIqf0:a2p]ZVh;r;-X,16;N\O]p';,HVHrjlR;$/)_'2%!HpbU!5=-hW:"G*3R?&=Jq+:*tej[9Xb,Dbe8Jj at P<#.(_Vl"g at 8+IaV=>cm5!*Z0eVFsB['FOZ<g:'BPO*V/[B^M,#Z/W/=/%_P?&4/8c=9VY=_ePPce1hBOdmGrme/CGp/YR_3HVD(/-5Nc.KnB1;W!l>)PTl4%BfiGK6><<RX[1S/l#s[3/If?i:b!T#[Fuot<AKlN[pGOKN<o;1G,:q?YNjPptP!"o[7;WR&kIU,P:<m"U0p:hS:6;RM1uIXZY[7Ha'KDu5P$Srin>S0N;D[p7Pptll=&;aqPYX[`0 at bbN7fun1CL642mkgb25c@/FQ:CA-`72s]kGTuC)OaD44,4bHca4BSRC<ltRc5!
 e:i$c15@!/m)eD*(F'?II9X+B&,__mm:h>i[MC-%WWVOgB?)gd:ufMkB^7E8ML at go<;#)hkf"57rhRtk_599t?oJ`du]`rP/3f7u$Cbn$`HL[<Gf)*n\=)c"t.S8:DQQ at bm!QiN('4'%2IhZSdHXDY%p@\WrgNaT^(_JE-DPtN+XTu0N[l+1;P>4Gja.mEKCj3dBdZfZgAlY\F6"]oP1F"2&qfu/:X$&U(O=Xt"+id/^,/+4HN'jb$L[dmVZ#j`eHr2JX^bBYCr)g`AS53Oj=a1D8EE9-u4DEi-U$$;gm8,:K`_kOS2'!!#YA?`(a[elP3AG+j7.-(jW+ZDdaSOiS4:^,G#+GCKF1hf;4 at VjPVqsbBf+'X]*j:5=P$8Tn(ZMg_2[],,cjP$(AG"@.;Tifc at GB,or\hdjnE-uI*qr"7E=ON;@)?pO3,R3KtBLQWc~>
+endstream
+endobj
+439 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 438 0 R
+>>
+endobj
+440 0 obj
+<< /Length 1212 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb!;c968Q9&AI=/pdWG'f6[2q-T]]dARL8$.2QA/,uKPtM%#Oei85bD,-;O5E=*MZQUos2p=n-c-i%443PPna'_m5<>ttIi@=l/-r#lU0E\e30O(*%=p-,&2DuA*H_dU**U,8?(qPW0dDu+Xt-]4&Zq9C6iF3UP-g";m'Ttgl>NbMHRL<f>6h9GokmHs#IO7,fi.&_`8/4R,SJJ5TsdGh3pI,N_\9A"lE879:%DQ\]U%pV.Rg#CUl4occ?$i\=(aHqG5&CpT6.FhSc0MO.1jLUGi<;DKMU^V[g*5p[XmH*1&]4j2rS,ed2PE2_q5ll#]84`^+4'<>.Y-VBCSOLhhGc':d-8tZEE,#,\_DI:?K:R9?Zn1?#QbM4Ek.j6&VL\g_6Z>^M^nT3Ofl#*cd=tM7F'^Ync.Qk)gXXL0Y[)#JcGMDd!Tr@]f+Pu<X:#3WE!F)b`>:4md[VntUNAMer2Ae_4rZg^,..1eQsZ#'bK8#i at L<N at CAng>UbP/HIN<STXT/mc21[9iY/'4%l2J>'>l%jf7nliT4\QO8npK!DF(U)7ZlQ8LF..YJqZ10;j0]\rM\d_PDP)9?jb<Tf4mFVOM^n(:rS7 at AI6N':+:<8^1^SQXn1cr%*Z`n;<<8E!H;W:%]4/@lXHKXOid7i6Ar^^Mp at o(F4f,,Pj=$k&fJu,mkomuP.m4=S$hcubLCgOef9Y\4Qh`=6P/MlbIif`m$\;X%`lLjI&s1=-[@R:$)t.DDV,/&/jMO^Kd9IrU/AYgK[iHV:7[bM^7RB[SmK>R;6UqtOZ"q8;<0SNl-S:IMYB!W6Sr%%8=Xfl:IM*\PVU2 at s:8au/d>mt9dF<N:Z3S2^f4+3kY-X'c5>@VuDaT)q(R5K0*om@:V<!$AU`(K93&LSsg=DK+hf,7JU0,b"#XRQq1'o41/B0\/*&BKW_0AV at Y5oPhPSBOM*/n?J`8,HoEFRBX9$VG7*06D,;DEe8IkBj)B\O<hBK<!
 9l5_u=&goFnFi#>+8mp<VL]O+MQ>*&XM5F``"=S<-=jZ6*LGQE?>l4O*_q at 2lD774W!S(YYGW;<4g43_=;G+&f6Q$5S8jP?j7fU4gG']s^%ngM__\*GHNJo^W?5fiuk0L4cq&#1Z`]`,%%FU1m&U!2r=!5M6Bp^%L1eFO7UmkdXqU&,IOrScJhhsr([]_^"A$4p(,%-!K9;`Z0fD:#'!+oMFl3t]j~>
+endstream
+endobj
+441 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 440 0 R
+>>
+endobj
+442 0 obj
+<< /Length 1303 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau`T>AqtE'RoMSa;Z':?@9qM4`/UoL-T3``sX#S[8%Z<P*2ULr]P/YfI*ZIVK at VQqt)u%*.L0?eRWbb)>tD_c?t;%Md4:16c:!GX^/K[KbKO87TU.W2\7WM$A(FOYi%LA%.;(``tcn^q"uI\n4#NsCV1l(%X'NLQ!T8/hjJk95+NBP^<T.b0=.T>FhTi![fBY.n3#dl)EY[F^E,VPRjd4j%E at +[f()s6CYJrMY0eJqlg=;cS+5=PmJ["V]8uDVSQDDp6(Ij81[FSeD-Dh-aGhU9rFu at NC;5bdV-1g1:G6fTHomHOIHD]Q!g6\#;P!;L]j(iLq&(d9@%5+u3)tZE$eHu#bee0s=cnq?Q at baX*ke;,VVdL66Xm2S=[dW.?'HNd?CPltDO2L$Zl]g<UA^#:W$83E'Ui^S>=Q0)WnD=7mYs_[(tBX at COlBR!#&51Xu#T`BUK)nasi-g7jm^8(g+A&SWV"cEtDn at XRXF:gcZt,,tor7`U5q!Zko(QdR9I\Eh0,6[9g,"ZDu<3M%5Aa.#eB2o%4L/ANiPM%:IWc5ioT^mc2bSQSLcj6&Xuj<45:X($h-m:lKH0n3[JH,LY$*EFWQ[+*Ws]XQgJ:WbMtRPnGNHeUWEAj<'iQZR*^Q$H(RBB_:tt`Q\p'@&4I%^K7.gk!R4X&WV+g+_M=2VJ3*U=p>@18gRFN]oAU9UB4P4b%r?gjAbF\2:m)lge,,t8]0!qfGBNZC*S%u.eEe at K7IT+*/e'tp?S5WVFr7-TSbCE2gXn[=fW,!9tX6!9ocVl\e*>/"bbJbYpepQf%V`7lc:V!ULK!Rgg_:P)C9r#7J"'WRJg&^/p[p at .kscX"JVadKtW!heHJX^24nK/G<)asP!mEt5\>KRm'ONFIJCV-i=:%Z-M:o at p9V>PB/\;\[>tmK-T_!S7L7.rikZiBV5.V\kRiDEXGn5_6E#-ZM17KO:an;b[V48J8:\=F2f<"7grdM^M(Y8=2,E!
 ;-=>.krAK^Q_!m7b-hUl$4BW@)Hb!u[=#.1$u9'mBk!Ii28q at VAY%Zd!J)+hdZg0atu1iJ*Q=EMiY$<PLh9t1AnF81=_=M^eDTotiWB(hupR'5<e1!UA);+QG#F#XR>,6Prr!PmEu!Zj8F&Q^:r[c]3\%[JU'!$b/JI2kU+Rh+g-a%8emH(N&\!5Kr'O;SIR0(S854cje4rl5ZiP>LF_d/A])U\L0OA8'udqb98KI!X9M)-AllG3^, at TAcAkbKQ_M&gEUV!+GORe`DQjA,KY4"7B.@*I.-l^XGAhZ2@>1W0ssZq8Ui)9EpRY~>
+endstream
+endobj
+443 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 442 0 R
+>>
+endobj
+444 0 obj
+<< /Length 1237 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0DgJZc[&:Ml+p^n?X/6T^7Vp^,FST`^lkY(/^KVJ[:`!0 at qUgIL)WjO&bLJ0'K?@2G5Y&o%lcGa=5G(hIL=f,b(Acp5D&!15A+#6[Nb+!:!:#m1UV=F.j4M6[XRkoM0]Q:2+jQK!;7`WM%A+Eb(3]15tKmhCdqB,mFP6X8uObDi]L.K,Q4]=gLVlu^jTraSoYu"IN'$`OgT'9_'b'NB&EV at Ir;-bDZ@`@AK)+FZhCZ(!uM",G+3PP;E.8_]FK;W2S$5i,tN^<5O93uUMbQbu$`<8/p5X'-!/mV;^g_rD4jFB>jb/Ci_0(IUpYdH+ij#k=;h6Q59l1^^)1uqVhpQ'Er>pLd?VM?X!I(Z at O7[,_pBKMhV>2^LtFN%^mSbr-Eds-+Y4W7UTq=.IMn9h7=24RrAE>nde\&[rE@;OVqXOfq'%B3e:m7CaE[q*[8Dj5[ZRa&G>*5Q1DrdrN3Qk['d7<AE[Z>!7PT>[neI&*8bR;=35=$(,5Y>;;2%T\/WXa"E6D9Hi`1u;(q\R^H#1YA8k=L\S$hYGtb!LQ>NS3<uV.bGHV9Fb0-Z\3Nn%]">rq__SE49V%\V#2C\Ka:gp$bFS,a;_+#&]hJ>7C;9W0P5+)g`_A\$MiKIb-ltZfMY[>*sj2jKFmCAJNY!rgkFd;.S- at Gqb:'g>\S&8782U<B_Li]%h$?eo>k7'^;+YUDC*\fT$n0rS*3;iFW\H+je*qqLYt&cgu*T9e*:4!B6>EL*:2-3'[nlO;%gdWhc5?&iIc<3Cr`[tfh9b0>6XFHBuN(;66%Oj[N+MLl'/Q&j`]/V+D>7fVege..UsR.kQ4OQ4o(g6RI+ODL*Y4MHZ:XaMah[o=d=aR>O),9%]f6 at SKqNXPkC3\E*u/p?<O8c;*7WM.Hbf:SdKeQ@)/2M;e<%.`hud4FXNWWla!q8W0a[Z"- at LH@&7)-Q88u6TO*02rZip<YnXc%;1Qia4-LI#;>)T]0%/&VN#^!
 =<qofR%hZW<?QleI2bM7g3Ie*YGNYs[M4l9m(foV9>+K4/^`g;@-HMHkU9a^js^obEGr'2)-ONN)G;r*Wj(j$(J3'W+sOQ&Vmf<&\Ta=bo5J5=1hcU^C."0W-Y3o9l:h at b?J`W#="d\!iX7Wg5.%AcaNWk^QbZQ[9'6V4Sg_V0>`($,FK6Ut&?jn/oEq".T/P-.Aml0,1_,JIM8n.Cl)BblItT>6`LKWjCiq8C>a+=4Vb/#7YAp&ZW~>
+endstream
+endobj
+445 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 444 0 R
+>>
+endobj
+446 0 obj
+<< /Length 1042 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb!#[bAu;j']&?q?:(MhoWi;2X/(qQdn-G<S8LrsUOW?R"=LXAVLMt3Q\6p*%\!qI$/^*tdFIcLHkH'IY7Pde"OIJ<4m4GCaFWo;*#(+&-OVUnSeF:IhttlISRque4bK6nrcn3XaV-Nr3Dni$_"lrBT-_'QK3,hkq?AX?M:g&d+6.%*M+%<)`S,Pcp-gTZVIk=Pe]J/8!LdUlZsK!XlV?B_1WE6c3"ahbZ9FIt1a$n(W%DF?**nTnDSd%J1 at ..=N at ePB#@*&H at jjj(E9=iBmip6_;'6r7KZaq6fa(6 at 967n$EFn)kc;s`4.VNW2_Dom3!%ZZk55e`B/6aHQc`@Rr!t%.i"<0Lc,"'Tf*]:5S-#D?jAOb[Ts(OU.],lqaDn^Ws.XZN>X7]Z=AK`nH7^H/J5XWnOr%].;fV at PKj`2ZCU`pV:.P5W*YeA,Y?<A:Ar]4X0APp+k*j9dFS54V:q]8X5YN1fnr'<lFl'^6pfPEkA'/!=Bp:],-73"Pp at _2q/O^1uY%I?AE&D(=`XZt$"KA]s^SVbt,D*H1.qT.6uP:iud1!\[NZPT3$r-l&M]\RIoAoT"u.^nJI;&bcD(%!4sPtL(H[#Lt]-p=*/0\$qiAaL\GS#oT0JA:JsIijBP7DpRhG:O\`^&KCU=f?r>`Z"VAAtt14<a at NKc*l?G1^PCW]!g3RVch:(q+f&7T!bQ#<o]du0ZI8If at OD*E6Z%Z8J7g3]:5Tl%>^cR&dP?>lY_kG+!'?CPMGR]B!=aBR`#0.(rI[SB#+#m=;441@)%Ca[0S=!(P1Bn$;8U9i>rlGhi1Ju5S/%JqY at qab-KR%RhRY69p7oj="[KIFEL[bQ.J58EgM[EG0b/^UuDt8WbTRq8\0oE+mF7nZ!A%_HHt8a:ss?4+ADXXP5:,Mg6!7ga8U2"dr[@L9E-EJgM`3F)J$8":'QQ:9'gAUKMhp3BS2Q3<ag.Ea+B>+E3)2 at YI-mJNXs8.?1Ac)6jE!
 M\L[4d'[/qG,\OaYb.dR>+r2A;,:ZU>%?BaJ*?D=bk+oMN''"-!~>
+endstream
+endobj
+447 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 446 0 R
+>>
+endobj
+448 0 obj
+<< /Length 1250 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GauHL>>O!-'RoMSaP4kU]\&6cfq+Q6)AASEPeE#i19Cp%-0^R,`kUD&il!4D92j1a,iiI-Ru`WFcfp5,kj8t)*U49hRES1(F$67X$\-["OUmY)`!?gBadr$OI"$C(X6aU?-\]_:S2\/dRZ1[D at I^j,KtQ8`IQ3Nei**LZ)mA&gH<qnb1JsPn>M"1q8C at 3%)<"n6Z+O6g]IXF84iE84On'^@e-8\qh0.h[>k!0qVO4>lPpPn7aGY;25>M(Qo^))FiacNmijm.RS]l!CapiKmab2IB#\Q8,-.=&5'/T6AK"_iY,#?Tq>hg/F:@^^u;jA"Q2`Kbl,hTFQN0mrM;H"j]3+fH;@t0]scKY*"Ldc/(d^c>`>eJ4=F<u!M1t.0&d:/'SF&bnPe;WTnLQg-S\p:?VMb$)s?8Zn7PUU6/3ZWX9+ at R3bJd<;1=sdt2'40d>X.Bf+l.H-Q4c7hY!bJI=&]E:daaa>DP?G^RS&n!#4%f:,"LP_$S^rFo9\4n"!V&6Pef_F!(gMWpl/h[bJAC^.g#:&^cYseb?f/kO1Hn#dL-'cgh-rM^ci/##3[eIlU0o5\F[Q?bbC)/f$q6M0n"2ii*KN#9l$-#Be7R%FVSrn!\D')kjojCW`<K>@+O26n2,6!OaTai:YL?]b0/=YHZg"=1jILnYQ/L0!P.P&&l6^kO1$j(9Y5J6!pr>"5@%>cgUug%lepO-m)J?SUF>d.`[cN-HaA-#RlHdg4&'0u*.+<#B]\K):nomoB'>QLeSQ\h=SZ9_QhR-1'i4??DdTUCA'Y/\0EMq-)Ot:F5CcWV)r_bp4;E5[m4ZD#eH:)$`fP=VW:.%@C-jjr7d:BXr,g3 at C:CLIYF[\*t[V2O`W-$8MFlcGaIU1-`L%"8-c/godb00kNkGi2mOdMEU%8pu8^`F3"WX1`*2rtD&L+a>j-[*_m_J at D?GuOB<QG`_F*5_1"'nh8C#_%;uNa41'7e%Iq,LL/]jV&?L_LP!
 &%/hHJaX>\&&&q/^4XSYEC5^S9<D-4E<UM[UOT[!9nd17C;-3=g!)ehO+N7TKWJ+>=H2fuBuSbSS_`c-,cG/Ko0(\9?bN+eaKcGrpKfYp)9 at g\<1149`Vf4cIZ#L at ZU>+>#l+1AcP/ZhK&DtA>W%+DL7rX]nV4X0e).(iihNa1o;L;B!F(iQ*&;%GG*jJ.-9JO_YH5M?U^6r/kr;:p?V*dg+/<BO3$PpuKG[KhG^iRV,.\]We:"=Kf7*k95=?OEDC1&~>
+endstream
+endobj
+449 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 448 0 R
+>>
+endobj
+450 0 obj
+<< /Length 1315 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0ChfIg7&:Vr4iO;Hm>%(S)06j3bD[:D(ZqYh>%&9V=@qb8"XQ4oH*nc^Q[A,Pg2b[Pbb3l1`eaDVNolBcVq`MY;$A2nE$\RU[%RTj+!KPmY'LsRj_=BJYFhY'&Vi0KB@/5F1_Ur$pMg0'cI/:P9T:$8WDek^^fL7b;ffdWq^V>2!gtge6puTPSi$o%;PPP4+Xm^0EQ/p7r\?2Y+LHf*m at o%sm4mZWMnd#hKdTUT:H)!X!cMKVC9BA4ef0NNDH?-lGf5)R!.D`T9CUrD!BI$g^Bm^rsQXK.:Q3m9-,o=hX0(n13@!S6YKK;JM!oM'nP_UK>J\.)%B+Ep9 at 8H`p_Wemsgt-7q!6-^BSTQU9`K<!<mS.R9#_IV#PI4Vu!._56^@6',ZVS/,\uU_;"=5mtSIhMT&3M at Q\$PBHd)<Kk,?C.gBrBFF]14TQ*TUp'F1,-ASaG_u*(?DqK!I[dY$Y;[Gj@&\"D)S&I<RXE%j.*Up4#\)<ei&Iqk&mES(.JiFoC=\%;T"GRFM7V6kG?urD1pm=SKR5lM`_o$)/7%eK9/jOkWtPDQO;n#e#BAeiVpY41A2km&.-;\DWX*LobVpG^8AO at TT[C=Td2k^%DUhMPh$YX1noS/bdBXnX#RRbA+p`. at VPF3?VAW?Zs>3Ajl$SUK6GuP at iIYGnt&@`#8PEc at ca9baDEf"1:kdXmsjM!K==bbD[WSCIJV`]$srq#`Z">nKX@(b4H2DCTG#I=>RG9*qtgL4"[l`KA/3`7(LKS]q%F[>rDIOKB/F('3srnV97eTk(Jc/pEP\;d4Ip<9!]sG:M>c_C]`-_:c)g#`Ug%"`"_;X,-IE+i;P8>N:MAUTU3SF)-H\'rDZQ^Q=Hpr_k?&d?;N-?+$P._>l=4+m'_$B[Fu5Qard-G#UZF?L-nL3#gW0<1fM+.,fD)WnB94F1/T,G;t>6K4rd%"ZJ5OFPGCj\drVnDGKW-rfl?L_dufJ!jJHhQnNa!
 8e$)36=X^3,Hf1$O2+7]9U;bchrgM6!o_0Al82KYRs+n,0E12Tq_pN at 86(B#f<O,,SSS+_\&)aJd*m70-grd\`Brj9Xng*M7NLi$@_PpUh'X:$+4?)_-jIQupOc;T(]B>D!iFjb78<:+!ncrnHcVQu1l/,O>#AtXJ.p`;V*q"Ym[H45udI#^dQia`+_:J`l\CW5o?*)h_=!r5m*_0c%\7i4\Z3R;k^EJT)AfadD0NU9ZC'eA)k4nDNg>l9'mjeFn1e]TrG?C=NDH43]G'JkD:,iAU6E8YrQ)sc,2ImDFW6uV%n?QV.eX2g,a:U*:`(GO>M-i~>
+endstream
+endobj
+451 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 450 0 R
+>>
+endobj
+452 0 obj
+<< /Length 996 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatU3?#Q2d'Re<2i3AD&(Oq"hSee<Q3c.caZFqg<6kUk9CS:pcC&R]\`aAmd at p2<Yr,L&nf=q"73/`$)\tgD>Ja^STRI;/.d.>3]H4\VbToT0^^%g1UH#f5caXs]@;1=mZ^V'?"^d>d<GJGU<$N\_lcW?IjcW at 0RY<TbG^%[(b"&9n!%Q^=LN!q,7CG)998naJ(#@?Y?9e3d"in8a$#T8#?)5&%5 at pb0%md4YRZUJ[I_FSJG#V-Qja)8/W6kUQK;i[]Fc11$R)IF=J'#Qu-:0ZTTcM6:POr(a+9%;hrM$\P:6J.Z`lP695H('TNkg[E<^%u7>[<f+^M&70sf?`ONSK<^fX at s-Bhjo\P%WuaX<gc/Ap&*hX7F7Qg1((8V\1Mr'nPU_ud6hm\4jiHW/@1n=gc^nR-;A7);OSJGAenZT-/1Z8<)?2u&1;1F at L\j/&WGCn_G)7.`<1*MFsM4N"#IHU^^,Z;B[Q2uhs5:.bXc0OSQ'p$Pf?J$`uBZ+WL'/^W0>t/TSc`+\Mi$`5?VF'G!`-(-unK!KO=e:6UPiI<5'<hBe>#M#+-0P?1saM^TeP/5nl$,fKSH^m\MfCkn#R]\+UAY7MFt76PbimSSqcE"qc9 at -m(ga)dT.o=%cm9dPULSOD%Eg`/gl%^@DNWUj06 at 0ub6ekg#6E@\A(AoWMA2=O!u^,;&'6D[Z]8^>2u2'Gh;"H=#h*e`AQs.E1b4?+>\Z+Cm+A73\4W3=+6Q;#+u;V[4/n&W$;3g>CuaeQF at 5d/ZS^']kbh$b]QO9j at nL8\3*"[U%OtBG]V-d-.EO<Q&eg0+r,rF#?D!OD3W'`G8Aa=hHF2*SL5=O2k_FHa*u3q:5&Dla$MMOGb`"h9V49/fb at cn&B=8/g5n`mgCL[?UpFQ&l3+qV[1`O=Qus1`2&H9''ACTQYC.DDCQq$R=A)bJdMTFYQ1rr^Y>ZEF'T;,^?5[G[bU:E'I(!^l<\9jPg<Z$'RPWmdsj!
 ^q<42~>
+endstream
+endobj
+453 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 452 0 R
+>>
+endobj
+454 0 obj
+<< /Length 980 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatU3a_oie&A at rkFGu-2iMr_;2+<+oBRtDB06L-j2Jj>:AOhsuo^>F)+Xr8*U`-t/d`e1>S=)nCAj3f?@h+(j3qN"M3h$_%T_or<iU!6C0gM<dh`F%UN[GEY0m9]Rb?eJ-HF]#6^>VZF_*RP<M!L$k_r]q2q;oi8e:P4Pd_WdGh"-aXidGNfI>=J)WZ2+"F(F"po5+!rIQG1 at qW"'(l,#RFZbg)Z#jg"Y7"oLs-6&QAI0SHJLHl#$S(t'^.G;YqC^bh$S&Ral;.u&L6DH_V"o]>UGo]s4LYMXgWMk/M!p7+F3Ab)1\OsB<*_f*_F2JOmncb5b.SN[)Z,MaN*3dnp%%Q)*!ajggc""aQpMkagSs"?pS`LTYFusJX0h-\K$JXa]G,:+QRcpj at d6tIK_Kh$9hkHqf(ZQ$EoK^Nc&3s(TkS9UoGL,79`6TDj->-Wg*\rK"f8fkkL*f='0s($[,sH9^T+7`c!(;1 at E"BiAG%!A3M(/.L?YqT]-JNcTXUTsmphWJ?RiXJ8CElJI<R8*C^=;K1+Vq'6c6f0Xck*m7H7:I at Z\CU1GhcpqLsH'4Sb)B?X<*57"$mdSObO8I+kgr*5S/`e&80ln";(eqTNp:u%G]te];$#92,l[,C1Y](b2,Z/#?VSFG?ed at -A8b`6jD8\\n?o>iN.uKrYif-k//fLE>-%sPK0crXselMDs+RUW_rGa4A@[<_L*LpV%/5#Cr+HP\6Qdbbr]SVmZsbVR.;$=m.A^smn]Zu7e4bY"h5,%Z!H?Dp42?#Oa)g=^jZfNmpT></e!M,4 at U@tWY0[l4Ah;OWB(A7#_F3\DgJbpZ&1^9C[O@(?G;ca%r0\=a2^B\NB at PMcmd`bp1Jg#+A-ak+o72&Fr^KIdssD^^QDKi=0T+?F>G[;Wf#2#mYW-Zqq&][W9(4:i[;M(.?TA!qXa=KiEi9Tq3iZn??1AmQNH_)505*LI\,"$h'3j&+"Iq<2#~>
+endstream
+endobj
+455 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 454 0 R
+>>
+endobj
+456 0 obj
+<< /Length 1571 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gatm<9lo&I&A at C2n.rW7,6Yd7SskZqFXNT6/NGi at SIR2:&ge6jOJ!Tff,"QT at R39q(&-_(Y'/\T(5msEhp!M"ZcT\5n#[orn<*/cH&c>eP&"F+.dAT5\!)$_&@WuX(24GPLkW`!N[3OS3uqGW\H9NoT6n(Jc^)`1',DY_E"GRT*$qRCgNn?TeDL8).A(NL>rR\1rC\fW^V/<m^dCR`&sQke0tk94T&+saBu at FK1%&QE?<N'sbNi7MQtb_(AF[J4iSop_mJY;ch=ZQL+"t;X*%.l7`VsKm9Q+hV:04e(3k"fI1q at Yq0MYF[X(WMEi_(Yan&+7jIEM*=L)!7HTLa]/.B`nE&>r&U8=k)CHqeHH;p-j[ZQPdj)HA8c. at 7J*E0)A8[dIa\Mlh:]2RbWRM at FN*'d\6``7Lfh2?"`W05EVQ(j`E\k+nB:W6IWMoi>?-&B+P#WEj$8C-CVf(.LS*$cZ=POH%Z<4/,VMiY1's+!FfV7:#X'*&hZ(XqGCKXOP60<a3-eX(RO^\gb at F9\-SF7pKI/%l:>5=j[Cnf*Y#rX_,/_ij,SEhNb2+Na+(,Tu]*Hf%(^29ij;#O\K+"kn2R1L6l,]fplk:cUKK'#)"I7=P]?B1,[NoieW^/B9ofY:d3EIfI\W+p'@;cTkPm&KdE4qG]V:k:i2Gu!!^'kL)jBP42[&b- at 5`l;j-H,WV"c;fO%f&].?uPHt%I4,618%#s(:n;XS^ae"GUaN`9O^`VJ-#Qj:JmjNG2ag#CXDg'"UYGQ.a+L41h,Y]dfR[A'=)/aUT,6>ZE9]I#ZYnX,il#=+ at P<cC@>]+<[h>L[rteVNcO0mIC$Y['bBEfWQc_B&rCo?hCVPhPD@\?j4g:-f[^nl(ug=W*o_E^8eK\h-PG5'05=;\c%UY+e%;A;_C[_4WP#St[W&Bf9R>MaAKhfnd1UKV=F.$r9T8p='k31!3uc9m*qNfsqKE"-ht]$uMu2?7`9)@@T,Xb5m!
 q#E+[9;1U?7&lp%W#"']\_0:Lm!HO8Ia)[VtPTaGJ at nSZR`(5f"Be_YF-Y8uK$iN";jqGeJ/SUcDS]\g+:- at l&(1ekL53/hjlWO(5:%#s9XZ8%#W2&h<;h1>MI)afE_Yjn\d"7\Zg1 at 8;sDTJ$`655e<W?)q\#^k3?WpG)]d1&C3oq8Krb<SbAIPQX0"(1t#7^1t[6QKAKT#[,tN_p?S)Cr`s[AWUj=Z7'I`3jR8$g.NtdW7tnHG(<CQ#YH:dh]t'_4>X%5B?K>"mnbWfDP)Q!rDO:ZYZrh_kK+&"iiNZV at g=28l.t?,Xn>#ZaOgBeg3-[7 at t&caJDM(\PrsU&\j?!cchiJOY[).fnj(iNu$?`#jUh-WCJ11gK4kOoW_O:EE>'X6)pp\c<!(**N"KBCF,tDC+VDq;*BO\%Bmod[0AAh=uO at 4X/XOSmG/P:(!En3\9PM?5<Z.%L)p?s,rnYV'a$*jD;)/D[:ql&7_OLX:e0\jem"LZ^[n'a)&aWVHO0qYQU^bkIhg5L-)`1*L)Ijs2h(XGA!$0C;LJDcdDH\AM,<skId#g8dMLfG)Ej&gdXN/Nl2U~>
+endstream
+endobj
+457 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 456 0 R
+>>
+endobj
+458 0 obj
+<< /Length 2750 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat$:?$#$amQJ>%ZS,'kZDp**CN''RmHe0.g[-i&pL\:q2]Z)!'2E)cQ/m>JoZ&%B5QX@&8NV5A5QCpP&-/[O<bL<<Nl"@%#2s+#4UWW]B at .t]?SmW1R6f-h3/H^\eSarMoB#XFe]KsV?VK>&_N*__D4WC-s.-6?2KH)h9J7TH6Uug02UZQWO#+t^[kr!k,m-P`-X20QdAf\p?^/,^e8eZ\g#2'YO+tU]>r=4u^:aI8?8,U_7`.jbjP+i4d3Ib(S*Ud3OF,BZ.8Ah[@qe!QmHT<YY[SL\/(V!heC=fAPibQkEJ]Pu/?`tU/\c^:TpSWVZeo245u'BIZ:SfOTc)C$Z9>f`qdIGLUYJORH%[G?k=cClQ?GUOVLsSRcF<:eTC_(`N+:$e$YF'ooD<IG2g\D[>uTP%ikarXCn:e$W/oVo,>=n$a6P:Nc;qr-C)rq4nKMt_DpNo:?@TSu\bYmZ?XM'L6j[\Pj!=g&@HqhI>Og-[g+3OGfj>3Op15n$U3X8^q"lR=N at UerOQ$U?flkc3`/A$[+&E*AVQuIE,Bsp!g6dMm/&HGKlknV\f-_gR7i^LHM"_1%N-q.thD<,mUW+d^l3(JCMW,d%pg[Il-Z60^mm.Qs*^Z(Xfej@,BafOWYZoj&7Mt\:N3*?4JVXq-+nr+o&8(l]6LshH'kh4*>VSFUmj:J+NqjF=V$i/-+S]^KVjAll@)$L:BQ24N-+?LQ'NjST*qTO/8[\:?b.nR"/2q_Q-(J4#,Z,o^kR:hH*)Djj\T9gc#:RQ4oR3j6Wk`CfRYQO+F<Ec[?'Whu0og;YT%M*8W_]'E,$ljlS_,mo8TQrba&TkEA\sXg0j,I+<L)p`REeMBmroS!;%>nIE+0Bu2$Xn&WoE.64EU9!QVJ='ZtdOj[&6(2K4m7@!8++S[&^.jme.hIUtX7Am"'_^nZ*8J#;tpa.3O)'Gm\<=i'SpR'9W>7$TOGPQNs"BM"UsYmlm at EVDS$NBeX!
 C4$C?su!N4RP5)Z/Ck7nTB,:tV9(W+F'(2Bmd%dSgKIXT(Ld"f7-p0?Hs].c$H9o?Q5 at qQShqu-7G:2"=koW4PCl*)d5D94?9OWYL6/$Ks8gS#'eAI16rN&_<?KSJPn)d>LS(0#5rj;-/5U$Jtf1GCFm_k92t!"/OT,QIlR`^=/0[$o#d]g05AEu&ZoYTaM^cjqK/-NW!a#p:k,PbL1GKNL20]jJet<L`PeMf=uY?-&G>HsiTVG8u6O"GZ,/Qq&g(D"l;?G?])SQ]0A_DA:,_PhF";CaWV-m,Ieg6K9HD<S/@5Qs`.+8gLrO'265;N_4QEQT,fmqh/oqO9'sf$]Ot2685+lT8<)`i@(%HEA5T-Hss0HC9s&Q(hZ9HnmpruH`rn&(h]u0E)i-X%;[90No<`p?e'rF343_a]XoM\Degd>paBn-'q0m96nPHR)_at;>ko-BB<:P#p@[J2a.HE4rq4alO3<#*=#X3qr57**]Be+6A5G:U#'LF<.XtF;3T\njQ,4S31D><ATF;BjkDg+<h+oiSc<n:/NM=dtl at RG>7fU\3fu1*5"3$ta-5KR3/M3HTcYY7-?N=@kRt1/L@^(UG[!uSsW'9Y9\j"&3O!G.O(iSjO*a0:FD/6h+R%OIhM#M:Hl%2X/'=uHJ':g5&ni*lCJu3kWT.8C/W9J1<dgHa3Td0M.%iM:0NW8k*oZah-Me?m<R.R:ZN'VOg_n^^5bjKA=lJ=i!g[?\+Y>>/r8bfE\5H'YjiPc&B^'l"n8o7ANNc%;+l26ld?bZ:MMl8a;H5nkl#ODs4Yr=U"\[h)i0+MQ?SE&Qp'J1`Rf4JCULW7&)7A4QX<a`ltZi(c"<krfSUDj$jJ/Fc\E at beu5?VbK8FBG'nCe;LVQJ5],f)E!J82VRD3(c%:;A]Mcc.%OH0B6,a[4oUF/g";/<):uFLm)ZC5#Fp,FW5''"():<&,pj-uh;'Dl`7=`eQ9lWi'>pFXYF+LIO9\$!
 8-l^g"%>$Q<LXJ;<=-%7V_[dK&3"p8K<E(VMb*/hq!72JA$-*>)0-FC:$VZ*$S!
 83il*3)3
(/Nkeg>5>Q`b;kW&<]fi$6KsJ6+D"F[b.I,4B%gCN1g41TL*dp+8mgDEIPj!]o`C]%`;YaWi$En'.DG_e5UpX>62L</%tB"q%ki3"m*uonBYS#!TS0PA@;DJ3\'Q:Dce$b_tBXPT#AWfYrcMlb5(A!78CFf"*,OqT"g#\GdYUAm>R7irHn?54\$.$%N/><;&>5i17u[C0r`qrR",3Zc1[]cM0m1T\$MIP-Aa*:<:fh&<-[i`jDZI>-IWbWHO0DTisHX.j&&hHGV7n#IbhF?ik[.kKM+pmq&BeE\@dl:QBi\1Z5Fa2/\:?1e5m"i/j>[-!E9@$g0EmA_djEltlPE,pT>$!`3t+_Antuam2^K>*Z+9#mg?0f:s)JEUc]gHV">D%8Sh.BPS<m\+Y&aIh'TgC<L!N_\V.OqO*)X_d2SqMb<=jgK)i6>AN#tV#7LOQ-(/l/Z`_@)9ZK!%=C>GW?#cMkqV+1.NA?*\0P>Z]Tp;d!jiU!-[dB\s-f(aCRaUMrB!@$@aW!n`Ep^RZt<f[:]CQ3nOM2#0PTKPo+P%I;YMUNE7eVCUtCWG74V%K&uL.T3\>2n]sQ.N5AEkP'iV-u"'&pGkV6Y_nDCR,IfoBkkkg at DG&BKE$(F,+^HC[nFQ/YMn/lRd)NVfJ/r"kW++Ltu2/_L+,Z&hs^&M'V[I$uiM=#jMPFYSI4<mGt#HSK"Q2~>
+endstream
+endobj
+459 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 458 0 R
+>>
+endobj
+460 0 obj
+<< /Length 1332 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasap>Ar7S'Roe[&GcsjJ\m4%?+-Z>aO"bVg;M9CjrmPIaqeGXXsb[jMZ3?I=4._L"9rD#53G$%Ma"4SQbQB*3l&"$aiq"J1MAf.""f>o9@#m(HIaRPrgC)%=BPT,X5=(V0^oMCJL`?X*s&"BoTtp2H^O2EXQ(3rH3aX>9=_^Kc7?>3jheTJSJl`Z0jYmPo2!Qaqs1l+X.-m(PlEnK(OAUg",L1&+!V+\852B)5[H,9T!Ru\OUBKni;Kj*:4`Lt/SA&D]TO8XgQ1)c5re$3#`Je\7Z11I(W*rsHB73BihGJ)a]#QXd:8V`C]uOjLpnjN\D&I163QPOO;8&//EDk<*?bVNmWITGP+CO1(s*q^W`1rS?9P3d2Z++TN5\%8aMB"_ilAesCfkfk0oX"">gK$YBV4\Z^[?#XedK/EBg;ZO.Qah+iNnsjfk9*]k7`BEb*TQaWu80jQ5UW(!q6a`!._F4<kQY7N)a)UL`XJ\J9Kd$KuIUU3M!G1[Lsu7_!V'l;bqrN#_kZ/#uSf&C3%8hqPB8TKGDr9Y7=-uVfaE'12JstNcmj^-FNlB9"1 at j$X6pM:dC`@.!l_09(IcR'3/eU at AT4+1),a[-"#!q4L*Xsg\E#i.cR at E,fHUrQ1="<C7ofM at r9F3Q64`MG6a_S>;(r8HPC^Ua[K:3fseEM2P$-Vd5bM&<?E2GXcci/lur)2V,5#or';;5@(2h\[29>r,n8r$KUqIq:a]J-"&oqk6?f[!(fBQLjD8$7j4;RDj$5`=cp&7Z4A6;`LQ`<:I6^Oe9JU\l#eA6:HTXJ7+mo33Q%ReIqn"]aIS(dqY21h80(^Le%R=<SIes!<&".sU`\KR(8NT83!V$!#`1$<f<9]t0U%<oLBKae9MT!<^kJ"S8/,=O!n?hW)nj]"M*-)-2YJTLCgnm/[O?_ABMsqN#HcN?S?q3!;8,it2`/op#:@t[*;D`9:Y$k\d#Pm3VVAn3rUL)><Ka:[+k:q!
 =iS)9m<lRJ?Hq)Zd?f@<l?P_A;A[[K,Qim_aL(bB@#5if=f<4<\;kHA]'4AVGdP=u826)0TS at JO#<dKP13S;<W6H!2Dk;Hi`+`*u/jUI"o,rrtoUU1=JFBq8fd/'=VnIOqM0RP$Xld39F at d;R^M at 6LmlBmd)OLb*/\)Q66ep&+_5 at Dk8ih2Q7\'2SX<9kPE2hFm5AKJ!FZ\U_!G6eBg/g+4s1j^oP*@]=V#QehifE<-KF%Pt1t6Og;`]jPr;NEq&D$QIU!$4sauN#&kLOS/s]LVIFjl`(hJ!Y>_dIs?His5dErh]5 at C.=&l(_SjTR?ebm*;gmYJWn5sG-.;ffV-d4~>
+endstream
+endobj
+461 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 460 0 R
+>>
+endobj
+462 0 obj
+<< /Length 1217 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0D9lo&I&A at C2n.rVL,6S;A,<<^`Hg49c'AIO\Ff,=5OMZ`!D1GTTIp_[Q=Ab_[g#F"Om_4*O0&D1BT?f.PZ_s5[D.]11aS3Os6-Q+Kf[h>s]_1W;Fq+t$D%ajq1Vob+3:%K!!"[e+JK$[Pi")02L[4't]!_:>Knhfb8E6&00_4?:hOc1\l#.ljo&lbrq<$3(bF<t^ekMA_6kO==Dm+(3DXY<b42VSq(n3M).is#I at R,[]-XlP\oD[g[gZuJPS"#>>J,Fc\SS:R$ccPlDR+u"Tje^T8$.dPTJ%I%O9#tp>R[7[T9sP>LX:<k`KrniTqYp,NiQ_(?gd2,eU)epDY0nGG[34?1R.P+V(Q.mAA[2##/BdpS8lK*eP(P.1NgCVblMf9cnC!==$^I#lOkUVA(bj'%6E?8&Iirs4HtKh_a<c<IV3'u;XU'D at 5=o/#/@LSNDmdd]p6cU"!?"/h-C)c6!;ip-&+U%+!J;[4qDM3+p](R0PFShpj>9Y?8culY<3i8o%l4DdO>3)[[$4hpZqH$BN`'8P(bdD]9'3\nc=dj;"qj8iaMpKbBG at 3iSg'ga$kS7C.-LfO/p;#T84.UoPD1eaR*i at J=;43dbRgTZ,tVm_/^i1U]#f[J6YrZ4qK1XQeBAIpB"5%3iJq:aKC^F+5QA\4(K7]&&r'N/B/?]E>FnjS%?q5cK$\Weh3o*)eBg?Ndt5Y%*j'.PC#9K]eX at 8X^jmH-BcS8qnV3K5bE6?s?>YJn!hdlDIX6_78JWP(gB2%0_(, at Abqcf:6Ajr!fi;9 at 2?]k$i:;Y<A.n5$3g!/6NsWZ-Z(88hhp,/3a*@\,E'*F\idb67q6E4]mE2`U[mHBq`5*G=mTEDG`So!O+]iBlJ_#"GSuPcX?+ZOT+GgVLPJ%'r<E>MaaNcHtV'jN1RH;VsQ]Y>[$i'/[fGg)B<ETWJ!MZ[6H_;Y[C19$WNOS&<'$/l1M8"EcA4d4T'I-3s[(m!&?0p!
 /3\/%VKKRDFL<%4:<E#\jE.)NeT9b;X;UH at 4<ZUa6Ri\icm^C`[q;&9KZUX<<DRl38TD1/:OAc#T/mp_5hHPUdpLL;e2?GI.-WB.&g at V-WffNTN;X*Z?,YQ9)ZDhSb+n#_-n6Oh(DS>\WA0h,RjjB%paat5W955+EZ(/FjkrjWEE;iG\ikMYs@/'I9KXG%@J,.iHkn"d`:bC#j;btqb1BSRWt(?p<a-2aJ~>
+endstream
+endobj
+463 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 462 0 R
+>>
+endobj
+464 0 obj
+<< /Length 1631 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat=,968iG&AII3n7[#^L&g,QWUAD;GLDm]Q@#Se)2NlTeeBN`Uf.6iJcJ=m?P_H:(>Sl^!UKp$=Y4MmMrV[ZFpisDgTc>i[XH>_CIbHc[C2!K`=6?G2+nL+RKWk(0uE+#'(@HE<\4'd'S!]P/Q?Yl[YirT*#>gk`_nFtK@!fhXhQNHj,\k(fqnAt>5\Ks,^p<W+]<]K&'N_JVlqVqpur9^<^SAPqL[VjaE@$H?&]OfiBZ](iqLKKVu,THp?Q(8?<YrhLho#1j1r5c?$5DPLO3(M*Tc,E"6!ct%!Z^]4R;ET>+S8C@([PAL`b93YAD]bJQ%'.i$9m&jZM_PQX<p7rF(X!NZ6WB`i6jS#U&J,+C^X.Q5::6Ag?K6I#O<SM%8V5E>KV0<@rhk9?N1=k$4INc#J. at rQ#7f:Ig2uoT%\/'D3Kj(LV5Spl:YpY$oZ1'6l)G]EHq,FTKdW"Ai4.?W.NqHu%:[<9)jtmVFD>P\JET38qE`M;FM\2tOZe!$[+4nVWpGYM&`>eiDGF>88e)U;Ejd"$p?=<0OTo\Y:@kl\p(E!]:jV2T<t^"Mi*G\3 at 3\MTM,,i?r*#]OGH`Ve/:HD9+h2.X;O]]r?8!G!O4YPl6pqPn%s^^[5U02B&:Zm&2GQeO3Y<ql)qVfdVEA\cId\RX?8pP>OMM0tbSAm8CtXWl;@^]3_ZNom0":`K(&BT((>u_B9'alN4hN5Ln%&588hrb"kHJ,eIcj\_4t6)'pXk+UmY<g.9m"VnC8]!9;Y3S$[%I!E2rmG,$;N^#qi_ZOa:"@D42%br8(k&u=)!3TuCVct:@AS_nO!RuR:o(jLDRWU-//5\Eq/#KerH1[`!s!rmOPmHOc6\QD>upd7]Hp<OQ$QWN=51-cMmB>(!6IZ.;!Rqb`%=dUe34doi*Bo"X2XNGoD)K)+1Dr\Q>e(hpU4jXY:]K?E*404N<#50B,2o^"Xc'^<B0XPgVA&t1VW-'W1F(8g+`,m!
 5?a*p)OMWULmU4gLt>9-sG*THi=UScY,)V6`*E!CaDrj^Vi1il,Hf+h`G3&7[pM=[iDRk2ADpW`6>>^)0.o1(,f*#ZR':NBQ$3ZuAR8Zlhjp;9r1s7[3Y`b9u[ePj[c"#I3+!#o)e4?\pJ0-T7Qec:W4\'>,@!o2d;V4:K2Ls*70S]GU5Lbuqhnesrk5iNZ,4bHVrer1]oCD=Che'5Bb+lgm='KS-mockhso(F<KdDu+<$fPLRQhRd+/):2DW-^AMUSoQlch']?HrV*FSlh-C(u:Q\7Ir++-X%$jA,Z[mNPhWJ%3]h6Z%=%['G_r$9;LO41.C9FkrO"7NgP]3A.L*ATCnY?V2ePCSd8-63WjCanV1S/P_Ebn44(""2 at T4[;3laY. at W"f&-&CYD9Zl^^fl]M>Vt^8B]H$#NuX&BEQ2"8J&`uq<9%_%[Km,q928&-91/:cE403@@9o;7op]*:HeD(B%4D;soW6F?!+St_S?bUP'e&sI=4puO;SbY-)k9[^!gU;p*S7*;ru%[T[dkQW;rjPXp9Z^5k4!R`n)6f&9l.]#ekdC<nP0l(XZ+-ef.1X1LF3#?[8e at ao9h*G,9(@H?bbD9A!V40\[pI($H2Sp^5K0i`ttq"N?1Onks)en^L.~>
+endstream
+endobj
+465 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 464 0 R
+>>
+endobj
+466 0 obj
+<< /Length 1460 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatU395iiK&AJ$CW4/SD.\]>E[cjD6Z=o,3d3R"Dej[F-Zn4\C*)^h*IpYgD7#Da3\O?LR1Re,!*6sI$o@`dQi&SSo4_ML#H-U"+*0:+##G_rE7]Gj.fU;2umh``%4ZqUb52P.Gqg.LSMS*-Wic+/[jii5;3+3'@63Ii<&EO[K<Bk;!911_K<-/R"Yr%pYHXb?QEH;E/2?^5O8;T9m.][T;_"kKO)ORl_9&)*pe&8e!=(GHG"mL(aZGI\1X%sf\/Q&+G5)Y\>q0LTSGm5f=K<=>bGsp[pOk1V3@\S-MSS?U"5s!!2K]0C[2euOd'M73a_kDrfXS_XP:0qn+p/qVg1\?hPJWCp2pX!QT.GE`h^\UNGNeOtqiDsqu at _M8Z:i8)/s8.^I!seV/9UNiRrKJ$CT=I-Z"5%-Q at jCXD`kRKb/_)gMY'XW[6R8Wk6ZOqV':fcS*uQSs-<s`_gggX`1^iT%]5F@:Z^/e`pPbNc'EJsr;<NTsT'u,R.<R_E]nncqHklKqkeLftnJ0$gHM0&)R;7BsjWD>^Q6MuV+-6k="#qbX2f@]22ST0R*[cqS+$#"g)p'n@\%aA(\AXUIF>s]=h(]JhLE]s%U]ea5TrBc"5 at g2.K=7toYS?ZIj\I7%=kF/3e."Y^\kK<a^!`JsVL=UcG3M=E>)/'&Q,mdXfV.Cb,C7N]e='?^53Q+iCLh5A*nBN!]u3*q(Hi%hin;T%:S7_CXk=S3#<h9?E(\%R#qr>u6HDq6'RNKho7B.sTpt\+Z9#"X&tZSe,]%hMj6b=erVU3Qa3`0gna-@\CY8dg9!+^,DMfW>1b[#WPb/RR]Wa854XFrs&@aF\dY8io=]/X[$)XZNdfnEfX=X(&fG?)S`tcE&D0/%HBmT4:(%L24d'HUtn<Dr.F/#!<&H@)Po]*:\)nt*)HZY';pEcrG`O#Eb-ogZuY19k,`O6O^0aMI#&EWaHes\$8Qr/?dM;97Z/<BZrK5#^27lC!
 oB\Pf7&$)o5Q8=;=;NF]DU6'B3Mca6BnX,:M"U[>A;F[,B$P0Rt<fB1j8N/$kA at +Bo*Q)tkiCmUNO6h+oL!2J(]&R"4_%O[alX0JZ3jrB0kMGYr%-m/sVPT?L%XFUBnkU&M/@gB]\rp[6tHiGZMX[QipOQg7qSI'OP)>ZT$gc1_M!s+?c5FKk#-O at l.L#@5>&FfHf<KAW=[!9%jIXlX at 1d/;Yl<6Q%%/.Qb2`)oS_IZ$%iN;En^M]2-jSMe+q=[au+7SPSX0`j*YD`7j'q&tqa_5<W`T`OXZ+?9m%7Qa4'iUSL'pGP/T-6OMbfh[OF;\Uk^-sABdAL@@d,*EZkiEo(j??.3a^8P+hD-`d7>D+&rr-a&6glN/?"#<joi\o&fk."/7%,1r=Q4bDm@?E">:MoIJ`Z^ZKm:h"BYXf%g\dC&mhGaG?=Sl7&eAml5rUc[+#IOc$sY4.j&@3#$b!fiXo~>
+endstream
+endobj
+467 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 466 0 R
+>>
+endobj
+468 0 obj
+<< /Length 1147 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gb!#[>BA7Q'RnB3n0;MQ6<@BG-Xb)5GM$?Y#$ugge3n!ZM/6_#/c4jr0<o%VBcRN_PF!9bSF:jgU<hj9e&deT/4'o`BY'SHk\>\nBRV?r\3<S/"t5>*lfe;B6>3WiQ.4pEUZc2ErPui#fE_/%Bl"8gD?KpQ3.$!uIX^kah7lJ-E=D/`8(Tm.gOUK'H4\V)RS_4scq<LP=]r at k]pDNRHE^PTb/uKM3.&1Mg=hVT?`E_s1`bWXc+,B<3\.3]=8"=T3-Daf-<75)B>UWe.8&c#DZ=(TD-?0%7Wj*6 at uL`\3GM]6Zn`jgVCA2KO+[TF+iItN@^Y`d[X at F5a2r>CL\@PLd3b0#cg0?4(.2#W._GD)AuiT"B^[WR6T`n at WUD1d1sF/2TubuVlmFbd2JdHHA1.nj_KD`VNEFkd[?rO%,sf:O,Vk!E#]o_j_8_`d.=eeEHuo*dcDn>?#tR(18I_N%@^?\!b6IBF3r.K9k%=IKeJF'2[':`]Od=C(E]/1tF^,B"(,6GSfXTL-W%KOWa_1c;_QunmH%sa3H'Rf(=PVD#0d)^gKpQ.2$*D0*;%upQK.G4UJ&4;IMmN#=Mmomf<Ys,#RY:NG_)*<mQuP at a_]G6Cb8$IE<QQcUBMCD"rG_Dq%ZP1\UFA.^mP5N&iM_<H[VU;->B?M0ocC at e.l$q\@&UUnMG:XG:4g^;ThOhS]H#ks'tL3RN`kc>/+PG7lDA:F#T?EC+LiLM:7N(@ng^EaM*1Q=L,no]*rIdg34<MZXh(-eMik!L]H&^kT<'ut]B9eH$V?b_Z289V[bJFC*fRYR%a8,?04fcg+KC(OW0P9l-9%!VEg9^'$,T#$-isO2&lO<!i+S(2Nq)JaGFjQr.3Ssn?f?ruK_l$8@/++E*JEhB#YHN$anJFS'QX`qrco.Qk:7TcM,WpfMMI$%q1FP`^j**C@<449I[K+(0RfYR+jMWu+'1Q=;]"R4.3:5d%[;rN4Cl0\;Dq#7`cu!
 [k43teYYE"Tj2:AeSrg1H%V?r(=6SsiO!"YfU8V3t/+>;4\4d9EVH<\;Cq!FJPH/I^C=IrsEiV"H*YDn](2.<PX?N1]1_V<]@^bnbo5`#g,rE%A;s%_sYS]c`:;U&`3R9=29bgh2]2k/%tTH-(K(?mok0%+#~>
+endstream
+endobj
+469 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 468 0 R
+>>
+endobj
+470 0 obj
+<< /Length 1040 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GauHK>AqtE'RoMSaQ"U%f66L?JL;d]@V?&$B"TgNZHhjSdU[E($N,4?94Ko'g8<=q?Ynnqn(^.>kM]fn8K at p7FMc]23qEAmT_]f:iSoqb$kRKsL%F\"n3$]no2Ff\e)K,=I,K;a#nd+j[^&9g.Ec3=B;n(Omsc:GZpQL5dI\$@3o?LtA'7H)TuP3P843h<\]E[ZZGT<<Rg9tP^ag+u<r=Whh->r[(Y<"Y.AIq8NW*ZHkSAgZr>*>+^G6FCDBtp+h<U+0)mIHJ.[>D,L%_B;e38?jLcE*27V]847r$e][S"*B,R6^@K3_?NHr]ghrl>Kb_4R&VQi,]ZVSq++CE8n at M^\0+I(9rjlC]pG\>7X'&<kN:@WHN1g/07S:_o1<bY&cU;5*kI9o at 0+'EcZA=_6m)hNgN+Y=h*$&C9uGPGn/*q/J$3,g3RG#P'$1c(1Oe>meDHW=Lmq2e83$Q;`NAP0(A-KsKd(GYJrSEK]PHh&3VfW at qii=0[/"]6'Gdq0LsP_SL:^:K<\m#1OgX)QK(\c>50QS;2hA$4;oGeKUs]b9BGJ!O?(810hrS$kG"DmJb/9E)ptW=!o5Br_Y">n6_'I\@%"r$NNQ[H.hC=2.^IU$6q,S]+pfjfPBg0Fthko]s^kgmHM5'1L,])"5opHFO\SnUR?"ZWJuM$P%`#*(BM@$"5iDg+AaT^^'Lr==qE@$#[EuZ@(e4Far_;VIpN8I'lg3c'`;'2F^8aTFHPjW7;>_+#M\[H/l$C$Qq%W0($mGo,6tHq!J6U(>-K*PhuEdb:]*'.Og(\nHTpq5?U?KT>4>Q>WI-Ic?Bn)9nH#TuQ*(uNO3 at uEUJZ<R(Y-d>Ih_;`52>\,I>)kr7]_HG(O_uB.iq8h-H(i,$Segc4-I<OLh#["]DK^JnjWJ1#]8?VT"bg`#0QK6<Ap],kc+)ug.?/_"O')`gDC+H5ChJ]bLM(b9=]Mik!K]I`07%Q*Yfouiu)NIXJ2OrV53!
 #En%W,l"HN;:X*=*@_jGa!\Q2r2Db<l$l2jkYqa_t1"6kJm)#~>
+endstream
+endobj
+471 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 470 0 R
+>>
+endobj
+472 0 obj
+<< /Length 1445 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GauHKgMZ%0&:O:Skg9DN<MW/YC7gq=78n#R-Lpe at ZWJUkD6&dF8!7rhqbe\.NYqW(D.=^XO?A:cc>_)(C,YqIf>L%-+*b-2..ENIj9>I64G:>_#[oqahJDS-);j?.?/L/21qW7kHF)Kh&0[%_W/+QSk5!cEW(NpaaTiBsfE+3pJ%NJoHujLUrTULM0"fAAcp>Z)'D)2%p82ZZP1=.mce]]qIaT1_O5>^L9bZlKC85,sf, at BrL/X^jj*&ClOZjOs at dLJ)ds#;&[J<!>dK\(ZA^dO<*,qbAN_ME3PIGg;!c[ikJ]pIlF$PtU)'IWkX.;a0fdh%>nS^=(Tske0>bH4R1")E.cSg:Dh90K)QYk/3?*fjIc&X2_Jr`2hVB%?I5^2Sh`"g>2U6(/N<']3F?F&/7*UQ.BJjbg5;sgeRJ0HX&p1?Fc(;RP1Y3Jh4>D1-&'JXT^KLW4iULro%/pTE/8J621N`/;R^$k:?kZLph8OJ:u,p!Xf^f.(AhI:Rg\se28.,bgR-U&_`%I1+EZ&fSaH$H%:>:t$bmA_O)e.]t8(kX#3Za=:<;75gr6HG5PWJ(hV>^JH2*Q8fb5HT)S5sA-bD5p=*if+WNB>Ujr-h_H&M[Hd0n<+Pk2B5oMeTs2a&lfC>ADOlFL=M3^?LRWtd;MG_<#h4(EXITF"!3:sDdhq)h3[m;9ks'fg\tCJVV4+POMl\[Ppe?,^%r%;\>udRSF!AZ at Z@Wb35sbF(<klJl8:4%@m'm:RJ3+R&dV'&!hLSB"<69eOoQrF>7sI<CU,`B!E,F<#r#B*;hQi^ZkoVgK#L'SJ7Y;&:Q;#5!KqoF<)94j_:4Ng4!KZ&]H:!"WCD,5FIBD61,C9S&dQ(a!bGuF?q[)A5(E_"W\!"doic?*iM8os!1#;*WdE+1_i%b*$.Xf<Cs+ge3<?&[h-4C%,dDXh5!Wq)fc2L5Kg1 at o!ETQ!)KXZK\3BYrpFq'+J;MX[/Bto?jZDOL'?/!
 #52s(@`nIb>?`'V#D>'QK`LHLP/,HY71pW,;U9b+A1-d"A9\b=Z-h[k(AHk-ut<E3JoY*nJ,HAoXL)Z)?/$9Z)m?7b2>-1'(D'j=e at BLkK@ZXT#r/.Hkf]7<L]Ua9ap"5$,JIGQ%,MQV$C'n?A#R<hUWQi6 at L:,`1]([bfXOhT4m77I%-.PI-#@$PUfXDH[DM>:r8!Bik*]Dk%`FMUWPMrM>P'1GlaSM$;X+$f at G$Kf'$;$'MSI("fk"ZU&=2W]ojkDti;Bo1ae'2GsCCqG$20VBE-OhPg6XPCi::u0AhZWc]tQa'16F4INdW/oKZMJW'0h!'h1etDWH&cO<$OR-jS>]K5trpXJ0RZTsOA#0uX7N>.0C.A&c=u at ONd\>8,_G\m>nDcP5<<jf/h-%f8`]f:@^&7fkNM4*s$f72*0#Y06Pka3Dr_QiN%=Ou'@r.P3!>L-rRf~>
+endstream
+endobj
+473 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 472 0 R
+>>
+endobj
+474 0 obj
+<< /Length 1318 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0Dhf%7-&:X@\Tsl at 6b)-fX9A at o&Ug&Q`=;#g2D)'Bqm:t45P`iBL^E60J]!G'fZFrF)i%`:@]Ajq#:4>9ogs.6R-bd']d(h$C(T/^=4Jp`E>"R\T-MN_5=HW#Oie1GL)QSQZ04Gjh76O;Foj#FRhPD:LDpMHRhbtF7ok4p#F")sDhQ631?I`E_?Amt"qs;RV7qrr+NldM([E&0"gW'inB3+QI4%_SdmaRKo:*"jpS(](fm1XoZqX*hP_qi5JmJFZt\Fs7Lra+XMq$,E2pNL0nej at 5S[f#j`qWEke3k!:X`*s?_U8R:U<WGFUOMncjYhY$T#V0$m+>mL/#^+$$)h_$?6$O#_<QW*PTWb.+.](:WX=DUu3P\bArt,W\Q8\o':K<r+@]Bf&_ at V9Al)*X-.l5$JmVuH\&_bW'LVa*26&KuX2]s&OLSAB-DDIgb)4.uINKEg/OGWsV[+"ucM%Vf3:9*b.9VC8YL,cEHiR3J.aEuPUm>8^jbalX)gOgWSE[e_R"k at AGCAXkp(6+0-1F,g7FCn(kCh9T_nX?<5hF<^oOaX57AYY#I.7,Jngsd6sqUF/\mF*OqiEf^W49t-.$qjb!>\sUA2JuW*.<;\2T:"H8GBG,;ORm:@:2j=$l4rn1K1W=GJ)parB+:rC1>a6:/*0afH'8XdkcOFkNW>^7U:u0f/g]DKpLWZL&[o*/9AXW>_E!hcX)5C\Mh9dD=cSTe8mQ_QL(/LQ<gk6arTKSXF/XN=^%TEEfoOgR`lTDs-l^Po7jqPYU\IaU4RAOgMFhj8g3D)fCqac);325[(m6.*[=dI;"#S;03pflFcsFk.8=1_"<A^T'"b]38d6_J,Cmdn,rsd.?c>/)2W'W]bP/,?Oj5Ol54'b5B"1J`qS80)?Z)Q*s%>&H\#/'8Bj*c"qKHG<&Ag)7R!9]>DLgmMs at V&j2c%@eko,XnI&<\qRBYAPOR.8"on\efac,A!"+4,Sc^@,+:>7F!
 \t+l[NXlA>ZS_WnYE0W!UmX_l3 at C/3rh&TdIn:`8SNjdnBIf^CdpRPmJ:#LAnu0Z:rZ7]7daM_:GV0Z:NN7P>Tk$l_KqFB4neD"K3+&2>q7`cR[m9M(>)kVaY"/[nS>XkNu;On>:UfXl7];*[^AT%[lIWFH-FO(!IF+513+2$lb:M!p:/Q47HhX.sc9H)G8b=1CHPUoYg_F)[D'i#,hkF[K0\mT_lNhTuN<Slotc`5VD(#&+<cB"c"ls'*/k!PYK6V+G=N"U/S^kePM40Yt_]Kh='CeG_T%bFa!/rrAZ4/qR2RX*tjLe/q_RRbKB>&d$L2MB?%C~>
+endstream
+endobj
+475 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 474 0 R
+>>
+endobj
+476 0 obj
+<< /Length 1241 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GauHLbAu;j']&?q?:(Q0/6TE$]4s+C1`b:!O*";]*<?5s3&Zm.8cHHU0-l2Z-CJBlanMD(e</gM;<quHH>$I$U4og_>))A?VIP^8Cr(o`A)?L[/n at 84M7?hhMBE]>)EET6J4J]n_mu;_nG0J1TPSm10B<S(0T^i>cLlS6oo.;3n[k>Sr*?OK`^7,,.I.h#N6sRU4?)<3VM>NK@=N5R]^:\N_=MGq[YD4o*`9;O7V!Sk<U=fBeT(KPY^_!U(gQ`_IIA"cY*Gun2]p"`fY<8@[U<>k"gb+HkO[8dZgVB9)0&B_1pgF699oP\G&iC\ai%`$k+"l>=:h`:/+L8A2kKqW;b<7O21hkg$.9rV`!V/@9qiQ>,c/sO;dVTHL]Am%pFKl<q';tQm:XGbHHu&7U:pU4P)JqGPTb5J9dtj8&G$>(W'AX-p9k3Kofhf)";+$Xp=,aYWiKkd&(a3R&r5+D2`OI^4G%UD&`4p\EsN%_X!rDQZ!\*+-EKR^@Ns6NFrCW%[S+GH`3W)t"B_tA_Zt8.fS8sI:-q,6&C35G:8'G&UEiLFgN?1C9?uX^E\[T5Lla=-V?;Jqj41`6MnfO@<.I, at .NBmnWH(mOe7&_&<=q4>LCP$^qrQtnmIb-[_^=G6JD?Y-!^a#a2F(J*Ts6.KZ<!6tUPdMS:=`ZRGY\Ad5_)iI:*MsX(Q,+(TPl7jY9lLRfW,'8SH'%I,`)1<^i<BPEMl*UNdW=mXR2((-t-5pR0cU?9Qn!MnG8Fm")WfM%5r6qiks#*mc`ES#&:7;h*2;T,TCAIhN"7Q`@Ubo*:J]K5*n'>Ro\EV/gdW.?^A%Z at 3*- at -PS)-pPC>bIbaXC@[<@q&r%[t*Ft\`<on<T=7]>^!^cace$O5or"M[)(p?k$#,fk#kt@:!QmgKJj`a:&.qG>IF0sCUlY*k&A<0"n8dlP#dV$[o3=S;X2I23nV&2Zof1G)O>nO:CB*`Bq7DK%o"?3h71_;3T(P8!
 Pj&MW`KbEpQ<7n2r,Ru=DPe-*ZX`'3j*,&>_rdCr=;e`<469sA2uT&&=AU/LP3%`"l.GE_2.bq*\1pXu(Q,A12$;SU',N'&XX4QUNON_k,^lU6JPp#1jGZitg8lU6JPl/>lO:L3D)[E@>Tc]DEHc^-oj3&.?p=SMSFA&.0#7!3L\%&/HI^@U_G414esL at TkgoRC_rL3H@$K4*;!jkl4S5Ap]$5Y83VG6XY.#P%1D95nAa-$km`V#P?(6+H~>
+endstream
+endobj
+477 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 476 0 R
+>>
+endobj
+478 0 obj
+<< /Length 1780 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatU4969,O%)2U?kgj9V_psC&V=(=NAuFm0B/YUTQ_r6*D)t]BMcr\qP(-h2HpKT+/))!D!ZsZ-!^U,TZ^Z at 9IHGlPZQSn&mj2+k at LiubT<B0uX_2jaCFC%l,"[Zg8<E=p6S?@\i)r'SG`ZtarqJMFJtAO:KtPGP]YFolE6ud)1AC at ApX_k2rL]g!4&RXZ>@2]+Hhm+qHE`PXBH at HDLV%?A8h'K(EtE"8=sjV.*L?rnT at +.QD=-lQ[thS6\+fVU?iKu`d^r-L?K,GoGkjqk`.oB>YAo.<M=W7bBX9:jNj]oRN!GSVD:YL<CUX#)/it3-]&hG0J0mZ at b9_!d;?4sQ8_OptqW>3J(6=lgXcR;Z2UeEfpWU5'!.Bm:Hq*Nt#I0:l9cC>)j4=3Gdd8+\46nCRcA\JZALI$`%TNo\7fIS,H(lE'4flQq35Je5U"ulN\DL at IMgB>K[s>=G5pJT_I[4QE/-%pCX&-TB(iW&*VJF`u?,<NqpF<PTc57MK at d17cj_B[&m+ejFTg0Vuo@>qBE>GO6,?#iLkV>/"_>gRO3!qqe\"n:eLGT3acthbTB"b72A*YX7gZg._.lFBdL\#]e.pk5O42kL+"61q$$(fTBE>kMN:MB_@"JorYGcq"+><bk]Pa]Tsd?h:P#FQA&8W;)"p&4cWLMpPjPF[2`/Zf*WcF+hJC<,'-#IAlh]B.lHM)L)gXBnBuihB?CJnM>=Q;_Z2N+7NN<T1 at NW?M9m1=L4hq+T\IIGLLN$@>\=ka2Ng:NB/-8VZL?V[V+_=gM^eg>>r?;TW<ONI]>GZ)]Z%F_"?Q/CoboGU$o>@bEDNJ$".J at pC>&CIb4YkC778q;@hG`e$S._TlVh$?"8C!oD`:fQo!hdSL=%^2,4^kfV]aYofA8I*XYiV+1"Rf5TkV&C[f@;uZ8h&F0hcqI7eJ"!EJ976useZ..I0_GWO$)\Yu#")o`&RlPsLJ2*92:4.`2S0DZE-`pegZW*!
 e9]qsHeD3/2eRf[9g8hqs-c)U?ZW^c5fjD.h@/R;*GG3f@%*2sJ3@`Kk4Rt5bBE4Q,gejX/DbYs%40O<I7HhIl_o?j8U<Mh`<RXIR_Cc.orX<LosP!8EcJnG)M*$Q?5O"fuNgpCJD,L]5?0q,"=VNW^X:mb"F:*p6=gHtCXdn)b3A8ld<FcRkX&0QE^]Q5o\>%;[;>V_f[lMU-V11f_VZ2hkld+;R8&Tp&DOa9.2[4Ednkcqq.-]Y)Q3N!-LNXgZf",S-h=&j9Kh)+3["0eWe=fO>kXm^]&,l_P>+`fR4^ZgdR?Z][0;>UO4mH=L"B6aWZY at FODjs]hL5O:%>rS0;)1+'&m\@E'hKLrLdi(gpCJABkOfN8DHr]XJVFI'Ocg:WDJ94E6lJ.*MiL8tLki5(F\=[fgckS_0-&U>h:NB8 at VVDBEfYu-B&Q/nW`,Y-@],\m<%(eW;^92<#A8aup!C\dlC`0+.!Y8 at W5WTo`/NK!SP5P_m7!0XoGMkq`)+Y=7<i&F)T5TEk(i`(]5DWnfB])dpN8??;D#T3_1kSOSGZ0Mfq;R-OSnd'hD.<nh0\`*^lo%mG[_+mAL[%[%<KOE?3VuY+HACk6mG,UNF4HPVjaDg`\;8RApV8FAUj2$(:$:):@.$,]NYce4LcYc.to_8phKXZ'raBqn3-m,U%!'g<_f=+S\\Kt6Qmn.Y7f/`XYUoWH;Dh6-rrSSbXJ2$@:?qgWB53'5(MebEG"Q>.EVC7P at UOW)cCQS!ZEOcMMJ,E($8&JRJo,!BS:Lf%L+0iP:!<~>
+endstream
+endobj
+479 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 478 0 R
+>>
+endobj
+480 0 obj
+<< /Length 1387 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau`T95iiK&AJ$Cki`#'<[@@tp=,a<1rU5I&oTGZ@\H2SXi?[>P+9Jj^(eQ,8>^3=[m^lSi!a84)%PgQk'Ab/pAoOLnm'LDA2DP7cB.)V+64O_Eb7kIM]uf=EW2Imgt`_T>I*P2\I-#NAY,f<(X?C5iYRUgBG^o(@t+K@(FeA_=#^cVAS0N<M?+p#QE1+=O+4J`5j-+B at bi;*cdF+f'&7AY+jt7-XP$UmH`lL0deYq!%)g'>rQW6XNsgebZ^?1.!n5!Da:0+rX?F:tR$5e_B%ID5La_-d&XFW>%AZEFn-.`A3GDU:faPXm5S$2B0GZ^3)p0tg?b]R^CWb50 at J.3JX?d2lmm]iRG:sFg;:)#)3-'"7CW)1V7i[_Do&ohp%sOX`n*b0Yrp_MR&O_=So9W*8^bf"QSqh`V/,Sj]6H2<(laeY!-BYdLHM*H&5@=>-,bHARke"P3q5HG'`uujSj"?DRZ9,aoZDu\^`L>k-bmaE:2lgs('\R*10)'Xr"=bppn:eooDed1YK`A3te2>He\[B'Fbk>OQp?]lCdKi9V%rjjVFLj#:.uWs\e<S`"dUu..`kYKiGhdpG+=KC[+f\(*1'(S5ZHerP/-';Y#-EqHfcKu&#\I_?-7qY]8?.2Eln*/PHRj*F[SZg&LN8Yr\#cN6]-'FDE19hojg1t9D[P)X9P)W-I;0JnPpac7j]H`)h>lPK$ZBHLq at e,mD#1O'quIAd3c/s_9c,e/:?>Dn.Vmp%I4Tor-"4k4XZq)J-uo';KNh0Y at o*UGfrfQt`R/[3oCX#pEZ[eN\a'g8bXUYk2JgJ*=<uJ<C3rAVK$,[eT'j</Br19cj<Ppe'V at 2(8J&Kn5%BnN+Xh2OK%$SW$&M:W3+bV1=s?AE2j@&Sj,lRQ)WFua2i\,H_tgFGaJE%obPIa>9DIC0)NrPXLY*%bV/i:2ZC>TZU#q*gW!(WZ2;oZmOnKYs<b5jM3Gr(['>l6/>,"[6Y_s/9REo!
 2ICI#ebB"2lo!QHQmB%.]irYVp%Qq-gl^i'oiHgU0,l8-Tf>a`"q8/W:[3/Yt':Dmn,0T+>7RWu,'M!lC"Qp_kZ)kTq<idZ>B at 5$,J9PM.f'GLcPAWp*>[=COaC3>"VepE&A>4QNL#j?@lV88b)<Cp.iZIbL%ke8H10#d!qIRHNSa(KMn1BaQA:2jD"8,Q$,lZM?9V";'5,;Q[u6`hO2Gisics(UYoYoAg3j!Xb5)l[J/=K6"-`tt^o.&9%.,cP-4Jl8cm6($9L+X!-QLF,FI'ES*F at ML+'FaY`5YQd6sEk;7QL`rWA1&++A`R&^Q=_%<M.2i.\4!,_sjJ.ieSER&3G\I^A)!c\$r:p/kZ#S)F<jCY at fa[F`3B;sm7"]42V\2-&%FRHYa(Xl~>
+endstream
+endobj
+481 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 480 0 R
+>>
+endobj
+482 0 obj
+<< /Length 1386 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau`S9lJcK%)1n+pt,YMB?B&cB`gCI0D5H_S*dKkK9F<T=3&U&V-ErtA4`)#7rFN,_iTetO:Q&oj<MF-9jYIA*TXc&1Wq,:Z^N#Wj$2TIgaZeE]-qi7CZk<BL=Ba.)6KBpkKXlVp)j#tSp&\FBuC``@N=:]?@SL%gg%Pmo`)IC)0r@%fqZOmpE4Df$m=1cjfUQWY)Lj\b)G,m5+>?$1t_3gZt+8ICQhK,r:t_(!$X(_oV]g(b!:,GV-;-Yd05X'El>4kAFZ<jlG&M'pN.<2A_XfWYN%B/rAM\P at N]QlDm!tB^7X(U]G.$?8c@!A(uuj&=.>uR"`D8"/rQ9_IT5):rb9Z:bR4dW,NTODF\R%=CD;$u4N4'G+kr:jQ:'Shj9<=N.s at PO/!*\9'LnMnXNe2aV]^o1*!GYq7^PdT-Fu%n27UfqC,Yl?B1.t<Mukq[!cdr/WMWEK\XpI%!CN+B5JeOC-E+nmfS+kVI+D$r(3[.%0A`T'rJtsa'Cof(*pWXSVJSpu>D,1\A(6K0YCH=dTmcDi(jP_hD>@Qr%!4G6+YM!l5-fCqYF_+bogB(r^'_6H2PQ1-m)F'FeFA+XJ6o\OT$\c3[a^+9?*0*^3`l`(GccK8>%^jK[c\e`f*N0N-/B[l<B1[hn!+ at rS2XH3pL2"Ke%u[FeeYpZ>nME.d5MH-eC==3[KlrpGTp?WLu2g&!%/]O7(.UWs,\i11tHB2c5(jK!L,aUi9Ro?B,i47'.o$m`_'.@=\3o7=?TJ*X/D&rOqr/iFhH-[]8"_ at Oc(3j'6>`#:_=7q1ek\6f<f')+?VGm7;H1tMUqEl<bh-!cnq.u]*hP'a`'K\A$:Q&6gH%,A;!U'^(-pr&2Nc92k](/2EAQL`Kl8!nVN<hS+K`F at B@c;>LqX2/1lN8X!Zf1bQ>II_H8fF*esTn*/!:i%D$2I9_JH.J'[_jR8g<8O3gt/[:%5TihG?_h,g`SL7QfIm;$@PGi1ml[#,!
 :4"%lIEs/UkqF6ElBL6a+\<&H_BHn%s685V&-I2Bm!h12dYWLGl[/&Z0<2ajL2n'%1)!>;TVh74,/4ggsqoS\m,TON$J<3.p>ME>5TZK'_8Sn>[C!!3F2DWU#gi5(FM&QFI8Z)sC%Ul/s`;2e+5+)(bA?e=>@d7qZ+YLfG1d'ei9V9=c/LT4H[65c'Q6oi70:]3_$&?"7N3>dO_$qK,pY\+qO]]VP9hnJ7r%]L8rC%iSQEU#]"cq:4K&et1'NFVB:""nCM2GOb@@DkASEH2$i+(2$V9>fe7)"I(iZq$5C(1eTG,]_B+=:tg5edtjdk*rpEq$.1M:p2iD,N%D0DWOsP^unJTj8S_,WTf<[RaIRi$Yg3l^\*"jX:F,(=5gRq'm^K3UgLOaGhE~>
+endstream
+endobj
+483 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 482 0 R
+>>
+endobj
+484 0 obj
+<< /Length 1217 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GauHK95iQE&AJ$Ckh#ll_P\gMSi/icB$gc?M;([%//X:;e0n3Eb20SA^=8?':!7^;"M4(Wo?G=DiJ`">T:K<8!.kabo5k1gq\]fmra5_'ZcE+R+UdF._<6$gjg-uT:(V8#h?c!>`Eb+ at 1p+nJC\,Br;RKUh=r9\;mE+(6cY?+s>#/Z]mmV)%QK]/pjkX"KY[QfKK$U:9lDuNflcF?d;G<W.4:8e*o=l<\71:*LM+TnP>#spL?M=!mK$ihX,**X2C)#R_>^a8t^-;SdkoXb!!j0l#Ld<sB:eVjb286Jsm\T#u#'M at 9$q at IjX376'pTcPj>"@u>@mOWo,/<RY4-urdbNYC=6UEdTBiMBE<eV%($/q72l$RPpI=CeX_q^<i at LM9h<0+&5JH3,`ap*Wr0EqNMTFiVSEdb(QCDM"e%k2?2LKe:i7'Sp74u$i@>+ZUO+dE\j%u5a(F/^/F`A5a[lY;'ZgglrjWg4iKLo(ZHle+2FBZ*Tu2AKf5=m,D0\#qQ1&\pB%!GTS>O")$CZ`Dd4g_,9FDbq;F,-\oXaAL at emZd#H[rO[MV\aaPqB4;O+<3lLU"$ROFH&pD.9E7d\shm,0R^8E*,aP8.dD?f2\!_S,\pRf%Jb5m%NP.GVslr<]#o)1:$c%;XQa3PMO\pP8 at 6X/p7YeG.)eg>[mtpC'U9_kC"dZ!A("K&[q\Tr]5>`Dj*-g#7:*!*AM(Q+T-BXA2]gDF#W.EopF-RlLu7W!R)^H(iI.`f at mdnCT:.eV at oLE_DThHh=W"q.\._I]2UhV"m*G9-h<ArWB.M^qj`JN"*r0jiPA'$(8>C at N223MinNMp6E>G9nO%us8?t[(f4KMUlrNFK1=Mk*)ij"ZGf0tMcORl4h<G'?`J"Wsa#.V,q5Zc4t$c>Ct2Ild3gS^VfW[#n1H=!TVl*':[D_oiiOHh at 4q]t"ICZ#p7.mgL$cQRuW!MfG,#Cm9RgP$B^C]o+D"2KY1b08FU]ts!
 jOdV,HHnco05e3_i5!+\g[`;6ZUjOI&G"8$YCNOs#m-WVu4gWEF#f=PE1Vg0`Vj1DV@/T[0ppHS9HYf^],o at .]i]p=NLh]3nM7<j1]CpoM+WuR.VKQRWW$r]6Q=ApDd3g$?sF7uApM_\ukY8\IB$"2#mRdN[kp/?&So^rAWi0O+i2hRN97T_1/BA[(r?5h\PV?H^R73ofX>6@',dtZkDo]U:2OF at 3UX:AS~>
+endstream
+endobj
+485 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 484 0 R
+>>
+endobj
+486 0 obj
+<< /Length 1460 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gatm<>>sQ?'RnB3n0<$?CWWku[84t(9\J*9QOql+dci0:6<o,5[@K#+?XHs!Fi3:gp.\&)kG!%p*3Q06nT=DG'M"3/LggocKMmn$=Is#BWd1rkh2\XC+RC3r`u5#93"4_C/.EZ=Bu^iFjS7OgNF6rn>q14I&.sjD6;ijGP"!j_kkDFGl^p%IMtsr![P^:1reREn*Op2Y#frZjhq_&IGP@`,)Yi_=6K?.#ALTm9et<[8`a0CV1f/T[qs!PBramo'J,8j0H$#IrONr"cp>!XZrl=@%T0Lu?cJ?pdgc)nF;AEbi3W-s_J36gqGqB_%//>X`L[uT]`9HU..d_lhXL3bSJussG`B,^ba[&NJbp2b?/uFDFs-EJTacM9,(]MBcgT5Y[h\E7H=/@RZeKt8I"2HC*gU(erFE%RcD<lId<s546)jsOcB#0g&aVUZ<]%T?Np?&8G@?<4P?GB?7Pa\&b`)FGo.](dj2QUN:]]F;-^$Y:`Fie>VQ"ahFr>*qSZeNqd8W3]a3jYebD-?hY>:Xo0&&se[`gA[s3ZL-lLI6*`Cq=>CV+X>fA.R?LZU\:8/M4Hn]Id[kokH#.>3VkcYH9YAp0<iolA7U"B&?i<%W_:`e5?O4OU6KAXc)bt8ZA3:IRI<T-o`E[#WfLRS&F1tLNDc`Z+2a^0rNqj8QqQCTl4&^W6*G5Ps'1H?Wj at tN+&6CMghIdA?.XC/""?=!B"f)FXcJ6'%<YO+Z6:!fuOXr"LNm%Wm1*E#SU\R:jrOW*Wad)(%;cIqL",S!AlZ5p/2\Yhaa%N-%OEB#VuS$di.p8aI"7&%2k?BbF&-RGPg.UAieKN6=3??9+TQqqXAOE&-J:JLBFl%$tgnD!Eg%Sk(=".dH!R%3WuE7'[QG8^2a.VHu&KdY7:DL_4.00H at P0@`FnJkF'4P^4P&7B*2Y?YTo]fVa7F.O8dI2o3Jj%7C_]aD-&;X:s-]/cZ1N?PIbX+3<8/E'b-Bt<;[,!
 N#a"cl$ai_gDqs6CG/lOcR1g;u?R^)5(/?n1hQNR(")@j61I[PG"s0@[;9QU0)%#2\J^Fd@<?n`IuCW0^9Jm8LY;U8`C;@KGJQGKq7A^<Ml.B-saf=:fA'R>>-`3-3#daI)e\S^]B8.OV&J5.8u^^;9GQ"O,^2:;nlTsMb/`UZp6cIuCOgaVrWM.4f^/ptseZ>rES2UECKP'''S#^&k-\g>V4Cr)VIqN,,\fLojEE"U?7S;@\9qhrd)s)'-3N3$Sp%P^%=WUt36[6olR'%"POILK,df>uFn*F]@hD!@KB(:@:9IT<)?.db!$G#bg"bNe=BQ-f at MTuT,l$Q6Y8j;7M@!5Dce*.O at 0X7,Cp;]S6H0I at q0I>U"TG&uAD7*fXTc<Xaq^+Ga?S at 4!5/=VFH@(:J;nS'md4-Q+,r5qb;0F(GSqr7R@)f'q46Q:&20M(ok:ZQJ<^OW]aS6ASc!09Sp)u~>
+endstream
+endobj
+487 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 486 0 R
+>>
+endobj
+488 0 obj
+<< /Length 1151 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gau0ChfG5O&:XAWi2t^)0&1FhZqn)>VTGX_`/q^_:?U+oBb1om,lR1Y+EAtR!_k_i*4Yn5YO?Y$OkVrZ2`7Z]?$!]NXt>!&e&;i5Qt.k*3^J"h\SLS&s+/.*bu5Z2*sUFpc+Oh&=>,q47E6#o/6aTQ\\5PcQqYM$hnKZ.;bPFNqG/DlGlU,M]`O>!\54J`Y*uY at a]&#*_)D."@Hc%HdH1/0/%p3]Nt5*oB)q9AnjANQi*@VS/<o=2p7'BZf..UhJkRmX2KjG.g\g5[\*srs)U6U>35o.oH8iO"$O!^ZrieeA[N[[=;^#f%*3`;C0V$=c%%j(PLUe]Vf,5d584W7G9 at QGLRf7Tj.9dSHmBasB.2q3J_X5TYI!^)!aqE]$1IG?nW\L:>OUS9;V[X&j:?5PS2rX:L=l_s7_Lq+2it:,^EEa+pKbM?%"H[5Vhn,7Jl?IhWnee^rH@!Qcj"V)-I+mJ6#SnrpRM"KD4CC`9*?]L$%&<I)e,;51<,BYLOgH!j<j:HE\fL=23i'.6])%C at 5ZCR9UZ(R%iebW<Rg"m#.gG![p4GUo-#"(b3dT?38h.F+cGc0KRlD+)5,F9*/%hoffa<UM2\K]Hiqk!V_)dmR(rR'#V=/9<H0RnnI.J<aH25O5,Q`Jlkt4/8@?NC^mf\2cSilIE&i&P_UNe?3Z."=`_a>@jFg1-X\)e3Ab!a#Qm&0<f`LjC<PU=/'5ST_OT$CDbJ^j;.E(jfi2?Uk$FbFIeM:"YoYe:e<2DYcr7.sqC(R^lPMo$lFAQT)gB%Mk?[?O.Fo>7jbWmdCGAoC at JLjQdf9u:8M!.h#<UWrQf-pc?^NK7S/c\nQ at 9de#g!DsVt%Ka0H+FRXXeQXY0Y'RAj(mi'\ROlC>MZ:1h6AS]]QJ$^Q95:J?d-M9nnA>EZ;31^OY#^_sCSWG+ at p%63Bn"mT%)Le6K($%&@(S8BATh'W):#ZY]1j6`Q at k"LU5cSm/8T5.]=$%fcT/!
 ;KAIEK7MkWJ),]$rN3'4!tUmS`I>,7mf0VE6TH.&Bqe&'qDrF#dQdt'BZ at JJD<\Msa3Y.d`'GA21M_]ju/A"?ek/bNFu`;nKhq'6tY>k:N:^U,O[%3]DO?cSeA0-pI+Qc>J4?L`#W']6u58CKi25^.=,oG?\`e%l~>
+endstream
+endobj
+489 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 488 0 R
+>>
+endobj
+490 0 obj
+<< /Length 1133 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GauHL8Q4 at t'Y`a3pt!e at 6E;]IVo"O0(qKi:0;[,0M*k/\S(^USrd>N"P(akq[c*r.^\rTLMp:4jG;*D7JcIjl=V!RF4lem(LE(t+QQF'FH-U[!r9>ZG;C"3ca$"(-,)G=/rbs1fbVkpgC`XuJ^A8dB1*nSOFcKquJPaCf3"D3q[g4i_KQlE^o8s1/.Z'BP'4Df04m0:153X)KHiJt,netc""6Ru.%-8oES69d[3ui$naHmEB7S4EVb(E-DdG3]UH=c#>cPH:`i7C\)%EH!g#B&5ao\UbDa"3g9Z,k)ARcAAo"!/r!cUS(3mpL[m_[s*e9d<jJ>B6+BL?3"HbPCB!iQ:W;=H:4Oq&%thj)'1SpSml-/EQ!t+9i+OnC=%C"&NQ\Q+.Ug8r)0FMPrqu[6l\UAjI%tP8Z@(bS[7#B"&rrb9.1U%J[!t_M9H5RjKjk)*ZWG/cELL1n<CAMb*!'2(7%UNnQ"SMeF#H$uKPgU(*c,_7;`?DT(JeJo`N1nm82@>pRZ6HX01+3*HQDmRK>Tol2j=T]@IH<\b1e3%=;tbH(=V7C[9EXr+NNfW')Kfa5)@'BO8fBbtNY*W_(?i2.!AAaDa'2g1o:#Mbu4HGUG>;8rTK'gE-HRWaGFVO9T+Q(pIjp164 at 9%Kc="%R'-Ik-hZOOgu0`);7=_e6<?md*qUMTB.&2$,j4&a08t+iMo1[#6u2G*`kp-B"a'rSV?j,qWdhMS=2QL7C1fIpTnn1iH`sL4\@;MlMVOCK55)7jtO<n2/!,O9:Pf+[#*)J9_C:l_%@u/erRT4R at .I)bcK.aWe=)iY6_JpjSnhZ&rX5NQt$aF-/:;XITPM1;-hC>?T=NL?Zmc+I9[_r!k8[Ab^EoLbZ#1gPH%f<//^G6/C4pO<B_$fP1I`rt_*D5oRGC[F[GWF.S<6gj>"d^0R8#[d61%54EQYh+)LW'R/4.%Z4ia6?0Kj7mp[aot+M+o;\(aks,b%;J<8o`H:!
 EM%Po\QriOq7\RCnEpVlXgm.g59<s at 7L#BdI?>6aAuo\9UV)/#.>2[n;WRVLaRpH.AAH`)a*E1LTMEmk(JO.qqYIeC/5!_T74YQ)H/q8Z<W5>t3`rMP8F0&,Z`jBK0?D^iBs89t%BoW7iN~>
+endstream
+endobj
+491 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 490 0 R
+>>
+endobj
+492 0 obj
+<< /Length 1145 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GauHK>B>un'RnB3i3 at 9Db?h^CPL4Jg7n;%&0?/!FfJH\3/WaN8f=MED4cmnlX%m$1jIG[dqje[br5&2_ARH1>L-HcI`n^V6VYJ%5-M!j?&qh:C?Q*:t*eGqFnq(NMbG"INn?7Ku2B1i!dBgdogJs:&DC1u/YHQ"8^O-k:05OQJS?3_=CBoI$X92<N\8W`pkun5C*A>qB')!^q)ace27p"_0^1*;_r]&1.5R;^#!u)M:'#m&70uj4NYnFAWdDc[%$s&roEQYdG+%uk`*uJH_r*To?.haHoC[<TQ!ZnbM".+2B^ulNjY#'e94q=ma>NV"(1EQ-1kOlgJ`F0'U**eog9L`_7X$#<GGaif&G2RME#jJoppCu+uFk1*uR6!O-e)@>0l)nr;1IUPj).07V:k=0YAphl[T$5!Ro.4/KgI.V,PRZ'a95-bd=799o3VMo)cg3nZ\bDI]+J4:S3Q_b^4etqQaKB=2V7h!&b0EDEX1T7L/.n&[?lkRh5h*?:Xe[#f_T4N-P8Ir[]`!=+(jOD\#L=:qn6t,_ at Fm>S5D[e$K,2CFLK!%uY0/YoCA9*f at ig;3Qc1:$(1"bVoEn<lC2)WVJk_"kaaGtU#iZh';(<u)RjdIrb%JYFXVYOBH'nbNi\J]]+Qoe9<^\B-p*M9.B_jN?p"Jum>8Fer8lcLHZeus:"@-L<E_qL-1>=?&rMlN^KktqTY+VqS0KW]GS7#I>Xpk30$gLp:L%AQJ]p2T]=Xo_fCK9N_1^XaG%'/]f%A6uFA[=_Ts0OU2,D]LWaq[lE]1#:j6pVgkimZjn=:5i'-:G&F5Wn0'LMHoW4F&Lia+Si3[MC"<5?SAIH6BOU1MOMag!:_'V4-WeI^_RB<B23BDfQ>gGnpFRm4^qf?ITPQ*GRmZ*8.jS'/PqRpNar#=*G:rEKK?=dug>XK(EBiolCI%ZHc6lWPt0_4CNP`;Oq9"LT`<,bprMnC(iHt7!j[Zk)2(0fB+'2SD/!
 4jERf*Wa3Y;I[c>#=@\#9/V"2HAg>N)#,B]N5<OL!C^::Ti4>2<>]tTEcPgcg&=QAAK`p3C:H at RpW<O2"M\1Y;3cEQV6Ku<DOn#Suja$u!p6aulSHi<2,dC<41o at a^8nO7C.T9dC1U57@`*`5JC!>bTfPQ~>
+endstream
+endobj
+493 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 492 0 R
+>>
+endobj
+494 0 obj
+<< /Length 902 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat%">u03/'RfGRaBQj+N1Dq8gXD6LlboU,%GSdf-50Xg8<`&#,6%Q-3/R#Z/OR2G*pu2c,M0t!cR*:k#^QaXk[j&do^4*JKCTOu.#fJhV*7/LQYjCmZ`gFKomF<_\GH%"`;:B;'f=[9G^mBmS)am&RZ>6\n:3hf:`8PR9rK34SdJsXg4lX]_,kjqTg#'s%H3B at -Q.RL6n2qX8gD,#^^riiRoTBHEYf at RCNGqC[\GHG>][IsZ4sC9;]!SJ;;@?4n^N7qmFnD\=4`,?*\T%I2Hs2jb0gs0J3)k0.g?ktR!9I)F/Q!%W17uh:">@EJ!,=a<aDjY^*/).AIT(G92\j;_>o at d$qbQVG!s]h;hJ(]nS5.K'=9JoK080n4S*T.i,64#GUGf2GOiV._CX-;[:HAo<KHb^ZkO>0j at QPchCTRrd)4*GaqL]0HErp.B9jc7jZgVhF$V;MLgPt'a4l&(Z1],0I!1qG>pSM.9hYhe[c.)ID_:$`eG/dXUGKhPLlqC;/X at 3Rl`7,%WsJ+ULgpuV;.DW+Wq4,I&:$(YMDWabEGEe"`OloW^:@c+<6uX;*1)p_5<mq4jF\`-.6eY at WnGY=k9I:^#%Jb5Y`fg<);X!"A.+[V_qLL&;!\X4Dh(<X[5enYMK0mH.h0pKD6ppN#V\FXK_j!&KTci[PUk#F5!IaD8TUYGC'*9Ep&Rhk'`TQSa6JLi:M0&g>>72i[jn[SNdjTdmr29!AG`Cn($u?LG4Fr$/\Z)@A=(QYP=-PWhMCm,T)rj<1:LpKpiA&fPhJu&(onCohS!r8LMoXd@?C*r*aSc-A]-:2YF-+"k4)1K4Lc9"7NG=j(o%1*h9/V7!?=YNUjj/or0WrV9=h!jQ8q+t'OWqQA,JXaHQrq!DV<LS0`;(iq^Yn~>
+endstream
+endobj
+495 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 494 0 R
+>>
+endobj
+496 0 obj
+<< /Length 1658 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+GatUthiFNj&BE]"=7E^M[2f1"Ti+m5gUjJ6WN,*_=.KV:'!qe>i9]n)YJ26BGQ<A;X]?AajNlFfcZj'GdsC]T!t-LfPCs,*h'rd*.hY8>7fl9".#='DN4BAJa5F.V?`U;THOTl`f"YKM_F*0X<s!JoLng';%f#YeEML_>L5:@J0E`QT,[?(<dNLi&pDA9N76Bj%T2_@!?%6?k&_;jL"^$-cplll+\gdVYT+K!T-Urg/MTX^G_6S"/Mh8K]jeQLt8>Ir$O\Xn+hsLb!6^dSAZaqiGUG>8%h583(:Ekh(<1SHWG0:J\>\k,V+fCO([YWn\a`)-c]ModB+K%tf0oMthF4W75>,J5:<?".iLh01Yq10s"^e(02!/D4tJTGo%'/Hg\XcE6Hq3b>oVN"hF,@\m(TrYhdi>h[..?"*6KH^(Kq at 9]JMS*lqfjmE(d$VDCp3sn'jSW)E4kFGX"C9:]9;Bn&Ysb`FR/3>6En'k,FZM8ukmYk<1Y&]H77Pje,(+E=4%@9l;s^Q[Wm&M=mls"q$)oRN0h0'6d8&oIQ_bOY6BUo82at+XLY1:cb!)lkV5X(+./VG+1tY"[c;ea)^EUR0jBQhlip"^'d4!39m`LX.V*i]7l'+5Y[R=U\UKY!dMUQE!O[qn+dM7^?`cdHk]2E8DkGD!&()VXlV=pq_ at tJ3,Ea33)c7Ch9/eb0f4%,'6HO\Kq#*R%DLGY0&bkd at Z-XRjV<.lf2f at g<3^pQ!#^UI'e"a7_JCsGN/#iXe^g7a[4'WR28WaSYE;_b[ZS\5f(*tcF8c.CXi,E'.]URS!WV&\aIfhrBE9_S@,OBiW#[gY6A:1gQb"e=IY*["8r/e;'2>V%M]Bfmnooq-X7]i>::#JD,pm7aq01t9O^!td^0 at AHncn4P$))+*@0oam?C$gA!g+GlX[%#+&&kd"0ufk9t)gLGETo(FUK0?YDt-q1b:FSA+3W+K-7&cl>'3%fL_ar,e+7B*0KC[@!
 T5jY9*<+eD at a0)rTl'18%$BJuF71!!W+1IZFes!JK"h8LNH.ICpJcO6_VZU#jU/X$)%D.\m]bib2\Dn_;7$)gbh_/+Us#r$O]%1b+]R85L>l?BE:E;/q+V>a2AZkh'',/*_h)M'MDp;9mqD+_39S+F at mG1n$Z+qg8,+9,9`nWY8`2jL#ir>YC""tiJ<aR'8)0W]>IMaB32qAPhGjZ0[d(HLpm%TiViqK_"Of,5P<T90$@98bX8NHY%$DMK+cIK<Pc<-j?S%,K<(oism>kAR4YN2=I%GB?d>#-]@>)k^sSP^7:ER_e$+J?(4cbY!t:BAI?Z"DQ?m*QXSK0%pDJ8&8ZmGcT9%p$RfKYoT7o=]mB5d<^PA3,*:QE623s?$_C$YdnhL#R/K;:?uSN,3EtpPE<a3CR6kqIqG!<A[E.s;ZeW^UEXh at bhnYq[!4 at V>.jk.Q8:OCclg[^iS$"#L!P^CMdP]-ma=Bf.,g`>0A\f[&nmg^^YU?<XsJ,B7q at 4,RPk>A#;,nMHg8+C>0[io1RNtMk&A&H<?ka.f!F!@pE8LKeQk3_e)gpcm3Io*fNRUQ;>;/KCB!!hlp6]mG<9'b3>MMEmXFg*p$/0mL[e$`00,QGJ3tgp*'Db$fWG-T4fq675`Rj[3J.U3Xo/GB?GEkFgeRhPo_D?a~>
+endstream
+endobj
+497 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 496 0 R
+/Annots 498 0 R
+>>
+endobj
+498 0 obj
+[
+]
+endobj
+499 0 obj
+<< /Length 1710 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gat=m>Ap8r'Z],&.<q at T4"7mOK="E!m7;T=j_\Y<,/Hk''$M2U:?U*pJWSe/0j7SZU=R(hA,jk8J("pteapg,6Ld*s2Z$Jo*EFSGi<r'o_s]S%CW*!m.Ji at 9=bsX>pSC^R2c%hJSFk/ir"T)MD18^n(erZ^=]DMjLpkJgEIq:rPggM'AapJ2Sd*A-W4\<dit:qgi0bA=-rem]ohO_O:V7Z?26IrBCKsL/E='C at 4, at cUjfQ6SP^"@omZ>Rub;r=YjA'g&m8R41FNAq).tm.-H5676')P04?(W&JkIK^Rs(m(aaenLE5q(V/P72.9[QEVtA<M5#1tIb:-$*?]"EZJJ#fgAA(2$l^QqGds-SY^#rno'ibk"=;+hFP!*o;-(n//>`7b7W)hFC at ECM\D3BBtM;UL1soX&Od+?Y?:3BsNaR^'=?]1`_:BS<'GGZ3,YW_=Bi/dNH*DWsQ;sWm%r;BW#2P!\t.:=%YVW&FtR15AHl&V%NVP@"!`b"EstrlP,Oubb'ML!_JXGEV)hE3IDpFE<a at NjqO!@%fVY.Khg9CC*3fCcU>R4<]\+1#iq&$<3d9.(kQ;GTMlM1)'m?m'[Qh0BdB^fAeE)uN at HU?GmMk)W57FQi%QNflj?DZ!2M>h-Wuri).$WCFQcs5$(U6(W5\'oS at 3$@nh(HNaQ++R39IJ3IHeoD9SkBVG/9JSWf*Q6Do91PF<UE/Xab%e=$u`55kbW3KlfVNl][BsXUPOu$FJM;rCa(I+J,_B+%O3lBr2/rldNIahg]t#99Zi2,0#Tbh,0$AYe"4MeJ,3\Wa/!i)I,/aHgWlI=$j1HFck9`+I%-q9iRn+:4USG4;nPJ6:RY7Z>7tI6;I]?P4<O2"0s]Sb9'Ht#%*Xl;`F^9_.3ZX:'eGq]cAV#%:*di9<r#HWlODM8i+FM=,l5/j7FR7h>Yaij$7)1gFM at a:4c4,qL7hd7>lldeCd0)c\J9[0+1Ut;&pBD8Ti8CU,#!
 C%$lr9!<`1PUF-7+ErS2U.e%VZejVt`ES"*CP>M_32ee9p#r at g_ogrO(.a^UT9U+O-;"Ye2Kn-/6,#&X7?OX@%nDp'%3=mt:m0#&We\H,klL>,eIO[@9f.Uh*Rk#N?I('XskN7!U<R'A#qh2XrU2:Z1t-g&`q_bp/i4>it/<Aq0SL4%qQ]\aZ215 at 6SG';543cVb9L<l!FbemXC,df_faC8(1?l6jl(7G"2Fe at ATE@L4ema9Z\JCp*Lkos(+.?Q0dTtCJoZ9?+:(Z6aMnZA%em[7E[KG,<3?TZJ+afnF\p8iq\9f"RQaQEA03kup)PM6RdKP>8?p>);8.knf-6V:JPTl)n+:-jJ0#?O7IDOCl5*cjEY/LSh<Gkj=?`9"^LQt'&b at rTrLjqk1^Qobp"Y1a7Sk%IG+s6]2qQg5t\oCiie3'nR3f)AqC_?Ygp,I;Ou%V^-'%$SkHekR3Y=l"!+7#oRNP]neMj9m"hG#[U/=_?ebRA2FUcniGY5cLN\:+k`ai4p?C%X5aBb`S-jME*S77!3C$.e54D($XW5rk at BCS)M>W>/1eA<0u(lR)=MDfMU/n(@P]XdnK^*Z)Oeg]rKBS>A at cMl6J%&HMphg2>%(g`50NK2i0=0Zo\Z13J[&]X3\[J$a+FF+_;=k+";StiKFo%IeEU'_e-JqJ:@V2%jS"HVr*+kr8N\@.O,JAOVeOfF%s\W=Y^0W%m<asIK~>
+endstream
+endobj
+500 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 499 0 R
+/Annots 501 0 R
+>>
+endobj
+501 0 obj
+[
+]
+endobj
+502 0 obj
+<< /Length 1690 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gasb]95iiK&BF8='KYX`XWtPJn[^t%BQ"(0p.uG,,?)$/ZDc:uhXo9`H6a\)PUQ_ at o$D<0SG at 4c,C_]oT"_K9`Q'r!jbGh,*)I?=0,/DBrl,O6+s*:mdGLSMn,HGRSs?nS)th\Ck\&*Dlk;m]UOT#eDh*cY+PTe<(7$]tQA?AcSU<'-mLh,pGAWR,>9Ms40M);t\#MI3:>.n:(M2AjJ*bf09cQWH7K+XW;Z4[9h%dM9/JEuu/Rc'orVWeHcWZYN-t4ickmGX-/aZOGIrl9*O[[g"Me^+FN)siM2+;WoU.dNbd^?*,q.-HLTN]rj5`$:K"@,#7U0`^;_Q!G+)J1CQ%*4rGBoF=!bD]C]GW&[hV(mTZ9`'QK6m9(cq?@iOLfSrgm*qL4.PTqB at T4,o-qt:!)g*TgeDBnQM=Pn&5jOsqVG'7"-1[$9e!5rJ$<3&kX9mq*O]3RoB2ts,_.oHa@@R>mU39 at h!NOsC`K$=?ik2uu;W1!"+>-hIg"Mh_C657D`GYNP"j\UUaJDQc?<,b%lm9k&0k<ug)ssHK^I9VQjBD?XD3>U+rCqtd at Ri@"KAP$K:]_3])3$lT7VuQnAcU+Kfs^ji/cKfllO>B\'[lhY(Stldn6T[K/tKo>YOje#.l4f\.-;A^BD(%eY$/RCF+b46 at S:j+SI,R=pns$fCmfS?N/7OZXrCAGWk-pcitT at i;QmAT5f?QM`":F#@A5?S9_ENfjY9_=-+i/:bseCj\$0\1J>0)U,B%FB<R,=@hHgYf:is+Ek[!%H=YOlP6`&%-$cn$KCF)TGe9j2PipH:JK2Mg-N.8#FWiUQJblN%V0<[POFp0c<b+d%d>nVhb1a;"\X)C^bGCI5Z[hq3<17c.nmjk`]dF>17p?s\H0!r at F+\%Q+Ge2'7U\i*dRmD7A\h!U)W;P%_RlE)ah4(-;47:`=[O3J%g!resSQ"/=Qp!YOXN21:]hm?^0U0Fj`h'$Hpqk(qnD]I(Gu<!
 8T*F6X),-5LXFQNh6MSfSL;c6b/C53=84BdeF>EC]Yq51,#basYP>n4a/!EhdP8&&8m2&CDHYNoJsXKcFjgbjacF4%\bZKm*iB[Nt1Z^%Gl`)Nla*St)7>K"Xn%#g5aUWMT]j7252#?X5BNe5T<O*0$c3@`J=Z-:^=-Qm at ZR@09mN2saR&5o)N`(*20K1hTL\\7nV`2EbQeW)4Yi\9aP7g*$>p5!\*(Ieep&_)\)dteX?o(e<)/RQt>STA-\GV)[FLk*@HM]#\5rc-1.[:D$$@[;'kpC+6NFr91cbK)(;@)QEC8Wq`L0?Su^<7X"1CBaU18XLg*l+NO8ajea:-Co.K_?OjHLa=>lf\s43m1'U2e?jcM>>=.3]E=&OLD!ihBUUd]%%=j_iie$&V[fQlO"2B*j2Pm^Z,C.jDTUe[%EgE8/=f)\Y9M2,'fBo*R1,BpjHgLV[ZjIDBnp6:4/":$o7bTS;Nfr`e)9VDLKac=alFP[gAqV0jEuEhDo_#$h:mS+DYlr$Y=p[=%/q.<T>X7>kJr!F<>,"=g*"kt9IB`GHc4u93*deJf8X%'$-q5/?\HLJGDmBgHbba-G<[,W*NkMYNU@%Us7Dcj(Ttd`rGjrH+$U+#500D\aNWJ/R\*:mU..TIiV16Vdh6(TNsT:Xaee\+[5t?1?@+">jInSCU+s=O4jr#L8/=Sm"1<a^Yl~>
+endstream
+endobj
+503 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 502 0 R
+/Annots 504 0 R
+>>
+endobj
+504 0 obj
+[
+]
+endobj
+505 0 obj
+<< /Length 242 /Filter [ /ASCII85Decode /FlateDecode ]
+ >>
+stream
+Gas2C4UV<G%#4NUMMql\Rl:5Toftf%To4_Z?r%=*5WqsD]i at jd+He#r%o;b^6&[,p8>:c6#mjg%+B&k3Q"H$jP(R_(Aacq*pTY5rAKGs^gofCVLeTtP1Z*s&KNW>1+@^f>h`f#9Yhl'OoF`c?FT14a\oisclf_OnpRD3GM)sZVLuU;8.g-M(@-^`E;g4*qM7G$%riKS8A.n,kEMq&.?@Vf&U].=CP1%WhjN^c8/@kog#Z*\~>
+endstream
+endobj
+506 0 obj
+<< /Type /Page
+/Parent 1 0 R
+/MediaBox [ 0 0 612 792 ]
+/Resources 3 0 R
+/Contents 505 0 R
+/Annots 507 0 R
+>>
+endobj
+507 0 obj
+[
+]
+endobj
+510 0 obj
+<<
+ /Title (\376\377\0\123\0\161\0\165\0\151\0\162\0\162\0\145\0\154\0\40\0\62\0\56\0\62\0\40\0\122\0\145\0\146\0\145\0\162\0\145\0\156\0\143\0\145\0\40\0\115\0\141\0\156\0\165\0\141\0\154)
+ /Parent 508 0 R
+ /Next 512 0 R
+ /A 509 0 R
+>> endobj
+512 0 obj
+<<
+ /Title (\376\377\0\124\0\141\0\142\0\154\0\145\0\40\0\157\0\146\0\40\0\103\0\157\0\156\0\164\0\145\0\156\0\164\0\163)
+ /Parent 508 0 R
+ /Prev 510 0 R
+ /Next 513 0 R
+ /A 511 0 R
+>> endobj
+513 0 obj
+<<
+ /Title (\376\377\0\103\0\150\0\141\0\160\0\164\0\145\0\162\0\240\0\61\0\56\0\240\0\111\0\156\0\164\0\162\0\157\0\144\0\165\0\143\0\164\0\151\0\157\0\156)
+ /Parent 508 0 R
+ /Prev 512 0 R
+ /Next 514 0 R
+ /A 15 0 R
+>> endobj
+514 0 obj
+<<
+ /Title (\376\377\0\103\0\150\0\141\0\160\0\164\0\145\0\162\0\240\0\62\0\56\0\240\0\124\0\150\0\145\0\40\0\154\0\141\0\156\0\147\0\165\0\141\0\147\0\145)
+ /Parent 508 0 R
+ /First 515 0 R
+ /Last 650 0 R
+ /Prev 513 0 R
+ /Next 677 0 R
+ /Count -128
+ /A 17 0 R
+>> endobj
+515 0 obj
+<<
+ /Title (\376\377\0\114\0\145\0\170\0\151\0\143\0\141\0\154\0\40\0\163\0\164\0\162\0\165\0\143\0\164\0\165\0\162\0\145)
+ /Parent 514 0 R
+ /First 516 0 R
+ /Last 521 0 R
+ /Next 522 0 R
+ /Count -6
+ /A 19 0 R
+>> endobj
+516 0 obj
+<<
+ /Title (\376\377\0\111\0\144\0\145\0\156\0\164\0\151\0\146\0\151\0\145\0\162\0\163)
+ /Parent 515 0 R
+ /Next 517 0 R
+ /A 21 0 R
+>> endobj
+517 0 obj
+<<
+ /Title (\376\377\0\113\0\145\0\171\0\167\0\157\0\162\0\144\0\163)
+ /Parent 515 0 R
+ /Prev 516 0 R
+ /Next 518 0 R
+ /A 23 0 R
+>> endobj
+518 0 obj
+<<
+ /Title (\376\377\0\117\0\160\0\145\0\162\0\141\0\164\0\157\0\162\0\163)
+ /Parent 515 0 R
+ /Prev 517 0 R
+ /Next 519 0 R
+ /A 25 0 R
+>> endobj
+519 0 obj
+<<
+ /Title (\376\377\0\117\0\164\0\150\0\145\0\162\0\40\0\164\0\157\0\153\0\145\0\156\0\163)
+ /Parent 515 0 R
+ /Prev 518 0 R
+ /Next 520 0 R
+ /A 27 0 R
+>> endobj
+520 0 obj
+<<
+ /Title (\376\377\0\114\0\151\0\164\0\145\0\162\0\141\0\154\0\163)
+ /Parent 515 0 R
+ /Prev 519 0 R
+ /Next 521 0 R
+ /A 29 0 R
+>> endobj
+521 0 obj
+<<
+ /Title (\376\377\0\103\0\157\0\155\0\155\0\145\0\156\0\164\0\163)
+ /Parent 515 0 R
+ /Prev 520 0 R
+ /A 31 0 R
+>> endobj
+522 0 obj
+<<
+ /Title (\376\377\0\126\0\141\0\154\0\165\0\145\0\163\0\40\0\141\0\156\0\144\0\40\0\104\0\141\0\164\0\141\0\40\0\164\0\171\0\160\0\145\0\163)
+ /Parent 514 0 R
+ /First 523 0 R
+ /Last 536 0 R
+ /Prev 515 0 R
+ /Next 537 0 R
+ /Count -14
+ /A 33 0 R
+>> endobj
+523 0 obj
+<<
+ /Title (\376\377\0\111\0\156\0\164\0\145\0\147\0\145\0\162)
+ /Parent 522 0 R
+ /Next 524 0 R
+ /A 35 0 R
+>> endobj
+524 0 obj
+<<
+ /Title (\376\377\0\106\0\154\0\157\0\141\0\164)
+ /Parent 522 0 R
+ /Prev 523 0 R
+ /Next 525 0 R
+ /A 37 0 R
+>> endobj
+525 0 obj
+<<
+ /Title (\376\377\0\123\0\164\0\162\0\151\0\156\0\147)
+ /Parent 522 0 R
+ /Prev 524 0 R
+ /Next 526 0 R
+ /A 39 0 R
+>> endobj
+526 0 obj
+<<
+ /Title (\376\377\0\116\0\165\0\154\0\154)
+ /Parent 522 0 R
+ /Prev 525 0 R
+ /Next 527 0 R
+ /A 41 0 R
+>> endobj
+527 0 obj
+<<
+ /Title (\376\377\0\102\0\157\0\157\0\154)
+ /Parent 522 0 R
+ /Prev 526 0 R
+ /Next 528 0 R
+ /A 43 0 R
+>> endobj
+528 0 obj
+<<
+ /Title (\376\377\0\124\0\141\0\142\0\154\0\145)
+ /Parent 522 0 R
+ /Prev 527 0 R
+ /Next 529 0 R
+ /A 45 0 R
+>> endobj
+529 0 obj
+<<
+ /Title (\376\377\0\101\0\162\0\162\0\141\0\171)
+ /Parent 522 0 R
+ /Prev 528 0 R
+ /Next 530 0 R
+ /A 47 0 R
+>> endobj
+530 0 obj
+<<
+ /Title (\376\377\0\106\0\165\0\156\0\143\0\164\0\151\0\157\0\156)
+ /Parent 522 0 R
+ /Prev 529 0 R
+ /Next 531 0 R
+ /A 49 0 R
+>> endobj
+531 0 obj
+<<
+ /Title (\376\377\0\103\0\154\0\141\0\163\0\163)
+ /Parent 522 0 R
+ /Prev 530 0 R
+ /Next 532 0 R
+ /A 51 0 R
+>> endobj
+532 0 obj
+<<
+ /Title (\376\377\0\103\0\154\0\141\0\163\0\163\0\40\0\151\0\156\0\163\0\164\0\141\0\156\0\143\0\145)
+ /Parent 522 0 R
+ /Prev 531 0 R
+ /Next 533 0 R
+ /A 53 0 R
+>> endobj
+533 0 obj
+<<
+ /Title (\376\377\0\107\0\145\0\156\0\145\0\162\0\141\0\164\0\157\0\162)
+ /Parent 522 0 R
+ /Prev 532 0 R
+ /Next 534 0 R
+ /A 55 0 R
+>> endobj
+534 0 obj
+<<
+ /Title (\376\377\0\125\0\163\0\145\0\162\0\144\0\141\0\164\0\141)
+ /Parent 522 0 R
+ /Prev 533 0 R
+ /Next 535 0 R
+ /A 57 0 R
+>> endobj
+535 0 obj
+<<
+ /Title (\376\377\0\124\0\150\0\162\0\145\0\141\0\144)
+ /Parent 522 0 R
+ /Prev 534 0 R
+ /Next 536 0 R
+ /A 59 0 R
+>> endobj
+536 0 obj
+<<
+ /Title (\376\377\0\127\0\145\0\141\0\153\0\40\0\122\0\145\0\146\0\145\0\162\0\145\0\156\0\143\0\145\0\163)
+ /Parent 522 0 R
+ /Prev 535 0 R
+ /A 61 0 R
+>> endobj
+537 0 obj
+<<
+ /Title (\376\377\0\105\0\170\0\145\0\143\0\165\0\164\0\151\0\157\0\156\0\40\0\103\0\157\0\156\0\164\0\145\0\170\0\164)
+ /Parent 514 0 R
+ /First 538 0 R
+ /Last 538 0 R
+ /Prev 522 0 R
+ /Next 539 0 R
+ /Count -1
+ /A 63 0 R
+>> endobj
+538 0 obj
+<<
+ /Title (\376\377\0\126\0\141\0\162\0\151\0\141\0\142\0\154\0\145\0\163)
+ /Parent 537 0 R
+ /A 65 0 R
+>> endobj
+539 0 obj
+<<
+ /Title (\376\377\0\123\0\164\0\141\0\164\0\145\0\155\0\145\0\156\0\164\0\163)
+ /Parent 514 0 R
+ /First 540 0 R
+ /Last 568 0 R
+ /Prev 537 0 R
+ /Next 569 0 R
+ /Count -22
+ /A 67 0 R
+>> endobj
+540 0 obj
+<<
+ /Title (\376\377\0\102\0\154\0\157\0\143\0\153)
+ /Parent 539 0 R
+ /Next 541 0 R
+ /A 69 0 R
+>> endobj
+541 0 obj
+<<
+ /Title (\376\377\0\103\0\157\0\156\0\164\0\162\0\157\0\154\0\40\0\106\0\154\0\157\0\167\0\40\0\123\0\164\0\141\0\164\0\145\0\155\0\145\0\156\0\164\0\163)
+ /Parent 539 0 R
+ /First 543 0 R
+ /Last 551 0 R
+ /Prev 540 0 R
+ /Next 552 0 R
+ /Count -5
+ /A 71 0 R
+>> endobj
+543 0 obj
+<<
+ /Title (\376\377\0\164\0\162\0\165\0\145\0\40\0\141\0\156\0\144\0\40\0\146\0\141\0\154\0\163\0\145)
+ /Parent 541 0 R
+ /Next 545 0 R
+ /A 542 0 R
+>> endobj
+545 0 obj
+<<
+ /Title (\376\377\0\151\0\146\0\57\0\145\0\154\0\163\0\145)
+ /Parent 541 0 R
+ /Prev 543 0 R
+ /Next 547 0 R
+ /A 544 0 R
+>> endobj
+547 0 obj
+<<
+ /Title (\376\377\0\167\0\150\0\151\0\154\0\145)
+ /Parent 541 0 R
+ /Prev 545 0 R
+ /Next 549 0 R
+ /A 546 0 R
+>> endobj
+549 0 obj
+<<
+ /Title (\376\377\0\144\0\157\0\57\0\167\0\150\0\151\0\154\0\145)
+ /Parent 541 0 R
+ /Prev 547 0 R
+ /Next 551 0 R
+ /A 548 0 R
+>> endobj
+551 0 obj
+<<
+ /Title (\376\377\0\163\0\167\0\151\0\164\0\143\0\150)
+ /Parent 541 0 R
+ /Prev 549 0 R
+ /A 550 0 R
+>> endobj
+552 0 obj
+<<
+ /Title (\376\377\0\114\0\157\0\157\0\160\0\163)
+ /Parent 539 0 R
+ /First 554 0 R
+ /Last 556 0 R
+ /Prev 541 0 R
+ /Next 557 0 R
+ /Count -2
+ /A 73 0 R
+>> endobj
+554 0 obj
+<<
+ /Title (\376\377\0\146\0\157\0\162)
+ /Parent 552 0 R
+ /Next 556 0 R
+ /A 553 0 R
+>> endobj
+556 0 obj
+<<
+ /Title (\376\377\0\146\0\157\0\162\0\145\0\141\0\143\0\150)
+ /Parent 552 0 R
+ /Prev 554 0 R
+ /A 555 0 R
+>> endobj
+557 0 obj
+<<
+ /Title (\376\377\0\142\0\162\0\145\0\141\0\153)
+ /Parent 539 0 R
+ /Prev 552 0 R
+ /Next 558 0 R
+ /A 75 0 R
+>> endobj
+558 0 obj
+<<
+ /Title (\376\377\0\143\0\157\0\156\0\164\0\151\0\156\0\165\0\145)
+ /Parent 539 0 R
+ /Prev 557 0 R
+ /Next 559 0 R
+ /A 77 0 R
+>> endobj
+559 0 obj
+<<
+ /Title (\376\377\0\162\0\145\0\164\0\165\0\162\0\156)
+ /Parent 539 0 R
+ /Prev 558 0 R
+ /Next 560 0 R
+ /A 79 0 R
+>> endobj
+560 0 obj
+<<
+ /Title (\376\377\0\171\0\151\0\145\0\154\0\144)
+ /Parent 539 0 R
+ /Prev 559 0 R
+ /Next 561 0 R
+ /A 81 0 R
+>> endobj
+561 0 obj
+<<
+ /Title (\376\377\0\114\0\157\0\143\0\141\0\154\0\40\0\166\0\141\0\162\0\151\0\141\0\142\0\154\0\145\0\163\0\40\0\144\0\145\0\143\0\154\0\141\0\162\0\141\0\164\0\151\0\157\0\156)
+ /Parent 539 0 R
+ /Prev 560 0 R
+ /Next 562 0 R
+ /A 83 0 R
+>> endobj
+562 0 obj
+<<
+ /Title (\376\377\0\106\0\165\0\156\0\143\0\164\0\151\0\157\0\156\0\40\0\144\0\145\0\143\0\154\0\141\0\162\0\141\0\164\0\151\0\157\0\156)
+ /Parent 539 0 R
+ /Prev 561 0 R
+ /Next 563 0 R
+ /A 85 0 R
+>> endobj
+563 0 obj
+<<
+ /Title (\376\377\0\103\0\154\0\141\0\163\0\163\0\40\0\144\0\145\0\143\0\154\0\141\0\162\0\141\0\164\0\151\0\157\0\156)
+ /Parent 539 0 R
+ /Prev 562 0 R
+ /Next 564 0 R
+ /A 87 0 R
+>> endobj
+564 0 obj
+<<
+ /Title (\376\377\0\164\0\162\0\171\0\57\0\143\0\141\0\164\0\143\0\150)
+ /Parent 539 0 R
+ /Prev 563 0 R
+ /Next 565 0 R
+ /A 89 0 R
+>> endobj
+565 0 obj
+<<
+ /Title (\376\377\0\164\0\150\0\162\0\157\0\167)
+ /Parent 539 0 R
+ /Prev 564 0 R
+ /Next 566 0 R
+ /A 91 0 R
+>> endobj
+566 0 obj
+<<
+ /Title (\376\377\0\143\0\157\0\156\0\163\0\164)
+ /Parent 539 0 R
+ /Prev 565 0 R
+ /Next 567 0 R
+ /A 93 0 R
+>> endobj
+567 0 obj
+<<
+ /Title (\376\377\0\145\0\156\0\165\0\155)
+ /Parent 539 0 R
+ /Prev 566 0 R
+ /Next 568 0 R
+ /A 95 0 R
+>> endobj
+568 0 obj
+<<
+ /Title (\376\377\0\145\0\170\0\160\0\162\0\145\0\163\0\163\0\151\0\157\0\156\0\40\0\163\0\164\0\141\0\164\0\145\0\155\0\145\0\156\0\164)
+ /Parent 539 0 R
+ /Prev 567 0 R
+ /A 97 0 R
+>> endobj
+569 0 obj
+<<
+ /Title (\376\377\0\105\0\170\0\160\0\162\0\145\0\163\0\163\0\151\0\157\0\156\0\163)
+ /Parent 514 0 R
+ /First 570 0 R
+ /Last 595 0 R
+ /Prev 539 0 R
+ /Next 596 0 R
+ /Count -16
+ /A 99 0 R
+>> endobj
+570 0 obj
+<<
+ /Title (\376\377\0\101\0\163\0\163\0\151\0\147\0\156\0\155\0\145\0\156\0\164\0\50\0\75\0\51\0\40\0\46\0\40\0\156\0\145\0\167\0\40\0\163\0\154\0\157\0\164\0\50\0\74\0\55\0\51)
+ /Parent 569 0 R
+ /Next 571 0 R
+ /A 101 0 R
+>> endobj
+571 0 obj
+<<
+ /Title (\376\377\0\117\0\160\0\145\0\162\0\141\0\164\0\157\0\162\0\163)
+ /Parent 569 0 R
+ /First 573 0 R
+ /Last 591 0 R
+ /Prev 570 0 R
+ /Next 592 0 R
+ /Count -10
+ /A 103 0 R
+>> endobj
+573 0 obj
+<<
+ /Title (\376\377\0\77\0\72\0\40\0\117\0\160\0\145\0\162\0\141\0\164\0\157\0\162)
+ /Parent 571 0 R
+ /Next 575 0 R
+ /A 572 0 R
+>> endobj
+575 0 obj
+<<
+ /Title (\376\377\0\101\0\162\0\151\0\164\0\150\0\155\0\145\0\164\0\151\0\143)
+ /Parent 571 0 R
+ /Prev 573 0 R
+ /Next 577 0 R
+ /A 574 0 R
+>> endobj
+577 0 obj
+<<
+ /Title (\376\377\0\122\0\145\0\154\0\141\0\164\0\151\0\157\0\156\0\141\0\154)
+ /Parent 571 0 R
+ /Prev 575 0 R
+ /Next 579 0 R
+ /A 576 0 R
+>> endobj
+579 0 obj
+<<
+ /Title (\376\377\0\114\0\157\0\147\0\151\0\143\0\141\0\154)
+ /Parent 571 0 R
+ /Prev 577 0 R
+ /Next 581 0 R
+ /A 578 0 R
+>> endobj
+581 0 obj
+<<
+ /Title (\376\377\0\151\0\156\0\40\0\157\0\160\0\145\0\162\0\141\0\164\0\157\0\162)
+ /Parent 571 0 R
+ /Prev 579 0 R
+ /Next 583 0 R
+ /A 580 0 R
+>> endobj
+583 0 obj
+<<
+ /Title (\376\377\0\151\0\156\0\163\0\164\0\141\0\156\0\143\0\145\0\157\0\146\0\40\0\157\0\160\0\145\0\162\0\141\0\164\0\157\0\162)
+ /Parent 571 0 R
+ /Prev 581 0 R
+ /Next 585 0 R
+ /A 582 0 R
+>> endobj
+585 0 obj
+<<
+ /Title (\376\377\0\164\0\171\0\160\0\145\0\157\0\146\0\40\0\157\0\160\0\145\0\162\0\141\0\164\0\157\0\162)
+ /Parent 571 0 R
+ /Prev 583 0 R
+ /Next 587 0 R
+ /A 584 0 R
+>> endobj
+587 0 obj
+<<
+ /Title (\376\377\0\143\0\157\0\155\0\155\0\141\0\40\0\157\0\160\0\145\0\162\0\141\0\164\0\157\0\162)
+ /Parent 571 0 R
+ /Prev 585 0 R
+ /Next 589 0 R
+ /A 586 0 R
+>> endobj
+589 0 obj
+<<
+ /Title (\376\377\0\102\0\151\0\164\0\167\0\151\0\163\0\145\0\40\0\117\0\160\0\145\0\162\0\141\0\164\0\157\0\162\0\163)
+ /Parent 571 0 R
+ /Prev 587 0 R
+ /Next 591 0 R
+ /A 588 0 R
+>> endobj
+591 0 obj
+<<
+ /Title (\376\377\0\117\0\160\0\145\0\162\0\141\0\164\0\157\0\162\0\163\0\40\0\160\0\162\0\145\0\143\0\145\0\144\0\145\0\156\0\143\0\145)
+ /Parent 571 0 R
+ /Prev 589 0 R
+ /A 590 0 R
+>> endobj
+592 0 obj
+<<
+ /Title (\376\377\0\124\0\141\0\142\0\154\0\145\0\40\0\143\0\157\0\156\0\163\0\164\0\162\0\165\0\143\0\164\0\157\0\162)
+ /Parent 569 0 R
+ /Prev 571 0 R
+ /Next 593 0 R
+ /A 105 0 R
+>> endobj
+593 0 obj
+<<
+ /Title (\376\377\0\144\0\145\0\154\0\145\0\147\0\141\0\164\0\145)
+ /Parent 569 0 R
+ /Prev 592 0 R
+ /Next 594 0 R
+ /A 107 0 R
+>> endobj
+594 0 obj
+<<
+ /Title (\376\377\0\143\0\154\0\157\0\156\0\145)
+ /Parent 569 0 R
+ /Prev 593 0 R
+ /Next 595 0 R
+ /A 109 0 R
+>> endobj
+595 0 obj
+<<
+ /Title (\376\377\0\101\0\162\0\162\0\141\0\171\0\40\0\143\0\157\0\156\0\163\0\164\0\162\0\165\0\143\0\164\0\157\0\162)
+ /Parent 569 0 R
+ /Prev 594 0 R
+ /A 111 0 R
+>> endobj
+596 0 obj
+<<
+ /Title (\376\377\0\124\0\141\0\142\0\154\0\145\0\163)
+ /Parent 514 0 R
+ /First 597 0 R
+ /Last 599 0 R
+ /Prev 569 0 R
+ /Next 600 0 R
+ /Count -3
+ /A 113 0 R
+>> endobj
+597 0 obj
+<<
+ /Title (\376\377\0\103\0\157\0\156\0\163\0\164\0\162\0\165\0\143\0\164\0\151\0\157\0\156)
+ /Parent 596 0 R
+ /Next 598 0 R
+ /A 115 0 R
+>> endobj
+598 0 obj
+<<
+ /Title (\376\377\0\123\0\154\0\157\0\164\0\40\0\143\0\162\0\145\0\141\0\164\0\151\0\157\0\156)
+ /Parent 596 0 R
+ /Prev 597 0 R
+ /Next 599 0 R
+ /A 117 0 R
+>> endobj
+599 0 obj
+<<
+ /Title (\376\377\0\123\0\154\0\157\0\164\0\40\0\144\0\145\0\154\0\145\0\164\0\151\0\157\0\156)
+ /Parent 596 0 R
+ /Prev 598 0 R
+ /A 119 0 R
+>> endobj
+600 0 obj
+<<
+ /Title (\376\377\0\101\0\162\0\162\0\141\0\171\0\163)
+ /Parent 514 0 R
+ /Prev 596 0 R
+ /Next 601 0 R
+ /A 124 0 R
+>> endobj
+601 0 obj
+<<
+ /Title (\376\377\0\106\0\165\0\156\0\143\0\164\0\151\0\157\0\156\0\163)
+ /Parent 514 0 R
+ /First 602 0 R
+ /Last 610 0 R
+ /Prev 600 0 R
+ /Next 611 0 R
+ /Count -7
+ /A 126 0 R
+>> endobj
+602 0 obj
+<<
+ /Title (\376\377\0\106\0\165\0\156\0\143\0\164\0\151\0\157\0\156\0\40\0\144\0\145\0\143\0\154\0\141\0\162\0\141\0\164\0\151\0\157\0\156)
+ /Parent 601 0 R
+ /First 604 0 R
+ /Last 606 0 R
+ /Next 607 0 R
+ /Count -2
+ /A 128 0 R
+>> endobj
+604 0 obj
+<<
+ /Title (\376\377\0\104\0\145\0\146\0\141\0\165\0\154\0\164\0\40\0\120\0\141\0\162\0\141\0\155\0\141\0\164\0\145\0\162\0\163)
+ /Parent 602 0 R
+ /Next 606 0 R
+ /A 603 0 R
+>> endobj
+606 0 obj
+<<
+ /Title (\376\377\0\106\0\165\0\156\0\143\0\164\0\151\0\157\0\156\0\40\0\167\0\151\0\164\0\150\0\40\0\166\0\141\0\162\0\151\0\141\0\142\0\154\0\145\0\40\0\156\0\165\0\155\0\142\0\145\0\162\0\40\0\157\0\146\0\40\0\160\0\141\0\162\0\141\0\155\0\141\0\164\0\145\0\162\0\163)
+ /Parent 602 0 R
+ /Prev 604 0 R
+ /A 605 0 R
+>> endobj
+607 0 obj
+<<
+ /Title (\376\377\0\106\0\165\0\156\0\143\0\164\0\151\0\157\0\156\0\40\0\143\0\141\0\154\0\154\0\163)
+ /Parent 601 0 R
+ /Prev 602 0 R
+ /Next 608 0 R
+ /A 130 0 R
+>> endobj
+608 0 obj
+<<
+ /Title (\376\377\0\102\0\151\0\156\0\144\0\151\0\156\0\147\0\40\0\141\0\156\0\40\0\145\0\156\0\166\0\151\0\162\0\157\0\156\0\155\0\145\0\156\0\164\0\40\0\164\0\157\0\40\0\141\0\40\0\146\0\165\0\156\0\143\0\164\0\151\0\157\0\156)
+ /Parent 601 0 R
+ /Prev 607 0 R
+ /Next 609 0 R
+ /A 132 0 R
+>> endobj
+609 0 obj
+<<
+ /Title (\376\377\0\106\0\162\0\145\0\145\0\40\0\166\0\141\0\162\0\151\0\141\0\142\0\154\0\145\0\163)
+ /Parent 601 0 R
+ /Prev 608 0 R
+ /Next 610 0 R
+ /A 134 0 R
+>> endobj
+610 0 obj
+<<
+ /Title (\376\377\0\124\0\141\0\151\0\154\0\40\0\162\0\145\0\143\0\165\0\162\0\163\0\151\0\157\0\156)
+ /Parent 601 0 R
+ /Prev 609 0 R
+ /A 136 0 R
+>> endobj
+611 0 obj
+<<
+ /Title (\376\377\0\103\0\154\0\141\0\163\0\163\0\145\0\163)
+ /Parent 514 0 R
+ /First 612 0 R
+ /Last 619 0 R
+ /Prev 601 0 R
+ /Next 620 0 R
+ /Count -6
+ /A 138 0 R
+>> endobj
+612 0 obj
+<<
+ /Title (\376\377\0\103\0\154\0\141\0\163\0\163\0\40\0\144\0\145\0\143\0\154\0\141\0\162\0\141\0\164\0\151\0\157\0\156)
+ /Parent 611 0 R
+ /First 614 0 R
+ /Last 616 0 R
+ /Next 617 0 R
+ /Count -2
+ /A 140 0 R
+>> endobj
+614 0 obj
+<<
+ /Title (\376\377\0\123\0\164\0\141\0\164\0\151\0\143\0\40\0\166\0\141\0\162\0\151\0\141\0\142\0\154\0\145\0\163)
+ /Parent 612 0 R
+ /Next 616 0 R
+ /A 613 0 R
+>> endobj
+616 0 obj
+<<
+ /Title (\376\377\0\103\0\154\0\141\0\163\0\163\0\40\0\141\0\164\0\164\0\162\0\151\0\142\0\165\0\164\0\145\0\163)
+ /Parent 612 0 R
+ /Prev 614 0 R
+ /A 615 0 R
+>> endobj
+617 0 obj
+<<
+ /Title (\376\377\0\103\0\154\0\141\0\163\0\163\0\40\0\151\0\156\0\163\0\164\0\141\0\156\0\143\0\145\0\163)
+ /Parent 611 0 R
+ /Prev 612 0 R
+ /Next 618 0 R
+ /A 142 0 R
+>> endobj
+618 0 obj
+<<
+ /Title (\376\377\0\111\0\156\0\150\0\145\0\162\0\151\0\164\0\141\0\156\0\143\0\145)
+ /Parent 611 0 R
+ /Prev 617 0 R
+ /Next 619 0 R
+ /A 144 0 R
+>> endobj
+619 0 obj
+<<
+ /Title (\376\377\0\115\0\145\0\164\0\141\0\155\0\145\0\164\0\150\0\157\0\144\0\163)
+ /Parent 611 0 R
+ /Prev 618 0 R
+ /A 146 0 R
+>> endobj
+620 0 obj
+<<
+ /Title (\376\377\0\107\0\145\0\156\0\145\0\162\0\141\0\164\0\157\0\162\0\163)
+ /Parent 514 0 R
+ /Prev 611 0 R
+ /Next 621 0 R
+ /A 148 0 R
+>> endobj
+621 0 obj
+<<
+ /Title (\376\377\0\103\0\157\0\156\0\163\0\164\0\141\0\156\0\164\0\163\0\40\0\46\0\40\0\105\0\156\0\165\0\155\0\145\0\162\0\141\0\164\0\151\0\157\0\156\0\163)
+ /Parent 514 0 R
+ /First 622 0 R
+ /Last 624 0 R
+ /Prev 620 0 R
+ /Next 625 0 R
+ /Count -3
+ /A 150 0 R
+>> endobj
+622 0 obj
+<<
+ /Title (\376\377\0\103\0\157\0\156\0\163\0\164\0\141\0\156\0\164\0\163)
+ /Parent 621 0 R
+ /Next 623 0 R
+ /A 152 0 R
+>> endobj
+623 0 obj
+<<
+ /Title (\376\377\0\105\0\156\0\165\0\155\0\145\0\162\0\141\0\164\0\151\0\157\0\156\0\163)
+ /Parent 621 0 R
+ /Prev 622 0 R
+ /Next 624 0 R
+ /A 154 0 R
+>> endobj
+624 0 obj
+<<
+ /Title (\376\377\0\111\0\155\0\160\0\154\0\145\0\155\0\145\0\156\0\164\0\141\0\164\0\151\0\157\0\156\0\40\0\156\0\157\0\164\0\145\0\163)
+ /Parent 621 0 R
+ /Prev 623 0 R
+ /A 156 0 R
+>> endobj
+625 0 obj
+<<
+ /Title (\376\377\0\124\0\150\0\162\0\145\0\141\0\144\0\163)
+ /Parent 514 0 R
+ /First 626 0 R
+ /Last 626 0 R
+ /Prev 621 0 R
+ /Next 627 0 R
+ /Count -1
+ /A 158 0 R
+>> endobj
+626 0 obj
+<<
+ /Title (\376\377\0\125\0\163\0\151\0\156\0\147\0\40\0\164\0\150\0\162\0\145\0\141\0\144\0\163)
+ /Parent 625 0 R
+ /A 160 0 R
+>> endobj
+627 0 obj
+<<
+ /Title (\376\377\0\127\0\145\0\141\0\153\0\40\0\122\0\145\0\146\0\145\0\162\0\145\0\156\0\143\0\145\0\163)
+ /Parent 514 0 R
+ /First 629 0 R
+ /Last 629 0 R
+ /Prev 625 0 R
+ /Next 630 0 R
+ /Count -1
+ /A 162 0 R
+>> endobj
+629 0 obj
+<<
+ /Title (\376\377\0\110\0\141\0\156\0\144\0\154\0\151\0\156\0\147\0\40\0\167\0\145\0\141\0\153\0\40\0\162\0\145\0\146\0\145\0\162\0\145\0\156\0\143\0\145\0\163\0\40\0\145\0\170\0\160\0\154\0\151\0\143\0\151\0\164\0\154\0\171)
+ /Parent 627 0 R
+ /A 628 0 R
+>> endobj
+630 0 obj
+<<
+ /Title (\376\377\0\104\0\145\0\154\0\145\0\147\0\141\0\164\0\151\0\157\0\156)
+ /Parent 514 0 R
+ /Prev 627 0 R
+ /Next 631 0 R
+ /A 164 0 R
+>> endobj
+631 0 obj
+<<
+ /Title (\376\377\0\115\0\145\0\164\0\141\0\155\0\145\0\164\0\150\0\157\0\144\0\163)
+ /Parent 514 0 R
+ /First 632 0 R
+ /Last 649 0 R
+ /Prev 630 0 R
+ /Next 650 0 R
+ /Count -18
+ /A 166 0 R
+>> endobj
+632 0 obj
+<<
+ /Title (\376\377\0\137\0\163\0\145\0\164)
+ /Parent 631 0 R
+ /Next 633 0 R
+ /A 168 0 R
+>> endobj
+633 0 obj
+<<
+ /Title (\376\377\0\137\0\147\0\145\0\164)
+ /Parent 631 0 R
+ /Prev 632 0 R
+ /Next 634 0 R
+ /A 170 0 R
+>> endobj
+634 0 obj
+<<
+ /Title (\376\377\0\137\0\156\0\145\0\167\0\163\0\154\0\157\0\164)
+ /Parent 631 0 R
+ /Prev 633 0 R
+ /Next 635 0 R
+ /A 172 0 R
+>> endobj
+635 0 obj
+<<
+ /Title (\376\377\0\137\0\144\0\145\0\154\0\163\0\154\0\157\0\164)
+ /Parent 631 0 R
+ /Prev 634 0 R
+ /Next 636 0 R
+ /A 174 0 R
+>> endobj
+636 0 obj
+<<
+ /Title (\376\377\0\137\0\141\0\144\0\144)
+ /Parent 631 0 R
+ /Prev 635 0 R
+ /Next 637 0 R
+ /A 176 0 R
+>> endobj
+637 0 obj
+<<
+ /Title (\376\377\0\137\0\163\0\165\0\142)
+ /Parent 631 0 R
+ /Prev 636 0 R
+ /Next 638 0 R
+ /A 178 0 R
+>> endobj
+638 0 obj
+<<
+ /Title (\376\377\0\137\0\155\0\165\0\154)
+ /Parent 631 0 R
+ /Prev 637 0 R
+ /Next 639 0 R
+ /A 180 0 R
+>> endobj
+639 0 obj
+<<
+ /Title (\376\377\0\137\0\144\0\151\0\166)
+ /Parent 631 0 R
+ /Prev 638 0 R
+ /Next 640 0 R
+ /A 182 0 R
+>> endobj
+640 0 obj
+<<
+ /Title (\376\377\0\137\0\155\0\157\0\144\0\165\0\154\0\157)
+ /Parent 631 0 R
+ /Prev 639 0 R
+ /Next 641 0 R
+ /A 184 0 R
+>> endobj
+641 0 obj
+<<
+ /Title (\376\377\0\137\0\165\0\156\0\155)
+ /Parent 631 0 R
+ /Prev 640 0 R
+ /Next 642 0 R
+ /A 186 0 R
+>> endobj
+642 0 obj
+<<
+ /Title (\376\377\0\137\0\164\0\171\0\160\0\145\0\157\0\146)
+ /Parent 631 0 R
+ /Prev 641 0 R
+ /Next 643 0 R
+ /A 188 0 R
+>> endobj
+643 0 obj
+<<
+ /Title (\376\377\0\137\0\143\0\155\0\160)
+ /Parent 631 0 R
+ /Prev 642 0 R
+ /Next 644 0 R
+ /A 190 0 R
+>> endobj
+644 0 obj
+<<
+ /Title (\376\377\0\137\0\143\0\141\0\154\0\154)
+ /Parent 631 0 R
+ /Prev 643 0 R
+ /Next 645 0 R
+ /A 192 0 R
+>> endobj
+645 0 obj
+<<
+ /Title (\376\377\0\137\0\143\0\154\0\157\0\156\0\145\0\144)
+ /Parent 631 0 R
+ /Prev 644 0 R
+ /Next 646 0 R
+ /A 194 0 R
+>> endobj
+646 0 obj
+<<
+ /Title (\376\377\0\137\0\156\0\145\0\170\0\164\0\151)
+ /Parent 631 0 R
+ /Prev 645 0 R
+ /Next 647 0 R
+ /A 196 0 R
+>> endobj
+647 0 obj
+<<
+ /Title (\376\377\0\137\0\164\0\157\0\163\0\164\0\162\0\151\0\156\0\147)
+ /Parent 631 0 R
+ /Prev 646 0 R
+ /Next 648 0 R
+ /A 198 0 R
+>> endobj
+648 0 obj
+<<
+ /Title (\376\377\0\137\0\151\0\156\0\150\0\145\0\162\0\151\0\164\0\145\0\144)
+ /Parent 631 0 R
+ /Prev 647 0 R
+ /Next 649 0 R
+ /A 200 0 R
+>> endobj
+649 0 obj
+<<
+ /Title (\376\377\0\137\0\156\0\145\0\167\0\155\0\145\0\155\0\142\0\145\0\162)
+ /Parent 631 0 R
+ /Prev 648 0 R
+ /A 202 0 R
+>> endobj
+650 0 obj
+<<
+ /Title (\376\377\0\102\0\165\0\151\0\154\0\164\0\55\0\151\0\156\0\40\0\146\0\165\0\156\0\143\0\164\0\151\0\157\0\156\0\163)
+ /Parent 514 0 R
+ /First 651 0 R
+ /Last 652 0 R
+ /Prev 631 0 R
+ /Count -14
+ /A 204 0 R
+>> endobj
+651 0 obj
+<<
+ /Title (\376\377\0\107\0\154\0\157\0\142\0\141\0\154\0\40\0\163\0\171\0\155\0\142\0\157\0\154\0\163)
+ /Parent 650 0 R
+ /Next 652 0 R
+ /A 206 0 R
+>> endobj
+652 0 obj
+<<
+ /Title (\376\377\0\104\0\145\0\146\0\141\0\165\0\154\0\164\0\40\0\144\0\145\0\154\0\145\0\147\0\141\0\164\0\145\0\163)
+ /Parent 650 0 R
+ /First 654 0 R
+ /Last 676 0 R
+ /Prev 651 0 R
+ /Count -12
+ /A 208 0 R
+>> endobj
+654 0 obj
+<<
+ /Title (\376\377\0\111\0\156\0\164\0\145\0\147\0\145\0\162)
+ /Parent 652 0 R
+ /Next 656 0 R
+ /A 653 0 R
+>> endobj
+656 0 obj
+<<
+ /Title (\376\377\0\106\0\154\0\157\0\141\0\164)
+ /Parent 652 0 R
+ /Prev 654 0 R
+ /Next 658 0 R
+ /A 655 0 R
+>> endobj
+658 0 obj
+<<
+ /Title (\376\377\0\102\0\157\0\157\0\154)
+ /Parent 652 0 R
+ /Prev 656 0 R
+ /Next 660 0 R
+ /A 657 0 R
+>> endobj
+660 0 obj
+<<
+ /Title (\376\377\0\123\0\164\0\162\0\151\0\156\0\147)
+ /Parent 652 0 R
+ /Prev 658 0 R
+ /Next 662 0 R
+ /A 659 0 R
+>> endobj
+662 0 obj
+<<
+ /Title (\376\377\0\124\0\141\0\142\0\154\0\145)
+ /Parent 652 0 R
+ /Prev 660 0 R
+ /Next 664 0 R
+ /A 661 0 R
+>> endobj
+664 0 obj
+<<
+ /Title (\376\377\0\101\0\162\0\162\0\141\0\171)
+ /Parent 652 0 R
+ /Prev 662 0 R
+ /Next 666 0 R
+ /A 663 0 R
+>> endobj
+666 0 obj
+<<
+ /Title (\376\377\0\106\0\165\0\156\0\143\0\164\0\151\0\157\0\156)
+ /Parent 652 0 R
+ /Prev 664 0 R
+ /Next 668 0 R
+ /A 665 0 R
+>> endobj
+668 0 obj
+<<
+ /Title (\376\377\0\103\0\154\0\141\0\163\0\163)
+ /Parent 652 0 R
+ /Prev 666 0 R
+ /Next 670 0 R
+ /A 667 0 R
+>> endobj
+670 0 obj
+<<
+ /Title (\376\377\0\103\0\154\0\141\0\163\0\163\0\40\0\111\0\156\0\163\0\164\0\141\0\156\0\143\0\145)
+ /Parent 652 0 R
+ /Prev 668 0 R
+ /Next 672 0 R
+ /A 669 0 R
+>> endobj
+672 0 obj
+<<
+ /Title (\376\377\0\107\0\145\0\156\0\145\0\162\0\141\0\164\0\157\0\162)
+ /Parent 652 0 R
+ /Prev 670 0 R
+ /Next 674 0 R
+ /A 671 0 R
+>> endobj
+674 0 obj
+<<
+ /Title (\376\377\0\124\0\150\0\162\0\145\0\141\0\144)
+ /Parent 652 0 R
+ /Prev 672 0 R
+ /Next 676 0 R
+ /A 673 0 R
+>> endobj
+676 0 obj
+<<
+ /Title (\376\377\0\127\0\145\0\141\0\153\0\40\0\122\0\145\0\146\0\145\0\162\0\145\0\156\0\143\0\145)
+ /Parent 652 0 R
+ /Prev 674 0 R
+ /A 675 0 R
+>> endobj
+677 0 obj
+<<
+ /Title (\376\377\0\103\0\150\0\141\0\160\0\164\0\145\0\162\0\240\0\63\0\56\0\240\0\105\0\155\0\142\0\145\0\144\0\144\0\151\0\156\0\147\0\40\0\123\0\161\0\165\0\151\0\162\0\162\0\145\0\154)
+ /Parent 508 0 R
+ /First 678 0 R
+ /Last 694 0 R
+ /Prev 514 0 R
+ /Next 695 0 R
+ /Count -17
+ /A 210 0 R
+>> endobj
+678 0 obj
+<<
+ /Title (\376\377\0\115\0\145\0\155\0\157\0\162\0\171\0\40\0\155\0\141\0\156\0\141\0\147\0\145\0\155\0\145\0\156\0\164)
+ /Parent 677 0 R
+ /Next 679 0 R
+ /A 212 0 R
+>> endobj
+679 0 obj
+<<
+ /Title (\376\377\0\125\0\156\0\151\0\143\0\157\0\144\0\145)
+ /Parent 677 0 R
+ /Prev 678 0 R
+ /Next 680 0 R
+ /A 214 0 R
+>> endobj
+680 0 obj
+<<
+ /Title (\376\377\0\123\0\161\0\165\0\151\0\162\0\162\0\145\0\154\0\40\0\157\0\156\0\40\0\66\0\64\0\40\0\142\0\151\0\164\0\163\0\40\0\141\0\162\0\143\0\150\0\151\0\164\0\145\0\143\0\164\0\165\0\162\0\145\0\163)
+ /Parent 677 0 R
+ /Prev 679 0 R
+ /Next 681 0 R
+ /A 216 0 R
+>> endobj
+681 0 obj
+<<
+ /Title (\376\377\0\105\0\162\0\162\0\157\0\162\0\40\0\143\0\157\0\156\0\166\0\145\0\156\0\164\0\151\0\157\0\156\0\163)
+ /Parent 677 0 R
+ /Prev 680 0 R
+ /Next 682 0 R
+ /A 218 0 R
+>> endobj
+682 0 obj
+<<
+ /Title (\376\377\0\111\0\156\0\151\0\164\0\151\0\141\0\154\0\151\0\172\0\151\0\156\0\147\0\40\0\123\0\161\0\165\0\151\0\162\0\162\0\145\0\154)
+ /Parent 677 0 R
+ /Prev 681 0 R
+ /Next 683 0 R
+ /A 220 0 R
+>> endobj
+683 0 obj
+<<
+ /Title (\376\377\0\124\0\150\0\145\0\40\0\123\0\164\0\141\0\143\0\153)
+ /Parent 677 0 R
+ /First 684 0 R
+ /Last 685 0 R
+ /Prev 682 0 R
+ /Next 686 0 R
+ /Count -2
+ /A 222 0 R
+>> endobj
+684 0 obj
+<<
+ /Title (\376\377\0\123\0\164\0\141\0\143\0\153\0\40\0\151\0\156\0\144\0\145\0\170\0\145\0\163)
+ /Parent 683 0 R
+ /Next 685 0 R
+ /A 224 0 R
+>> endobj
+685 0 obj
+<<
+ /Title (\376\377\0\123\0\164\0\141\0\143\0\153\0\40\0\155\0\141\0\156\0\151\0\160\0\165\0\154\0\141\0\164\0\151\0\157\0\156)
+ /Parent 683 0 R
+ /Prev 684 0 R
+ /A 226 0 R
+>> endobj
+686 0 obj
+<<
+ /Title (\376\377\0\122\0\165\0\156\0\164\0\151\0\155\0\145\0\40\0\145\0\162\0\162\0\157\0\162\0\40\0\150\0\141\0\156\0\144\0\154\0\151\0\156\0\147)
+ /Parent 677 0 R
+ /Prev 683 0 R
+ /Next 687 0 R
+ /A 228 0 R
+>> endobj
+687 0 obj
+<<
+ /Title (\376\377\0\103\0\157\0\155\0\160\0\151\0\154\0\151\0\156\0\147\0\40\0\141\0\40\0\163\0\143\0\162\0\151\0\160\0\164)
+ /Parent 677 0 R
+ /Prev 686 0 R
+ /Next 688 0 R
+ /A 230 0 R
+>> endobj
+688 0 obj
+<<
+ /Title (\376\377\0\103\0\141\0\154\0\154\0\151\0\156\0\147\0\40\0\141\0\40\0\146\0\165\0\156\0\143\0\164\0\151\0\157\0\156)
+ /Parent 677 0 R
+ /Prev 687 0 R
+ /Next 689 0 R
+ /A 232 0 R
+>> endobj
+689 0 obj
+<<
+ /Title (\376\377\0\103\0\162\0\145\0\141\0\164\0\145\0\40\0\141\0\40\0\103\0\40\0\146\0\165\0\156\0\143\0\164\0\151\0\157\0\156)
+ /Parent 677 0 R
+ /Prev 688 0 R
+ /Next 690 0 R
+ /A 234 0 R
+>> endobj
+690 0 obj
+<<
+ /Title (\376\377\0\124\0\141\0\142\0\154\0\145\0\163\0\40\0\141\0\156\0\144\0\40\0\141\0\162\0\162\0\141\0\171\0\163\0\40\0\155\0\141\0\156\0\151\0\160\0\165\0\154\0\141\0\164\0\151\0\157\0\156)
+ /Parent 677 0 R
+ /Prev 689 0 R
+ /Next 691 0 R
+ /A 236 0 R
+>> endobj
+691 0 obj
+<<
+ /Title (\376\377\0\125\0\163\0\145\0\162\0\144\0\141\0\164\0\141\0\40\0\141\0\156\0\144\0\40\0\125\0\163\0\145\0\162\0\120\0\157\0\151\0\156\0\164\0\145\0\162\0\163)
+ /Parent 677 0 R
+ /Prev 690 0 R
+ /Next 692 0 R
+ /A 238 0 R
+>> endobj
+692 0 obj
+<<
+ /Title (\376\377\0\124\0\150\0\145\0\40\0\162\0\145\0\147\0\151\0\163\0\164\0\162\0\171\0\40\0\164\0\141\0\142\0\154\0\145)
+ /Parent 677 0 R
+ /Prev 691 0 R
+ /Next 693 0 R
+ /A 243 0 R
+>> endobj
+693 0 obj
+<<
+ /Title (\376\377\0\115\0\141\0\156\0\164\0\141\0\151\0\156\0\151\0\156\0\147\0\40\0\163\0\164\0\162\0\157\0\156\0\147\0\40\0\162\0\145\0\146\0\145\0\162\0\145\0\156\0\143\0\145\0\163\0\40\0\164\0\157\0\40\0\123\0\161\0\165\0\151\0\162\0\162\0\145\0\154\0\40\0\166\0\141\0\154\0\165\0\145\0\163\0\40\0\146\0\162\0\157\0\155\0\40\0\164\0\150\0\145\0\40\0\103\0\40\0\101\0\120\0\111)
+ /Parent 677 0 R
+ /Prev 692 0 R
+ /Next 694 0 R
+ /A 245 0 R
+>> endobj
+694 0 obj
+<<
+ /Title (\376\377\0\104\0\145\0\142\0\165\0\147\0\40\0\111\0\156\0\164\0\145\0\162\0\146\0\141\0\143\0\145)
+ /Parent 677 0 R
+ /Prev 693 0 R
+ /A 247 0 R
+>> endobj
+695 0 obj
+<<
+ /Title (\376\377\0\103\0\150\0\141\0\160\0\164\0\145\0\162\0\240\0\64\0\56\0\240\0\101\0\120\0\111\0\40\0\122\0\145\0\146\0\145\0\162\0\145\0\156\0\143\0\145)
+ /Parent 508 0 R
+ /First 696 0 R
+ /Last 704 0 R
+ /Prev 677 0 R
+ /Next 705 0 R
+ /Count -9
+ /A 249 0 R
+>> endobj
+696 0 obj
+<<
+ /Title (\376\377\0\126\0\151\0\162\0\164\0\165\0\141\0\154\0\40\0\115\0\141\0\143\0\150\0\151\0\156\0\145)
+ /Parent 695 0 R
+ /Next 697 0 R
+ /A 251 0 R
+>> endobj
+697 0 obj
+<<
+ /Title (\376\377\0\103\0\157\0\155\0\160\0\151\0\154\0\145\0\162)
+ /Parent 695 0 R
+ /Prev 696 0 R
+ /Next 698 0 R
+ /A 253 0 R
+>> endobj
+698 0 obj
+<<
+ /Title (\376\377\0\123\0\164\0\141\0\143\0\153\0\40\0\117\0\160\0\145\0\162\0\141\0\164\0\151\0\157\0\156\0\163)
+ /Parent 695 0 R
+ /Prev 697 0 R
+ /Next 699 0 R
+ /A 255 0 R
+>> endobj
+699 0 obj
+<<
+ /Title (\376\377\0\117\0\142\0\152\0\145\0\143\0\164\0\40\0\143\0\162\0\145\0\141\0\164\0\151\0\157\0\156\0\40\0\141\0\156\0\144\0\40\0\150\0\141\0\156\0\144\0\154\0\151\0\156\0\147)
+ /Parent 695 0 R
+ /Prev 698 0 R
+ /Next 700 0 R
+ /A 257 0 R
+>> endobj
+700 0 obj
+<<
+ /Title (\376\377\0\103\0\141\0\154\0\154\0\163)
+ /Parent 695 0 R
+ /Prev 699 0 R
+ /Next 701 0 R
+ /A 259 0 R
+>> endobj
+701 0 obj
+<<
+ /Title (\376\377\0\117\0\142\0\152\0\145\0\143\0\164\0\163\0\40\0\155\0\141\0\156\0\151\0\160\0\165\0\154\0\141\0\164\0\151\0\157\0\156)
+ /Parent 695 0 R
+ /Prev 700 0 R
+ /Next 702 0 R
+ /A 261 0 R
+>> endobj
+702 0 obj
+<<
+ /Title (\376\377\0\102\0\171\0\164\0\145\0\143\0\157\0\144\0\145\0\40\0\163\0\145\0\162\0\151\0\141\0\154\0\151\0\172\0\141\0\164\0\151\0\157\0\156)
+ /Parent 695 0 R
+ /Prev 701 0 R
+ /Next 703 0 R
+ /A 263 0 R
+>> endobj
+703 0 obj
+<<
+ /Title (\376\377\0\122\0\141\0\167\0\40\0\157\0\142\0\152\0\145\0\143\0\164\0\40\0\150\0\141\0\156\0\144\0\154\0\151\0\156\0\147)
+ /Parent 695 0 R
+ /Prev 702 0 R
+ /Next 704 0 R
+ /A 265 0 R
+>> endobj
+704 0 obj
+<<
+ /Title (\376\377\0\104\0\145\0\142\0\165\0\147\0\40\0\151\0\156\0\164\0\145\0\162\0\146\0\141\0\143\0\145)
+ /Parent 695 0 R
+ /Prev 703 0 R
+ /A 267 0 R
+>> endobj
+705 0 obj
+<<
+ /Title (\376\377\0\111\0\156\0\144\0\145\0\170)
+ /Parent 508 0 R
+ /Prev 695 0 R
+ /A 269 0 R
+>> endobj
+706 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F11
+/BaseFont /Courier-Bold
+/Encoding /WinAnsiEncoding >>
+endobj
+707 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F1
+/BaseFont /Helvetica
+/Encoding /WinAnsiEncoding >>
+endobj
+708 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F10
+/BaseFont /Courier-Oblique
+/Encoding /WinAnsiEncoding >>
+endobj
+709 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F5
+/BaseFont /Times-Roman
+/Encoding /WinAnsiEncoding >>
+endobj
+710 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F3
+/BaseFont /Helvetica-Bold
+/Encoding /WinAnsiEncoding >>
+endobj
+711 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F9
+/BaseFont /Courier
+/Encoding /WinAnsiEncoding >>
+endobj
+712 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F6
+/BaseFont /Times-Italic
+/Encoding /WinAnsiEncoding >>
+endobj
+713 0 obj
+<< /Type /Font
+/Subtype /Type1
+/Name /F7
+/BaseFont /Times-Bold
+/Encoding /WinAnsiEncoding >>
+endobj
+1 0 obj
+<< /Type /Pages
+/Count 103
+/Kids [6 0 R 8 0 R 10 0 R 12 0 R 121 0 R 240 0 R 271 0 R 273 0 R 275 0 R 277 0 R 279 0 R 281 0 R 296 0 R 298 0 R 300 0 R 302 0 R 304 0 R 308 0 R 314 0 R 319 0 R 321 0 R 323 0 R 328 0 R 336 0 R 341 0 R 343 0 R 345 0 R 347 0 R 349 0 R 351 0 R 355 0 R 359 0 R 361 0 R 365 0 R 367 0 R 369 0 R 371 0 R 373 0 R 375 0 R 377 0 R 379 0 R 381 0 R 383 0 R 385 0 R 387 0 R 389 0 R 391 0 R 393 0 R 395 0 R 397 0 R 399 0 R 401 0 R 403 0 R 405 0 R 407 0 R 409 0 R 411 0 R 413 0 R 415 0 R 417 0 R 419 0 R 421 0 R 423 0 R 425 0 R 427 0 R 429 0 R 431 0 R 433 0 R 435 0 R 437 0 R 439 0 R 441 0 R 443 0 R 445 0 R 447 0 R 449 0 R 451 0 R 453 0 R 455 0 R 457 0 R 459 0 R 461 0 R 463 0 R 465 0 R 467 0 R 469 0 R 471 0 R 473 0 R 475 0 R 477 0 R 479 0 R 481 0 R 483 0 R 485 0 R 487 0 R 489 0 R 491 0 R 493 0 R 495 0 R 497 0 R 500 0 R 503 0 R 506 0 R ] >>
+endobj
+2 0 obj
+<< /Type /Catalog
+/Pages 1 0 R
+ /Outlines 508 0 R
+ /PageMode /UseOutlines
+ >>
+endobj
+3 0 obj
+<< 
+/Font << /F1 707 0 R /F11 706 0 R /F10 708 0 R /F5 709 0 R /F3 710 0 R /F9 711 0 R /F6 712 0 R /F7 713 0 R >> 
+/ProcSet [ /PDF /ImageC /Text ] >> 
+endobj
+15 0 obj
+<<
+/S /GoTo
+/D [271 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+17 0 obj
+<<
+/S /GoTo
+/D [273 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+19 0 obj
+<<
+/S /GoTo
+/D [273 0 R /XYZ 115.0 666.009 null]
+>>
+endobj
+21 0 obj
+<<
+/S /GoTo
+/D [273 0 R /XYZ 115.0 632.684 null]
+>>
+endobj
+23 0 obj
+<<
+/S /GoTo
+/D [273 0 R /XYZ 115.0 519.385 null]
+>>
+endobj
+25 0 obj
+<<
+/S /GoTo
+/D [273 0 R /XYZ 115.0 337.946 null]
+>>
+endobj
+27 0 obj
+<<
+/S /GoTo
+/D [273 0 R /XYZ 115.0 207.507 null]
+>>
+endobj
+29 0 obj
+<<
+/S /GoTo
+/D [273 0 R /XYZ 115.0 122.068 null]
+>>
+endobj
+31 0 obj
+<<
+/S /GoTo
+/D [275 0 R /XYZ 115.0 433.98 null]
+>>
+endobj
+33 0 obj
+<<
+/S /GoTo
+/D [275 0 R /XYZ 115.0 139.361 null]
+>>
+endobj
+35 0 obj
+<<
+/S /GoTo
+/D [277 0 R /XYZ 115.0 693.0 null]
+>>
+endobj
+37 0 obj
+<<
+/S /GoTo
+/D [277 0 R /XYZ 115.0 563.401 null]
+>>
+endobj
+39 0 obj
+<<
+/S /GoTo
+/D [277 0 R /XYZ 115.0 453.522 null]
+>>
+endobj
+41 0 obj
+<<
+/S /GoTo
+/D [277 0 R /XYZ 115.0 148.763 null]
+>>
+endobj
+43 0 obj
+<<
+/S /GoTo
+/D [279 0 R /XYZ 115.0 675.42 null]
+>>
+endobj
+45 0 obj
+<<
+/S /GoTo
+/D [279 0 R /XYZ 115.0 564.401 null]
+>>
+endobj
+47 0 obj
+<<
+/S /GoTo
+/D [279 0 R /XYZ 115.0 415.082 null]
+>>
+endobj
+49 0 obj
+<<
+/S /GoTo
+/D [279 0 R /XYZ 115.0 295.343 null]
+>>
+endobj
+51 0 obj
+<<
+/S /GoTo
+/D [279 0 R /XYZ 115.0 233.904 null]
+>>
+endobj
+53 0 obj
+<<
+/S /GoTo
+/D [279 0 R /XYZ 115.0 161.465 null]
+>>
+endobj
+55 0 obj
+<<
+/S /GoTo
+/D [281 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+57 0 obj
+<<
+/S /GoTo
+/D [281 0 R /XYZ 115.0 673.561 null]
+>>
+endobj
+59 0 obj
+<<
+/S /GoTo
+/D [281 0 R /XYZ 115.0 612.122 null]
+>>
+endobj
+61 0 obj
+<<
+/S /GoTo
+/D [281 0 R /XYZ 115.0 561.683 null]
+>>
+endobj
+63 0 obj
+<<
+/S /GoTo
+/D [281 0 R /XYZ 115.0 500.244 null]
+>>
+endobj
+65 0 obj
+<<
+/S /GoTo
+/D [281 0 R /XYZ 115.0 379.919 null]
+>>
+endobj
+67 0 obj
+<<
+/S /GoTo
+/D [298 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+69 0 obj
+<<
+/S /GoTo
+/D [298 0 R /XYZ 115.0 585.815 null]
+>>
+endobj
+71 0 obj
+<<
+/S /GoTo
+/D [298 0 R /XYZ 115.0 505.516 null]
+>>
+endobj
+73 0 obj
+<<
+/S /GoTo
+/D [300 0 R /XYZ 115.0 169.088 null]
+>>
+endobj
+75 0 obj
+<<
+/S /GoTo
+/D [302 0 R /XYZ 115.0 328.304 null]
+>>
+endobj
+77 0 obj
+<<
+/S /GoTo
+/D [302 0 R /XYZ 115.0 237.005 null]
+>>
+endobj
+79 0 obj
+<<
+/S /GoTo
+/D [302 0 R /XYZ 115.0 145.706 null]
+>>
+endobj
+81 0 obj
+<<
+/S /GoTo
+/D [304 0 R /XYZ 115.0 682.0 null]
+>>
+endobj
+83 0 obj
+<<
+/S /GoTo
+/D [304 0 R /XYZ 115.0 601.701 null]
+>>
+endobj
+85 0 obj
+<<
+/S /GoTo
+/D [304 0 R /XYZ 115.0 410.382 null]
+>>
+endobj
+87 0 obj
+<<
+/S /GoTo
+/D [304 0 R /XYZ 115.0 300.503 null]
+>>
+endobj
+89 0 obj
+<<
+/S /GoTo
+/D [304 0 R /XYZ 115.0 170.904 null]
+>>
+endobj
+91 0 obj
+<<
+/S /GoTo
+/D [308 0 R /XYZ 115.0 704.0 null]
+>>
+endobj
+93 0 obj
+<<
+/S /GoTo
+/D [308 0 R /XYZ 115.0 623.701 null]
+>>
+endobj
+95 0 obj
+<<
+/S /GoTo
+/D [308 0 R /XYZ 115.0 533.542 null]
+>>
+endobj
+97 0 obj
+<<
+/S /GoTo
+/D [308 0 R /XYZ 115.0 403.943 null]
+>>
+endobj
+99 0 obj
+<<
+/S /GoTo
+/D [308 0 R /XYZ 115.0 312.644 null]
+>>
+endobj
+101 0 obj
+<<
+/S /GoTo
+/D [308 0 R /XYZ 115.0 279.319 null]
+>>
+endobj
+103 0 obj
+<<
+/S /GoTo
+/D [314 0 R /XYZ 115.0 693.0 null]
+>>
+endobj
+105 0 obj
+<<
+/S /GoTo
+/D [321 0 R /XYZ 115.0 275.338 null]
+>>
+endobj
+107 0 obj
+<<
+/S /GoTo
+/D [323 0 R /XYZ 115.0 263.64 null]
+>>
+endobj
+109 0 obj
+<<
+/S /GoTo
+/D [323 0 R /XYZ 115.0 172.341 null]
+>>
+endobj
+111 0 obj
+<<
+/S /GoTo
+/D [328 0 R /XYZ 115.0 651.0 null]
+>>
+endobj
+113 0 obj
+<<
+/S /GoTo
+/D [328 0 R /XYZ 115.0 450.541 null]
+>>
+endobj
+115 0 obj
+<<
+/S /GoTo
+/D [328 0 R /XYZ 115.0 363.216 null]
+>>
+endobj
+117 0 obj
+<<
+/S /GoTo
+/D [328 0 R /XYZ 115.0 312.777 null]
+>>
+endobj
+119 0 obj
+<<
+/S /GoTo
+/D [336 0 R /XYZ 115.0 614.7 null]
+>>
+endobj
+124 0 obj
+<<
+/S /GoTo
+/D [336 0 R /XYZ 115.0 414.661 null]
+>>
+endobj
+126 0 obj
+<<
+/S /GoTo
+/D [336 0 R /XYZ 115.0 248.036 null]
+>>
+endobj
+128 0 obj
+<<
+/S /GoTo
+/D [336 0 R /XYZ 115.0 171.711 null]
+>>
+endobj
+130 0 obj
+<<
+/S /GoTo
+/D [343 0 R /XYZ 115.0 441.344 null]
+>>
+endobj
+132 0 obj
+<<
+/S /GoTo
+/D [343 0 R /XYZ 115.0 166.885 null]
+>>
+endobj
+134 0 obj
+<<
+/S /GoTo
+/D [345 0 R /XYZ 115.0 655.866 null]
+>>
+endobj
+136 0 obj
+<<
+/S /GoTo
+/D [345 0 R /XYZ 115.0 443.827 null]
+>>
+endobj
+138 0 obj
+<<
+/S /GoTo
+/D [345 0 R /XYZ 115.0 231.928 null]
+>>
+endobj
+140 0 obj
+<<
+/S /GoTo
+/D [345 0 R /XYZ 115.0 155.603 null]
+>>
+endobj
+142 0 obj
+<<
+/S /GoTo
+/D [351 0 R /XYZ 115.0 370.94 null]
+>>
+endobj
+144 0 obj
+<<
+/S /GoTo
+/D [355 0 R /XYZ 115.0 411.66 null]
+>>
+endobj
+146 0 obj
+<<
+/S /GoTo
+/D [361 0 R /XYZ 115.0 616.26 null]
+>>
+endobj
+148 0 obj
+<<
+/S /GoTo
+/D [361 0 R /XYZ 115.0 191.181 null]
+>>
+endobj
+150 0 obj
+<<
+/S /GoTo
+/D [365 0 R /XYZ 115.0 373.36 null]
+>>
+endobj
+152 0 obj
+<<
+/S /GoTo
+/D [365 0 R /XYZ 115.0 308.035 null]
+>>
+endobj
+154 0 obj
+<<
+/S /GoTo
+/D [367 0 R /XYZ 115.0 634.7 null]
+>>
+endobj
+156 0 obj
+<<
+/S /GoTo
+/D [367 0 R /XYZ 115.0 169.481 null]
+>>
+endobj
+158 0 obj
+<<
+/S /GoTo
+/D [369 0 R /XYZ 115.0 499.68 null]
+>>
+endobj
+160 0 obj
+<<
+/S /GoTo
+/D [369 0 R /XYZ 115.0 379.355 null]
+>>
+endobj
+162 0 obj
+<<
+/S /GoTo
+/D [373 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+164 0 obj
+<<
+/S /GoTo
+/D [375 0 R /XYZ 115.0 675.42 null]
+>>
+endobj
+166 0 obj
+<<
+/S /GoTo
+/D [375 0 R /XYZ 115.0 338.615 null]
+>>
+endobj
+168 0 obj
+<<
+/S /GoTo
+/D [377 0 R /XYZ 115.0 397.78 null]
+>>
+endobj
+170 0 obj
+<<
+/S /GoTo
+/D [377 0 R /XYZ 115.0 317.481 null]
+>>
+endobj
+172 0 obj
+<<
+/S /GoTo
+/D [377 0 R /XYZ 115.0 237.182 null]
+>>
+endobj
+174 0 obj
+<<
+/S /GoTo
+/D [377 0 R /XYZ 115.0 124.883 null]
+>>
+endobj
+176 0 obj
+<<
+/S /GoTo
+/D [379 0 R /XYZ 115.0 653.14 null]
+>>
+endobj
+178 0 obj
+<<
+/S /GoTo
+/D [379 0 R /XYZ 115.0 572.841 null]
+>>
+endobj
+180 0 obj
+<<
+/S /GoTo
+/D [379 0 R /XYZ 115.0 522.402 null]
+>>
+endobj
+182 0 obj
+<<
+/S /GoTo
+/D [379 0 R /XYZ 115.0 471.963 null]
+>>
+endobj
+184 0 obj
+<<
+/S /GoTo
+/D [379 0 R /XYZ 115.0 421.524 null]
+>>
+endobj
+186 0 obj
+<<
+/S /GoTo
+/D [379 0 R /XYZ 115.0 371.085 null]
+>>
+endobj
+188 0 obj
+<<
+/S /GoTo
+/D [379 0 R /XYZ 115.0 290.786 null]
+>>
+endobj
+190 0 obj
+<<
+/S /GoTo
+/D [379 0 R /XYZ 115.0 210.487 null]
+>>
+endobj
+192 0 obj
+<<
+/S /GoTo
+/D [381 0 R /XYZ 115.0 684.75 null]
+>>
+endobj
+194 0 obj
+<<
+/S /GoTo
+/D [381 0 R /XYZ 115.0 604.451 null]
+>>
+endobj
+196 0 obj
+<<
+/S /GoTo
+/D [381 0 R /XYZ 115.0 524.152 null]
+>>
+endobj
+198 0 obj
+<<
+/S /GoTo
+/D [381 0 R /XYZ 115.0 411.853 null]
+>>
+endobj
+200 0 obj
+<<
+/S /GoTo
+/D [381 0 R /XYZ 115.0 299.554 null]
+>>
+endobj
+202 0 obj
+<<
+/S /GoTo
+/D [381 0 R /XYZ 115.0 187.255 null]
+>>
+endobj
+204 0 obj
+<<
+/S /GoTo
+/D [383 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+206 0 obj
+<<
+/S /GoTo
+/D [383 0 R /XYZ 115.0 680.675 null]
+>>
+endobj
+208 0 obj
+<<
+/S /GoTo
+/D [385 0 R /XYZ 115.0 220.24 null]
+>>
+endobj
+210 0 obj
+<<
+/S /GoTo
+/D [399 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+212 0 obj
+<<
+/S /GoTo
+/D [399 0 R /XYZ 115.0 601.009 null]
+>>
+endobj
+214 0 obj
+<<
+/S /GoTo
+/D [399 0 R /XYZ 115.0 343.684 null]
+>>
+endobj
+216 0 obj
+<<
+/S /GoTo
+/D [399 0 R /XYZ 115.0 278.359 null]
+>>
+endobj
+218 0 obj
+<<
+/S /GoTo
+/D [399 0 R /XYZ 115.0 213.034 null]
+>>
+endobj
+220 0 obj
+<<
+/S /GoTo
+/D [401 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+222 0 obj
+<<
+/S /GoTo
+/D [401 0 R /XYZ 115.0 520.215 null]
+>>
+endobj
+224 0 obj
+<<
+/S /GoTo
+/D [401 0 R /XYZ 115.0 432.89 null]
+>>
+endobj
+226 0 obj
+<<
+/S /GoTo
+/D [401 0 R /XYZ 115.0 127.451 null]
+>>
+endobj
+228 0 obj
+<<
+/S /GoTo
+/D [405 0 R /XYZ 115.0 574.12 null]
+>>
+endobj
+230 0 obj
+<<
+/S /GoTo
+/D [405 0 R /XYZ 115.0 413.935 null]
+>>
+endobj
+232 0 obj
+<<
+/S /GoTo
+/D [407 0 R /XYZ 115.0 385.22 null]
+>>
+endobj
+234 0 obj
+<<
+/S /GoTo
+/D [409 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+236 0 obj
+<<
+/S /GoTo
+/D [411 0 R /XYZ 115.0 230.16 null]
+>>
+endobj
+238 0 obj
+<<
+/S /GoTo
+/D [415 0 R /XYZ 115.0 616.26 null]
+>>
+endobj
+243 0 obj
+<<
+/S /GoTo
+/D [415 0 R /XYZ 115.0 269.915 null]
+>>
+endobj
+245 0 obj
+<<
+/S /GoTo
+/D [415 0 R /XYZ 115.0 152.73 null]
+>>
+endobj
+247 0 obj
+<<
+/S /GoTo
+/D [417 0 R /XYZ 115.0 532.68 null]
+>>
+endobj
+249 0 obj
+<<
+/S /GoTo
+/D [421 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+251 0 obj
+<<
+/S /GoTo
+/D [421 0 R /XYZ 115.0 687.009 null]
+>>
+endobj
+253 0 obj
+<<
+/S /GoTo
+/D [431 0 R /XYZ 115.0 621.0 null]
+>>
+endobj
+255 0 obj
+<<
+/S /GoTo
+/D [435 0 R /XYZ 115.0 524.14 null]
+>>
+endobj
+257 0 obj
+<<
+/S /GoTo
+/D [439 0 R /XYZ 115.0 422.28 null]
+>>
+endobj
+259 0 obj
+<<
+/S /GoTo
+/D [463 0 R /XYZ 115.0 113.56 null]
+>>
+endobj
+261 0 obj
+<<
+/S /GoTo
+/D [469 0 R /XYZ 115.0 611.0 null]
+>>
+endobj
+263 0 obj
+<<
+/S /GoTo
+/D [485 0 R /XYZ 115.0 116.42 null]
+>>
+endobj
+265 0 obj
+<<
+/S /GoTo
+/D [487 0 R /XYZ 115.0 218.56 null]
+>>
+endobj
+267 0 obj
+<<
+/S /GoTo
+/D [493 0 R /XYZ 115.0 231.28 null]
+>>
+endobj
+269 0 obj
+<<
+/S /GoTo
+/D [497 0 R /XYZ 67.0 725.0 null]
+>>
+endobj
+284 0 obj
+<<
+/S /GoTo
+/D [361 0 R /XYZ 115.0 157.856 null]
+>>
+endobj
+287 0 obj
+<<
+/S /GoTo
+/D [415 0 R /XYZ 115.0 582.935 null]
+>>
+endobj
+289 0 obj
+<<
+/S /GoTo
+/D [373 0 R /XYZ 115.0 701.675 null]
+>>
+endobj
+291 0 obj
+<<
+/S /GoTo
+/D [336 0 R /XYZ 115.0 214.711 null]
+>>
+endobj
+294 0 obj
+<<
+/S /GoTo
+/D [281 0 R /XYZ 115.0 350.48 null]
+>>
+endobj
+311 0 obj
+<<
+/S /GoTo
+/D [365 0 R /XYZ 115.0 340.035 null]
+>>
+endobj
+317 0 obj
+<<
+/S /GoTo
+/D [328 0 R /XYZ 115.0 417.216 null]
+>>
+endobj
+326 0 obj
+<<
+/S /GoTo
+/D [375 0 R /XYZ 115.0 642.095 null]
+>>
+endobj
+332 0 obj
+<<
+/S /GoTo
+/D [375 0 R /XYZ 115.0 305.29 null]
+>>
+endobj
+334 0 obj
+<<
+/S /GoTo
+/D [321 0 R /XYZ 115.0 245.899 null]
+>>
+endobj
+339 0 obj
+<<
+/S /GoTo
+/D [383 0 R /XYZ 115.0 701.675 null]
+>>
+endobj
+508 0 obj
+<<
+ /First 510 0 R
+ /Last 705 0 R
+>> endobj
+509 0 obj
+<<
+/S /GoTo
+/D [10 0 R /XYZ 115.0 725.0 null]
+>>
+endobj
+511 0 obj
+<<
+/S /GoTo
+/D [12 0 R /XYZ 115.0 715.0 null]
+>>
+endobj
+542 0 obj
+<<
+/S /GoTo
+/D [298 0 R /XYZ 115.0 444.077 null]
+>>
+endobj
+544 0 obj
+<<
+/S /GoTo
+/D [298 0 R /XYZ 115.0 385.881 null]
+>>
+endobj
+546 0 obj
+<<
+/S /GoTo
+/D [298 0 R /XYZ 115.0 170.505 null]
+>>
+endobj
+548 0 obj
+<<
+/S /GoTo
+/D [300 0 R /XYZ 115.0 566.96 null]
+>>
+endobj
+550 0 obj
+<<
+/S /GoTo
+/D [300 0 R /XYZ 115.0 370.164 null]
+>>
+endobj
+553 0 obj
+<<
+/S /GoTo
+/D [300 0 R /XYZ 115.0 139.649 null]
+>>
+endobj
+555 0 obj
+<<
+/S /GoTo
+/D [302 0 R /XYZ 115.0 545.96 null]
+>>
+endobj
+572 0 obj
+<<
+/S /GoTo
+/D [314 0 R /XYZ 115.0 663.561 null]
+>>
+endobj
+574 0 obj
+<<
+/S /GoTo
+/D [314 0 R /XYZ 115.0 586.505 null]
+>>
+endobj
+576 0 obj
+<<
+/S /GoTo
+/D [314 0 R /XYZ 115.0 345.569 null]
+>>
+endobj
+578 0 obj
+<<
+/S /GoTo
+/D [314 0 R /XYZ 115.0 236.513 null]
+>>
+endobj
+580 0 obj
+<<
+/S /GoTo
+/D [319 0 R /XYZ 115.0 693.0 null]
+>>
+endobj
+582 0 obj
+<<
+/S /GoTo
+/D [319 0 R /XYZ 115.0 476.484 null]
+>>
+endobj
+584 0 obj
+<<
+/S /GoTo
+/D [319 0 R /XYZ 115.0 388.428 null]
+>>
+endobj
+586 0 obj
+<<
+/S /GoTo
+/D [319 0 R /XYZ 115.0 242.072 null]
+>>
+endobj
+588 0 obj
+<<
+/S /GoTo
+/D [321 0 R /XYZ 115.0 675.42 null]
+>>
+endobj
+590 0 obj
+<<
+/S /GoTo
+/D [321 0 R /XYZ 115.0 535.784 null]
+>>
+endobj
+603 0 obj
+<<
+/S /GoTo
+/D [341 0 R /XYZ 115.0 256.9 null]
+>>
+endobj
+605 0 obj
+<<
+/S /GoTo
+/D [343 0 R /XYZ 115.0 703.0 null]
+>>
+endobj
+613 0 obj
+<<
+/S /GoTo
+/D [349 0 R /XYZ 115.0 454.8 null]
+>>
+endobj
+615 0 obj
+<<
+/S /GoTo
+/D [349 0 R /XYZ 115.0 240.87 null]
+>>
+endobj
+628 0 obj
+<<
+/S /GoTo
+/D [373 0 R /XYZ 115.0 288.775 null]
+>>
+endobj
+653 0 obj
+<<
+/S /GoTo
+/D [385 0 R /XYZ 115.0 158.801 null]
+>>
+endobj
+655 0 obj
+<<
+/S /GoTo
+/D [387 0 R /XYZ 115.0 557.0 null]
+>>
+endobj
+657 0 obj
+<<
+/S /GoTo
+/D [387 0 R /XYZ 115.0 320.804 null]
+>>
+endobj
+659 0 obj
+<<
+/S /GoTo
+/D [387 0 R /XYZ 115.0 126.608 null]
+>>
+endobj
+661 0 obj
+<<
+/S /GoTo
+/D [389 0 R /XYZ 115.0 313.0 null]
+>>
+endobj
+663 0 obj
+<<
+/S /GoTo
+/D [391 0 R /XYZ 115.0 546.0 null]
+>>
+endobj
+665 0 obj
+<<
+/S /GoTo
+/D [393 0 R /XYZ 115.0 372.12 null]
+>>
+endobj
+667 0 obj
+<<
+/S /GoTo
+/D [395 0 R /XYZ 115.0 577.0 null]
+>>
+endobj
+669 0 obj
+<<
+/S /GoTo
+/D [395 0 R /XYZ 115.0 254.804 null]
+>>
+endobj
+671 0 obj
+<<
+/S /GoTo
+/D [397 0 R /XYZ 115.0 683.0 null]
+>>
+endobj
+673 0 obj
+<<
+/S /GoTo
+/D [397 0 R /XYZ 115.0 530.804 null]
+>>
+endobj
+675 0 obj
+<<
+/S /GoTo
+/D [397 0 R /XYZ 115.0 283.608 null]
+>>
+endobj
+xref
+0 714
+0000000000 65535 f 
+0000220303 00000 n 
+0000221175 00000 n 
+0000221268 00000 n 
+0000000015 00000 n 
+0000000071 00000 n 
+0000000404 00000 n 
+0000000510 00000 n 
+0000001703 00000 n 
+0000001809 00000 n 
+0000001970 00000 n 
+0000002077 00000 n 
+0000003980 00000 n 
+0000004103 00000 n 
+0000004504 00000 n 
+0000221434 00000 n 
+0000004640 00000 n 
+0000221500 00000 n 
+0000004776 00000 n 
+0000221566 00000 n 
+0000004912 00000 n 
+0000221634 00000 n 
+0000005047 00000 n 
+0000221702 00000 n 
+0000005182 00000 n 
+0000221770 00000 n 
+0000005318 00000 n 
+0000221838 00000 n 
+0000005454 00000 n 
+0000221906 00000 n 
+0000005590 00000 n 
+0000221974 00000 n 
+0000005726 00000 n 
+0000222041 00000 n 
+0000005861 00000 n 
+0000222109 00000 n 
+0000005997 00000 n 
+0000222175 00000 n 
+0000006133 00000 n 
+0000222243 00000 n 
+0000006269 00000 n 
+0000222311 00000 n 
+0000006405 00000 n 
+0000222379 00000 n 
+0000006541 00000 n 
+0000222446 00000 n 
+0000006677 00000 n 
+0000222514 00000 n 
+0000006813 00000 n 
+0000222582 00000 n 
+0000006949 00000 n 
+0000222650 00000 n 
+0000007085 00000 n 
+0000222718 00000 n 
+0000007221 00000 n 
+0000222786 00000 n 
+0000007357 00000 n 
+0000222852 00000 n 
+0000007493 00000 n 
+0000222920 00000 n 
+0000007629 00000 n 
+0000222988 00000 n 
+0000007765 00000 n 
+0000223056 00000 n 
+0000007901 00000 n 
+0000223124 00000 n 
+0000008037 00000 n 
+0000223192 00000 n 
+0000008173 00000 n 
+0000223258 00000 n 
+0000008309 00000 n 
+0000223326 00000 n 
+0000008445 00000 n 
+0000223394 00000 n 
+0000008580 00000 n 
+0000223462 00000 n 
+0000008716 00000 n 
+0000223530 00000 n 
+0000008852 00000 n 
+0000223598 00000 n 
+0000008988 00000 n 
+0000223666 00000 n 
+0000009123 00000 n 
+0000223732 00000 n 
+0000009258 00000 n 
+0000223800 00000 n 
+0000009394 00000 n 
+0000223868 00000 n 
+0000009529 00000 n 
+0000223936 00000 n 
+0000009665 00000 n 
+0000224004 00000 n 
+0000009801 00000 n 
+0000224070 00000 n 
+0000009937 00000 n 
+0000224138 00000 n 
+0000010073 00000 n 
+0000224206 00000 n 
+0000010208 00000 n 
+0000224274 00000 n 
+0000010344 00000 n 
+0000224342 00000 n 
+0000010481 00000 n 
+0000224411 00000 n 
+0000010619 00000 n 
+0000224478 00000 n 
+0000010757 00000 n 
+0000224547 00000 n 
+0000010895 00000 n 
+0000224615 00000 n 
+0000011033 00000 n 
+0000224684 00000 n 
+0000011171 00000 n 
+0000224751 00000 n 
+0000011309 00000 n 
+0000224820 00000 n 
+0000011446 00000 n 
+0000224889 00000 n 
+0000011582 00000 n 
+0000224958 00000 n 
+0000011718 00000 n 
+0000013818 00000 n 
+0000013944 00000 n 
+0000014429 00000 n 
+0000225025 00000 n 
+0000014563 00000 n 
+0000225094 00000 n 
+0000014697 00000 n 
+0000225163 00000 n 
+0000014831 00000 n 
+0000225232 00000 n 
+0000014965 00000 n 
+0000225301 00000 n 
+0000015099 00000 n 
+0000225370 00000 n 
+0000015233 00000 n 
+0000225439 00000 n 
+0000015367 00000 n 
+0000225508 00000 n 
+0000015500 00000 n 
+0000225577 00000 n 
+0000015633 00000 n 
+0000225646 00000 n 
+0000015767 00000 n 
+0000225714 00000 n 
+0000015901 00000 n 
+0000225782 00000 n 
+0000016035 00000 n 
+0000225850 00000 n 
+0000016169 00000 n 
+0000225919 00000 n 
+0000016303 00000 n 
+0000225987 00000 n 
+0000016437 00000 n 
+0000226056 00000 n 
+0000016571 00000 n 
+0000226123 00000 n 
+0000016705 00000 n 
+0000226192 00000 n 
+0000016839 00000 n 
+0000226260 00000 n 
+0000016973 00000 n 
+0000226329 00000 n 
+0000017107 00000 n 
+0000226396 00000 n 
+0000017241 00000 n 
+0000226464 00000 n 
+0000017375 00000 n 
+0000226533 00000 n 
+0000017509 00000 n 
+0000226601 00000 n 
+0000017643 00000 n 
+0000226670 00000 n 
+0000017777 00000 n 
+0000226739 00000 n 
+0000017911 00000 n 
+0000226808 00000 n 
+0000018045 00000 n 
+0000226876 00000 n 
+0000018179 00000 n 
+0000226945 00000 n 
+0000018313 00000 n 
+0000227014 00000 n 
+0000018447 00000 n 
+0000227083 00000 n 
+0000018581 00000 n 
+0000227152 00000 n 
+0000018715 00000 n 
+0000227221 00000 n 
+0000018849 00000 n 
+0000227290 00000 n 
+0000018983 00000 n 
+0000227359 00000 n 
+0000019117 00000 n 
+0000227427 00000 n 
+0000019251 00000 n 
+0000227496 00000 n 
+0000019384 00000 n 
+0000227565 00000 n 
+0000019518 00000 n 
+0000227634 00000 n 
+0000019652 00000 n 
+0000227703 00000 n 
+0000019786 00000 n 
+0000227772 00000 n 
+0000019920 00000 n 
+0000227839 00000 n 
+0000020054 00000 n 
+0000227908 00000 n 
+0000020187 00000 n 
+0000227976 00000 n 
+0000020321 00000 n 
+0000228043 00000 n 
+0000020455 00000 n 
+0000228112 00000 n 
+0000020589 00000 n 
+0000228181 00000 n 
+0000020723 00000 n 
+0000228250 00000 n 
+0000020857 00000 n 
+0000228319 00000 n 
+0000020991 00000 n 
+0000228386 00000 n 
+0000021125 00000 n 
+0000228455 00000 n 
+0000021259 00000 n 
+0000228523 00000 n 
+0000021392 00000 n 
+0000228592 00000 n 
+0000021526 00000 n 
+0000228660 00000 n 
+0000021660 00000 n 
+0000228729 00000 n 
+0000021794 00000 n 
+0000228797 00000 n 
+0000021928 00000 n 
+0000228864 00000 n 
+0000022061 00000 n 
+0000228932 00000 n 
+0000022193 00000 n 
+0000023077 00000 n 
+0000023203 00000 n 
+0000023336 00000 n 
+0000229000 00000 n 
+0000023470 00000 n 
+0000229069 00000 n 
+0000023604 00000 n 
+0000229137 00000 n 
+0000023738 00000 n 
+0000229205 00000 n 
+0000023872 00000 n 
+0000229272 00000 n 
+0000024006 00000 n 
+0000229341 00000 n 
+0000024140 00000 n 
+0000229408 00000 n 
+0000024273 00000 n 
+0000229476 00000 n 
+0000024407 00000 n 
+0000229544 00000 n 
+0000024541 00000 n 
+0000229612 00000 n 
+0000024675 00000 n 
+0000229679 00000 n 
+0000024809 00000 n 
+0000229747 00000 n 
+0000024943 00000 n 
+0000229815 00000 n 
+0000025077 00000 n 
+0000229883 00000 n 
+0000025211 00000 n 
+0000026030 00000 n 
+0000026140 00000 n 
+0000027759 00000 n 
+0000027869 00000 n 
+0000029633 00000 n 
+0000029743 00000 n 
+0000031609 00000 n 
+0000031719 00000 n 
+0000033369 00000 n 
+0000033479 00000 n 
+0000035555 00000 n 
+0000035681 00000 n 
+0000035758 00000 n 
+0000229949 00000 n 
+0000035897 00000 n 
+0000036035 00000 n 
+0000230018 00000 n 
+0000036174 00000 n 
+0000230087 00000 n 
+0000036313 00000 n 
+0000230156 00000 n 
+0000036452 00000 n 
+0000036590 00000 n 
+0000230225 00000 n 
+0000036731 00000 n 
+0000038006 00000 n 
+0000038116 00000 n 
+0000039927 00000 n 
+0000040037 00000 n 
+0000041568 00000 n 
+0000041678 00000 n 
+0000043120 00000 n 
+0000043230 00000 n 
+0000044847 00000 n 
+0000044973 00000 n 
+0000045002 00000 n 
+0000045140 00000 n 
+0000046295 00000 n 
+0000046421 00000 n 
+0000046458 00000 n 
+0000230293 00000 n 
+0000046597 00000 n 
+0000046736 00000 n 
+0000048611 00000 n 
+0000048737 00000 n 
+0000048766 00000 n 
+0000230362 00000 n 
+0000048903 00000 n 
+0000050312 00000 n 
+0000050422 00000 n 
+0000052124 00000 n 
+0000052234 00000 n 
+0000053504 00000 n 
+0000053630 00000 n 
+0000053659 00000 n 
+0000230431 00000 n 
+0000053798 00000 n 
+0000055477 00000 n 
+0000055603 00000 n 
+0000055648 00000 n 
+0000055783 00000 n 
+0000230500 00000 n 
+0000055918 00000 n 
+0000230568 00000 n 
+0000056056 00000 n 
+0000057571 00000 n 
+0000057697 00000 n 
+0000057726 00000 n 
+0000230637 00000 n 
+0000057864 00000 n 
+0000058952 00000 n 
+0000059062 00000 n 
+0000061298 00000 n 
+0000061408 00000 n 
+0000063710 00000 n 
+0000063820 00000 n 
+0000065001 00000 n 
+0000065111 00000 n 
+0000067230 00000 n 
+0000067340 00000 n 
+0000069712 00000 n 
+0000069838 00000 n 
+0000069867 00000 n 
+0000070006 00000 n 
+0000071885 00000 n 
+0000072011 00000 n 
+0000072040 00000 n 
+0000072174 00000 n 
+0000073653 00000 n 
+0000073763 00000 n 
+0000076098 00000 n 
+0000076224 00000 n 
+0000076253 00000 n 
+0000076394 00000 n 
+0000078189 00000 n 
+0000078299 00000 n 
+0000080046 00000 n 
+0000080156 00000 n 
+0000082998 00000 n 
+0000083108 00000 n 
+0000084307 00000 n 
+0000084417 00000 n 
+0000086517 00000 n 
+0000086627 00000 n 
+0000088693 00000 n 
+0000088803 00000 n 
+0000090018 00000 n 
+0000090128 00000 n 
+0000091142 00000 n 
+0000091252 00000 n 
+0000092713 00000 n 
+0000092823 00000 n 
+0000094207 00000 n 
+0000094317 00000 n 
+0000095917 00000 n 
+0000096027 00000 n 
+0000096927 00000 n 
+0000097037 00000 n 
+0000098503 00000 n 
+0000098613 00000 n 
+0000099980 00000 n 
+0000100090 00000 n 
+0000101652 00000 n 
+0000101762 00000 n 
+0000103271 00000 n 
+0000103381 00000 n 
+0000104497 00000 n 
+0000104607 00000 n 
+0000107364 00000 n 
+0000107474 00000 n 
+0000109676 00000 n 
+0000109786 00000 n 
+0000111258 00000 n 
+0000111368 00000 n 
+0000113619 00000 n 
+0000113729 00000 n 
+0000115466 00000 n 
+0000115576 00000 n 
+0000117593 00000 n 
+0000117703 00000 n 
+0000119192 00000 n 
+0000119302 00000 n 
+0000120476 00000 n 
+0000120586 00000 n 
+0000123138 00000 n 
+0000123248 00000 n 
+0000125612 00000 n 
+0000125722 00000 n 
+0000126373 00000 n 
+0000126483 00000 n 
+0000127640 00000 n 
+0000127750 00000 n 
+0000129402 00000 n 
+0000129512 00000 n 
+0000130570 00000 n 
+0000130680 00000 n 
+0000132116 00000 n 
+0000132226 00000 n 
+0000133696 00000 n 
+0000133806 00000 n 
+0000135582 00000 n 
+0000135692 00000 n 
+0000137473 00000 n 
+0000137583 00000 n 
+0000138813 00000 n 
+0000138923 00000 n 
+0000139968 00000 n 
+0000140078 00000 n 
+0000141610 00000 n 
+0000141720 00000 n 
+0000143026 00000 n 
+0000143136 00000 n 
+0000144533 00000 n 
+0000144643 00000 n 
+0000145974 00000 n 
+0000146084 00000 n 
+0000147220 00000 n 
+0000147330 00000 n 
+0000148674 00000 n 
+0000148784 00000 n 
+0000150193 00000 n 
+0000150303 00000 n 
+0000151392 00000 n 
+0000151502 00000 n 
+0000152575 00000 n 
+0000152685 00000 n 
+0000154350 00000 n 
+0000154460 00000 n 
+0000157304 00000 n 
+0000157414 00000 n 
+0000158840 00000 n 
+0000158950 00000 n 
+0000160261 00000 n 
+0000160371 00000 n 
+0000162096 00000 n 
+0000162206 00000 n 
+0000163760 00000 n 
+0000163870 00000 n 
+0000165111 00000 n 
+0000165221 00000 n 
+0000166355 00000 n 
+0000166465 00000 n 
+0000168004 00000 n 
+0000168114 00000 n 
+0000169526 00000 n 
+0000169636 00000 n 
+0000170971 00000 n 
+0000171081 00000 n 
+0000172955 00000 n 
+0000173065 00000 n 
+0000174546 00000 n 
+0000174656 00000 n 
+0000176136 00000 n 
+0000176246 00000 n 
+0000177557 00000 n 
+0000177667 00000 n 
+0000179221 00000 n 
+0000179331 00000 n 
+0000180576 00000 n 
+0000180686 00000 n 
+0000181913 00000 n 
+0000182023 00000 n 
+0000183262 00000 n 
+0000183372 00000 n 
+0000184367 00000 n 
+0000184477 00000 n 
+0000186229 00000 n 
+0000186355 00000 n 
+0000186376 00000 n 
+0000188180 00000 n 
+0000188306 00000 n 
+0000188327 00000 n 
+0000190111 00000 n 
+0000190237 00000 n 
+0000190258 00000 n 
+0000190593 00000 n 
+0000190719 00000 n 
+0000230706 00000 n 
+0000230760 00000 n 
+0000190740 00000 n 
+0000230826 00000 n 
+0000190994 00000 n 
+0000191195 00000 n 
+0000191431 00000 n 
+0000191710 00000 n 
+0000191938 00000 n 
+0000192089 00000 n 
+0000192237 00000 n 
+0000192391 00000 n 
+0000192562 00000 n 
+0000192710 00000 n 
+0000192843 00000 n 
+0000193109 00000 n 
+0000193236 00000 n 
+0000193366 00000 n 
+0000193502 00000 n 
+0000193626 00000 n 
+0000193750 00000 n 
+0000193880 00000 n 
+0000194010 00000 n 
+0000194158 00000 n 
+0000194288 00000 n 
+0000194471 00000 n 
+0000194625 00000 n 
+0000194773 00000 n 
+0000194909 00000 n 
+0000195083 00000 n 
+0000195326 00000 n 
+0000195450 00000 n 
+0000195653 00000 n 
+0000195768 00000 n 
+0000230892 00000 n 
+0000196046 00000 n 
+0000230961 00000 n 
+0000196214 00000 n 
+0000231030 00000 n 
+0000196356 00000 n 
+0000231099 00000 n 
+0000196487 00000 n 
+0000231167 00000 n 
+0000196635 00000 n 
+0000196757 00000 n 
+0000231236 00000 n 
+0000196929 00000 n 
+0000231305 00000 n 
+0000197033 00000 n 
+0000197161 00000 n 
+0000197291 00000 n 
+0000197439 00000 n 
+0000197575 00000 n 
+0000197705 00000 n 
+0000197965 00000 n 
+0000198184 00000 n 
+0000198385 00000 n 
+0000198538 00000 n 
+0000198668 00000 n 
+0000198798 00000 n 
+0000198922 00000 n 
+0000199126 00000 n 
+0000199335 00000 n 
+0000199578 00000 n 
+0000231373 00000 n 
+0000199776 00000 n 
+0000231442 00000 n 
+0000199925 00000 n 
+0000231511 00000 n 
+0000200086 00000 n 
+0000231580 00000 n 
+0000200247 00000 n 
+0000231649 00000 n 
+0000200390 00000 n 
+0000231716 00000 n 
+0000200556 00000 n 
+0000231785 00000 n 
+0000200770 00000 n 
+0000231854 00000 n 
+0000200960 00000 n 
+0000231923 00000 n 
+0000201144 00000 n 
+0000231991 00000 n 
+0000201346 00000 n 
+0000201551 00000 n 
+0000201753 00000 n 
+0000201902 00000 n 
+0000202033 00000 n 
+0000202220 00000 n 
+0000202399 00000 n 
+0000202557 00000 n 
+0000202735 00000 n 
+0000202898 00000 n 
+0000203035 00000 n 
+0000203232 00000 n 
+0000232060 00000 n 
+0000203479 00000 n 
+0000232127 00000 n 
+0000203672 00000 n 
+0000204011 00000 n 
+0000204195 00000 n 
+0000204507 00000 n 
+0000204691 00000 n 
+0000204860 00000 n 
+0000205045 00000 n 
+0000232194 00000 n 
+0000205274 00000 n 
+0000232261 00000 n 
+0000205455 00000 n 
+0000205636 00000 n 
+0000205826 00000 n 
+0000205993 00000 n 
+0000206145 00000 n 
+0000206306 00000 n 
+0000206590 00000 n 
+0000206730 00000 n 
+0000206903 00000 n 
+0000207108 00000 n 
+0000207293 00000 n 
+0000207441 00000 n 
+0000232329 00000 n 
+0000207673 00000 n 
+0000207951 00000 n 
+0000208112 00000 n 
+0000208322 00000 n 
+0000208432 00000 n 
+0000208557 00000 n 
+0000208706 00000 n 
+0000208855 00000 n 
+0000208980 00000 n 
+0000209105 00000 n 
+0000209230 00000 n 
+0000209355 00000 n 
+0000209498 00000 n 
+0000209623 00000 n 
+0000209766 00000 n 
+0000209891 00000 n 
+0000210022 00000 n 
+0000210165 00000 n 
+0000210302 00000 n 
+0000210457 00000 n 
+0000210618 00000 n 
+0000210764 00000 n 
+0000210999 00000 n 
+0000211168 00000 n 
+0000232398 00000 n 
+0000211398 00000 n 
+0000232467 00000 n 
+0000211526 00000 n 
+0000232534 00000 n 
+0000211657 00000 n 
+0000232603 00000 n 
+0000211782 00000 n 
+0000232672 00000 n 
+0000211919 00000 n 
+0000232739 00000 n 
+0000212050 00000 n 
+0000232806 00000 n 
+0000212181 00000 n 
+0000232874 00000 n 
+0000212330 00000 n 
+0000232941 00000 n 
+0000212461 00000 n 
+0000233010 00000 n 
+0000212645 00000 n 
+0000233077 00000 n 
+0000212800 00000 n 
+0000233146 00000 n 
+0000212937 00000 n 
+0000213106 00000 n 
+0000213421 00000 n 
+0000213608 00000 n 
+0000213751 00000 n 
+0000214044 00000 n 
+0000214246 00000 n 
+0000214472 00000 n 
+0000214668 00000 n 
+0000214831 00000 n 
+0000215024 00000 n 
+0000215255 00000 n 
+0000215462 00000 n 
+0000215669 00000 n 
+0000215881 00000 n 
+0000216159 00000 n 
+0000216408 00000 n 
+0000216615 00000 n 
+0000217079 00000 n 
+0000217254 00000 n 
+0000217538 00000 n 
+0000217713 00000 n 
+0000217862 00000 n 
+0000218058 00000 n 
+0000218324 00000 n 
+0000218455 00000 n 
+0000218675 00000 n 
+0000218907 00000 n 
+0000219120 00000 n 
+0000219295 00000 n 
+0000219411 00000 n 
+0000219524 00000 n 
+0000219633 00000 n 
+0000219749 00000 n 
+0000219860 00000 n 
+0000219974 00000 n 
+0000220081 00000 n 
+0000220193 00000 n 
+trailer
+<<
+/Size 714
+/Root 2 0 R
+/Info 4 0 R
+>>
+startxref
+233215
+%%EOF

Added: trunk/windstille/lib/SQUIRREL2/etc/minimal.c
===================================================================
--- trunk/windstille/lib/SQUIRREL2/etc/minimal.c	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/etc/minimal.c	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,63 @@
+#include <stdarg.h> 
+#include <stdio.h> 
+
+#include <squirrel.h> 
+#include <sqstdio.h> 
+#include <sqstdaux.h> 
+
+#ifdef _MSC_VER
+#pragma comment (lib ,"squirrel.lib")
+#pragma comment (lib ,"sqstdlib.lib")
+#endif
+
+#ifdef SQUNICODE 
+#define scvprintf vwprintf 
+#else 
+#define scvprintf vprintf 
+#endif 
+
+void printfunc(HSQUIRRELVM v, const SQChar *s, ...) 
+{ 
+va_list arglist; 
+va_start(arglist, s); 
+scvprintf(s, arglist); 
+va_end(arglist); 
+} 
+
+void call_foo(HSQUIRRELVM v, int n,float f,const SQChar *s)
+{
+	SQInteger top = sq_gettop(v); //saves the stack size before the call
+	sq_pushroottable(v); //pushes the global table
+	sq_pushstring(v,_SC("foo"),-1);
+	if(SQ_SUCCEEDED(sq_get(v,-2))) { //gets the field 'foo' from the global table
+		sq_pushroottable(v); //push the 'this' (in this case is the global table)
+		sq_pushinteger(v,n); 
+		sq_pushfloat(v,f);
+		sq_pushstring(v,s,-1);
+		sq_call(v,4,SQFalse,SQTrue); //calls the function 
+	}
+	sq_settop(v,top); //restores the original stack size
+}
+
+int main(int argc, char* argv[]) 
+{ 
+	HSQUIRRELVM v; 
+	v = sq_open(1024); // creates a VM with initial stack size 1024 
+
+	//sq_pushroottable(v); //push the root table were to register the lib function
+	//sqstd_register_iolib(v); 
+	sqstd_seterrorhandlers(v); //registers the default error handlers
+
+	sq_setprintfunc(v, printfunc); //sets the print function
+
+	sq_pushroottable(v); //push the root table(were the globals of the script will be stored)
+	if(SQ_SUCCEEDED(sqstd_dofile(v, _SC("test.nut"), SQFalse, SQTrue))) // also prints syntax errors if any 
+	{
+		call_foo(v,1,2.5,_SC("teststring"));
+	}
+
+	sq_pop(v,1); //pops the root table
+	sq_close(v); 
+
+	return 0; 
+} 

Added: trunk/windstille/lib/SQUIRREL2/etc/test.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/etc/test.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/etc/test.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,4 @@
+function foo(i, f, s) 
+{ 
+    print("Called foo(), i="+i+", f="+f+", s='"+s+"'\n"); 
+} 

Added: trunk/windstille/lib/SQUIRREL2/include/sqstdaux.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/include/sqstdaux.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/include/sqstdaux.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,16 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQSTD_AUXLIB_H_
+#define _SQSTD_AUXLIB_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+SQUIRREL_API void sqstd_seterrorhandlers(HSQUIRRELVM v);
+SQUIRREL_API void sqstd_printcallstack(HSQUIRRELVM v);
+
+#ifdef __cplusplus
+} /*extern "C"*/
+#endif
+
+#endif /* _SQSTD_AUXLIB_H_ */

Added: trunk/windstille/lib/SQUIRREL2/include/sqstdblob.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/include/sqstdblob.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/include/sqstdblob.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,20 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQSTDBLOB_H_
+#define _SQSTDBLOB_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+SQUIRREL_API SQUserPointer sqstd_createblob(HSQUIRRELVM v, SQInteger size);
+SQUIRREL_API SQRESULT sqstd_getblob(HSQUIRRELVM v,SQInteger idx,SQUserPointer *ptr);
+SQUIRREL_API SQInteger sqstd_getblobsize(HSQUIRRELVM v,SQInteger idx);
+
+SQUIRREL_API SQRESULT sqstd_register_bloblib(HSQUIRRELVM v);
+
+#ifdef __cplusplus
+} /*extern "C"*/
+#endif
+
+#endif /*_SQSTDBLOB_H_*/
+

Added: trunk/windstille/lib/SQUIRREL2/include/sqstdio.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/include/sqstdio.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/include/sqstdio.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,53 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQSTDIO_H_
+#define _SQSTDIO_H_
+
+#ifdef __cplusplus
+
+#define SQSTD_STREAM_TYPE_TAG 0x80000000
+
+struct SQStream {
+	virtual SQInteger Read(void *buffer, SQInteger size) = 0;
+	virtual SQInteger Write(void *buffer, SQInteger size) = 0;
+	virtual SQInteger Flush() = 0;
+	virtual SQInteger Tell() = 0;
+	virtual SQInteger Len() = 0;
+	virtual SQInteger Seek(SQInteger offset, SQInteger origin) = 0;
+	virtual bool IsValid() = 0;
+	virtual bool EOS() = 0;
+};
+
+extern "C" {
+#endif
+
+#define SQ_SEEK_CUR 0
+#define SQ_SEEK_END 1
+#define SQ_SEEK_SET 2
+
+typedef void* SQFILE;
+
+SQUIRREL_API SQFILE sqstd_fopen(const SQChar *,const SQChar *);
+SQUIRREL_API SQInteger sqstd_fread(SQUserPointer, SQInteger, SQInteger, SQFILE);
+SQUIRREL_API SQInteger sqstd_fwrite(const SQUserPointer, SQInteger, SQInteger, SQFILE);
+SQUIRREL_API SQInteger sqstd_fseek(SQFILE , SQInteger , SQInteger);
+SQUIRREL_API SQInteger sqstd_ftell(SQFILE);
+SQUIRREL_API SQInteger sqstd_fflush(SQFILE);
+SQUIRREL_API SQInteger sqstd_fclose(SQFILE);
+SQUIRREL_API SQInteger sqstd_feof(SQFILE);
+
+SQUIRREL_API SQRESULT sqstd_createfile(HSQUIRRELVM v, SQFILE file,SQBool own);
+SQUIRREL_API SQRESULT sqstd_getfile(HSQUIRRELVM v, SQInteger idx, SQFILE *file);
+
+//compiler helpers
+SQUIRREL_API SQRESULT sqstd_loadfile(HSQUIRRELVM v,const SQChar *filename,SQBool printerror);
+SQUIRREL_API SQRESULT sqstd_dofile(HSQUIRRELVM v,const SQChar *filename,SQBool retval,SQBool printerror);
+SQUIRREL_API SQRESULT sqstd_writeclosuretofile(HSQUIRRELVM v,const SQChar *filename);
+
+SQUIRREL_API SQRESULT sqstd_register_iolib(HSQUIRRELVM v);
+
+#ifdef __cplusplus
+} /*extern "C"*/
+#endif
+
+#endif /*_SQSTDIO_H_*/
+

Added: trunk/windstille/lib/SQUIRREL2/include/sqstdmath.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/include/sqstdmath.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/include/sqstdmath.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,15 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQSTD_MATH_H_
+#define _SQSTD_MATH_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+SQUIRREL_API SQRESULT sqstd_register_mathlib(HSQUIRRELVM v);
+
+#ifdef __cplusplus
+} /*extern "C"*/
+#endif
+
+#endif /*_SQSTD_MATH_H_*/

Added: trunk/windstille/lib/SQUIRREL2/include/sqstdstring.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/include/sqstdstring.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/include/sqstdstring.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,31 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQSTD_STRING_H_
+#define _SQSTD_STRING_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef unsigned int SQRexBool;
+typedef struct SQRex SQRex;
+
+typedef struct {
+	const SQChar *begin;
+	SQInteger len;
+} SQRexMatch;
+
+SQUIRREL_API SQRex *sqstd_rex_compile(const SQChar *pattern,const SQChar **error);
+SQUIRREL_API void sqstd_rex_free(SQRex *exp);
+SQUIRREL_API SQBool sqstd_rex_match(SQRex* exp,const SQChar* text);
+SQUIRREL_API SQBool sqstd_rex_search(SQRex* exp,const SQChar* text, const SQChar** out_begin, const SQChar** out_end);
+SQUIRREL_API SQBool sqstd_rex_searchrange(SQRex* exp,const SQChar* text_begin,const SQChar* text_end,const SQChar** out_begin, const SQChar** out_end);
+SQUIRREL_API SQInteger sqstd_rex_getsubexpcount(SQRex* exp);
+SQUIRREL_API SQBool sqstd_rex_getsubexp(SQRex* exp, SQInteger n, SQRexMatch *subexp);
+
+SQUIRREL_API SQRESULT sqstd_register_stringlib(HSQUIRRELVM v);
+
+#ifdef __cplusplus
+} /*extern "C"*/
+#endif
+
+#endif /*_SQSTD_STRING_H_*/

Added: trunk/windstille/lib/SQUIRREL2/include/sqstdsystem.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/include/sqstdsystem.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/include/sqstdsystem.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,15 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQSTD_SYSTEMLIB_H_
+#define _SQSTD_SYSTEMLIB_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+SQUIRREL_API SQInteger sqstd_register_systemlib(HSQUIRRELVM v);
+
+#ifdef __cplusplus
+} /*extern "C"*/
+#endif
+
+#endif /* _SQSTD_SYSTEMLIB_H_ */

Added: trunk/windstille/lib/SQUIRREL2/include/squirrel.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/include/squirrel.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/include/squirrel.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,424 @@
+/*
+Copyright (c) 2003-2008 Alberto Demichelis
+
+This software is provided 'as-is', without any 
+express or implied warranty. In no event will the 
+authors be held liable for any damages arising from 
+the use of this software.
+
+Permission is granted to anyone to use this software 
+for any purpose, including commercial applications, 
+and to alter it and redistribute it freely, subject 
+to the following restrictions:
+
+		1. The origin of this software must not be 
+		misrepresented; you must not claim that 
+		you wrote the original software. If you 
+		use this software in a product, an 
+		acknowledgment in the product 
+		documentation would be appreciated but is 
+		not required.
+
+		2. Altered source versions must be plainly 
+		marked as such, and must not be 
+		misrepresented as being the original 
+		software.
+
+		3. This notice may not be removed or 
+		altered from any source distribution.
+
+*/
+#ifndef _SQUIRREL_H_
+#define _SQUIRREL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef SQUIRREL_API
+#define SQUIRREL_API extern
+#endif
+
+#ifdef _SQ64
+#ifdef _MSC_VER
+typedef __int64 SQInteger;
+typedef unsigned __int64 SQUnsignedInteger;
+typedef unsigned __int64 SQHash; /*should be the same size of a pointer*/
+#else
+typedef long SQInteger;
+typedef unsigned long SQUnsignedInteger;
+typedef unsigned long SQHash; /*should be the same size of a pointer*/
+#endif
+typedef int SQInt32; 
+#else 
+typedef int SQInteger;
+typedef int SQInt32; /*must be 32 bits(also on 64bits processors)*/
+typedef unsigned int SQUnsignedInteger;
+typedef unsigned int SQHash; /*should be the same size of a pointer*/
+#endif
+
+
+typedef float SQFloat;
+typedef void* SQUserPointer;
+typedef SQUnsignedInteger SQBool;
+typedef SQInteger SQRESULT;
+
+#define SQTrue	(1)
+#define SQFalse	(0)
+
+struct SQVM;
+struct SQTable;
+struct SQArray;
+struct SQString;
+struct SQClosure;
+struct SQGenerator;
+struct SQNativeClosure;
+struct SQUserData;
+struct SQFunctionProto;
+struct SQRefCounted;
+struct SQClass;
+struct SQInstance;
+struct SQDelegable;
+
+#ifdef _UNICODE
+#define SQUNICODE
+#endif
+
+#ifdef SQUNICODE
+#if (defined(_MSC_VER) && _MSC_VER >= 1400) // 1400 = VS8
+
+#if defined(wchar_t) //this is if the compiler considers wchar_t as native type
+#define wchar_t unsigned short
+#endif
+
+#else
+typedef unsigned short wchar_t;
+#endif
+
+typedef wchar_t SQChar;
+#define _SC(a) L##a
+#define	scstrcmp	wcscmp
+#define scsprintf	swprintf
+#define scstrlen	wcslen
+#define scstrtod	wcstod
+#define scstrtol	wcstol
+#define scatoi		_wtoi
+#define scstrtoul	wcstoul
+#define scvsprintf	vswprintf
+#define scstrstr	wcsstr
+#define scisspace	iswspace
+#define scisdigit	iswdigit
+#define scisxdigit	iswxdigit
+#define scisalpha	iswalpha
+#define sciscntrl	iswcntrl
+#define scisalnum	iswalnum
+#define scprintf	wprintf
+#define MAX_CHAR 0xFFFF
+#else
+typedef char SQChar;
+#define _SC(a) a
+#define	scstrcmp	strcmp
+#define scsprintf	sprintf
+#define scstrlen	strlen
+#define scstrtod	strtod
+#define scstrtol	strtol
+#define scatoi		atoi
+#define scstrtoul	strtoul
+#define scvsprintf	vsprintf
+#define scstrstr	strstr
+#define scisspace	isspace
+#define scisdigit	isdigit
+#define scisxdigit	isxdigit
+#define sciscntrl	iscntrl
+#define scisalpha	isalpha
+#define scisalnum	isalnum
+#define scprintf	printf
+#define MAX_CHAR 0xFF
+#endif
+
+#define SQUIRREL_VERSION	_SC("Squirrel 2.2.1 stable")
+#define SQUIRREL_COPYRIGHT	_SC("Copyright (C) 2003-2008 Alberto Demichelis")
+#define SQUIRREL_AUTHOR		_SC("Alberto Demichelis")
+
+#define SQ_VMSTATE_IDLE			0
+#define SQ_VMSTATE_RUNNING		1
+#define SQ_VMSTATE_SUSPENDED	2
+
+#define SQUIRREL_EOB 0
+#define SQ_BYTECODE_STREAM_TAG	0xFAFA
+
+#define SQOBJECT_REF_COUNTED	0x08000000
+#define SQOBJECT_NUMERIC		0x04000000
+#define SQOBJECT_DELEGABLE		0x02000000
+#define SQOBJECT_CANBEFALSE		0x01000000
+
+#define SQ_MATCHTYPEMASKSTRING (-99999)
+
+#define _RT_MASK 0x00FFFFFF
+#define _RAW_TYPE(type) (type&_RT_MASK)
+
+#define _RT_NULL			0x00000001
+#define _RT_INTEGER			0x00000002
+#define _RT_FLOAT			0x00000004
+#define _RT_BOOL			0x00000008
+#define _RT_STRING			0x00000010
+#define _RT_TABLE			0x00000020
+#define _RT_ARRAY			0x00000040
+#define _RT_USERDATA		0x00000080
+#define _RT_CLOSURE			0x00000100
+#define _RT_NATIVECLOSURE	0x00000200
+#define _RT_GENERATOR		0x00000400
+#define _RT_USERPOINTER		0x00000800
+#define _RT_THREAD			0x00001000
+#define _RT_FUNCPROTO		0x00002000
+#define _RT_CLASS			0x00004000
+#define _RT_INSTANCE		0x00008000
+#define _RT_WEAKREF			0x00010000
+
+typedef enum tagSQObjectType{
+	OT_NULL =			(_RT_NULL|SQOBJECT_CANBEFALSE),
+	OT_INTEGER =		(_RT_INTEGER|SQOBJECT_NUMERIC|SQOBJECT_CANBEFALSE),
+	OT_FLOAT =			(_RT_FLOAT|SQOBJECT_NUMERIC|SQOBJECT_CANBEFALSE),
+	OT_BOOL =			(_RT_BOOL|SQOBJECT_CANBEFALSE),
+	OT_STRING =			(_RT_STRING|SQOBJECT_REF_COUNTED),
+	OT_TABLE =			(_RT_TABLE|SQOBJECT_REF_COUNTED|SQOBJECT_DELEGABLE),
+	OT_ARRAY =			(_RT_ARRAY|SQOBJECT_REF_COUNTED),
+	OT_USERDATA =		(_RT_USERDATA|SQOBJECT_REF_COUNTED|SQOBJECT_DELEGABLE),
+	OT_CLOSURE =		(_RT_CLOSURE|SQOBJECT_REF_COUNTED),
+	OT_NATIVECLOSURE =	(_RT_NATIVECLOSURE|SQOBJECT_REF_COUNTED),
+	OT_GENERATOR =		(_RT_GENERATOR|SQOBJECT_REF_COUNTED),
+	OT_USERPOINTER =	_RT_USERPOINTER,
+	OT_THREAD =			(_RT_THREAD|SQOBJECT_REF_COUNTED) ,
+	OT_FUNCPROTO =		(_RT_FUNCPROTO|SQOBJECT_REF_COUNTED), //internal usage only
+	OT_CLASS =			(_RT_CLASS|SQOBJECT_REF_COUNTED),
+	OT_INSTANCE =		(_RT_INSTANCE|SQOBJECT_REF_COUNTED|SQOBJECT_DELEGABLE),
+	OT_WEAKREF =		(_RT_WEAKREF|SQOBJECT_REF_COUNTED)
+}SQObjectType;
+
+#define ISREFCOUNTED(t) (t&SQOBJECT_REF_COUNTED)
+
+
+typedef union tagSQObjectValue
+{
+	struct SQTable *pTable;
+	struct SQArray *pArray;
+	struct SQClosure *pClosure;
+	struct SQGenerator *pGenerator;
+	struct SQNativeClosure *pNativeClosure;
+	struct SQString *pString;
+	struct SQUserData *pUserData;
+	SQInteger nInteger;
+	SQFloat fFloat;
+	SQUserPointer pUserPointer;
+	struct SQFunctionProto *pFunctionProto;
+	struct SQRefCounted *pRefCounted;
+	struct SQDelegable *pDelegable;
+	struct SQVM *pThread;
+	struct SQClass *pClass;
+	struct SQInstance *pInstance;
+	struct SQWeakRef *pWeakRef;
+}SQObjectValue;
+
+
+typedef struct tagSQObject
+{
+	SQObjectType _type;
+	SQObjectValue _unVal;
+}SQObject;
+
+typedef struct tagSQStackInfos{
+	const SQChar* funcname;
+	const SQChar* source;
+	SQInteger line;
+}SQStackInfos;
+
+typedef struct SQVM* HSQUIRRELVM;
+typedef SQObject HSQOBJECT;
+typedef SQInteger (*SQFUNCTION)(HSQUIRRELVM);
+typedef SQInteger (*SQRELEASEHOOK)(SQUserPointer,SQInteger size);
+typedef void (*SQCOMPILERERROR)(HSQUIRRELVM,const SQChar * /*desc*/,const SQChar * /*source*/,SQInteger /*line*/,SQInteger /*column*/);
+typedef void (*SQPRINTFUNCTION)(HSQUIRRELVM,const SQChar * ,...);
+
+typedef SQInteger (*SQWRITEFUNC)(SQUserPointer,SQUserPointer,SQInteger);
+typedef SQInteger (*SQREADFUNC)(SQUserPointer,SQUserPointer,SQInteger);
+
+typedef SQInteger (*SQLEXREADFUNC)(SQUserPointer);
+
+typedef struct tagSQRegFunction{
+	const SQChar *name;
+	SQFUNCTION f;
+	SQInteger nparamscheck;
+	const SQChar *typemask;
+}SQRegFunction;
+
+/*vm*/
+SQUIRREL_API HSQUIRRELVM sq_open(SQInteger initialstacksize);
+SQUIRREL_API HSQUIRRELVM sq_newthread(HSQUIRRELVM friendvm, SQInteger initialstacksize);
+SQUIRREL_API void sq_seterrorhandler(HSQUIRRELVM v);
+SQUIRREL_API void sq_close(HSQUIRRELVM v);
+SQUIRREL_API void sq_setforeignptr(HSQUIRRELVM v,SQUserPointer p);
+SQUIRREL_API SQUserPointer sq_getforeignptr(HSQUIRRELVM v);
+SQUIRREL_API void sq_setprintfunc(HSQUIRRELVM v, SQPRINTFUNCTION printfunc);
+SQUIRREL_API SQPRINTFUNCTION sq_getprintfunc(HSQUIRRELVM v);
+SQUIRREL_API SQRESULT sq_suspendvm(HSQUIRRELVM v);
+SQUIRREL_API SQRESULT sq_wakeupvm(HSQUIRRELVM v,SQBool resumedret,SQBool retval,SQBool raiseerror);
+SQUIRREL_API SQInteger sq_getvmstate(HSQUIRRELVM v);
+
+/*compiler*/
+SQUIRREL_API SQRESULT sq_compile(HSQUIRRELVM v,SQLEXREADFUNC read,SQUserPointer p,const SQChar *sourcename,SQBool raiseerror);
+SQUIRREL_API SQRESULT sq_compilebuffer(HSQUIRRELVM v,const SQChar *s,SQInteger size,const SQChar *sourcename,SQBool raiseerror);
+SQUIRREL_API void sq_enabledebuginfo(HSQUIRRELVM v, SQBool enable);
+SQUIRREL_API void sq_notifyallexceptions(HSQUIRRELVM v, SQBool enable);
+SQUIRREL_API void sq_setcompilererrorhandler(HSQUIRRELVM v,SQCOMPILERERROR f);
+
+/*stack operations*/
+SQUIRREL_API void sq_push(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API void sq_pop(HSQUIRRELVM v,SQInteger nelemstopop);
+SQUIRREL_API void sq_poptop(HSQUIRRELVM v);
+SQUIRREL_API void sq_remove(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQInteger sq_gettop(HSQUIRRELVM v);
+SQUIRREL_API void sq_settop(HSQUIRRELVM v,SQInteger newtop);
+SQUIRREL_API void sq_reservestack(HSQUIRRELVM v,SQInteger nsize);
+SQUIRREL_API SQInteger sq_cmp(HSQUIRRELVM v);
+SQUIRREL_API void sq_move(HSQUIRRELVM dest,HSQUIRRELVM src,SQInteger idx);
+
+/*object creation handling*/
+SQUIRREL_API SQUserPointer sq_newuserdata(HSQUIRRELVM v,SQUnsignedInteger size);
+SQUIRREL_API void sq_newtable(HSQUIRRELVM v);
+SQUIRREL_API void sq_newarray(HSQUIRRELVM v,SQInteger size);
+SQUIRREL_API void sq_newclosure(HSQUIRRELVM v,SQFUNCTION func,SQUnsignedInteger nfreevars);
+SQUIRREL_API SQRESULT sq_setparamscheck(HSQUIRRELVM v,SQInteger nparamscheck,const SQChar *typemask);
+SQUIRREL_API SQRESULT sq_bindenv(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API void sq_pushstring(HSQUIRRELVM v,const SQChar *s,SQInteger len);
+SQUIRREL_API void sq_pushfloat(HSQUIRRELVM v,SQFloat f);
+SQUIRREL_API void sq_pushinteger(HSQUIRRELVM v,SQInteger n);
+SQUIRREL_API void sq_pushbool(HSQUIRRELVM v,SQBool b);
+SQUIRREL_API void sq_pushuserpointer(HSQUIRRELVM v,SQUserPointer p);
+SQUIRREL_API void sq_pushnull(HSQUIRRELVM v);
+SQUIRREL_API SQObjectType sq_gettype(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQInteger sq_getsize(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_getbase(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQBool sq_instanceof(HSQUIRRELVM v);
+SQUIRREL_API void sq_tostring(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API void sq_tobool(HSQUIRRELVM v, SQInteger idx, SQBool *b);
+SQUIRREL_API SQRESULT sq_getstring(HSQUIRRELVM v,SQInteger idx,const SQChar **c);
+SQUIRREL_API SQRESULT sq_getinteger(HSQUIRRELVM v,SQInteger idx,SQInteger *i);
+SQUIRREL_API SQRESULT sq_getfloat(HSQUIRRELVM v,SQInteger idx,SQFloat *f);
+SQUIRREL_API SQRESULT sq_getbool(HSQUIRRELVM v,SQInteger idx,SQBool *b);
+SQUIRREL_API SQRESULT sq_getthread(HSQUIRRELVM v,SQInteger idx,HSQUIRRELVM *thread);
+SQUIRREL_API SQRESULT sq_getuserpointer(HSQUIRRELVM v,SQInteger idx,SQUserPointer *p);
+SQUIRREL_API SQRESULT sq_getuserdata(HSQUIRRELVM v,SQInteger idx,SQUserPointer *p,SQUserPointer *typetag);
+SQUIRREL_API SQRESULT sq_settypetag(HSQUIRRELVM v,SQInteger idx,SQUserPointer typetag);
+SQUIRREL_API SQRESULT sq_gettypetag(HSQUIRRELVM v,SQInteger idx,SQUserPointer *typetag);
+SQUIRREL_API void sq_setreleasehook(HSQUIRRELVM v,SQInteger idx,SQRELEASEHOOK hook);
+SQUIRREL_API SQChar *sq_getscratchpad(HSQUIRRELVM v,SQInteger minsize);
+SQUIRREL_API SQRESULT sq_getclosureinfo(HSQUIRRELVM v,SQInteger idx,SQUnsignedInteger *nparams,SQUnsignedInteger *nfreevars);
+SQUIRREL_API SQRESULT sq_setnativeclosurename(HSQUIRRELVM v,SQInteger idx,const SQChar *name);
+SQUIRREL_API SQRESULT sq_setinstanceup(HSQUIRRELVM v, SQInteger idx, SQUserPointer p);
+SQUIRREL_API SQRESULT sq_getinstanceup(HSQUIRRELVM v, SQInteger idx, SQUserPointer *p,SQUserPointer typetag);
+SQUIRREL_API SQRESULT sq_setclassudsize(HSQUIRRELVM v, SQInteger idx, SQInteger udsize);
+SQUIRREL_API SQRESULT sq_newclass(HSQUIRRELVM v,SQBool hasbase);
+SQUIRREL_API SQRESULT sq_createinstance(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_setattributes(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_getattributes(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_getclass(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API void sq_weakref(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_getdefaultdelegate(HSQUIRRELVM v,SQObjectType t);
+
+/*object manipulation*/
+SQUIRREL_API void sq_pushroottable(HSQUIRRELVM v);
+SQUIRREL_API void sq_pushregistrytable(HSQUIRRELVM v);
+SQUIRREL_API void sq_pushconsttable(HSQUIRRELVM v);
+SQUIRREL_API SQRESULT sq_setroottable(HSQUIRRELVM v);
+SQUIRREL_API SQRESULT sq_setconsttable(HSQUIRRELVM v);
+SQUIRREL_API SQRESULT sq_newslot(HSQUIRRELVM v, SQInteger idx, SQBool bstatic);
+SQUIRREL_API SQRESULT sq_deleteslot(HSQUIRRELVM v,SQInteger idx,SQBool pushval);
+SQUIRREL_API SQRESULT sq_set(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_get(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_rawget(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_rawset(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_rawdeleteslot(HSQUIRRELVM v,SQInteger idx,SQBool pushval);
+SQUIRREL_API SQRESULT sq_arrayappend(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_arraypop(HSQUIRRELVM v,SQInteger idx,SQBool pushval); 
+SQUIRREL_API SQRESULT sq_arrayresize(HSQUIRRELVM v,SQInteger idx,SQInteger newsize); 
+SQUIRREL_API SQRESULT sq_arrayreverse(HSQUIRRELVM v,SQInteger idx); 
+SQUIRREL_API SQRESULT sq_setdelegate(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_getdelegate(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_clone(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_setfreevariable(HSQUIRRELVM v,SQInteger idx,SQUnsignedInteger nval);
+SQUIRREL_API SQRESULT sq_next(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_getweakrefval(HSQUIRRELVM v,SQInteger idx);
+SQUIRREL_API SQRESULT sq_clear(HSQUIRRELVM v,SQInteger idx);
+
+/*calls*/
+SQUIRREL_API SQRESULT sq_call(HSQUIRRELVM v,SQInteger params,SQBool retval,SQBool raiseerror);
+SQUIRREL_API SQRESULT sq_resume(HSQUIRRELVM v,SQBool retval,SQBool raiseerror);
+SQUIRREL_API const SQChar *sq_getlocal(HSQUIRRELVM v,SQUnsignedInteger level,SQUnsignedInteger idx);
+SQUIRREL_API const SQChar *sq_getfreevariable(HSQUIRRELVM v,SQInteger idx,SQUnsignedInteger nval);
+SQUIRREL_API SQRESULT sq_throwerror(HSQUIRRELVM v,const SQChar *err);
+SQUIRREL_API void sq_reseterror(HSQUIRRELVM v);
+SQUIRREL_API void sq_getlasterror(HSQUIRRELVM v);
+
+/*raw object handling*/
+SQUIRREL_API SQRESULT sq_getstackobj(HSQUIRRELVM v,SQInteger idx,HSQOBJECT *po);
+SQUIRREL_API void sq_pushobject(HSQUIRRELVM v,HSQOBJECT obj);
+SQUIRREL_API void sq_addref(HSQUIRRELVM v,HSQOBJECT *po);
+SQUIRREL_API SQBool sq_release(HSQUIRRELVM v,HSQOBJECT *po);
+SQUIRREL_API void sq_resetobject(HSQOBJECT *po);
+SQUIRREL_API const SQChar *sq_objtostring(HSQOBJECT *o);
+SQUIRREL_API SQBool sq_objtobool(HSQOBJECT *o);
+SQUIRREL_API SQInteger sq_objtointeger(HSQOBJECT *o);
+SQUIRREL_API SQFloat sq_objtofloat(HSQOBJECT *o);
+SQUIRREL_API SQRESULT sq_getobjtypetag(HSQOBJECT *o,SQUserPointer * typetag);
+
+/*GC*/
+SQUIRREL_API SQInteger sq_collectgarbage(HSQUIRRELVM v);
+
+/*serialization*/
+SQUIRREL_API SQRESULT sq_writeclosure(HSQUIRRELVM vm,SQWRITEFUNC writef,SQUserPointer up);
+SQUIRREL_API SQRESULT sq_readclosure(HSQUIRRELVM vm,SQREADFUNC readf,SQUserPointer up);
+
+/*mem allocation*/
+SQUIRREL_API void *sq_malloc(SQUnsignedInteger size);
+SQUIRREL_API void *sq_realloc(void* p,SQUnsignedInteger oldsize,SQUnsignedInteger newsize);
+SQUIRREL_API void sq_free(void *p,SQUnsignedInteger size);
+
+/*debug*/
+SQUIRREL_API SQRESULT sq_stackinfos(HSQUIRRELVM v,SQInteger level,SQStackInfos *si);
+SQUIRREL_API void sq_setdebughook(HSQUIRRELVM v);
+
+/*UTILITY MACRO*/
+#define sq_isnumeric(o) ((o)._type&SQOBJECT_NUMERIC)
+#define sq_istable(o) ((o)._type==OT_TABLE)
+#define sq_isarray(o) ((o)._type==OT_ARRAY)
+#define sq_isfunction(o) ((o)._type==OT_FUNCPROTO)
+#define sq_isclosure(o) ((o)._type==OT_CLOSURE)
+#define sq_isgenerator(o) ((o)._type==OT_GENERATOR)
+#define sq_isnativeclosure(o) ((o)._type==OT_NATIVECLOSURE)
+#define sq_isstring(o) ((o)._type==OT_STRING)
+#define sq_isinteger(o) ((o)._type==OT_INTEGER)
+#define sq_isfloat(o) ((o)._type==OT_FLOAT)
+#define sq_isuserpointer(o) ((o)._type==OT_USERPOINTER)
+#define sq_isuserdata(o) ((o)._type==OT_USERDATA)
+#define sq_isthread(o) ((o)._type==OT_THREAD)
+#define sq_isnull(o) ((o)._type==OT_NULL)
+#define sq_isclass(o) ((o)._type==OT_CLASS)
+#define sq_isinstance(o) ((o)._type==OT_INSTANCE)
+#define sq_isbool(o) ((o)._type==OT_BOOL)
+#define sq_isweakref(o) ((o)._type==OT_WEAKREF)
+#define sq_type(o) ((o)._type)
+
+/* deprecated */
+#define sq_createslot(v,n) sq_newslot(v,n,SQFalse)
+
+#define SQ_OK (0)
+#define SQ_ERROR (-1)
+
+#define SQ_FAILED(res) (res<0)
+#define SQ_SUCCEEDED(res) (res>=0)
+
+#ifdef __cplusplus
+} /*extern "C"*/
+#endif
+
+#endif /*_SQUIRREL_H_*/

Added: trunk/windstille/lib/SQUIRREL2/samples/ackermann.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/ackermann.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/ackermann.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,23 @@
+/*
+*
+* Original Javascript version by David Hedbor(http://www.bagley.org/~doug/shootout/)
+*
+*/
+
+function Ack(M, N) {
+    if (M == 0) return( N + 1 );
+    if (N == 0) return( Ack(M - 1, 1) );
+    return( Ack(M - 1, Ack(M, (N - 1))) );
+}
+
+local n;
+
+if(ARGS.len()!=0) {
+   n = ARGS[0].tointeger();
+  if(n < 1) n = 1;
+} else {   
+  n = 1;
+}
+print("n="+n+"\n");
+print("Ack(3,"+ n+ "):"+ Ack(3, n));
+

Added: trunk/windstille/lib/SQUIRREL2/samples/array.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/array.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/array.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,29 @@
+/*
+*
+* Original Javascript version by David Hedbor(http://www.bagley.org/~doug/shootout/)
+*
+*/
+local n, i, k;
+
+if(ARGS.len()!=0) {
+   n = ARGS[0].tointeger();
+  if(n < 1) n = 1;
+} else {   
+  n = 1;
+}
+
+local x = []; x.resize(n);
+local y = []; y.resize(n);
+
+for (i = 0; i < n; i+=1) {
+  x[i] = i + 1;
+  y[i] = 0; 
+}
+
+for (k = 0 ; k < n; k+=1) {
+  for (i = n-1; i >= 0; i-=1) {
+	y[i] = y[i]+ x[i];
+  }
+}
+print(y[0].tostring()+" "+y[n-1]);
+

Added: trunk/windstille/lib/SQUIRREL2/samples/class.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/class.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/class.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,49 @@
+//////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////
+class BaseVector {
+	constructor(...)
+	{
+		if(vargc >= 3) {
+			x = vargv[0];
+			y = vargv[1];
+			z = vargv[2];
+		}
+	}
+	
+	
+	x = 0;
+	y = 0;
+	z = 0;
+}
+
+class Vector3 extends BaseVector {
+	function _add(other)
+	{
+		if(other instanceof this.getclass())
+			return ::Vector3(x+other.x,y+other.y,z+other.z);
+		else
+			throw "wrong parameter";
+	}
+	function Print()
+	{
+		::print(x+","+y+","+z+"\n");
+	}
+}
+
+local v0 = Vector3(1,2,3)
+local v1 = Vector3(11,12,13)
+local v2 = v0 + v1;
+v2.Print();
+
+FakeNamespace <- {
+	Utils = {}
+}
+
+class FakeNamespace.Utils.SuperClass {
+	constructor()
+	{
+		::print("FakeNamespace.Utils.SuperClass")
+	}
+}
+
+local testy = FakeNamespace.Utils.SuperClass();
\ No newline at end of file

Added: trunk/windstille/lib/SQUIRREL2/samples/classattributes.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/classattributes.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/classattributes.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,35 @@
+class Foo {
+	//constructor
+	constructor(a)
+	{
+		testy = ["stuff",1,2,3];
+	}
+	//attributes of PrintTesty
+	</ test = "freakin attribute"/>
+	function PrintTesty()
+	{
+		foreach(i,val in testy)
+		{
+			::print("idx = "+i+" = "+val+" \n");
+		}
+	}
+	//attributes of testy
+	</ flippy = 10 , second = [1,2,3] />
+	testy = null;
+	
+}
+
+foreach(member,val in Foo)
+{
+	::print(member+"\n");
+	local attr;
+	if((attr = Foo.getattributes(member)) != null) {
+		foreach(i,v in attr)
+		{
+			::print("\t"+i+" = "+(typeof v)+"\n");
+		}
+	}
+	else {
+		::print("\t<no attributes>\n")
+	}
+}
\ No newline at end of file

Added: trunk/windstille/lib/SQUIRREL2/samples/coroutines.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/coroutines.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/coroutines.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,25 @@
+function coroutine_test(a,b)
+{
+	::print(a+" "+b+"\n");
+	local ret = ::suspend("suspend 1");
+	::print("the coroutine says "+ret+"\n");
+	ret = ::suspend("suspend 2");
+	::print("the coroutine says "+ret+"\n");
+	ret = ::suspend("suspend 3");
+	::print("the coroutine says "+ret+"\n");
+	return "I'm done"
+}
+
+local coro = ::newthread(coroutine_test);
+
+local susparam = coro.call("test","coroutine"); //starts the coroutine
+
+local i = 1;
+do
+{
+	::print("suspend passed ["+susparam+"]\n")
+	susparam = coro.wakeup("ciao "+i);
+	++i;
+}while(coro.getstatus()=="suspended")
+
+::print("return passed ["+susparam+"]\n")
\ No newline at end of file

Added: trunk/windstille/lib/SQUIRREL2/samples/delegation.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/delegation.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/delegation.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,52 @@
+
+PEntity <- {
+	name="noname"
+	pos={x=0,y=0,z=0}
+	type="entity"
+	//methamethod
+	_typeof=function()
+	{
+		return type;
+	}
+}
+
+function PEntity::PrintPos()
+{
+	::print("x="+pos.x+" y="+pos.y+" z="+pos.z+"\n");	
+}
+
+function PEntity::new(name,pos)
+{
+	local newentity=clone ::PEntity;
+	if(name)
+		newentity.name=name;
+	if(pos)
+		newentity.pos=pos;
+	return newentity;
+}
+
+PPlayer <- {
+	model="warrior.mdl"
+	weapon="fist"
+	health=100
+	armor=0
+	//overrides the parent type
+	type="player"
+}
+
+function PPlayer::new(name,pos)
+{
+	local newplayer=delegate ::PEntity.new(name,pos) : clone ::PPlayer;
+	return newplayer;
+}
+
+local player=PPlayer.new("godzilla",{x=10,y=20,z=30});
+
+::print("PLAYER NAME"+player.name+"\n");
+::print("ENTITY TYPE"+typeof player+"\n");
+
+player.PrintPos();
+
+player.pos.x=123;
+
+player.PrintPos();
\ No newline at end of file

Added: trunk/windstille/lib/SQUIRREL2/samples/fibonacci.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/fibonacci.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/fibonacci.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,15 @@
+/*
+*
+* Original Javascript version by David Hedbor(http://www.bagley.org/~doug/shootout/)
+*
+*/
+
+function fib(n)
+{
+    if (n < 2) return 1
+    return fib(n-2) + fib(n-1) 
+}
+
+local n = ARGS.len()!=0?ARGS[0].tointeger():1
+
+print(fib(n)+"\n")

Added: trunk/windstille/lib/SQUIRREL2/samples/flow.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/flow.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/flow.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,33 @@
+function min(x,y)
+	return x<y?x:y;
+	
+function max(x,y)
+	return x>y?x:y;
+
+if(min(100,200)>max(50,20))
+	print("I'm useless statement just to show up the if/else\n");
+else
+	print("squirrel!!\n");
+	
+print("\n")
+
+function typy(obj)
+{
+	switch(typeof obj)
+	{
+		case "integer":
+		case "float":
+			return "is a number";
+		case "table":
+		case "array":
+			return "is a container";
+		default:
+			return "is other stuff"
+	}
+}
+
+local a=1,b={},c=function(a,b){return a+b;}
+
+print("a "+typy(a)+"\n");
+print("b "+typy(b)+"\n");
+print("c "+typy(c)+"\n");
\ No newline at end of file

Added: trunk/windstille/lib/SQUIRREL2/samples/generators.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/generators.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/generators.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,42 @@
+/*
+*Random number function from The Great Computer Language shootout
+*converted to a generator func
+*/
+
+function gen_random(max) { 
+	local last=42
+	local IM = 139968;
+	local IA = 3877;
+	local IC = 29573;
+	for(;;){  //loops forever
+		yield (max * (last = (last * IA + IC) % IM) / IM); 
+	}
+}
+
+local randtor=gen_random(100);
+
+print("RAND NUMBERS \n")	
+
+for(local i=0;i<10;i+=1)
+	print(">"+resume randtor+"\n");
+	
+print("FIBONACCI \n")	
+function fiboz(n)
+{
+	local prev=0;
+	local curr=1;
+	yield 1;
+	
+	for(local i=0;i<n-1;i+=1)
+	{
+		local res=prev+curr;
+		prev=curr;
+		yield curr=res;
+	}
+	return prev+curr;
+}
+
+foreach(val in fiboz(10))
+{
+	::print(">"+val+"\n");
+}
\ No newline at end of file

Added: trunk/windstille/lib/SQUIRREL2/samples/hello.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/hello.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/hello.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1 @@
+print("Hello World!")
\ No newline at end of file

Added: trunk/windstille/lib/SQUIRREL2/samples/list.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/list.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/list.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,40 @@
+/*translation of the list test from The Great Computer Language Shootout 
+*/
+
+function compare_arr(a1,a2)
+{
+	foreach(i,val in a1)
+		if(val!=a2[i])return null;
+	return 1;	
+}
+
+function test()
+{
+	local size=10000
+	local l1=[]; l1.resize(size);
+	for(local i=0;i<size;i+=1) l1[i]=i;
+	local l2=clone l1;
+	local l3=[]
+	
+	l2.reverse();
+	while(l2.len()>0)
+		l3.append(l2.pop());
+	while(l3.len()>0)
+		l2.append(l3.pop());
+	l1.reverse();
+	
+	if(compare_arr(l1,l2))
+		return l1.len();
+	return null;
+}
+
+local n = ARGS.len()!=0?ARGS[0].tointeger():1
+for(local i=0;i<n;i+=1)
+	if(!test())
+	{
+		print("failed");
+		return;
+	}
+	
+print("oki doki");
+	
\ No newline at end of file

Added: trunk/windstille/lib/SQUIRREL2/samples/loops.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/loops.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/loops.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,32 @@
+local arr=["one","two","three"]
+
+::print("FOREACH\n");
+
+foreach(i,val in arr)
+{
+	::print("index ["+i+"]="+val+"\n");
+}
+
+::print("FOR\n");
+
+for(local i=0;i<arr.len();i+=1)
+{
+	::print("index ["+i+"]="+arr[i]+"\n");
+}
+
+::print("WHILE\n");
+
+local i=0;
+while(i<arr.len())
+{
+	::print("index ["+i+"]="+arr[i]+"\n");
+	i+=1;
+}
+::print("DO WHILE\n");
+
+local i=0;
+do
+{
+	::print("index ["+i+"]="+arr[i]+"\n");
+	i+=1;
+}while(i<arr.len());
\ No newline at end of file

Added: trunk/windstille/lib/SQUIRREL2/samples/matrix.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/matrix.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/matrix.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,44 @@
+/*
+*
+* Original Javascript version by David Hedbor(http://www.bagley.org/~doug/shootout/)
+*
+*/
+local SIZE=30;
+
+function mkmatrix(rows, cols) {
+  local i, j, count = 1;
+  local m = []; m.resize(rows);
+  for (i = 0; i < rows; i+=1) {
+    m[i] = [];m[i].resize(cols)
+    for (j = 0; j < cols; j+=1) {
+      m[i][j] = count+=1;
+    }
+  }
+  return m;
+}
+
+function mmult(rows, cols,  m1, m2, m3) {
+  local i, j, k, val;
+  for (i = 0; i < rows; i+=1) {
+    for (j = 0; j < cols; j+=1) {
+      val = 0;
+      for (k = 0; k < cols; k+=1) {
+	val += m1[i][k] * m2[k][j];
+      }
+      m3[i][j] = val;
+    }
+  }
+  return m3;
+}
+
+local n = ARGS.len()!=0?ARGS[0].tointeger():1
+
+local m1 = mkmatrix(SIZE, SIZE);
+local m2 = mkmatrix(SIZE, SIZE);
+local mm = mkmatrix(SIZE, SIZE);
+
+for (local i = 0; i < n; i+=1) {
+  mmult(SIZE, SIZE, m1, m2, mm);
+}
+
+print(mm[0][0]+" "+mm[2][3]+" "+mm[3][2]+" "+mm[4][4]);
\ No newline at end of file

Added: trunk/windstille/lib/SQUIRREL2/samples/metamethods.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/metamethods.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/metamethods.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,115 @@
+
+local base_vec={
+	function _add(n)
+	{
+		return {
+			x=x+n.x,
+			y=y+n.y,
+			z=z+n.z,
+		}
+	}
+	function _sub(n)
+	{
+		return {
+			x=x-n.x,
+			y=y-n.y,
+			z=z-n.z,
+		}
+	}
+	function _div(n)
+	{
+		return {
+			x=x/n.x,
+			y=y/n.y,
+			z=z/n.z,
+		}
+	}
+	function _mul(n)
+	{
+		return {
+			x=x*n.x,
+			y=y*n.y,
+			z=z*n.z,
+		}
+	}
+	function _modulo(n)
+	{
+		return {
+			x=x%n,
+			y=y%n,
+			z=z%n,
+		}
+	}
+	function _typeof() {return "vector";}
+	function _get(key)
+	{
+		if(key==100)
+		{
+			return test_field;
+		}
+	},
+	function _set(key,val)
+	{
+		::print("key = "+key+"\n");
+		::print("val = "+val+"\n")
+		if(key==100)
+		{
+			return test_field=val;
+		}
+	}
+	test_field="nothing"
+}
+
+function vector(_x,_y,_z):(base_vec)
+{
+	return delegate base_vec : {x=_x,y=_y,z=_z }
+}
+////////////////////////////////////////////////////////////
+
+local v1=vector(1.5,2.5,3.5);
+local v2=vector(1.5,2.5,3.5);
+
+local r=v1+v2;
+
+
+foreach(i,val in r)
+{
+	print(i+" = "+val+"\n");
+}
+
+r=v1*v2;
+
+foreach(i,val in r)
+{
+	print(i+" = "+val+"\n");
+}
+
+r=v1/v2;
+
+foreach(i,val in r)
+{
+	print(i+" = "+val+"\n");
+}
+
+r=v1-v2;
+
+foreach(i,val in r)
+{
+	print(i+" = "+val+"\n");
+}
+
+r=v1%2;
+
+foreach(i,val in r)
+{
+	print(i+" = "+val+"\n");
+}
+
+print(v1[100]+"\n");
+v1[100]="set SUCCEEDED";
+print(v1[100]+"\n");
+
+if(typeof v1=="vector")
+	print("<SUCCEEDED>\n");
+else
+	print("<FAILED>\n");

Added: trunk/windstille/lib/SQUIRREL2/samples/methcall.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/methcall.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/methcall.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,61 @@
+/*translation of the methcall test from The Great Computer Language Shootout 
+*/
+
+Toggle <- {
+	bool=null
+}
+
+function Toggle::value() {
+	return bool;
+}
+
+function Toggle::activate() {
+	bool = !bool;
+	return this;
+}
+
+function Toggle::new(startstate) {
+	local newo=clone this;
+	newo.bool = startstate;
+	return newo;
+}
+
+NthToggle <- {
+	count_max=null
+	count=0
+}
+
+function NthToggle::new(start_state,max_counter)
+{
+	local newo=delegate ::Toggle.new(start_state) : clone this;	
+	newo.count_max <- max_counter
+	return newo;
+}
+
+function NthToggle::activate () 
+{
+	count+=1
+    if (count >= count_max) {
+      bool = !bool;
+      count = 0;
+    }
+    return this;
+}
+
+
+local n = ARGS.len()!=0?ARGS[0].tointeger():1
+
+local val = 1;
+local toggle = Toggle.new(val);
+for (local i=0; i<n; i+=1) {
+  val = toggle.activate().value();
+  
+}
+print(toggle.value() ? "true\n" : "false\n");
+
+val = 1;
+local ntoggle = NthToggle.new(val, 3);
+for (local i=0; i<n; i+=1) {
+  val = ntoggle.activate().value();
+}
+print(ntoggle.value() ? "true\n" : "false\n");
\ No newline at end of file

Added: trunk/windstille/lib/SQUIRREL2/samples/tailstate.nut
===================================================================
--- trunk/windstille/lib/SQUIRREL2/samples/tailstate.nut	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/samples/tailstate.nut	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,24 @@
+function state1()
+{
+	::suspend("state1");
+	return state2();
+}
+
+function state2()
+{
+	::suspend("state2");
+	return state3();
+}
+
+function state3()
+{
+	::suspend("state3");
+	return state1();
+}
+
+local statethread = ::newthread(state1)
+
+::print(statethread.call()+"\n");
+
+for(local i = 0; i < 10000; i++)
+	::print(statethread.wakeup()+"\n");

Added: trunk/windstille/lib/SQUIRREL2/sq/Makefile
===================================================================
--- trunk/windstille/lib/SQUIRREL2/sq/Makefile	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/sq/Makefile	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,21 @@
+SQUIRREL= ..
+
+
+OUT= $(SQUIRREL)/bin/sq
+INCZ= -I$(SQUIRREL)/include -I. -I$(SQUIRREL)/sqlibs
+LIBZ= -L$(SQUIRREL)/lib 
+LIB= -lsquirrel -lsqstdlib
+
+OBJS= sq.o
+	
+SRCS= sq.c
+	
+	
+sq32:
+	g++ -O2 -fno-rtti -o $(OUT) $(SRCS) $(INCZ) $(LIBZ) $(LIB)
+
+sqprof:
+	g++ -O2 -pg -fno-rtti -pie -gstabs -g3 -o $(OUT) $(SRCS) $(INCZ) $(LIBZ) $(LIB)
+	
+sq64:
+	g++ -O2 -fno-rtti -D_SQ64 -o $(OUT) $(SRCS) $(INCZ) $(LIBZ) $(LIB)
\ No newline at end of file

Added: trunk/windstille/lib/SQUIRREL2/sq/sq.c
===================================================================
--- trunk/windstille/lib/SQUIRREL2/sq/sq.c	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/sq/sq.c	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,321 @@
+/*	see copyright notice in squirrel.h */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+
+#if defined(_MSC_VER) && defined(_DEBUG)
+#include <crtdbg.h>
+#include <conio.h>
+#endif
+#include <squirrel.h>
+#include <sqstdblob.h>
+#include <sqstdsystem.h>
+#include <sqstdio.h>
+#include <sqstdmath.h>	
+#include <sqstdstring.h>
+#include <sqstdaux.h>
+
+#ifdef SQUNICODE
+#define scfprintf fwprintf
+#define scfopen	_wfopen
+#define scvprintf vwprintf
+#else
+#define scfprintf fprintf
+#define scfopen	fopen
+#define scvprintf vprintf
+#endif
+
+
+void PrintVersionInfos();
+
+#if defined(_MSC_VER) && defined(_DEBUG)
+int MemAllocHook( int allocType, void *userData, size_t size, int blockType, 
+   long requestNumber, const unsigned char *filename, int lineNumber)
+{
+//	if(requestNumber==585)_asm int 3;
+	return 1;
+}
+#endif
+
+
+SQInteger quit(HSQUIRRELVM v)
+{
+	int *done;
+	sq_getuserpointer(v,-1,(SQUserPointer*)&done);
+	*done=1;
+	return 0;
+}
+
+void printfunc(HSQUIRRELVM v,const SQChar *s,...)
+{
+	va_list vl;
+	va_start(vl, s);
+	scvprintf( s, vl);
+	va_end(vl);
+}
+
+void PrintVersionInfos()
+{
+	scfprintf(stdout,_SC("%s %s (%d bits)\n"),SQUIRREL_VERSION,SQUIRREL_COPYRIGHT,sizeof(SQInteger)*8);
+}
+
+void PrintUsage()
+{
+	scfprintf(stderr,_SC("usage: sq <options> <scriptpath [args]>.\n")
+		_SC("Available options are:\n")
+		_SC("   -c              compiles the file to bytecode(default output 'out.cnut')\n")
+		_SC("   -o              specifies output file for the -c option\n")
+		_SC("   -c              compiles only\n")
+		_SC("   -d              generates debug infos\n")
+		_SC("   -v              displays version infos\n")
+		_SC("   -h              prints help\n"));
+}
+
+#define _INTERACTIVE 0
+#define _DONE 2
+//<<FIXME>> this func is a mess
+int getargs(HSQUIRRELVM v,int argc, char* argv[])
+{
+	int i;
+	int compiles_only = 0;
+	static SQChar temp[500];
+	const SQChar *ret=NULL;
+	char * output = NULL;
+	int lineinfo=0;
+	if(argc>1)
+	{
+		int arg=1,exitloop=0;
+		while(arg < argc && !exitloop)
+		{
+
+			if(argv[arg][0]=='-')
+			{
+				switch(argv[arg][1])
+				{
+				case 'd': //DEBUG(debug infos)
+					sq_enabledebuginfo(v,1);
+					break;
+				case 'c':
+					compiles_only = 1;
+					break;
+				case 'o':
+					if(arg < argc) {
+						arg++;
+						output = argv[arg];
+					}
+					break;
+				case 'v':
+					PrintVersionInfos();
+					return _DONE;
+				
+				case 'h':
+					PrintVersionInfos();
+					PrintUsage();
+					return _DONE;
+				default:
+					PrintVersionInfos();
+					scprintf(_SC("unknown prameter '-%c'\n"),argv[arg][1]);
+					PrintUsage();
+					return _DONE;
+				}
+			}else break;
+			arg++;
+		}
+
+		// src file
+		
+		if(arg<argc) {
+			const SQChar *filename=NULL;
+#ifdef SQUNICODE
+			mbstowcs(temp,argv[arg],strlen(argv[arg]));
+			filename=temp;
+#else
+			filename=argv[arg];
+#endif
+
+			arg++;
+			sq_pushroottable(v);
+			sq_pushstring(v,_SC("ARGS"),-1);
+			sq_newarray(v,0);
+			for(i=arg;i<argc;i++)
+			{
+				const SQChar *a;
+#ifdef SQUNICODE
+				int alen=(int)strlen(argv[i]);
+				a=sq_getscratchpad(v,(int)(alen*sizeof(SQChar)));
+				mbstowcs(sq_getscratchpad(v,-1),argv[i],alen);
+				sq_getscratchpad(v,-1)[alen] = _SC('\0');
+#else
+				a=argv[i];
+#endif
+				sq_pushstring(v,a,-1);
+
+				sq_arrayappend(v,-2);
+			}
+			sq_createslot(v,-3);
+			sq_pop(v,1);
+			if(compiles_only) {
+				if(SQ_SUCCEEDED(sqstd_loadfile(v,filename,SQTrue))){
+					SQChar *outfile = _SC("out.cnut");
+					if(output) {
+#ifdef SQUNICODE
+						int len = (int)(strlen(output)+1);
+						mbstowcs(sq_getscratchpad(v,len*sizeof(SQChar)),output,len);
+						outfile = sq_getscratchpad(v,-1);
+#else
+						outfile = output;
+#endif
+					}
+					if(SQ_SUCCEEDED(sqstd_writeclosuretofile(v,outfile)))
+						return _DONE;
+				}
+			}
+			else {
+				if(SQ_SUCCEEDED(sqstd_dofile(v,filename,SQFalse,SQTrue))) {
+					return _DONE;
+				}
+			}
+			//if this point is reached an error occured
+			{
+				const SQChar *err;
+				sq_getlasterror(v);
+				if(SQ_SUCCEEDED(sq_getstring(v,-1,&err))) {
+					scprintf(_SC("Error [%s]\n"),err);
+					return _DONE;
+				}
+			}
+			
+		}
+	}
+
+	return _INTERACTIVE;
+}
+
+void Interactive(HSQUIRRELVM v)
+{
+	
+#define MAXINPUT 1024
+	SQChar buffer[MAXINPUT];
+	SQInteger blocks =0;
+	SQInteger string=0;
+	SQInteger retval=0;
+	SQInteger done=0;
+	PrintVersionInfos();
+		
+	sq_pushroottable(v);
+	sq_pushstring(v,_SC("quit"),-1);
+	sq_pushuserpointer(v,&done);
+	sq_newclosure(v,quit,1);
+	sq_setparamscheck(v,1,NULL);
+	sq_createslot(v,-3);
+	sq_pop(v,1);
+
+    while (!done) 
+	{
+		SQInteger i = 0;
+		scprintf(_SC("\nsq>"));
+		for(;;) {
+			int c;
+			if(done)return;
+			c = getchar();
+			if (c == _SC('\n')) {
+				if (i>0 && buffer[i-1] == _SC('\\'))
+				{
+					buffer[i-1] = _SC('\n');
+				}
+				else if(blocks==0)break;
+				buffer[i++] = _SC('\n');
+			}
+			else if (c==_SC('}')) {blocks--; buffer[i++] = (SQChar)c;}
+			else if(c==_SC('{') && !string){
+					blocks++;
+					buffer[i++] = (SQChar)c;
+			}
+			else if(c==_SC('"') || c==_SC('\'')){
+					string=!string;
+					buffer[i++] = (SQChar)c;
+			}
+			else if (i >= MAXINPUT-1) {
+				scfprintf(stderr, _SC("sq : input line too long\n"));
+				break;
+			}
+			else{
+				buffer[i++] = (SQChar)c;
+			}
+		}
+		buffer[i] = _SC('\0');
+		
+		if(buffer[0]==_SC('=')){
+			scsprintf(sq_getscratchpad(v,MAXINPUT),_SC("return (%s)"),&buffer[1]);
+			memcpy(buffer,sq_getscratchpad(v,-1),(scstrlen(sq_getscratchpad(v,-1))+1)*sizeof(SQChar));
+			retval=1;
+		}
+		i=scstrlen(buffer);
+		if(i>0){
+			SQInteger oldtop=sq_gettop(v);
+			if(SQ_SUCCEEDED(sq_compilebuffer(v,buffer,i,_SC("interactive console"),SQTrue))){
+				sq_pushroottable(v);
+				if(SQ_SUCCEEDED(sq_call(v,1,retval,SQTrue)) &&	retval){
+					scprintf(_SC("\n"));
+					sq_pushroottable(v);
+					sq_pushstring(v,_SC("print"),-1);
+					sq_get(v,-2);
+					sq_pushroottable(v);
+					sq_push(v,-4);
+					sq_call(v,2,SQFalse,SQTrue);
+					retval=0;
+					scprintf(_SC("\n"));
+				}
+			}
+			
+			sq_settop(v,oldtop);
+		}
+	}
+}
+
+int main(int argc, char* argv[])
+{
+	HSQUIRRELVM v;
+	
+	const SQChar *filename=NULL;
+#if defined(_MSC_VER) && defined(_DEBUG)
+	_CrtSetAllocHook(MemAllocHook);
+#endif
+	
+	v=sq_open(1024);
+	sq_setprintfunc(v,printfunc);
+
+	sq_pushroottable(v);
+
+	sqstd_register_bloblib(v);
+	sqstd_register_iolib(v);
+	sqstd_register_systemlib(v);
+	sqstd_register_mathlib(v);
+	sqstd_register_stringlib(v);
+
+	//aux library
+	//sets error handlers
+	sqstd_seterrorhandlers(v);
+
+	//gets arguments
+	switch(getargs(v,argc,argv))
+	{
+	case _INTERACTIVE:
+		Interactive(v);
+		break;
+	case _DONE:
+	default: 
+		break;
+	}
+
+	sq_close(v);
+	
+#if defined(_MSC_VER) && defined(_DEBUG)
+	_getch();
+	_CrtMemDumpAllObjectsSince( NULL );
+#endif
+	return 0;
+}
+

Added: trunk/windstille/lib/SQUIRREL2/sq/sq.dsp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/sq/sq.dsp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/sq/sq.dsp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,101 @@
+# Microsoft Developer Studio Project File - Name="sq" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=sq - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "sq.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "sq.mak" CFG="sq - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "sq - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "sq - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_LocalPath ".."
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "sq - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /I "..\include" /I "..\sqstdlib" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD BASE RSC /l 0x410 /d "NDEBUG"
+# ADD RSC /l 0x410 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 squirrel.lib sqstdlib.lib /nologo /subsystem:console /machine:I386 /out:"../bin/sq.exe" /libpath:"../lib"
+
+!ELSEIF  "$(CFG)" == "sq - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "..\include" /I "..\sqstdlib" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD BASE RSC /l 0x410 /d "_DEBUG"
+# ADD RSC /l 0x410 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 squirrel.lib sqstdlib.lib /nologo /subsystem:console /debug /machine:I386 /out:"../bin/sq.exe" /pdbtype:sept /libpath:"../lib"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "sq - Win32 Release"
+# Name "sq - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\sq.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# End Group
+# End Target
+# End Project

Added: trunk/windstille/lib/SQUIRREL2/sqstdlib/Makefile
===================================================================
--- trunk/windstille/lib/SQUIRREL2/sqstdlib/Makefile	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/sqstdlib/Makefile	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,30 @@
+SQUIRREL= ..
+
+
+OUT= $(SQUIRREL)/lib/libsqstdlib.a
+INCZ= -I$(SQUIRREL)/include -I. -Iinclude
+
+SRCS= \
+	sqstdblob.cpp \
+	sqstdio.cpp \
+	sqstdstream.cpp \
+	sqstdmath.cpp \
+	sqstdsystem.cpp \
+	sqstdstring.cpp \
+	sqstdaux.cpp \
+	sqstdrex.cpp
+	
+	
+sq32:
+	gcc -O2  -fno-rtti -Wall -c $(SRCS) $(INCZ)
+	ar rc $(OUT) *.o
+	rm *.o
+
+sqprof:
+	gcc -O2 -pg -fno-rtti -pie -gstabs -g3 -Wall -c $(SRCS) $(INCZ)
+	ar rc $(OUT) *.o
+	rm *.o
+sq64:
+	gcc -O2 -D_SQ64 -fno-rtti -Wall -c $(SRCS) $(INCZ)
+	ar rc $(OUT) *.o
+	rm *.o

Added: trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdaux.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdaux.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdaux.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,129 @@
+/* see copyright notice in squirrel.h */
+#include <squirrel.h>
+#include <sqstdaux.h>
+#include <assert.h>
+
+void sqstd_printcallstack(HSQUIRRELVM v)
+{
+	SQPRINTFUNCTION pf = sq_getprintfunc(v);
+	if(pf) {
+		SQStackInfos si;
+		SQInteger i;
+		SQFloat f;
+		const SQChar *s;
+		SQInteger level=1; //1 is to skip this function that is level 0
+		const SQChar *name=0; 
+		SQInteger seq=0;
+		pf(v,_SC("\nCALLSTACK\n"));
+		while(SQ_SUCCEEDED(sq_stackinfos(v,level,&si)))
+		{
+			const SQChar *fn=_SC("unknown");
+			const SQChar *src=_SC("unknown");
+			if(si.funcname)fn=si.funcname;
+			if(si.source)src=si.source;
+			pf(v,_SC("*FUNCTION [%s()] %s line [%d]\n"),fn,src,si.line);
+			level++;
+		}
+		level=0;
+		pf(v,_SC("\nLOCALS\n"));
+
+		for(level=0;level<10;level++){
+			seq=0;
+			while((name = sq_getlocal(v,level,seq)))
+			{
+				seq++;
+				switch(sq_gettype(v,-1))
+				{
+				case OT_NULL:
+					pf(v,_SC("[%s] NULL\n"),name);
+					break;
+				case OT_INTEGER:
+					sq_getinteger(v,-1,&i);
+					pf(v,_SC("[%s] %d\n"),name,i);
+					break;
+				case OT_FLOAT:
+					sq_getfloat(v,-1,&f);
+					pf(v,_SC("[%s] %.14g\n"),name,f);
+					break;
+				case OT_USERPOINTER:
+					pf(v,_SC("[%s] USERPOINTER\n"),name);
+					break;
+				case OT_STRING:
+					sq_getstring(v,-1,&s);
+					pf(v,_SC("[%s] \"%s\"\n"),name,s);
+					break;
+				case OT_TABLE:
+					pf(v,_SC("[%s] TABLE\n"),name);
+					break;
+				case OT_ARRAY:
+					pf(v,_SC("[%s] ARRAY\n"),name);
+					break;
+				case OT_CLOSURE:
+					pf(v,_SC("[%s] CLOSURE\n"),name);
+					break;
+				case OT_NATIVECLOSURE:
+					pf(v,_SC("[%s] NATIVECLOSURE\n"),name);
+					break;
+				case OT_GENERATOR:
+					pf(v,_SC("[%s] GENERATOR\n"),name);
+					break;
+				case OT_USERDATA:
+					pf(v,_SC("[%s] USERDATA\n"),name);
+					break;
+				case OT_THREAD:
+					pf(v,_SC("[%s] THREAD\n"),name);
+					break;
+				case OT_CLASS:
+					pf(v,_SC("[%s] CLASS\n"),name);
+					break;
+				case OT_INSTANCE:
+					pf(v,_SC("[%s] INSTANCE\n"),name);
+					break;
+				case OT_WEAKREF:
+					pf(v,_SC("[%s] WEAKREF\n"),name);
+					break;
+				case OT_BOOL:{
+					sq_getinteger(v,-1,&i);
+					pf(v,_SC("[%s] %s\n"),name,i?_SC("true"):_SC("false"));
+							 }
+					break;
+				default: assert(0); break;
+				}
+				sq_pop(v,1);
+			}
+		}
+	}
+}
+
+static SQInteger _sqstd_aux_printerror(HSQUIRRELVM v)
+{
+	SQPRINTFUNCTION pf = sq_getprintfunc(v);
+	if(pf) {
+		const SQChar *sErr = 0;
+		if(sq_gettop(v)>=1) {
+			if(SQ_SUCCEEDED(sq_getstring(v,2,&sErr)))	{
+				pf(v,_SC("\nAN ERROR HAS OCCURED [%s]\n"),sErr);
+			}
+			else{
+				pf(v,_SC("\nAN ERROR HAS OCCURED [unknown]\n"));
+			}
+			sqstd_printcallstack(v);
+		}
+	}
+	return 0;
+}
+
+void _sqstd_compiler_error(HSQUIRRELVM v,const SQChar *sErr,const SQChar *sSource,SQInteger line,SQInteger column)
+{
+	SQPRINTFUNCTION pf = sq_getprintfunc(v);
+	if(pf) {
+		pf(v,_SC("%s line = (%d) column = (%d) : error %s\n"),sSource,line,column,sErr);
+	}
+}
+
+void sqstd_seterrorhandlers(HSQUIRRELVM v)
+{
+	sq_setcompilererrorhandler(v,_sqstd_compiler_error);
+	sq_newclosure(v,_sqstd_aux_printerror,0);
+	sq_seterrorhandler(v);
+}

Added: trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdblob.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdblob.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdblob.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,251 @@
+/* see copyright notice in squirrel.h */
+#include <new>
+#include <squirrel.h>
+#include <sqstdio.h>
+#include <string.h>
+#include <sqstdblob.h>
+#include "sqstdstream.h"
+#include "sqstdblobimpl.h"
+
+#define SQSTD_BLOB_TYPE_TAG (SQSTD_STREAM_TYPE_TAG | 0x00000002)
+
+//Blob
+
+
+#define SETUP_BLOB(v) \
+	SQBlob *self = NULL; \
+	{ if(SQ_FAILED(sq_getinstanceup(v,1,(SQUserPointer*)&self,(SQUserPointer)SQSTD_BLOB_TYPE_TAG))) \
+		return SQ_ERROR; }
+
+
+static SQInteger _blob_resize(HSQUIRRELVM v)
+{
+	SETUP_BLOB(v);
+	SQInteger size;
+	sq_getinteger(v,2,&size);
+	if(!self->Resize(size))
+		return sq_throwerror(v,_SC("resize failed"));
+	return 0;
+}
+
+static void __swap_dword(unsigned int *n)
+{
+	*n=(unsigned int)(((*n&0xFF000000)>>24)  |
+			((*n&0x00FF0000)>>8)  |
+			((*n&0x0000FF00)<<8)  |
+			((*n&0x000000FF)<<24));
+}
+
+static void __swap_word(unsigned short *n)
+{
+	*n=(unsigned short)((*n>>8)&0x00FF)| ((*n<<8)&0xFF00);
+}
+
+static SQInteger _blob_swap4(HSQUIRRELVM v)
+{
+	SETUP_BLOB(v);
+	SQInteger num=(self->Len()-(self->Len()%4))>>2;
+	unsigned int *t=(unsigned int *)self->GetBuf();
+	for(SQInteger i = 0; i < num; i++) {
+		__swap_dword(&t[i]);
+	}
+	return 0;
+}
+
+static SQInteger _blob_swap2(HSQUIRRELVM v)
+{
+	SETUP_BLOB(v);
+	SQInteger num=(self->Len()-(self->Len()%2))>>1;
+	unsigned short *t = (unsigned short *)self->GetBuf();
+	for(SQInteger i = 0; i < num; i++) {
+		__swap_word(&t[i]);
+	}
+	return 0;
+}
+
+static SQInteger _blob__set(HSQUIRRELVM v)
+{
+	SETUP_BLOB(v);
+	SQInteger idx,val;
+	sq_getinteger(v,2,&idx);
+	sq_getinteger(v,3,&val);
+	if(idx < 0 || idx >= self->Len())
+		return sq_throwerror(v,_SC("index out of range"));
+	((unsigned char *)self->GetBuf())[idx] = (unsigned char) val;
+	sq_push(v,3);
+	return 1;
+}
+
+static SQInteger _blob__get(HSQUIRRELVM v)
+{
+	SETUP_BLOB(v);
+	SQInteger idx;
+	sq_getinteger(v,2,&idx);
+	if(idx < 0 || idx >= self->Len())
+		return sq_throwerror(v,_SC("index out of range"));
+	sq_pushinteger(v,((unsigned char *)self->GetBuf())[idx]);
+	return 1;
+}
+
+static SQInteger _blob__nexti(HSQUIRRELVM v)
+{
+	SETUP_BLOB(v);
+	if(sq_gettype(v,2) == OT_NULL) {
+		sq_pushinteger(v, 0);
+		return 1;
+	}
+	SQInteger idx;
+	if(SQ_SUCCEEDED(sq_getinteger(v, 2, &idx))) {
+		if(idx+1 < self->Len()) {
+			sq_pushinteger(v, idx+1);
+			return 1;
+		}
+		sq_pushnull(v);
+		return 1;
+	}
+	return sq_throwerror(v,_SC("internal error (_nexti) wrong argument type"));
+}
+
+static SQInteger _blob__typeof(HSQUIRRELVM v)
+{
+	sq_pushstring(v,_SC("blob"),-1);
+	return 1;
+}
+
+static SQInteger _blob_releasehook(SQUserPointer p, SQInteger size)
+{
+	SQBlob *self = (SQBlob*)p;
+	delete self;
+	return 1;
+}
+
+static SQInteger _blob_constructor(HSQUIRRELVM v)
+{
+	SQInteger nparam = sq_gettop(v);
+	SQInteger size = 0;
+	if(nparam == 2) {
+		sq_getinteger(v, 2, &size);
+	}
+	if(size < 0) return sq_throwerror(v, _SC("cannot create blob with negative size"));
+	SQBlob *b = new SQBlob(size);
+	if(SQ_FAILED(sq_setinstanceup(v,1,b))) {
+		delete b;
+		return sq_throwerror(v, _SC("cannot create blob with negative size"));
+	}
+	sq_setreleasehook(v,1,_blob_releasehook);
+	return 0;
+}
+
+#define _DECL_BLOB_FUNC(name,nparams,typecheck) {_SC(#name),_blob_##name,nparams,typecheck}
+static SQRegFunction _blob_methods[] = {
+	_DECL_BLOB_FUNC(constructor,-1,_SC("xn")),
+	_DECL_BLOB_FUNC(resize,2,_SC("xn")),
+	_DECL_BLOB_FUNC(swap2,1,_SC("x")),
+	_DECL_BLOB_FUNC(swap4,1,_SC("x")),
+	_DECL_BLOB_FUNC(_set,3,_SC("xnn")),
+	_DECL_BLOB_FUNC(_get,2,_SC("xn")),
+	_DECL_BLOB_FUNC(_typeof,1,_SC("x")),
+	_DECL_BLOB_FUNC(_nexti,2,_SC("x")),
+	{0,0,0,0}
+};
+
+
+
+//GLOBAL FUNCTIONS
+
+static SQInteger _g_blob_casti2f(HSQUIRRELVM v)
+{
+	SQInteger i;
+	sq_getinteger(v,2,&i);
+	sq_pushfloat(v,*((SQFloat *)&i));
+	return 1;
+}
+
+static SQInteger _g_blob_castf2i(HSQUIRRELVM v)
+{
+	SQFloat f;
+	sq_getfloat(v,2,&f);
+	sq_pushinteger(v,*((SQInteger *)&f));
+	return 1;
+}
+
+static SQInteger _g_blob_swap2(HSQUIRRELVM v)
+{
+	SQInteger i;
+	sq_getinteger(v,2,&i);
+	short s=(short)i;
+	sq_pushinteger(v,(s<<8)|((s>>8)&0x00FF));
+	return 1;
+}
+
+static SQInteger _g_blob_swap4(HSQUIRRELVM v)
+{
+	SQInteger i;
+	sq_getinteger(v,2,&i);
+	unsigned int t4 = (unsigned int)i;
+	__swap_dword(&t4);
+	sq_pushinteger(v,(SQInteger)t4);
+	return 1;
+}
+
+static SQInteger _g_blob_swapfloat(HSQUIRRELVM v)
+{
+	SQFloat f;
+	sq_getfloat(v,2,&f);
+	__swap_dword((unsigned int *)&f);
+	sq_pushfloat(v,f);
+	return 1;
+}
+
+#define _DECL_GLOBALBLOB_FUNC(name,nparams,typecheck) {_SC(#name),_g_blob_##name,nparams,typecheck}
+static SQRegFunction bloblib_funcs[]={
+	_DECL_GLOBALBLOB_FUNC(casti2f,2,_SC(".n")),
+	_DECL_GLOBALBLOB_FUNC(castf2i,2,_SC(".n")),
+	_DECL_GLOBALBLOB_FUNC(swap2,2,_SC(".n")),
+	_DECL_GLOBALBLOB_FUNC(swap4,2,_SC(".n")),
+	_DECL_GLOBALBLOB_FUNC(swapfloat,2,_SC(".n")),
+	{0,0}
+};
+
+SQRESULT sqstd_getblob(HSQUIRRELVM v,SQInteger idx,SQUserPointer *ptr)
+{
+	SQBlob *blob;
+	if(SQ_FAILED(sq_getinstanceup(v,idx,(SQUserPointer *)&blob,(SQUserPointer)SQSTD_BLOB_TYPE_TAG)))
+		return -1;
+	*ptr = blob->GetBuf();
+	return SQ_OK;
+}
+
+SQInteger sqstd_getblobsize(HSQUIRRELVM v,SQInteger idx)
+{
+	SQBlob *blob;
+	if(SQ_FAILED(sq_getinstanceup(v,idx,(SQUserPointer *)&blob,(SQUserPointer)SQSTD_BLOB_TYPE_TAG)))
+		return -1;
+	return blob->Len();
+}
+
+SQUserPointer sqstd_createblob(HSQUIRRELVM v, SQInteger size)
+{
+	SQInteger top = sq_gettop(v);
+	sq_pushregistrytable(v);
+	sq_pushstring(v,_SC("std_blob"),-1);
+	if(SQ_SUCCEEDED(sq_get(v,-2))) {
+		sq_remove(v,-2); //removes the registry
+		sq_push(v,1); // push the this
+		sq_pushinteger(v,size); //size
+		SQBlob *blob = NULL;
+		if(SQ_SUCCEEDED(sq_call(v,2,SQTrue,SQFalse))
+			&& SQ_SUCCEEDED(sq_getinstanceup(v,-1,(SQUserPointer *)&blob,(SQUserPointer)SQSTD_BLOB_TYPE_TAG))) {
+			sq_remove(v,-2);
+			return blob->GetBuf();
+		}
+	}
+	sq_settop(v,top);
+	return NULL;
+}
+
+SQRESULT sqstd_register_bloblib(HSQUIRRELVM v)
+{
+	return declare_stream(v,_SC("blob"),(SQUserPointer)SQSTD_BLOB_TYPE_TAG,_SC("std_blob"),_blob_methods,bloblib_funcs);
+}
+

Added: trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdblobimpl.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdblobimpl.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdblobimpl.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,108 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQSTD_BLOBIMPL_H_
+#define _SQSTD_BLOBIMPL_H_
+
+struct SQBlob : public SQStream
+{
+	SQBlob(SQInteger size) {
+		_size = size;
+		_allocated = size;
+		_buf = (unsigned char *)sq_malloc(size);
+		memset(_buf, 0, _size);
+		_ptr = 0;
+		_owns = true;
+	}
+	virtual ~SQBlob() {
+		sq_free(_buf, _allocated);
+	}
+	SQInteger Write(void *buffer, SQInteger size) {
+		if(!CanAdvance(size)) {
+			GrowBufOf(_ptr + size - _size);
+		}
+		memcpy(&_buf[_ptr], buffer, size);
+		_ptr += size;
+		return size;
+	}
+	SQInteger Read(void *buffer,SQInteger size) {
+		SQInteger n = size;
+		if(!CanAdvance(size)) {
+			if((_size - _ptr) > 0)
+				n = _size - _ptr;
+			else return 0;
+		}
+		memcpy(buffer, &_buf[_ptr], n);
+		_ptr += n;
+		return n;
+	}
+	bool Resize(SQInteger n) {
+		if(!_owns) return false;
+		if(n != _allocated) {
+			unsigned char *newbuf = (unsigned char *)sq_malloc(n);
+			memset(newbuf,0,n);
+			if(_size > n)
+				memcpy(newbuf,_buf,n);
+			else
+				memcpy(newbuf,_buf,_size);
+			sq_free(_buf,_allocated);
+			_buf=newbuf;
+			_allocated = n;
+			if(_size > _allocated)
+				_size = _allocated;
+			if(_ptr > _allocated)
+				_ptr = _allocated;
+		}
+		return true;
+	}
+	bool GrowBufOf(SQInteger n)
+	{
+		bool ret = true;
+		if(_size + n > _allocated) {
+			if(_size + n > _size * 2)
+				ret = Resize(_size + n);
+			else
+				ret = Resize(_size * 2);
+		}
+		_size = _size + n;
+		return ret;
+	}
+	bool CanAdvance(SQInteger n) {
+		if(_ptr+n>_size)return false;
+		return true;
+	}
+	SQInteger Seek(SQInteger offset, SQInteger origin) {
+		switch(origin) {
+			case SQ_SEEK_SET:
+				if(offset > _size || offset < 0) return -1;
+				_ptr = offset;
+				break;
+			case SQ_SEEK_CUR:
+				if(_ptr + offset > _size || _ptr + offset < 0) return -1;
+				_ptr += offset;
+				break;
+			case SQ_SEEK_END:
+				if(_size + offset > _size || _size + offset < 0) return -1;
+				_ptr = _size + offset;
+				break;
+			default: return -1;
+		}
+		return 0;
+	}
+	bool IsValid() {
+		return _buf?true:false;
+	}
+	bool EOS() {
+		return _ptr == _size;
+	}
+	SQInteger Flush() { return 0; }
+	SQInteger Tell() { return _ptr; }
+	SQInteger Len() { return _size; }
+	SQUserPointer GetBuf(){ return _buf; }
+private:
+	SQInteger _size;
+	SQInteger _allocated;
+	SQInteger _ptr;
+	unsigned char *_buf;
+	bool _owns;
+};
+
+#endif //_SQSTD_BLOBIMPL_H_

Added: trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdio.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdio.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdio.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,410 @@
+/* see copyright notice in squirrel.h */
+#include <new>
+#include <stdio.h>
+#include <squirrel.h>
+#include <sqstdio.h>
+#include "sqstdstream.h"
+
+#define SQSTD_FILE_TYPE_TAG (SQSTD_STREAM_TYPE_TAG | 0x00000001)
+//basic API
+SQFILE sqstd_fopen(const SQChar *filename ,const SQChar *mode)
+{
+#ifndef SQUNICODE
+	return (SQFILE)fopen(filename,mode);
+#else
+	return (SQFILE)_wfopen(filename,mode);
+#endif
+}
+
+SQInteger sqstd_fread(void* buffer, SQInteger size, SQInteger count, SQFILE file)
+{
+	return (SQInteger)fread(buffer,size,count,(FILE *)file);
+}
+
+SQInteger sqstd_fwrite(const SQUserPointer buffer, SQInteger size, SQInteger count, SQFILE file)
+{
+	return (SQInteger)fwrite(buffer,size,count,(FILE *)file);
+}
+
+SQInteger sqstd_fseek(SQFILE file, SQInteger offset, SQInteger origin)
+{
+	SQInteger realorigin;
+	switch(origin) {
+		case SQ_SEEK_CUR: realorigin = SEEK_CUR; break;
+		case SQ_SEEK_END: realorigin = SEEK_END; break;
+		case SQ_SEEK_SET: realorigin = SEEK_SET; break;
+		default: return -1; //failed
+	}
+	return fseek((FILE *)file,(long)offset,(int)realorigin);
+}
+
+SQInteger sqstd_ftell(SQFILE file)
+{
+	return ftell((FILE *)file);
+}
+
+SQInteger sqstd_fflush(SQFILE file)
+{
+	return fflush((FILE *)file);
+}
+
+SQInteger sqstd_fclose(SQFILE file)
+{
+	return fclose((FILE *)file);
+}
+
+SQInteger sqstd_feof(SQFILE file)
+{
+	return feof((FILE *)file);
+}
+
+//File
+struct SQFile : public SQStream {
+	SQFile() { _handle = NULL; _owns = false;}
+	SQFile(SQFILE file, bool owns) { _handle = file; _owns = owns;}
+	virtual ~SQFile() { Close(); }
+	bool Open(const SQChar *filename ,const SQChar *mode) {
+		Close();
+		if( (_handle = sqstd_fopen(filename,mode)) ) {
+			_owns = true;
+			return true;
+		}
+		return false;
+	}
+	void Close() {
+		if(_handle && _owns) { 
+			sqstd_fclose(_handle);
+			_handle = NULL;
+			_owns = false;
+		}
+	}
+	SQInteger Read(void *buffer,SQInteger size) {
+		return sqstd_fread(buffer,1,size,_handle);
+	}
+	SQInteger Write(void *buffer,SQInteger size) {
+		return sqstd_fwrite(buffer,1,size,_handle);
+	}
+	SQInteger Flush() {
+		return sqstd_fflush(_handle);
+	}
+	SQInteger Tell() {
+		return sqstd_ftell(_handle);
+	}
+	SQInteger Len() {
+		SQInteger prevpos=Tell();
+		Seek(0,SQ_SEEK_END);
+		SQInteger size=Tell();
+		Seek(prevpos,SQ_SEEK_SET);
+		return size;
+	}
+	SQInteger Seek(SQInteger offset, SQInteger origin)	{
+		return sqstd_fseek(_handle,offset,origin);
+	}
+	bool IsValid() { return _handle?true:false; }
+	bool EOS() { return Tell()==Len()?true:false;}
+	SQFILE GetHandle() {return _handle;}
+private:
+	SQFILE _handle;
+	bool _owns;
+};
+
+static SQInteger _file__typeof(HSQUIRRELVM v)
+{
+	sq_pushstring(v,_SC("file"),-1);
+	return 1;
+}
+
+static SQInteger _file_releasehook(SQUserPointer p, SQInteger size)
+{
+	SQFile *self = (SQFile*)p;
+	delete self;
+	return 1;
+}
+
+static SQInteger _file_constructor(HSQUIRRELVM v)
+{
+	const SQChar *filename,*mode;
+	bool owns = true;
+	SQFile *f;
+	SQFILE newf;
+	if(sq_gettype(v,2) == OT_STRING && sq_gettype(v,3) == OT_STRING) {
+		sq_getstring(v, 2, &filename);
+		sq_getstring(v, 3, &mode);
+		newf = sqstd_fopen(filename, mode);
+		if(!newf) return sq_throwerror(v, _SC("cannot open file"));
+	} else if(sq_gettype(v,2) == OT_USERPOINTER) {
+		owns = !(sq_gettype(v,3) == OT_NULL);
+		sq_getuserpointer(v,2,&newf);
+	} else {
+		return sq_throwerror(v,_SC("wrong parameter"));
+	}
+	f = new SQFile(newf,owns);
+	if(SQ_FAILED(sq_setinstanceup(v,1,f))) {
+		delete f;
+		return sq_throwerror(v, _SC("cannot create blob with negative size"));
+	}
+	sq_setreleasehook(v,1,_file_releasehook);
+	return 0;
+}
+
+//bindings
+#define _DECL_FILE_FUNC(name,nparams,typecheck) {_SC(#name),_file_##name,nparams,typecheck}
+static SQRegFunction _file_methods[] = {
+	_DECL_FILE_FUNC(constructor,3,_SC("x")),
+	_DECL_FILE_FUNC(_typeof,1,_SC("x")),
+	{0,0,0,0},
+};
+
+
+
+SQRESULT sqstd_createfile(HSQUIRRELVM v, SQFILE file,SQBool own)
+{
+	SQInteger top = sq_gettop(v);
+	sq_pushregistrytable(v);
+	sq_pushstring(v,_SC("std_file"),-1);
+	if(SQ_SUCCEEDED(sq_get(v,-2))) {
+		sq_remove(v,-2); //removes the registry
+		sq_pushroottable(v); // push the this
+		sq_pushuserpointer(v,file); //file
+		if(own){
+			sq_pushinteger(v,1); //true
+		}
+		else{
+			sq_pushnull(v); //false
+		}
+		if(SQ_SUCCEEDED( sq_call(v,3,SQTrue,SQFalse) )) {
+			sq_remove(v,-2);
+			return SQ_OK;
+		}
+	}
+	sq_settop(v,top);
+	return SQ_OK;
+}
+
+SQRESULT sqstd_getfile(HSQUIRRELVM v, SQInteger idx, SQFILE *file)
+{
+	SQFile *fileobj = NULL;
+	if(SQ_SUCCEEDED(sq_getinstanceup(v,idx,(SQUserPointer*)&fileobj,(SQUserPointer)SQSTD_FILE_TYPE_TAG))) {
+		*file = fileobj->GetHandle();
+		return SQ_OK;
+	}
+	return sq_throwerror(v,_SC("not a file"));
+}
+
+
+
+static SQInteger _io_file_lexfeed_ASCII(SQUserPointer file)
+{
+	SQInteger ret;
+	char c;
+	if( ( ret=sqstd_fread(&c,sizeof(c),1,(FILE *)file )>0) )
+		return c;
+	return 0;
+}
+
+static SQInteger _io_file_lexfeed_UTF8(SQUserPointer file)
+{
+#define READ() \
+	if(sqstd_fread(&inchar,sizeof(inchar),1,(FILE *)file) != 1) \
+		return 0;
+
+	static const SQInteger utf8_lengths[16] =
+	{
+		1,1,1,1,1,1,1,1,        /* 0000 to 0111 : 1 byte (plain ASCII) */
+		0,0,0,0,                /* 1000 to 1011 : not valid */
+		2,2,                    /* 1100, 1101 : 2 bytes */
+		3,                      /* 1110 : 3 bytes */
+		4                       /* 1111 :4 bytes */
+	};
+	static unsigned char byte_masks[5] = {0,0,0x1f,0x0f,0x07};
+	unsigned char inchar;
+	SQInteger c = 0;
+	READ();
+	c = inchar;
+	//
+	if(c >= 0x80) {
+		SQInteger tmp;
+		SQInteger codelen = utf8_lengths[c>>4];
+		if(codelen == 0) 
+			return 0;
+			//"invalid UTF-8 stream";
+		tmp = c&byte_masks[codelen];
+		for(SQInteger n = 0; n < codelen-1; n++) {
+			tmp<<=6;
+			READ();
+			tmp |= inchar & 0x3F;
+		}
+		c = tmp;
+	}
+	return c;
+}
+
+static SQInteger _io_file_lexfeed_UCS2_LE(SQUserPointer file)
+{
+	SQInteger ret;
+	wchar_t c;
+	if( ( ret=sqstd_fread(&c,sizeof(c),1,(FILE *)file )>0) )
+		return (SQChar)c;
+	return 0;
+}
+
+static SQInteger _io_file_lexfeed_UCS2_BE(SQUserPointer file)
+{
+	SQInteger ret;
+	unsigned short c;
+	if( ( ret=sqstd_fread(&c,sizeof(c),1,(FILE *)file )>0) ) {
+		c = ((c>>8)&0x00FF)| ((c<<8)&0xFF00);
+		return (SQChar)c;
+	}
+	return 0;
+}
+
+SQInteger file_read(SQUserPointer file,SQUserPointer buf,SQInteger size)
+{
+	SQInteger ret;
+	if( ( ret = sqstd_fread(buf,1,size,(SQFILE)file ))!=0 )return ret;
+	return -1;
+}
+
+SQInteger file_write(SQUserPointer file,SQUserPointer p,SQInteger size)
+{
+	return sqstd_fwrite(p,1,size,(SQFILE)file);
+}
+
+SQRESULT sqstd_loadfile(HSQUIRRELVM v,const SQChar *filename,SQBool printerror)
+{
+	SQFILE file = sqstd_fopen(filename,_SC("rb"));
+	SQInteger ret;
+	unsigned short us;
+	unsigned char uc;
+	SQLEXREADFUNC func = _io_file_lexfeed_ASCII;
+	if(file){
+		ret = sqstd_fread(&us,1,2,file);
+		if(ret != 2) {
+			//probably an empty file
+			us = 0;
+		}
+		if(us == SQ_BYTECODE_STREAM_TAG) { //BYTECODE
+			sqstd_fseek(file,0,SQ_SEEK_SET);
+			if(SQ_SUCCEEDED(sq_readclosure(v,file_read,file))) {
+				sqstd_fclose(file);
+				return SQ_OK;
+			}
+		}
+		else { //SCRIPT
+			switch(us)
+			{
+				//gotta swap the next 2 lines on BIG endian machines
+				case 0xFFFE: func = _io_file_lexfeed_UCS2_BE; break;//UTF-16 little endian;
+				case 0xFEFF: func = _io_file_lexfeed_UCS2_LE; break;//UTF-16 big endian;
+				case 0xBBEF: 
+					if(sqstd_fread(&uc,1,sizeof(uc),file) == 0) { 
+						sqstd_fclose(file); 
+						return sq_throwerror(v,_SC("io error")); 
+					}
+					if(uc != 0xBF) { 
+						sqstd_fclose(file); 
+						return sq_throwerror(v,_SC("Unrecognozed ecoding")); 
+					}
+					func = _io_file_lexfeed_UTF8;
+					break;//UTF-8 ;
+				default: sqstd_fseek(file,0,SQ_SEEK_SET); break; // ascii
+			}
+
+			if(SQ_SUCCEEDED(sq_compile(v,func,file,filename,printerror))){
+				sqstd_fclose(file);
+				return SQ_OK;
+			}
+		}
+		sqstd_fclose(file);
+		return SQ_ERROR;
+	}
+	return sq_throwerror(v,_SC("cannot open the file"));
+}
+
+SQRESULT sqstd_dofile(HSQUIRRELVM v,const SQChar *filename,SQBool retval,SQBool printerror)
+{
+	if(SQ_SUCCEEDED(sqstd_loadfile(v,filename,printerror))) {
+		sq_push(v,-2);
+		if(SQ_SUCCEEDED(sq_call(v,1,retval,SQTrue))) {
+			sq_remove(v,retval?-2:-1); //removes the closure
+			return 1;
+		}
+		sq_pop(v,1); //removes the closure
+	}
+	return SQ_ERROR;
+}
+
+SQRESULT sqstd_writeclosuretofile(HSQUIRRELVM v,const SQChar *filename)
+{
+	SQFILE file = sqstd_fopen(filename,_SC("wb+"));
+	if(!file) return sq_throwerror(v,_SC("cannot open the file"));
+	if(SQ_SUCCEEDED(sq_writeclosure(v,file_write,file))) {
+		sqstd_fclose(file);
+		return SQ_OK;
+	}
+	sqstd_fclose(file);
+	return SQ_ERROR; //forward the error
+}
+
+SQInteger _g_io_loadfile(HSQUIRRELVM v)
+{
+	const SQChar *filename;
+	SQBool printerror = SQFalse;
+	sq_getstring(v,2,&filename);
+	if(sq_gettop(v) >= 3) {
+		sq_getbool(v,3,&printerror);
+	}
+	if(SQ_SUCCEEDED(sqstd_loadfile(v,filename,printerror)))
+		return 1;
+	return SQ_ERROR; //propagates the error
+}
+
+SQInteger _g_io_writeclosuretofile(HSQUIRRELVM v)
+{
+	const SQChar *filename;
+	sq_getstring(v,2,&filename);
+	if(SQ_SUCCEEDED(sqstd_writeclosuretofile(v,filename)))
+		return 1;
+	return SQ_ERROR; //propagates the error
+}
+
+SQInteger _g_io_dofile(HSQUIRRELVM v)
+{
+	const SQChar *filename;
+	SQBool printerror = SQFalse;
+	sq_getstring(v,2,&filename);
+	if(sq_gettop(v) >= 3) {
+		sq_getbool(v,3,&printerror);
+	}
+	sq_push(v,1); //repush the this
+	if(SQ_SUCCEEDED(sqstd_dofile(v,filename,SQTrue,printerror)))
+		return 1;
+	return SQ_ERROR; //propagates the error
+}
+
+#define _DECL_GLOBALIO_FUNC(name,nparams,typecheck) {_SC(#name),_g_io_##name,nparams,typecheck}
+static SQRegFunction iolib_funcs[]={
+	_DECL_GLOBALIO_FUNC(loadfile,-2,_SC(".sb")),
+	_DECL_GLOBALIO_FUNC(dofile,-2,_SC(".sb")),
+	_DECL_GLOBALIO_FUNC(writeclosuretofile,3,_SC(".sc")),
+	{0,0}
+};
+
+SQRESULT sqstd_register_iolib(HSQUIRRELVM v)
+{
+	SQInteger top = sq_gettop(v);
+	//create delegate
+	declare_stream(v,_SC("file"),(SQUserPointer)SQSTD_FILE_TYPE_TAG,_SC("std_file"),_file_methods,iolib_funcs);
+	sq_pushstring(v,_SC("stdout"),-1);
+	sqstd_createfile(v,stdout,SQFalse);
+	sq_createslot(v,-3);
+	sq_pushstring(v,_SC("stdin"),-1);
+	sqstd_createfile(v,stdin,SQFalse);
+	sq_createslot(v,-3);
+	sq_pushstring(v,_SC("stderr"),-1);
+	sqstd_createfile(v,stderr,SQFalse);
+	sq_createslot(v,-3);
+	sq_settop(v,top);
+	return SQ_OK;
+}

Added: trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdlib.dsp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdlib.dsp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdlib.dsp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,131 @@
+# Microsoft Developer Studio Project File - Name="sqstdlib" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=sqstdlib - Win32 Release
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "sqstdlib.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "sqstdlib.mak" CFG="sqstdlib - Win32 Release"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "sqstdlib - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "sqstdlib - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_LocalPath ".."
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "sqstdlib - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD BASE RSC /l 0x410 /d "NDEBUG"
+# ADD RSC /l 0x410 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"..\lib\sqstdlib.lib"
+
+!ELSEIF  "$(CFG)" == "sqstdlib - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD BASE RSC /l 0x410 /d "_DEBUG"
+# ADD RSC /l 0x410 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"..\lib\sqstdlib.lib"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "sqstdlib - Win32 Release"
+# Name "sqstdlib - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\sqstdblob.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdio.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdmath.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdrex.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdstream.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdstring.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdaux.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdsystem.cpp
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\sqstdblobimpl.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdstream.h
+# End Source File
+# End Group
+# End Target
+# End Project

Added: trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdmath.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdmath.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdmath.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,106 @@
+/* see copyright notice in squirrel.h */
+#include <squirrel.h>
+#include <math.h>
+#include <stdlib.h>
+#include <sqstdmath.h>
+
+#define SINGLE_ARG_FUNC(_funcname) static SQInteger math_##_funcname(HSQUIRRELVM v){ \
+	SQFloat f; \
+	sq_getfloat(v,2,&f); \
+	sq_pushfloat(v,(SQFloat)_funcname(f)); \
+	return 1; \
+}
+
+#define TWO_ARGS_FUNC(_funcname) static SQInteger math_##_funcname(HSQUIRRELVM v){ \
+	SQFloat p1,p2; \
+	sq_getfloat(v,2,&p1); \
+	sq_getfloat(v,3,&p2); \
+	sq_pushfloat(v,(SQFloat)_funcname(p1,p2)); \
+	return 1; \
+}
+
+static SQInteger math_srand(HSQUIRRELVM v)
+{
+	SQInteger i;
+	if(SQ_FAILED(sq_getinteger(v,2,&i)))
+		return sq_throwerror(v,_SC("invalid param"));
+	srand((unsigned int)i);
+	return 0;
+}
+
+static SQInteger math_rand(HSQUIRRELVM v)
+{
+	sq_pushinteger(v,rand());
+	return 1;
+}
+
+static SQInteger math_abs(HSQUIRRELVM v)
+{
+	SQInteger n;
+	sq_getinteger(v,2,&n);
+	sq_pushinteger(v,(SQInteger)abs((int)n)); 
+	return 1; 
+}
+
+SINGLE_ARG_FUNC(sqrt)
+SINGLE_ARG_FUNC(fabs)
+SINGLE_ARG_FUNC(sin)
+SINGLE_ARG_FUNC(cos)
+SINGLE_ARG_FUNC(asin)
+SINGLE_ARG_FUNC(acos)
+SINGLE_ARG_FUNC(log)
+SINGLE_ARG_FUNC(log10)
+SINGLE_ARG_FUNC(tan)
+SINGLE_ARG_FUNC(atan)
+TWO_ARGS_FUNC(atan2)
+TWO_ARGS_FUNC(pow)
+SINGLE_ARG_FUNC(floor)
+SINGLE_ARG_FUNC(ceil)
+SINGLE_ARG_FUNC(exp)
+
+#define _DECL_FUNC(name,nparams,tycheck) {_SC(#name),math_##name,nparams,tycheck}
+static SQRegFunction mathlib_funcs[] = {
+	_DECL_FUNC(sqrt,2,_SC(".n")),
+	_DECL_FUNC(sin,2,_SC(".n")),
+	_DECL_FUNC(cos,2,_SC(".n")),
+	_DECL_FUNC(asin,2,_SC(".n")),
+	_DECL_FUNC(acos,2,_SC(".n")),
+	_DECL_FUNC(log,2,_SC(".n")),
+	_DECL_FUNC(log10,2,_SC(".n")),
+	_DECL_FUNC(tan,2,_SC(".n")),
+	_DECL_FUNC(atan,2,_SC(".n")),
+	_DECL_FUNC(atan2,3,_SC(".nn")),
+	_DECL_FUNC(pow,3,_SC(".nn")),
+	_DECL_FUNC(floor,2,_SC(".n")),
+	_DECL_FUNC(ceil,2,_SC(".n")),
+	_DECL_FUNC(exp,2,_SC(".n")),
+	_DECL_FUNC(srand,2,_SC(".n")),
+	_DECL_FUNC(rand,1,NULL),
+	_DECL_FUNC(fabs,2,_SC(".n")),
+	_DECL_FUNC(abs,2,_SC(".n")),
+	{0,0},
+};
+
+#ifndef M_PI
+#define M_PI (3.14159265358979323846)
+#endif
+
+SQRESULT sqstd_register_mathlib(HSQUIRRELVM v)
+{
+	SQInteger i=0;
+	while(mathlib_funcs[i].name!=0)	{
+		sq_pushstring(v,mathlib_funcs[i].name,-1);
+		sq_newclosure(v,mathlib_funcs[i].f,0);
+		sq_setparamscheck(v,mathlib_funcs[i].nparamscheck,mathlib_funcs[i].typemask);
+		sq_setnativeclosurename(v,-1,mathlib_funcs[i].name);
+		sq_createslot(v,-3);
+		i++;
+	}
+	sq_pushstring(v,_SC("RAND_MAX"),-1);
+	sq_pushinteger(v,RAND_MAX);
+	sq_createslot(v,-3);
+	sq_pushstring(v,_SC("PI"),-1);
+	sq_pushfloat(v,(SQFloat)M_PI);
+	sq_createslot(v,-3);
+	return SQ_OK;
+}

Added: trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdrex.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdrex.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdrex.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,637 @@
+/* see copyright notice in squirrel.h */
+#include <squirrel.h>
+#include <string.h>
+#include <ctype.h>
+#include <setjmp.h>
+#include "sqstdstring.h"
+
+#ifdef _UINCODE
+#define scisprint iswprint
+#else
+#define scisprint isprint
+#endif
+
+#ifdef _DEBUG
+#include <stdio.h>
+
+static const SQChar *g_nnames[] =
+{
+	_SC("NONE"),_SC("OP_GREEDY"),	_SC("OP_OR"),
+	_SC("OP_EXPR"),_SC("OP_NOCAPEXPR"),_SC("OP_DOT"),	_SC("OP_CLASS"),
+	_SC("OP_CCLASS"),_SC("OP_NCLASS"),_SC("OP_RANGE"),_SC("OP_CHAR"),
+	_SC("OP_EOL"),_SC("OP_BOL"),_SC("OP_WB")
+};
+
+#endif
+
+#define OP_GREEDY		(MAX_CHAR+1) // * + ? {n}
+#define OP_OR			(MAX_CHAR+2)
+#define OP_EXPR			(MAX_CHAR+3) //parentesis ()
+#define OP_NOCAPEXPR	(MAX_CHAR+4) //parentesis (?:)
+#define OP_DOT			(MAX_CHAR+5)
+#define OP_CLASS		(MAX_CHAR+6)
+#define OP_CCLASS		(MAX_CHAR+7)
+#define OP_NCLASS		(MAX_CHAR+8) //negates class the [^
+#define OP_RANGE		(MAX_CHAR+9)
+#define OP_CHAR			(MAX_CHAR+10)
+#define OP_EOL			(MAX_CHAR+11)
+#define OP_BOL			(MAX_CHAR+12)
+#define OP_WB			(MAX_CHAR+13)
+
+#define SQREX_SYMBOL_ANY_CHAR ('.')
+#define SQREX_SYMBOL_GREEDY_ONE_OR_MORE ('+')
+#define SQREX_SYMBOL_GREEDY_ZERO_OR_MORE ('*')
+#define SQREX_SYMBOL_GREEDY_ZERO_OR_ONE ('?')
+#define SQREX_SYMBOL_BRANCH ('|')
+#define SQREX_SYMBOL_END_OF_STRING ('$')
+#define SQREX_SYMBOL_BEGINNING_OF_STRING ('^')
+#define SQREX_SYMBOL_ESCAPE_CHAR ('\\')
+
+
+typedef int SQRexNodeType;
+
+typedef struct tagSQRexNode{
+	SQRexNodeType type;
+	SQInteger left;
+	SQInteger right;
+	SQInteger next;
+}SQRexNode;
+
+struct SQRex{
+	const SQChar *_eol;
+	const SQChar *_bol;
+	const SQChar *_p;
+	SQInteger _first;
+	SQInteger _op;
+	SQRexNode *_nodes;
+	SQInteger _nallocated;
+	SQInteger _nsize;
+	SQInteger _nsubexpr;
+	SQRexMatch *_matches;
+	SQInteger _currsubexp;
+	void *_jmpbuf;
+	const SQChar **_error;
+};
+
+static SQInteger sqstd_rex_list(SQRex *exp);
+
+static SQInteger sqstd_rex_newnode(SQRex *exp, SQRexNodeType type)
+{
+	SQRexNode n;
+	n.type = type;
+	n.next = n.right = n.left = -1;
+	if(type == OP_EXPR)
+		n.right = exp->_nsubexpr++;
+	if(exp->_nallocated < (exp->_nsize + 1)) {
+		SQInteger oldsize = exp->_nallocated;
+		exp->_nallocated *= 2;
+		exp->_nodes = (SQRexNode *)sq_realloc(exp->_nodes, oldsize * sizeof(SQRexNode) ,exp->_nallocated * sizeof(SQRexNode));
+	}
+	exp->_nodes[exp->_nsize++] = n;
+	SQInteger newid = exp->_nsize - 1;
+	return (SQInteger)newid;
+}
+
+static void sqstd_rex_error(SQRex *exp,const SQChar *error)
+{
+	if(exp->_error) *exp->_error = error;
+	longjmp(*((jmp_buf*)exp->_jmpbuf),-1);
+}
+
+static void sqstd_rex_expect(SQRex *exp, SQInteger n){
+	if((*exp->_p) != n) 
+		sqstd_rex_error(exp, _SC("expected paren"));
+	exp->_p++;
+}
+
+static SQChar sqstd_rex_escapechar(SQRex *exp)
+{
+	if(*exp->_p == SQREX_SYMBOL_ESCAPE_CHAR){
+		exp->_p++;
+		switch(*exp->_p) {
+		case 'v': exp->_p++; return '\v';
+		case 'n': exp->_p++; return '\n';
+		case 't': exp->_p++; return '\t';
+		case 'r': exp->_p++; return '\r';
+		case 'f': exp->_p++; return '\f';
+		default: return (*exp->_p++);
+		}
+	} else if(!scisprint(*exp->_p)) sqstd_rex_error(exp,_SC("letter expected"));
+	return (*exp->_p++);
+}
+
+static SQInteger sqstd_rex_charclass(SQRex *exp,SQInteger classid)
+{
+	SQInteger n = sqstd_rex_newnode(exp,OP_CCLASS);
+	exp->_nodes[n].left = classid;
+	return n;
+}
+
+static SQInteger sqstd_rex_charnode(SQRex *exp,SQBool isclass)
+{
+	SQChar t;
+	if(*exp->_p == SQREX_SYMBOL_ESCAPE_CHAR) {
+		exp->_p++;
+		switch(*exp->_p) {
+			case 'n': exp->_p++; return sqstd_rex_newnode(exp,'\n');
+			case 't': exp->_p++; return sqstd_rex_newnode(exp,'\t');
+			case 'r': exp->_p++; return sqstd_rex_newnode(exp,'\r');
+			case 'f': exp->_p++; return sqstd_rex_newnode(exp,'\f');
+			case 'v': exp->_p++; return sqstd_rex_newnode(exp,'\v');
+			case 'a': case 'A': case 'w': case 'W': case 's': case 'S': 
+			case 'd': case 'D': case 'x': case 'X': case 'c': case 'C': 
+			case 'p': case 'P': case 'l': case 'u': 
+				{
+				t = *exp->_p; exp->_p++; 
+				return sqstd_rex_charclass(exp,t);
+				}
+			case 'b': 
+			case 'B':
+				if(!isclass) {
+					SQInteger node = sqstd_rex_newnode(exp,OP_WB);
+					exp->_nodes[node].left = *exp->_p;
+					exp->_p++; 
+					return node;
+				} //else default
+			default: 
+				t = *exp->_p; exp->_p++; 
+				return sqstd_rex_newnode(exp,t);
+		}
+	}
+	else if(!scisprint(*exp->_p)) {
+		
+		sqstd_rex_error(exp,_SC("letter expected"));
+	}
+	t = *exp->_p; exp->_p++; 
+	return sqstd_rex_newnode(exp,t);
+}
+static SQInteger sqstd_rex_class(SQRex *exp)
+{
+	SQInteger ret = -1;
+	SQInteger first = -1,chain;
+	if(*exp->_p == SQREX_SYMBOL_BEGINNING_OF_STRING){
+		ret = sqstd_rex_newnode(exp,OP_NCLASS);
+		exp->_p++;
+	}else ret = sqstd_rex_newnode(exp,OP_CLASS);
+	
+	if(*exp->_p == ']') sqstd_rex_error(exp,_SC("empty class"));
+	chain = ret;
+	while(*exp->_p != ']' && exp->_p != exp->_eol) {
+		if(*exp->_p == '-' && first != -1){ 
+			SQInteger r;
+			if(*exp->_p++ == ']') sqstd_rex_error(exp,_SC("unfinished range"));
+			r = sqstd_rex_newnode(exp,OP_RANGE);
+			if(first>*exp->_p) sqstd_rex_error(exp,_SC("invalid range"));
+			if(exp->_nodes[first].type == OP_CCLASS) sqstd_rex_error(exp,_SC("cannot use character classes in ranges"));
+			exp->_nodes[r].left = exp->_nodes[first].type;
+			SQInteger t = sqstd_rex_escapechar(exp);
+			exp->_nodes[r].right = t;
+            exp->_nodes[chain].next = r;
+			chain = r;
+			first = -1;
+		}
+		else{
+			if(first!=-1){
+				SQInteger c = first;
+				exp->_nodes[chain].next = c;
+				chain = c;
+				first = sqstd_rex_charnode(exp,SQTrue);
+			}
+			else{
+				first = sqstd_rex_charnode(exp,SQTrue);
+			}
+		}
+	}
+	if(first!=-1){
+		SQInteger c = first;
+		exp->_nodes[chain].next = c;
+		chain = c;
+		first = -1;
+	}
+	/* hack? */
+	exp->_nodes[ret].left = exp->_nodes[ret].next;
+	exp->_nodes[ret].next = -1;
+	return ret;
+}
+
+static SQInteger sqstd_rex_parsenumber(SQRex *exp)
+{
+	SQInteger ret = *exp->_p-'0';
+	SQInteger positions = 10;
+	exp->_p++;
+	while(isdigit(*exp->_p)) {
+		ret = ret*10+(*exp->_p++-'0');
+		if(positions==1000000000) sqstd_rex_error(exp,_SC("overflow in numeric constant"));
+		positions *= 10;
+	};
+	return ret;
+}
+
+static SQInteger sqstd_rex_element(SQRex *exp)
+{
+	SQInteger ret = -1;
+	switch(*exp->_p)
+	{
+	case '(': {
+		SQInteger expr;
+		exp->_p++;
+
+
+		if(*exp->_p =='?') {
+			exp->_p++;
+			sqstd_rex_expect(exp,':');
+			expr = sqstd_rex_newnode(exp,OP_NOCAPEXPR);
+		}
+		else
+			expr = sqstd_rex_newnode(exp,OP_EXPR);
+		SQInteger newn = sqstd_rex_list(exp);
+		exp->_nodes[expr].left = newn;
+		ret = expr;
+		sqstd_rex_expect(exp,')');
+			  }
+			  break;
+	case '[':
+		exp->_p++;
+		ret = sqstd_rex_class(exp);
+		sqstd_rex_expect(exp,']');
+		break;
+	case SQREX_SYMBOL_END_OF_STRING: exp->_p++; ret = sqstd_rex_newnode(exp,OP_EOL);break;
+	case SQREX_SYMBOL_ANY_CHAR: exp->_p++; ret = sqstd_rex_newnode(exp,OP_DOT);break;
+	default:
+		ret = sqstd_rex_charnode(exp,SQFalse);
+		break;
+	}
+
+
+	SQInteger op;
+	SQBool isgreedy = SQFalse;
+	unsigned short p0 = 0, p1 = 0;
+	switch(*exp->_p){
+		case SQREX_SYMBOL_GREEDY_ZERO_OR_MORE: p0 = 0; p1 = 0xFFFF; exp->_p++; isgreedy = SQTrue; break;
+		case SQREX_SYMBOL_GREEDY_ONE_OR_MORE: p0 = 1; p1 = 0xFFFF; exp->_p++; isgreedy = SQTrue; break;
+		case SQREX_SYMBOL_GREEDY_ZERO_OR_ONE: p0 = 0; p1 = 1; exp->_p++; isgreedy = SQTrue; break;
+		case '{':
+			exp->_p++;
+			if(!isdigit(*exp->_p)) sqstd_rex_error(exp,_SC("number expected"));
+			p0 = (unsigned short)sqstd_rex_parsenumber(exp);
+			/*******************************/
+			switch(*exp->_p) {
+		case '}':
+			p1 = p0; exp->_p++;
+			break;
+		case ',':
+			exp->_p++;
+			p1 = 0xFFFF;
+			if(isdigit(*exp->_p)){
+				p1 = (unsigned short)sqstd_rex_parsenumber(exp);
+			}
+			sqstd_rex_expect(exp,'}');
+			break;
+		default:
+			sqstd_rex_error(exp,_SC(", or } expected"));
+			}
+			/*******************************/
+			isgreedy = SQTrue; 
+			break;
+
+	}
+	if(isgreedy) {
+		SQInteger nnode = sqstd_rex_newnode(exp,OP_GREEDY);
+		op = OP_GREEDY;
+		exp->_nodes[nnode].left = ret;
+		exp->_nodes[nnode].right = ((p0)<<16)|p1;
+		ret = nnode;
+	}
+
+	if((*exp->_p != SQREX_SYMBOL_BRANCH) && (*exp->_p != ')') && (*exp->_p != SQREX_SYMBOL_GREEDY_ZERO_OR_MORE) && (*exp->_p != SQREX_SYMBOL_GREEDY_ONE_OR_MORE) && (*exp->_p != '\0')) {
+		SQInteger nnode = sqstd_rex_element(exp);
+		exp->_nodes[ret].next = nnode;
+	}
+
+	return ret;
+}
+
+static SQInteger sqstd_rex_list(SQRex *exp)
+{
+	SQInteger ret=-1,e;
+	if(*exp->_p == SQREX_SYMBOL_BEGINNING_OF_STRING) {
+		exp->_p++;
+		ret = sqstd_rex_newnode(exp,OP_BOL);
+	}
+	e = sqstd_rex_element(exp);
+	if(ret != -1) {
+		exp->_nodes[ret].next = e;
+	}
+	else ret = e;
+
+	if(*exp->_p == SQREX_SYMBOL_BRANCH) {
+		SQInteger temp,tright;
+		exp->_p++;
+		temp = sqstd_rex_newnode(exp,OP_OR);
+		exp->_nodes[temp].left = ret;
+		tright = sqstd_rex_list(exp);
+		exp->_nodes[temp].right = tright;
+		ret = temp;
+	}
+	return ret;
+}
+
+static SQBool sqstd_rex_matchcclass(SQInteger cclass,SQChar c)
+{
+	switch(cclass) {
+	case 'a': return isalpha(c)?SQTrue:SQFalse;
+	case 'A': return !isalpha(c)?SQTrue:SQFalse;
+	case 'w': return (isalnum(c) || c == '_')?SQTrue:SQFalse;
+	case 'W': return (!isalnum(c) && c != '_')?SQTrue:SQFalse;
+	case 's': return isspace(c)?SQTrue:SQFalse;
+	case 'S': return !isspace(c)?SQTrue:SQFalse;
+	case 'd': return isdigit(c)?SQTrue:SQFalse;
+	case 'D': return !isdigit(c)?SQTrue:SQFalse;
+	case 'x': return isxdigit(c)?SQTrue:SQFalse;
+	case 'X': return !isxdigit(c)?SQTrue:SQFalse;
+	case 'c': return iscntrl(c)?SQTrue:SQFalse;
+	case 'C': return !iscntrl(c)?SQTrue:SQFalse;
+	case 'p': return ispunct(c)?SQTrue:SQFalse;
+	case 'P': return !ispunct(c)?SQTrue:SQFalse;
+	case 'l': return islower(c)?SQTrue:SQFalse;
+	case 'u': return isupper(c)?SQTrue:SQFalse;
+	}
+	return SQFalse; /*cannot happen*/
+}
+
+static SQBool sqstd_rex_matchclass(SQRex* exp,SQRexNode *node,SQChar c)
+{
+	do {
+		switch(node->type) {
+			case OP_RANGE:
+				if(c >= node->left && c <= node->right) return SQTrue;
+				break;
+			case OP_CCLASS:
+				if(sqstd_rex_matchcclass(node->left,c)) return SQTrue;
+				break;
+			default:
+				if(c == node->type)return SQTrue;
+		}
+	} while((node->next != -1) && (node = &exp->_nodes[node->next]));
+	return SQFalse;
+}
+
+static const SQChar *sqstd_rex_matchnode(SQRex* exp,SQRexNode *node,const SQChar *str,SQRexNode *next)
+{
+	
+	SQRexNodeType type = node->type;
+	switch(type) {
+	case OP_GREEDY: {
+		//SQRexNode *greedystop = (node->next != -1) ? &exp->_nodes[node->next] : NULL;
+		SQRexNode *greedystop = NULL;
+		SQInteger p0 = (node->right >> 16)&0x0000FFFF, p1 = node->right&0x0000FFFF, nmaches = 0;
+		const SQChar *s=str, *good = str;
+
+		if(node->next != -1) {
+			greedystop = &exp->_nodes[node->next];
+		}
+		else {
+			greedystop = next;
+		}
+
+		while((nmaches == 0xFFFF || nmaches < p1)) {
+
+			const SQChar *stop;
+			if(!(s = sqstd_rex_matchnode(exp,&exp->_nodes[node->left],s,greedystop)))
+				break;
+			nmaches++;
+			good=s;
+			if(greedystop) {
+				//checks that 0 matches satisfy the expression(if so skips)
+				//if not would always stop(for instance if is a '?')
+				if(greedystop->type != OP_GREEDY ||
+				(greedystop->type == OP_GREEDY && ((greedystop->right >> 16)&0x0000FFFF) != 0))
+				{
+					SQRexNode *gnext = NULL;
+					if(greedystop->next != -1) {
+						gnext = &exp->_nodes[greedystop->next];
+					}else if(next && next->next != -1){
+						gnext = &exp->_nodes[next->next];
+					}
+					stop = sqstd_rex_matchnode(exp,greedystop,s,gnext);
+					if(stop) {
+						//if satisfied stop it
+						if(p0 == p1 && p0 == nmaches) break;
+						else if(nmaches >= p0 && p1 == 0xFFFF) break;
+						else if(nmaches >= p0 && nmaches <= p1) break;
+					}
+				}
+			}
+			
+			if(s >= exp->_eol)
+				break;
+		}
+		if(p0 == p1 && p0 == nmaches) return good;
+		else if(nmaches >= p0 && p1 == 0xFFFF) return good;
+		else if(nmaches >= p0 && nmaches <= p1) return good;
+		return NULL;
+	}
+	case OP_OR: {
+			const SQChar *asd = str;
+			SQRexNode *temp=&exp->_nodes[node->left];
+			while( (asd = sqstd_rex_matchnode(exp,temp,asd,NULL)) ) {
+				if(temp->next != -1)
+					temp = &exp->_nodes[temp->next];
+				else
+					return asd;
+			}
+			asd = str;
+			temp = &exp->_nodes[node->right];
+			while( (asd = sqstd_rex_matchnode(exp,temp,asd,NULL)) ) {
+				if(temp->next != -1)
+					temp = &exp->_nodes[temp->next];
+				else
+					return asd;
+			}
+			return NULL;
+			break;
+	}
+	case OP_EXPR:
+	case OP_NOCAPEXPR:{
+			SQRexNode *n = &exp->_nodes[node->left];
+			const SQChar *cur = str;
+			SQInteger capture = -1;
+			if(node->type != OP_NOCAPEXPR && node->right == exp->_currsubexp) {
+				capture = exp->_currsubexp;
+				exp->_matches[capture].begin = cur;
+				exp->_currsubexp++;
+			}
+			
+			do {
+				SQRexNode *subnext = NULL;
+				if(n->next != -1) {
+					subnext = &exp->_nodes[n->next];
+				}else {
+					subnext = next;
+				}
+				if(!(cur = sqstd_rex_matchnode(exp,n,cur,subnext))) {
+					if(capture != -1){
+						exp->_matches[capture].begin = 0;
+						exp->_matches[capture].len = 0;
+					}
+					return NULL;
+				}
+			} while((n->next != -1) && (n = &exp->_nodes[n->next]));
+
+			if(capture != -1) 
+				exp->_matches[capture].len = cur - exp->_matches[capture].begin;
+			return cur;
+	}				 
+	case OP_WB:
+		if(str == exp->_bol && !isspace(*str)
+		 || (str == exp->_eol && !isspace(*(str-1)))
+		 || (!isspace(*str) && isspace(*(str+1)))
+		 || (isspace(*str) && !isspace(*(str+1))) ) {
+			return (node->left == 'b')?str:NULL;
+		}
+		return (node->left == 'b')?NULL:str;
+	case OP_BOL:
+		if(str == exp->_bol) return str;
+		return NULL;
+	case OP_EOL:
+		if(str == exp->_eol) return str;
+		return NULL;
+	case OP_DOT:{
+		*str++;
+				}
+		return str;
+	case OP_NCLASS:
+	case OP_CLASS:
+		if(sqstd_rex_matchclass(exp,&exp->_nodes[node->left],*str)?(type == OP_CLASS?SQTrue:SQFalse):(type == OP_NCLASS?SQTrue:SQFalse)) {
+			*str++;
+			return str;
+		}
+		return NULL;
+	case OP_CCLASS:
+		if(sqstd_rex_matchcclass(node->left,*str)) {
+			*str++;
+			return str;
+		}
+		return NULL;
+	default: /* char */
+		if(*str != node->type) return NULL;
+		*str++;
+		return str;
+	}
+	return NULL;
+}
+
+/* public api */
+SQRex *sqstd_rex_compile(const SQChar *pattern,const SQChar **error)
+{
+	SQRex *exp = (SQRex *)sq_malloc(sizeof(SQRex));
+	exp->_eol = exp->_bol = NULL;
+	exp->_p = pattern;
+	exp->_nallocated = (SQInteger)scstrlen(pattern) * sizeof(SQChar);
+	exp->_nodes = (SQRexNode *)sq_malloc(exp->_nallocated * sizeof(SQRexNode));
+	exp->_nsize = 0;
+	exp->_matches = 0;
+	exp->_nsubexpr = 0;
+	exp->_first = sqstd_rex_newnode(exp,OP_EXPR);
+	exp->_error = error;
+	exp->_jmpbuf = sq_malloc(sizeof(jmp_buf));
+	if(setjmp(*((jmp_buf*)exp->_jmpbuf)) == 0) {
+		SQInteger res = sqstd_rex_list(exp);
+		exp->_nodes[exp->_first].left = res;
+		if(*exp->_p!='\0')
+			sqstd_rex_error(exp,_SC("unexpected character"));
+#ifdef _DEBUG
+		{
+			SQInteger nsize,i;
+			SQRexNode *t;
+			nsize = exp->_nsize;
+			t = &exp->_nodes[0];
+			scprintf(_SC("\n"));
+			for(i = 0;i < nsize; i++) {
+				if(exp->_nodes[i].type>MAX_CHAR)
+					scprintf(_SC("[%02d] %10s "),i,g_nnames[exp->_nodes[i].type-MAX_CHAR]);
+				else
+					scprintf(_SC("[%02d] %10c "),i,exp->_nodes[i].type);
+				scprintf(_SC("left %02d right %02d next %02d\n"),exp->_nodes[i].left,exp->_nodes[i].right,exp->_nodes[i].next);
+			}
+			scprintf(_SC("\n"));
+		}
+#endif
+		exp->_matches = (SQRexMatch *) sq_malloc(exp->_nsubexpr * sizeof(SQRexMatch));
+		memset(exp->_matches,0,exp->_nsubexpr * sizeof(SQRexMatch));
+	}
+	else{
+		sqstd_rex_free(exp);
+		return NULL;
+	}
+	return exp;
+}
+
+void sqstd_rex_free(SQRex *exp)
+{
+	if(exp)	{
+		if(exp->_nodes) sq_free(exp->_nodes,exp->_nallocated * sizeof(SQRexNode));
+		if(exp->_jmpbuf) sq_free(exp->_jmpbuf,sizeof(jmp_buf));
+		if(exp->_matches) sq_free(exp->_matches,exp->_nsubexpr * sizeof(SQRexMatch));
+		sq_free(exp,sizeof(SQRex));
+	}
+}
+
+SQBool sqstd_rex_match(SQRex* exp,const SQChar* text)
+{
+	const SQChar* res = NULL;
+	exp->_bol = text;
+	exp->_eol = text + scstrlen(text);
+	exp->_currsubexp = 0;
+	res = sqstd_rex_matchnode(exp,exp->_nodes,text,NULL);
+	if(res == NULL || res != exp->_eol)
+		return SQFalse;
+	return SQTrue;
+}
+
+SQBool sqstd_rex_searchrange(SQRex* exp,const SQChar* text_begin,const SQChar* text_end,const SQChar** out_begin, const SQChar** out_end)
+{
+	const SQChar *cur = NULL;
+	SQInteger node = exp->_first;
+	if(text_begin >= text_end) return SQFalse;
+	exp->_bol = text_begin;
+	exp->_eol = text_end;
+	do {
+		cur = text_begin;
+		while(node != -1) {
+			exp->_currsubexp = 0;
+			cur = sqstd_rex_matchnode(exp,&exp->_nodes[node],cur,NULL);
+			if(!cur)
+				break;
+			node = exp->_nodes[node].next;
+		}
+		*text_begin++;
+	} while(cur == NULL && text_begin != text_end);
+
+	if(cur == NULL)
+		return SQFalse;
+
+	--text_begin;
+
+	if(out_begin) *out_begin = text_begin;
+	if(out_end) *out_end = cur;
+	return SQTrue;
+}
+
+SQBool sqstd_rex_search(SQRex* exp,const SQChar* text, const SQChar** out_begin, const SQChar** out_end)
+{
+	return sqstd_rex_searchrange(exp,text,text + scstrlen(text),out_begin,out_end);
+}
+
+SQInteger sqstd_rex_getsubexpcount(SQRex* exp)
+{
+	return exp->_nsubexpr;
+}
+
+SQBool sqstd_rex_getsubexp(SQRex* exp, SQInteger n, SQRexMatch *subexp)
+{
+	if( n<0 || n >= exp->_nsubexpr) return SQFalse;
+	*subexp = exp->_matches[n];
+	return SQTrue;
+}
+

Added: trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdstream.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdstream.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdstream.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,330 @@
+/* see copyright notice in squirrel.h */
+#include <new>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <squirrel.h>
+#include <sqstdio.h>
+#include <sqstdblob.h>
+#include "sqstdstream.h"
+#include "sqstdblobimpl.h"
+
+#define SETUP_STREAM(v) \
+	SQStream *self = NULL; \
+	if(SQ_FAILED(sq_getinstanceup(v,1,(SQUserPointer*)&self,(SQUserPointer)SQSTD_STREAM_TYPE_TAG))) \
+		return sq_throwerror(v,_SC("invalid type tag")); \
+	if(!self->IsValid())  \
+		return sq_throwerror(v,_SC("the stream is invalid"));
+
+SQInteger _stream_readblob(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	SQUserPointer data,blobp;
+	SQInteger size,res;
+	sq_getinteger(v,2,&size);
+	if(size > self->Len()) {
+		size = self->Len();
+	}
+	data = sq_getscratchpad(v,size);
+	res = self->Read(data,size);
+	if(res <= 0)
+		return sq_throwerror(v,_SC("no data left to read"));
+	blobp = sqstd_createblob(v,res);
+	memcpy(blobp,data,res);
+	return 1;
+}
+
+#define SAFE_READN(ptr,len) { \
+	if(self->Read(ptr,len) != len) return sq_throwerror(v,_SC("io error")); \
+	}
+SQInteger _stream_readn(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	SQInteger format;
+	sq_getinteger(v, 2, &format);
+	switch(format) {
+	case 'l': {
+		SQInteger i;
+		SAFE_READN(&i, sizeof(i));
+		sq_pushinteger(v, i);
+			  }
+		break;
+	case 'i': {
+		SQInt32 i;
+		SAFE_READN(&i, sizeof(i));
+		sq_pushinteger(v, i);
+			  }
+		break;
+	case 's': {
+		short s;
+		SAFE_READN(&s, sizeof(short));
+		sq_pushinteger(v, s);
+			  }
+		break;
+	case 'w': {
+		unsigned short w;
+		SAFE_READN(&w, sizeof(unsigned short));
+		sq_pushinteger(v, w);
+			  }
+		break;
+	case 'c': {
+		char c;
+		SAFE_READN(&c, sizeof(char));
+		sq_pushinteger(v, c);
+			  }
+		break;
+	case 'b': {
+		unsigned char c;
+		SAFE_READN(&c, sizeof(unsigned char));
+		sq_pushinteger(v, c);
+			  }
+		break;
+	case 'f': {
+		float f;
+		SAFE_READN(&f, sizeof(float));
+		sq_pushfloat(v, f);
+			  }
+		break;
+	case 'd': {
+		double d;
+		SAFE_READN(&d, sizeof(double));
+		sq_pushfloat(v, (SQFloat)d);
+			  }
+		break;
+	default:
+		return sq_throwerror(v, _SC("invalid format"));
+	}
+	return 1;
+}
+
+SQInteger _stream_writeblob(HSQUIRRELVM v)
+{
+	SQUserPointer data;
+	SQInteger size;
+	SETUP_STREAM(v);
+	if(SQ_FAILED(sqstd_getblob(v,2,&data)))
+		return sq_throwerror(v,_SC("invalid parameter"));
+	size = sqstd_getblobsize(v,2);
+	if(self->Write(data,size) != size)
+		return sq_throwerror(v,_SC("io error"));
+	sq_pushinteger(v,size);
+	return 1;
+}
+
+SQInteger _stream_writen(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	SQInteger format, ti;
+	SQFloat tf;
+	sq_getinteger(v, 3, &format);
+	switch(format) {
+	case 'l': {
+		SQInteger i;
+		sq_getinteger(v, 2, &ti);
+		i = ti;
+		self->Write(&i, sizeof(SQInteger));
+			  }
+		break;
+	case 'i': {
+		SQInt32 i;
+		sq_getinteger(v, 2, &ti);
+		i = (SQInt32)ti;
+		self->Write(&i, sizeof(SQInt32));
+			  }
+		break;
+	case 's': {
+		short s;
+		sq_getinteger(v, 2, &ti);
+		s = (short)ti;
+		self->Write(&s, sizeof(short));
+			  }
+		break;
+	case 'w': {
+		unsigned short w;
+		sq_getinteger(v, 2, &ti);
+		w = (unsigned short)ti;
+		self->Write(&w, sizeof(unsigned short));
+			  }
+		break;
+	case 'c': {
+		char c;
+		sq_getinteger(v, 2, &ti);
+		c = (char)ti;
+		self->Write(&c, sizeof(char));
+				  }
+		break;
+	case 'b': {
+		unsigned char b;
+		sq_getinteger(v, 2, &ti);
+		b = (unsigned char)ti;
+		self->Write(&b, sizeof(unsigned char));
+			  }
+		break;
+	case 'f': {
+		float f;
+		sq_getfloat(v, 2, &tf);
+		f = (float)tf;
+		self->Write(&f, sizeof(float));
+			  }
+		break;
+	case 'd': {
+		double d;
+		sq_getfloat(v, 2, &tf);
+		d = tf;
+		self->Write(&d, sizeof(double));
+			  }
+		break;
+	default:
+		return sq_throwerror(v, _SC("invalid format"));
+	}
+	return 0;
+}
+
+SQInteger _stream_seek(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	SQInteger offset, origin = SQ_SEEK_SET;
+	sq_getinteger(v, 2, &offset);
+	if(sq_gettop(v) > 2) {
+		SQInteger t;
+		sq_getinteger(v, 3, &t);
+		switch(t) {
+			case 'b': origin = SQ_SEEK_SET; break;
+			case 'c': origin = SQ_SEEK_CUR; break;
+			case 'e': origin = SQ_SEEK_END; break;
+			default: return sq_throwerror(v,_SC("invalid origin"));
+		}
+	}
+	sq_pushinteger(v, self->Seek(offset, origin));
+	return 1;
+}
+
+SQInteger _stream_tell(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	sq_pushinteger(v, self->Tell());
+	return 1;
+}
+
+SQInteger _stream_len(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	sq_pushinteger(v, self->Len());
+	return 1;
+}
+
+SQInteger _stream_flush(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	if(!self->Flush())
+		sq_pushinteger(v, 1);
+	else
+		sq_pushnull(v);
+	return 1;
+}
+
+SQInteger _stream_eos(HSQUIRRELVM v)
+{
+	SETUP_STREAM(v);
+	if(self->EOS())
+		sq_pushinteger(v, 1);
+	else
+		sq_pushnull(v);
+	return 1;
+}
+
+static SQRegFunction _stream_methods[] = {
+	_DECL_STREAM_FUNC(readblob,2,_SC("xn")),
+	_DECL_STREAM_FUNC(readn,2,_SC("xn")),
+	_DECL_STREAM_FUNC(writeblob,-2,_SC("xx")),
+	_DECL_STREAM_FUNC(writen,3,_SC("xnn")),
+	_DECL_STREAM_FUNC(seek,-2,_SC("xnn")),
+	_DECL_STREAM_FUNC(tell,1,_SC("x")),
+	_DECL_STREAM_FUNC(len,1,_SC("x")),
+	_DECL_STREAM_FUNC(eos,1,_SC("x")),
+	_DECL_STREAM_FUNC(flush,1,_SC("x")),
+	{0,0}
+};
+
+void init_streamclass(HSQUIRRELVM v)
+{
+	sq_pushregistrytable(v);
+	sq_pushstring(v,_SC("std_stream"),-1);
+	if(SQ_FAILED(sq_get(v,-2))) {
+		sq_pushstring(v,_SC("std_stream"),-1);
+		sq_newclass(v,SQFalse);
+		sq_settypetag(v,-1,(SQUserPointer)SQSTD_STREAM_TYPE_TAG);
+		SQInteger i = 0;
+		while(_stream_methods[i].name != 0) {
+			SQRegFunction &f = _stream_methods[i];
+			sq_pushstring(v,f.name,-1);
+			sq_newclosure(v,f.f,0);
+			sq_setparamscheck(v,f.nparamscheck,f.typemask);
+			sq_createslot(v,-3);
+			i++;
+		}
+		sq_createslot(v,-3);
+		sq_pushroottable(v);
+		sq_pushstring(v,_SC("stream"),-1);
+		sq_pushstring(v,_SC("std_stream"),-1);
+		sq_get(v,-4);
+		sq_createslot(v,-3);
+		sq_pop(v,1);
+	}
+	else {
+		sq_pop(v,1); //result
+	}
+	sq_pop(v,1);
+}
+
+SQRESULT declare_stream(HSQUIRRELVM v,SQChar* name,SQUserPointer typetag,SQChar* reg_name,SQRegFunction *methods,SQRegFunction *globals)
+{
+	if(sq_gettype(v,-1) != OT_TABLE)
+		return sq_throwerror(v,_SC("table expected"));
+	SQInteger top = sq_gettop(v);
+	//create delegate
+    init_streamclass(v);
+	sq_pushregistrytable(v);
+	sq_pushstring(v,reg_name,-1);
+	sq_pushstring(v,_SC("std_stream"),-1);
+	if(SQ_SUCCEEDED(sq_get(v,-3))) {
+		sq_newclass(v,SQTrue);
+		sq_settypetag(v,-1,typetag);
+		SQInteger i = 0;
+		while(methods[i].name != 0) {
+			SQRegFunction &f = methods[i];
+			sq_pushstring(v,f.name,-1);
+			sq_newclosure(v,f.f,0);
+			sq_setparamscheck(v,f.nparamscheck,f.typemask);
+			sq_setnativeclosurename(v,-1,f.name);
+			sq_createslot(v,-3);
+			i++;
+		}
+		sq_createslot(v,-3);
+		sq_pop(v,1);
+		
+		i = 0;
+		while(globals[i].name!=0)
+		{
+			SQRegFunction &f = globals[i];
+			sq_pushstring(v,f.name,-1);
+			sq_newclosure(v,f.f,0);
+			sq_setparamscheck(v,f.nparamscheck,f.typemask);
+			sq_setnativeclosurename(v,-1,f.name);
+			sq_createslot(v,-3);
+			i++;
+		}
+		//register the class in the target table
+		sq_pushstring(v,name,-1);
+		sq_pushregistrytable(v);
+		sq_pushstring(v,reg_name,-1);
+		sq_get(v,-2);
+		sq_remove(v,-2);
+		sq_createslot(v,-3);
+
+		sq_settop(v,top);
+		return SQ_OK;
+	}
+	sq_settop(v,top);
+	return SQ_ERROR;
+}

Added: trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdstream.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdstream.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdstream.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,18 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQSTD_STREAM_H_
+#define _SQSTD_STREAM_H_
+
+SQInteger _stream_readblob(HSQUIRRELVM v);
+SQInteger _stream_readline(HSQUIRRELVM v);
+SQInteger _stream_readn(HSQUIRRELVM v);
+SQInteger _stream_writeblob(HSQUIRRELVM v);
+SQInteger _stream_writen(HSQUIRRELVM v);
+SQInteger _stream_seek(HSQUIRRELVM v);
+SQInteger _stream_tell(HSQUIRRELVM v);
+SQInteger _stream_len(HSQUIRRELVM v);
+SQInteger _stream_eos(HSQUIRRELVM v);
+SQInteger _stream_flush(HSQUIRRELVM v);
+
+#define _DECL_STREAM_FUNC(name,nparams,typecheck) {_SC(#name),_stream_##name,nparams,typecheck}
+SQRESULT declare_stream(HSQUIRRELVM v,SQChar* name,SQUserPointer typetag,SQChar* reg_name,SQRegFunction *methods,SQRegFunction *globals);
+#endif /*_SQSTD_STREAM_H_*/

Added: trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdstring.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdstring.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdstring.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,350 @@
+/* see copyright notice in squirrel.h */
+#include <squirrel.h>
+#include <sqstdstring.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <assert.h>
+
+#ifdef SQUNICODE
+#define scstrchr wcschr
+#define scsnprintf wsnprintf
+#define scatoi _wtoi
+#define scstrtok wcstok
+#else
+#define scstrchr strchr
+#define scsnprintf snprintf
+#define scatoi atoi
+#define scstrtok strtok
+#endif
+#define MAX_FORMAT_LEN	20
+#define MAX_WFORMAT_LEN	3
+#define ADDITIONAL_FORMAT_SPACE (100*sizeof(SQChar))
+
+static SQInteger validate_format(HSQUIRRELVM v, SQChar *fmt, const SQChar *src, SQInteger n,SQInteger &width)
+{
+	SQChar swidth[MAX_WFORMAT_LEN];
+	SQInteger wc = 0;
+	SQInteger start = n;
+	fmt[0] = '%';
+	while (scstrchr(_SC("-+ #0"), src[n])) n++;
+	while (scisdigit(src[n])) {
+		swidth[wc] = src[n];
+		n++;
+		wc++;
+		if(wc>=MAX_WFORMAT_LEN)
+			return sq_throwerror(v,_SC("width format too long"));
+	}
+	swidth[wc] = '\0';
+	if(wc > 0) {
+		width = scatoi(swidth);
+	}
+	else
+		width = 0;
+	if (src[n] == '.') {
+	    n++;
+    	
+		wc = 0;
+		while (scisdigit(src[n])) {
+			swidth[wc] = src[n];
+			n++;
+			wc++;
+			if(wc>=MAX_WFORMAT_LEN)
+				return sq_throwerror(v,_SC("precision format too long"));
+		}
+		swidth[wc] = '\0';
+		if(wc > 0) {
+			width += scatoi(swidth);
+		}
+	}
+	if (n-start > MAX_FORMAT_LEN )
+		return sq_throwerror(v,_SC("format too long"));
+	memcpy(&fmt[1],&src[start],((n-start)+1)*sizeof(SQChar));
+	fmt[(n-start)+2] = '\0';
+	return n;
+}
+
+static SQInteger _string_format(HSQUIRRELVM v)
+{
+	const SQChar *format;
+	SQChar *dest;
+	SQChar fmt[MAX_FORMAT_LEN];
+	sq_getstring(v,2,&format);
+	SQInteger allocated = (sq_getsize(v,2)+1)*sizeof(SQChar);
+	dest = sq_getscratchpad(v,allocated);
+	SQInteger n = 0,i = 0, nparam = 3, w = 0;
+	while(format[n] != '\0') {
+		if(format[n] != '%') {
+			assert(i < allocated);
+			dest[i++] = format[n];
+			n++;
+		}
+		else if(format[n+1] == '%') { //handles %%
+				dest[i++] = '%';
+				n += 2; 
+		}
+		else {
+			n++;
+			if( nparam > sq_gettop(v) )
+				return sq_throwerror(v,_SC("not enough paramters for the given format string"));
+			n = validate_format(v,fmt,format,n,w);
+			if(n < 0) return -1;
+			SQInteger addlen = 0;
+			SQInteger valtype = 0;
+			const SQChar *ts;
+			SQInteger ti;
+			SQFloat tf;
+			switch(format[n]) {
+			case 's':
+				if(SQ_FAILED(sq_getstring(v,nparam,&ts))) 
+					return sq_throwerror(v,_SC("string expected for the specified format"));
+				addlen = (sq_getsize(v,nparam)*sizeof(SQChar))+((w+1)*sizeof(SQChar));
+				valtype = 's';
+				break;
+			case 'i': case 'd': case 'c':case 'o':  case 'u':  case 'x':  case 'X':
+				if(SQ_FAILED(sq_getinteger(v,nparam,&ti))) 
+					return sq_throwerror(v,_SC("integer expected for the specified format"));
+				addlen = (ADDITIONAL_FORMAT_SPACE)+((w+1)*sizeof(SQChar));
+				valtype = 'i';
+				break;
+			case 'f': case 'g': case 'G': case 'e':  case 'E':
+				if(SQ_FAILED(sq_getfloat(v,nparam,&tf))) 
+					return sq_throwerror(v,_SC("float expected for the specified format"));
+				addlen = (ADDITIONAL_FORMAT_SPACE)+((w+1)*sizeof(SQChar));
+				valtype = 'f';
+				break;
+			default:
+				return sq_throwerror(v,_SC("invalid format"));
+			}
+			n++;
+			allocated += addlen;
+			dest = sq_getscratchpad(v,allocated);
+			switch(valtype) {
+			case 's': i += scsprintf(&dest[i],fmt,ts); break;
+			case 'i': i += scsprintf(&dest[i],fmt,ti); break;
+			case 'f': i += scsprintf(&dest[i],fmt,tf); break;
+			};
+			nparam ++;
+		}
+	}
+	sq_pushstring(v,dest,i);
+	return 1;
+}
+
+static void __strip_l(const SQChar *str,const SQChar **start)
+{
+	const SQChar *t = str;
+	while(((*t) != '\0') && scisspace(*t)){ t++; }
+	*start = t;
+}
+
+static void __strip_r(const SQChar *str,SQInteger len,const SQChar **end)
+{
+	if(len == 0) {
+		*end = str;
+		return;
+	}
+	const SQChar *t = &str[len-1];
+	while(t != str && scisspace(*t)) { t--; }
+	*end = t+1;
+}
+
+static SQInteger _string_strip(HSQUIRRELVM v)
+{
+	const SQChar *str,*start,*end;
+	sq_getstring(v,2,&str);
+	SQInteger len = sq_getsize(v,2);
+	__strip_l(str,&start);
+	__strip_r(str,len,&end);
+	sq_pushstring(v,start,end - start);
+	return 1;
+}
+
+static SQInteger _string_lstrip(HSQUIRRELVM v)
+{
+	const SQChar *str,*start;
+	sq_getstring(v,2,&str);
+	__strip_l(str,&start);
+	sq_pushstring(v,start,-1);
+	return 1;
+}
+
+static SQInteger _string_rstrip(HSQUIRRELVM v)
+{
+	const SQChar *str,*end;
+	sq_getstring(v,2,&str);
+	SQInteger len = sq_getsize(v,2);
+	__strip_r(str,len,&end);
+	sq_pushstring(v,str,end - str);
+	return 1;
+}
+
+static SQInteger _string_split(HSQUIRRELVM v)
+{
+	const SQChar *str,*seps;
+	SQChar *stemp,*tok;
+	sq_getstring(v,2,&str);
+	sq_getstring(v,3,&seps);
+	if(sq_getsize(v,3) == 0) return sq_throwerror(v,_SC("empty separators string"));
+	SQInteger memsize = (sq_getsize(v,2)+1)*sizeof(SQChar);
+	stemp = sq_getscratchpad(v,memsize);
+	memcpy(stemp,str,memsize);
+	tok = scstrtok(stemp,seps);
+	sq_newarray(v,0);
+	while( tok != NULL ) {
+		sq_pushstring(v,tok,-1);
+		sq_arrayappend(v,-2);
+		tok = scstrtok( NULL, seps );
+	}
+	return 1;
+}
+
+#define SETUP_REX(v) \
+	SQRex *self = NULL; \
+	sq_getinstanceup(v,1,(SQUserPointer *)&self,0); 
+
+static SQInteger _rexobj_releasehook(SQUserPointer p, SQInteger size)
+{
+	SQRex *self = ((SQRex *)p);
+	sqstd_rex_free(self);
+	return 1;
+}
+
+static SQInteger _regexp_match(HSQUIRRELVM v)
+{
+	SETUP_REX(v);
+	const SQChar *str;
+	sq_getstring(v,2,&str);
+	if(sqstd_rex_match(self,str) == SQTrue)
+	{
+		sq_pushbool(v,SQTrue);
+		return 1;
+	}
+	sq_pushbool(v,SQFalse);
+	return 1;
+}
+
+static void _addrexmatch(HSQUIRRELVM v,const SQChar *str,const SQChar *begin,const SQChar *end)
+{
+	sq_newtable(v);
+	sq_pushstring(v,_SC("begin"),-1);
+	sq_pushinteger(v,begin - str);
+	sq_rawset(v,-3);
+	sq_pushstring(v,_SC("end"),-1);
+	sq_pushinteger(v,end - str);
+	sq_rawset(v,-3);
+}
+
+static SQInteger _regexp_search(HSQUIRRELVM v)
+{
+	SETUP_REX(v);
+	const SQChar *str,*begin,*end;
+	SQInteger start = 0;
+	sq_getstring(v,2,&str);
+	if(sq_gettop(v) > 2) sq_getinteger(v,3,&start);
+	if(sqstd_rex_search(self,str+start,&begin,&end) == SQTrue) {
+		_addrexmatch(v,str,begin,end);
+		return 1;
+	}
+	return 0;
+}
+
+static SQInteger _regexp_capture(HSQUIRRELVM v)
+{
+	SETUP_REX(v);
+	const SQChar *str,*begin,*end;
+	SQInteger start = 0;
+	sq_getstring(v,2,&str);
+	if(sq_gettop(v) > 2) sq_getinteger(v,3,&start);
+	if(sqstd_rex_search(self,str+start,&begin,&end) == SQTrue) {
+		SQInteger n = sqstd_rex_getsubexpcount(self);
+		SQRexMatch match;
+		sq_newarray(v,0);
+		for(SQInteger i = 0;i < n; i++) {
+			sqstd_rex_getsubexp(self,i,&match);
+			if(match.len > 0)
+				_addrexmatch(v,str,match.begin,match.begin+match.len);
+			else
+				_addrexmatch(v,str,str,str); //empty match
+			sq_arrayappend(v,-2);
+		}
+		return 1;
+	}
+	return 0;
+}
+
+static SQInteger _regexp_subexpcount(HSQUIRRELVM v)
+{
+	SETUP_REX(v);
+	sq_pushinteger(v,sqstd_rex_getsubexpcount(self));
+	return 1;
+}
+
+static SQInteger _regexp_constructor(HSQUIRRELVM v)
+{
+	const SQChar *error,*pattern;
+	sq_getstring(v,2,&pattern);
+	SQRex *rex = sqstd_rex_compile(pattern,&error);
+	if(!rex) return sq_throwerror(v,error);
+	sq_setinstanceup(v,1,rex);
+	sq_setreleasehook(v,1,_rexobj_releasehook);
+	return 0;
+}
+
+static SQInteger _regexp__typeof(HSQUIRRELVM v)
+{
+	sq_pushstring(v,_SC("regexp"),-1);
+	return 1;
+}
+
+#define _DECL_REX_FUNC(name,nparams,pmask) {_SC(#name),_regexp_##name,nparams,pmask}
+static SQRegFunction rexobj_funcs[]={
+	_DECL_REX_FUNC(constructor,2,_SC(".s")),
+	_DECL_REX_FUNC(search,-2,_SC("xsn")),
+	_DECL_REX_FUNC(match,2,_SC("xs")),
+	_DECL_REX_FUNC(capture,-2,_SC("xsn")),
+	_DECL_REX_FUNC(subexpcount,1,_SC("x")),
+	_DECL_REX_FUNC(_typeof,1,_SC("x")),
+	{0,0}
+};
+
+#define _DECL_FUNC(name,nparams,pmask) {_SC(#name),_string_##name,nparams,pmask}
+static SQRegFunction stringlib_funcs[]={
+	_DECL_FUNC(format,-2,_SC(".s")),
+	_DECL_FUNC(strip,2,_SC(".s")),
+	_DECL_FUNC(lstrip,2,_SC(".s")),
+	_DECL_FUNC(rstrip,2,_SC(".s")),
+	_DECL_FUNC(split,3,_SC(".ss")),
+	{0,0}
+};
+
+
+SQInteger sqstd_register_stringlib(HSQUIRRELVM v)
+{
+	sq_pushstring(v,_SC("regexp"),-1);
+	sq_newclass(v,SQFalse);
+	SQInteger i = 0;
+	while(rexobj_funcs[i].name != 0) {
+		SQRegFunction &f = rexobj_funcs[i];
+		sq_pushstring(v,f.name,-1);
+		sq_newclosure(v,f.f,0);
+		sq_setparamscheck(v,f.nparamscheck,f.typemask);
+		sq_setnativeclosurename(v,-1,f.name);
+		sq_createslot(v,-3);
+		i++;
+	}
+	sq_createslot(v,-3);
+
+	i = 0;
+	while(stringlib_funcs[i].name!=0)
+	{
+		sq_pushstring(v,stringlib_funcs[i].name,-1);
+		sq_newclosure(v,stringlib_funcs[i].f,0);
+		sq_setparamscheck(v,stringlib_funcs[i].nparamscheck,stringlib_funcs[i].typemask);
+		sq_setnativeclosurename(v,-1,stringlib_funcs[i].name);
+		sq_createslot(v,-3);
+		i++;
+	}
+	return 1;
+}

Added: trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdsystem.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdsystem.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/sqstdlib/sqstdsystem.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,147 @@
+/* see copyright notice in squirrel.h */
+#include <squirrel.h>
+#include <time.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sqstdsystem.h>
+
+#ifdef SQUNICODE
+#include <wchar.h>
+#define scgetenv _wgetenv
+#define scsystem _wsystem
+#define scasctime _wasctime
+#define scremove _wremove
+#define screname _wrename
+#else
+#define scgetenv getenv
+#define scsystem system
+#define scasctime asctime
+#define scremove remove
+#define screname rename
+#endif
+
+static SQInteger _system_getenv(HSQUIRRELVM v)
+{
+	const SQChar *s;
+	if(SQ_SUCCEEDED(sq_getstring(v,2,&s))){
+        sq_pushstring(v,scgetenv(s),-1);
+		return 1;
+	}
+	return 0;
+}
+
+
+static SQInteger _system_system(HSQUIRRELVM v)
+{
+	const SQChar *s;
+	if(SQ_SUCCEEDED(sq_getstring(v,2,&s))){
+		sq_pushinteger(v,scsystem(s));
+		return 1;
+	}
+	return sq_throwerror(v,_SC("wrong param"));
+}
+
+
+static SQInteger _system_clock(HSQUIRRELVM v)
+{
+	sq_pushfloat(v,((SQFloat)clock())/(SQFloat)CLOCKS_PER_SEC);
+	return 1;
+}
+
+static SQInteger _system_time(HSQUIRRELVM v)
+{
+	time_t t;
+	time(&t);
+	sq_pushinteger(v,*((SQInteger *)&t));
+	return 1;
+}
+
+static SQInteger _system_remove(HSQUIRRELVM v)
+{
+	const SQChar *s;
+	sq_getstring(v,2,&s);
+	if(scremove(s)==-1)
+		return sq_throwerror(v,_SC("remove() failed"));
+	return 0;
+}
+
+static SQInteger _system_rename(HSQUIRRELVM v)
+{
+	const SQChar *oldn,*newn;
+	sq_getstring(v,2,&oldn);
+	sq_getstring(v,3,&newn);
+	if(screname(oldn,newn)==-1)
+		return sq_throwerror(v,_SC("rename() failed"));
+	return 0;
+}
+
+static void _set_integer_slot(HSQUIRRELVM v,const SQChar *name,SQInteger val)
+{
+	sq_pushstring(v,name,-1);
+	sq_pushinteger(v,val);
+	sq_rawset(v,-3);
+}
+
+static SQInteger _system_date(HSQUIRRELVM v)
+{
+	time_t t;
+	SQInteger it;
+	SQInteger format = 'l';
+	if(sq_gettop(v) > 1) {
+		sq_getinteger(v,2,&it);
+		t = it;
+		if(sq_gettop(v) > 2) {
+			sq_getinteger(v,3,(SQInteger*)&format);
+		}
+	}
+	else {
+		time(&t);
+	}
+	tm *date;
+    if(format == 'u')
+		date = gmtime(&t);
+	else
+		date = localtime(&t);
+	if(!date)
+		return sq_throwerror(v,_SC("crt api failure"));
+	sq_newtable(v);
+	_set_integer_slot(v, _SC("sec"), date->tm_sec);
+    _set_integer_slot(v, _SC("min"), date->tm_min);
+    _set_integer_slot(v, _SC("hour"), date->tm_hour);
+    _set_integer_slot(v, _SC("day"), date->tm_mday);
+    _set_integer_slot(v, _SC("month"), date->tm_mon);
+    _set_integer_slot(v, _SC("year"), date->tm_year+1900);
+    _set_integer_slot(v, _SC("wday"), date->tm_wday);
+    _set_integer_slot(v, _SC("yday"), date->tm_yday);
+	return 1;
+}
+
+
+
+#define _DECL_FUNC(name,nparams,pmask) {_SC(#name),_system_##name,nparams,pmask}
+static SQRegFunction systemlib_funcs[]={
+	_DECL_FUNC(getenv,2,_SC(".s")),
+	_DECL_FUNC(system,2,_SC(".s")),
+	_DECL_FUNC(clock,1,NULL),
+	_DECL_FUNC(time,1,NULL),
+	_DECL_FUNC(date,-1,_SC(".nn")),
+	_DECL_FUNC(remove,2,_SC(".s")),
+	_DECL_FUNC(rename,3,_SC(".ss")),
+	{0,0}
+};
+
+
+SQInteger sqstd_register_systemlib(HSQUIRRELVM v)
+{
+	SQInteger i=0;
+	while(systemlib_funcs[i].name!=0)
+	{
+		sq_pushstring(v,systemlib_funcs[i].name,-1);
+		sq_newclosure(v,systemlib_funcs[i].f,0);
+		sq_setparamscheck(v,systemlib_funcs[i].nparamscheck,systemlib_funcs[i].typemask);
+		sq_setnativeclosurename(v,-1,systemlib_funcs[i].name);
+		sq_createslot(v,-3);
+		i++;
+	}
+	return 1;
+}

Added: trunk/windstille/lib/SQUIRREL2/squirrel/Makefile
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/Makefile	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/Makefile	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,52 @@
+SQUIRREL= ..
+
+
+OUT= $(SQUIRREL)/lib/libsquirrel.a
+INCZ= -I$(SQUIRREL)/include -I. -Iinclude
+DEFS= 
+LIB=	
+
+OBJS= \
+	sqapi.o \
+	sqbaselib.o \
+	sqcompiler.o \
+	sqdebug.o \
+	sqlexer.o \
+	sqobject.o \
+	sqparser.o \
+	sqstate.o \
+	sqtable.o \
+	sqvm.o \
+	sqmem.o \
+	sqclass.o
+	
+SRCS= \
+	sqapi.cpp \
+	sqbaselib.cpp \
+	sqfuncstate.cpp \
+	sqdebug.cpp \
+	sqlexer.cpp \
+	sqobject.cpp \
+	sqcompiler.cpp \
+	sqstate.cpp \
+	sqtable.cpp \
+	sqmem.cpp \
+	sqvm.cpp \
+	sqclass.cpp
+
+	
+	
+sq32:
+	gcc -O2  -fno-rtti -Wall -c $(SRCS) $(INCZ) $(DEFS)
+	ar rc $(OUT) *.o
+	rm *.o
+
+sqprof:
+	gcc -O2 -pg -fno-rtti -pie -gstabs -g3 -Wall -c $(SRCS) $(INCZ) $(DEFS)
+	ar rc $(OUT) *.o
+	rm *.o
+
+sq64:
+	gcc -O2  -D_SQ64 -fno-rtti -Wall -c $(SRCS) $(INCZ) $(DEFS)
+	ar rc $(OUT) *.o
+	rm *.o

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqapi.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqapi.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqapi.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,1249 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include "sqvm.h"
+#include "sqstring.h"
+#include "sqtable.h"
+#include "sqarray.h"
+#include "sqfuncproto.h"
+#include "sqclosure.h"
+#include "squserdata.h"
+#include "sqcompiler.h"
+#include "sqfuncstate.h"
+#include "sqclass.h"
+
+bool sq_aux_gettypedarg(HSQUIRRELVM v,SQInteger idx,SQObjectType type,SQObjectPtr **o)
+{
+	*o = &stack_get(v,idx);
+	if(type(**o) != type){
+		SQObjectPtr oval = v->PrintObjVal(**o);
+		v->Raise_Error(_SC("wrong argument type, expected '%s' got '%.50s'"),IdType2Name(type),_stringval(oval));
+		return false;
+	}
+	return true;
+}
+
+#define _GETSAFE_OBJ(v,idx,type,o) { if(!sq_aux_gettypedarg(v,idx,type,&o)) return SQ_ERROR; }
+
+#define sq_aux_paramscheck(v,count) \
+{ \
+	if(sq_gettop(v) < count){ v->Raise_Error(_SC("not enough params in the stack")); return SQ_ERROR; }\
+}		
+
+SQInteger sq_aux_throwobject(HSQUIRRELVM v,SQObjectPtr &e)
+{
+	v->_lasterror = e;
+	return SQ_ERROR;
+}
+
+SQInteger sq_aux_invalidtype(HSQUIRRELVM v,SQObjectType type)
+{
+	scsprintf(_ss(v)->GetScratchPad(100), _SC("unexpected type %s"), IdType2Name(type));
+	return sq_throwerror(v, _ss(v)->GetScratchPad(-1));
+}
+
+HSQUIRRELVM sq_open(SQInteger initialstacksize)
+{
+	SQSharedState *ss;
+	SQVM *v;
+	sq_new(ss, SQSharedState);
+	ss->Init();
+	v = (SQVM *)SQ_MALLOC(sizeof(SQVM));
+	new (v) SQVM(ss);
+	ss->_root_vm = v;
+	if(v->Init(NULL, initialstacksize)) {
+		return v;
+	} else {
+		sq_delete(v, SQVM);
+		return NULL;
+	}
+	return v;
+}
+
+HSQUIRRELVM sq_newthread(HSQUIRRELVM friendvm, SQInteger initialstacksize)
+{
+	SQSharedState *ss;
+	SQVM *v;
+	ss=_ss(friendvm);
+	
+	v= (SQVM *)SQ_MALLOC(sizeof(SQVM));
+	new (v) SQVM(ss);
+	
+	if(v->Init(friendvm, initialstacksize)) {
+		friendvm->Push(v);
+		return v;
+	} else {
+		sq_delete(v, SQVM);
+		return NULL;
+	}
+}
+
+SQInteger sq_getvmstate(HSQUIRRELVM v)
+{
+	if(v->_suspended)
+		return SQ_VMSTATE_SUSPENDED;
+	else { 
+		if(v->_callsstacksize != 0) return SQ_VMSTATE_RUNNING;
+		else return SQ_VMSTATE_IDLE;
+	}
+}
+
+void sq_seterrorhandler(HSQUIRRELVM v)
+{
+	SQObject o = stack_get(v, -1);
+	if(sq_isclosure(o) || sq_isnativeclosure(o) || sq_isnull(o)) {
+		v->_errorhandler = o;
+		v->Pop();
+	}
+}
+
+void sq_setdebughook(HSQUIRRELVM v)
+{
+	SQObject o = stack_get(v,-1);
+	if(sq_isclosure(o) || sq_isnativeclosure(o) || sq_isnull(o)) {
+		v->_debughook = o;
+		v->Pop();
+	}
+}
+
+void sq_close(HSQUIRRELVM v)
+{
+	SQSharedState *ss = _ss(v);
+	_thread(ss->_root_vm)->Finalize();
+	sq_delete(ss, SQSharedState);
+}
+
+SQRESULT sq_compile(HSQUIRRELVM v,SQLEXREADFUNC read,SQUserPointer p,const SQChar *sourcename,SQBool raiseerror)
+{
+	SQObjectPtr o;
+	if(Compile(v, read, p, sourcename, o, raiseerror?true:false, _ss(v)->_debuginfo)) {
+		v->Push(SQClosure::Create(_ss(v), _funcproto(o)));
+		return SQ_OK;
+	}
+	return SQ_ERROR;
+}
+
+void sq_enabledebuginfo(HSQUIRRELVM v, SQBool enable)
+{
+	_ss(v)->_debuginfo = enable?true:false;
+}
+
+void sq_notifyallexceptions(HSQUIRRELVM v, SQBool enable)
+{
+	_ss(v)->_notifyallexceptions = enable?true:false;
+}
+
+void sq_addref(HSQUIRRELVM v,HSQOBJECT *po)
+{
+	if(!ISREFCOUNTED(type(*po))) return;
+#ifdef NO_GARBAGE_COLLECTOR
+	__AddRef(po->_type,po->_unVal);
+#else
+	_ss(v)->_refs_table.AddRef(*po);
+#endif
+}
+
+SQBool sq_release(HSQUIRRELVM v,HSQOBJECT *po)
+{
+	if(!ISREFCOUNTED(type(*po))) return SQTrue;
+#ifdef NO_GARBAGE_COLLECTOR
+	__Release(po->_type,po->_unVal);
+	return SQFalse; //the ret val doesn't work(and cannot be fixed)
+#else
+	return _ss(v)->_refs_table.Release(*po);
+#endif
+}
+
+const SQChar *sq_objtostring(HSQOBJECT *o) 
+{
+	if(sq_type(*o) == OT_STRING) {
+		return _stringval(*o);
+	}
+	return NULL;
+}
+
+SQInteger sq_objtointeger(HSQOBJECT *o) 
+{
+	if(sq_isnumeric(*o)) {
+		return tointeger(*o);
+	}
+	return 0;
+}
+
+SQFloat sq_objtofloat(HSQOBJECT *o) 
+{
+	if(sq_isnumeric(*o)) {
+		return tofloat(*o);
+	}
+	return 0;
+}
+
+SQBool sq_objtobool(HSQOBJECT *o) 
+{
+	if(sq_isbool(*o)) {
+		return _integer(*o);
+	}
+	return SQFalse;
+}
+
+void sq_pushnull(HSQUIRRELVM v)
+{
+	v->Push(_null_);
+}
+
+void sq_pushstring(HSQUIRRELVM v,const SQChar *s,SQInteger len)
+{
+	if(s)
+		v->Push(SQObjectPtr(SQString::Create(_ss(v), s, len)));
+	else v->Push(_null_);
+}
+
+void sq_pushinteger(HSQUIRRELVM v,SQInteger n)
+{
+	v->Push(n);
+}
+
+void sq_pushbool(HSQUIRRELVM v,SQBool b)
+{
+	v->Push(b?true:false);
+}
+
+void sq_pushfloat(HSQUIRRELVM v,SQFloat n)
+{
+	v->Push(n);
+}
+
+void sq_pushuserpointer(HSQUIRRELVM v,SQUserPointer p)
+{
+	v->Push(p);
+}
+
+SQUserPointer sq_newuserdata(HSQUIRRELVM v,SQUnsignedInteger size)
+{
+	SQUserData *ud = SQUserData::Create(_ss(v), size);
+	v->Push(ud);
+	return ud->_val;
+}
+
+void sq_newtable(HSQUIRRELVM v)
+{
+	v->Push(SQTable::Create(_ss(v), 0));	
+}
+
+void sq_newarray(HSQUIRRELVM v,SQInteger size)
+{
+	v->Push(SQArray::Create(_ss(v), size));	
+}
+
+SQRESULT sq_newclass(HSQUIRRELVM v,SQBool hasbase)
+{
+	SQClass *baseclass = NULL;
+	if(hasbase) {
+		SQObjectPtr &base = stack_get(v,-1);
+		if(type(base) != OT_CLASS)
+			return sq_throwerror(v,_SC("invalid base type"));
+		baseclass = _class(base);
+	}
+	SQClass *newclass = SQClass::Create(_ss(v), baseclass);
+	if(baseclass) v->Pop();
+	v->Push(newclass);	
+	return SQ_OK;
+}
+
+SQBool sq_instanceof(HSQUIRRELVM v)
+{
+	SQObjectPtr &inst = stack_get(v,-1);
+	SQObjectPtr &cl = stack_get(v,-2);
+	if(type(inst) != OT_INSTANCE || type(cl) != OT_CLASS)
+		return sq_throwerror(v,_SC("invalid param type"));
+	return _instance(inst)->InstanceOf(_class(cl))?SQTrue:SQFalse;
+}
+
+SQRESULT sq_arrayappend(HSQUIRRELVM v,SQInteger idx)
+{
+	sq_aux_paramscheck(v,2);
+	SQObjectPtr *arr;
+	_GETSAFE_OBJ(v, idx, OT_ARRAY,arr);
+	_array(*arr)->Append(v->GetUp(-1));
+	v->Pop(1);
+	return SQ_OK;
+}
+
+SQRESULT sq_arraypop(HSQUIRRELVM v,SQInteger idx,SQBool pushval)
+{
+	sq_aux_paramscheck(v, 1);
+	SQObjectPtr *arr;
+	_GETSAFE_OBJ(v, idx, OT_ARRAY,arr);
+	if(_array(*arr)->Size() > 0) {
+        if(pushval != 0){ v->Push(_array(*arr)->Top()); }
+		_array(*arr)->Pop();
+		return SQ_OK;
+	}
+	return sq_throwerror(v, _SC("empty array"));
+}
+
+SQRESULT sq_arrayresize(HSQUIRRELVM v,SQInteger idx,SQInteger newsize)
+{
+	sq_aux_paramscheck(v,1);
+	SQObjectPtr *arr;
+	_GETSAFE_OBJ(v, idx, OT_ARRAY,arr);
+	if(_array(*arr)->Size() > 0) {
+		_array(*arr)->Resize(newsize);
+		return SQ_OK;
+	}
+	return SQ_OK;
+}
+
+
+SQRESULT sq_arrayreverse(HSQUIRRELVM v,SQInteger idx)
+{
+	sq_aux_paramscheck(v, 1);
+	SQObjectPtr *o;
+	_GETSAFE_OBJ(v, idx, OT_ARRAY,o);
+	SQArray *arr = _array(*o);
+	if(arr->Size() > 0) {
+		SQObjectPtr t;
+		SQInteger size = arr->Size();
+		SQInteger n = size >> 1; size -= 1;
+		for(SQInteger i = 0; i < n; i++) {
+			t = arr->_values[i];
+			arr->_values[i] = arr->_values[size-i];
+			arr->_values[size-i] = t;
+		}
+		return SQ_OK;
+	}
+	return SQ_OK;
+}
+
+void sq_newclosure(HSQUIRRELVM v,SQFUNCTION func,SQUnsignedInteger nfreevars)
+{
+	SQNativeClosure *nc = SQNativeClosure::Create(_ss(v), func);
+	nc->_nparamscheck = 0;
+	for(SQUnsignedInteger i = 0; i < nfreevars; i++) {
+		nc->_outervalues.push_back(v->Top());
+		v->Pop();
+	}
+	v->Push(SQObjectPtr(nc));	
+}
+
+SQRESULT sq_getclosureinfo(HSQUIRRELVM v,SQInteger idx,SQUnsignedInteger *nparams,SQUnsignedInteger *nfreevars)
+{
+	SQObject o = stack_get(v, idx);
+	if(sq_isclosure(o)) {
+		SQClosure *c = _closure(o);
+		SQFunctionProto *proto = _funcproto(c->_function);
+		*nparams = (SQUnsignedInteger)proto->_nparameters;
+        *nfreevars = (SQUnsignedInteger)c->_outervalues.size();
+		return SQ_OK;
+	}
+	return sq_throwerror(v,_SC("the object is not a closure"));
+}
+
+SQRESULT sq_setnativeclosurename(HSQUIRRELVM v,SQInteger idx,const SQChar *name)
+{
+	SQObject o = stack_get(v, idx);
+	if(sq_isnativeclosure(o)) {
+		SQNativeClosure *nc = _nativeclosure(o);
+		nc->_name = SQString::Create(_ss(v),name);
+		return SQ_OK;
+	}
+	return sq_throwerror(v,_SC("the object is not a nativeclosure"));
+}
+
+SQRESULT sq_setparamscheck(HSQUIRRELVM v,SQInteger nparamscheck,const SQChar *typemask)
+{
+	SQObject o = stack_get(v, -1);
+	if(!sq_isnativeclosure(o))
+		return sq_throwerror(v, _SC("native closure expected"));
+	SQNativeClosure *nc = _nativeclosure(o);
+	nc->_nparamscheck = nparamscheck;
+	if(typemask) {
+		SQIntVec res;
+		if(!CompileTypemask(res, typemask))
+			return sq_throwerror(v, _SC("invalid typemask"));
+		nc->_typecheck.copy(res);
+	}
+	else {
+		nc->_typecheck.resize(0);
+	}
+	if(nparamscheck == SQ_MATCHTYPEMASKSTRING) {
+		nc->_nparamscheck = nc->_typecheck.size();
+	}
+	return SQ_OK;
+}
+
+SQRESULT sq_bindenv(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	if(!sq_isnativeclosure(o) &&
+		!sq_isclosure(o))
+		return sq_throwerror(v,_SC("the target is not a closure"));
+    SQObjectPtr &env = stack_get(v,-1);
+	if(!sq_istable(env) &&
+		!sq_isclass(env) &&
+		!sq_isinstance(env))
+		return sq_throwerror(v,_SC("invalid environment"));
+	SQObjectPtr w = _refcounted(env)->GetWeakRef(type(env));
+	SQObjectPtr ret;
+	if(sq_isclosure(o)) {
+		SQClosure *c = _closure(o)->Clone();
+		c->_env = w;
+		ret = c;
+	}
+	else { //then must be a native closure
+		SQNativeClosure *c = _nativeclosure(o)->Clone();
+		c->_env = w;
+		ret = c;
+	}
+	v->Pop();
+	v->Push(ret);
+	return SQ_OK;
+}
+
+SQRESULT sq_clear(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObject &o=stack_get(v,idx);
+	switch(type(o)) {
+		case OT_TABLE: _table(o)->Clear();	break;
+		case OT_ARRAY: _array(o)->Resize(0); break;
+		default:
+			return sq_throwerror(v, _SC("clear only works on table and array"));
+		break;
+
+	}
+	return SQ_OK;
+}
+
+void sq_pushroottable(HSQUIRRELVM v)
+{
+	v->Push(v->_roottable);
+}
+
+void sq_pushregistrytable(HSQUIRRELVM v)
+{
+	v->Push(_ss(v)->_registry);
+}
+
+void sq_pushconsttable(HSQUIRRELVM v)
+{
+	v->Push(_ss(v)->_consts);
+}
+
+SQRESULT sq_setroottable(HSQUIRRELVM v)
+{
+	SQObject o = stack_get(v, -1);
+	if(sq_istable(o) || sq_isnull(o)) {
+		v->_roottable = o;
+		v->Pop();
+		return SQ_OK;
+	}
+	return sq_throwerror(v, _SC("ivalid type"));
+}
+
+SQRESULT sq_setconsttable(HSQUIRRELVM v)
+{
+	SQObject o = stack_get(v, -1);
+	if(sq_istable(o)) {
+		_ss(v)->_consts = o;
+		v->Pop();
+		return SQ_OK;
+	}
+	return sq_throwerror(v, _SC("ivalid type, expected table"));
+}
+
+void sq_setforeignptr(HSQUIRRELVM v,SQUserPointer p)
+{
+	v->_foreignptr = p;
+}
+
+SQUserPointer sq_getforeignptr(HSQUIRRELVM v)
+{
+	return v->_foreignptr;
+}
+
+void sq_push(HSQUIRRELVM v,SQInteger idx)
+{
+	v->Push(stack_get(v, idx));
+}
+
+SQObjectType sq_gettype(HSQUIRRELVM v,SQInteger idx)
+{
+	return type(stack_get(v, idx));
+}
+
+
+void sq_tostring(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &o = stack_get(v, idx);
+	SQObjectPtr res;
+	v->ToString(o,res);
+	v->Push(res);
+}
+
+void sq_tobool(HSQUIRRELVM v, SQInteger idx, SQBool *b)
+{
+	SQObjectPtr &o = stack_get(v, idx);
+	*b = v->IsFalse(o)?SQFalse:SQTrue;
+}
+
+SQRESULT sq_getinteger(HSQUIRRELVM v,SQInteger idx,SQInteger *i)
+{
+	SQObjectPtr &o = stack_get(v, idx);
+	if(sq_isnumeric(o)) {
+		*i = tointeger(o);
+		return SQ_OK;
+	}
+	return SQ_ERROR;
+}
+
+SQRESULT sq_getfloat(HSQUIRRELVM v,SQInteger idx,SQFloat *f)
+{
+	SQObjectPtr &o = stack_get(v, idx);
+	if(sq_isnumeric(o)) {
+		*f = tofloat(o);
+		return SQ_OK;
+	}
+	return SQ_ERROR;
+}
+
+SQRESULT sq_getbool(HSQUIRRELVM v,SQInteger idx,SQBool *b)
+{
+	SQObjectPtr &o = stack_get(v, idx);
+	if(sq_isbool(o)) {
+		*b = _integer(o);
+		return SQ_OK;
+	}
+	return SQ_ERROR;
+}
+
+SQRESULT sq_getstring(HSQUIRRELVM v,SQInteger idx,const SQChar **c)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_STRING,o);
+	*c = _stringval(*o);
+	return SQ_OK;
+}
+
+SQRESULT sq_getthread(HSQUIRRELVM v,SQInteger idx,HSQUIRRELVM *thread)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_THREAD,o);
+	*thread = _thread(*o);
+	return SQ_OK;
+}
+
+SQRESULT sq_clone(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	v->Push(_null_);
+	if(!v->Clone(o, stack_get(v, -1))){
+		v->Pop();
+		return sq_aux_invalidtype(v, type(o));
+	}
+	return SQ_OK;
+}
+
+SQInteger sq_getsize(HSQUIRRELVM v, SQInteger idx)
+{
+	SQObjectPtr &o = stack_get(v, idx);
+	SQObjectType type = type(o);
+	switch(type) {
+	case OT_STRING:		return _string(o)->_len;
+	case OT_TABLE:		return _table(o)->CountUsed();
+	case OT_ARRAY:		return _array(o)->Size();
+	case OT_USERDATA:	return _userdata(o)->_size;
+	default:
+		return sq_aux_invalidtype(v, type);
+	}
+}
+
+SQRESULT sq_getuserdata(HSQUIRRELVM v,SQInteger idx,SQUserPointer *p,SQUserPointer *typetag)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_USERDATA,o);
+	(*p) = _userdataval(*o);
+	if(typetag) *typetag = _userdata(*o)->_typetag;
+	return SQ_OK;
+}
+
+SQRESULT sq_settypetag(HSQUIRRELVM v,SQInteger idx,SQUserPointer typetag)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	switch(type(o)) {
+		case OT_USERDATA:	_userdata(o)->_typetag = typetag;	break;
+		case OT_CLASS:		_class(o)->_typetag = typetag;		break;
+		default:			return sq_throwerror(v,_SC("invalid object type"));
+	}
+	return SQ_OK;
+}
+
+SQRESULT sq_getobjtypetag(HSQOBJECT *o,SQUserPointer * typetag)
+{
+  switch(type(*o)) {
+    case OT_INSTANCE: *typetag = _instance(*o)->_class->_typetag; break;
+    case OT_USERDATA: *typetag = _userdata(*o)->_typetag; break;
+    case OT_CLASS:    *typetag = _class(*o)->_typetag; break;
+    default: return SQ_ERROR;
+  }
+  return SQ_OK;
+}
+
+SQRESULT sq_gettypetag(HSQUIRRELVM v,SQInteger idx,SQUserPointer *typetag)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	if(SQ_FAILED(sq_getobjtypetag(&o,typetag)))
+		return sq_throwerror(v,_SC("invalid object type"));
+	return SQ_OK;
+}
+
+SQRESULT sq_getuserpointer(HSQUIRRELVM v, SQInteger idx, SQUserPointer *p)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_USERPOINTER,o);
+	(*p) = _userpointer(*o);
+	return SQ_OK;
+}
+
+SQRESULT sq_setinstanceup(HSQUIRRELVM v, SQInteger idx, SQUserPointer p)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	if(type(o) != OT_INSTANCE) return sq_throwerror(v,_SC("the object is not a class instance"));
+	_instance(o)->_userpointer = p;
+	return SQ_OK;
+}
+
+SQRESULT sq_setclassudsize(HSQUIRRELVM v, SQInteger idx, SQInteger udsize)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	if(type(o) != OT_CLASS) return sq_throwerror(v,_SC("the object is not a class"));
+	if(_class(o)->_locked) return sq_throwerror(v,_SC("the class is locked"));
+	_class(o)->_udsize = udsize;
+	return SQ_OK;
+}
+
+
+SQRESULT sq_getinstanceup(HSQUIRRELVM v, SQInteger idx, SQUserPointer *p,SQUserPointer typetag)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	if(type(o) != OT_INSTANCE) return sq_throwerror(v,_SC("the object is not a class instance"));
+	(*p) = _instance(o)->_userpointer;
+	if(typetag != 0) {
+		SQClass *cl = _instance(o)->_class;
+		do{
+			if(cl->_typetag == typetag)
+				return SQ_OK;
+			cl = cl->_base;
+		}while(cl != NULL);
+		return sq_throwerror(v,_SC("invalid type tag"));
+	}
+	return SQ_OK;
+}
+
+SQInteger sq_gettop(HSQUIRRELVM v)
+{
+	return (v->_top) - v->_stackbase;
+}
+
+void sq_settop(HSQUIRRELVM v, SQInteger newtop)
+{
+	SQInteger top = sq_gettop(v);
+	if(top > newtop)
+		sq_pop(v, top - newtop);
+	else
+		while(top++ < newtop) sq_pushnull(v);
+}
+
+void sq_pop(HSQUIRRELVM v, SQInteger nelemstopop)
+{
+	assert(v->_top >= nelemstopop);
+	v->Pop(nelemstopop);
+}
+
+void sq_poptop(HSQUIRRELVM v)
+{
+	assert(v->_top >= 1);
+    v->Pop();
+}
+
+
+void sq_remove(HSQUIRRELVM v, SQInteger idx)
+{
+	v->Remove(idx);
+}
+
+SQInteger sq_cmp(HSQUIRRELVM v)
+{
+	SQInteger res;
+	v->ObjCmp(stack_get(v, -1), stack_get(v, -2),res);
+	return res;
+}
+
+SQRESULT sq_newslot(HSQUIRRELVM v, SQInteger idx, SQBool bstatic)
+{
+	sq_aux_paramscheck(v, 3);
+	SQObjectPtr &self = stack_get(v, idx);
+	if(type(self) == OT_TABLE || type(self) == OT_CLASS) {
+		SQObjectPtr &key = v->GetUp(-2);
+		if(type(key) == OT_NULL) return sq_throwerror(v, _SC("null is not a valid key"));
+		v->NewSlot(self, key, v->GetUp(-1),bstatic?true:false);
+		v->Pop(2);
+	}
+	return SQ_OK;
+}
+
+SQRESULT sq_deleteslot(HSQUIRRELVM v,SQInteger idx,SQBool pushval)
+{
+	sq_aux_paramscheck(v, 2);
+	SQObjectPtr *self;
+	_GETSAFE_OBJ(v, idx, OT_TABLE,self);
+	SQObjectPtr &key = v->GetUp(-1);
+	if(type(key) == OT_NULL) return sq_throwerror(v, _SC("null is not a valid key"));
+	SQObjectPtr res;
+	if(!v->DeleteSlot(*self, key, res)){
+		return SQ_ERROR;
+	}
+	if(pushval)	v->GetUp(-1) = res;
+	else v->Pop(1);
+	return SQ_OK;
+}
+
+SQRESULT sq_set(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &self = stack_get(v, idx);
+	if(v->Set(self, v->GetUp(-2), v->GetUp(-1),false)) {
+		v->Pop(2);
+		return SQ_OK;
+	}
+	v->Raise_IdxError(v->GetUp(-2));return SQ_ERROR;
+}
+
+SQRESULT sq_rawset(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &self = stack_get(v, idx);
+	if(type(v->GetUp(-2)) == OT_NULL) return sq_throwerror(v, _SC("null key"));
+	switch(type(self)) {
+	case OT_TABLE:
+		_table(self)->NewSlot(v->GetUp(-2), v->GetUp(-1));
+		v->Pop(2);
+		return SQ_OK;
+	break;
+	case OT_CLASS:
+		_class(self)->NewSlot(_ss(v), v->GetUp(-2), v->GetUp(-1),false);
+		v->Pop(2);
+		return SQ_OK;
+	break;
+	case OT_INSTANCE:
+		if(_instance(self)->Set(v->GetUp(-2), v->GetUp(-1))) {
+			v->Pop(2);
+			return SQ_OK;
+		}
+	break;
+	case OT_ARRAY:
+		if(v->Set(self, v->GetUp(-2), v->GetUp(-1),false)) {
+			v->Pop(2);
+			return SQ_OK;
+		}
+	break;
+	default:
+		v->Pop(2);
+		return sq_throwerror(v, _SC("rawset works only on array/table/class and instance"));
+	}
+	v->Raise_IdxError(v->GetUp(-2));return SQ_ERROR;
+}
+
+SQRESULT sq_setdelegate(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &self = stack_get(v, idx);
+	SQObjectPtr &mt = v->GetUp(-1);
+	SQObjectType type = type(self);
+	switch(type) {
+	case OT_TABLE:
+		if(type(mt) == OT_TABLE) {
+			if(!_table(self)->SetDelegate(_table(mt))) return sq_throwerror(v, _SC("delagate cycle")); v->Pop();}
+		else if(type(mt)==OT_NULL) {
+			_table(self)->SetDelegate(NULL); v->Pop(); }
+		else return sq_aux_invalidtype(v,type);
+		break;
+	case OT_USERDATA:
+		if(type(mt)==OT_TABLE) {
+			_userdata(self)->SetDelegate(_table(mt)); v->Pop(); }
+		else if(type(mt)==OT_NULL) {
+			_userdata(self)->SetDelegate(NULL); v->Pop(); }
+		else return sq_aux_invalidtype(v, type);
+		break;
+	default:
+			return sq_aux_invalidtype(v, type);
+		break;
+	}
+	return SQ_OK;
+}
+
+SQRESULT sq_rawdeleteslot(HSQUIRRELVM v,SQInteger idx,SQBool pushval)
+{
+	sq_aux_paramscheck(v, 2);
+	SQObjectPtr *self;
+	_GETSAFE_OBJ(v, idx, OT_TABLE,self);
+	SQObjectPtr &key = v->GetUp(-1);
+	SQObjectPtr t;
+	if(_table(*self)->Get(key,t)) {
+		_table(*self)->Remove(key);
+	}
+	if(pushval != 0)
+		if(pushval)	v->GetUp(-1) = t;
+	else
+		v->Pop(1);
+	return SQ_OK;
+}
+
+SQRESULT sq_getdelegate(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &self=stack_get(v,idx);
+	switch(type(self)){
+	case OT_TABLE:
+	case OT_USERDATA:
+		if(!_delegable(self)->_delegate){
+			v->Push(_null_);
+			break;
+		}
+		v->Push(SQObjectPtr(_delegable(self)->_delegate));
+		break;
+	default: return sq_throwerror(v,_SC("wrong type")); break;
+	}
+	return SQ_OK;
+	
+}
+
+SQRESULT sq_get(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &self=stack_get(v,idx);
+	if(v->Get(self,v->GetUp(-1),v->GetUp(-1),false,false))
+		return SQ_OK;
+	v->Pop(1);
+	return sq_throwerror(v,_SC("the index doesn't exist"));
+}
+
+SQRESULT sq_rawget(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &self=stack_get(v,idx);
+	switch(type(self)) {
+	case OT_TABLE:
+		if(_table(self)->Get(v->GetUp(-1),v->GetUp(-1)))
+			return SQ_OK;
+		break;
+	case OT_CLASS:
+		if(_class(self)->Get(v->GetUp(-1),v->GetUp(-1)))
+			return SQ_OK;
+		break;
+	case OT_INSTANCE:
+		if(_instance(self)->Get(v->GetUp(-1),v->GetUp(-1)))
+			return SQ_OK;
+		break;
+	case OT_ARRAY:
+		if(v->Get(self,v->GetUp(-1),v->GetUp(-1),false,false))
+			return SQ_OK;
+		break;
+	default:
+		v->Pop(1);
+		return sq_throwerror(v,_SC("rawget works only on array/table/instance and class"));
+	}	
+	v->Pop(1);
+	return sq_throwerror(v,_SC("the index doesn't exist"));
+}
+
+SQRESULT sq_getstackobj(HSQUIRRELVM v,SQInteger idx,HSQOBJECT *po)
+{
+	*po=stack_get(v,idx);
+	return SQ_OK;
+}
+
+const SQChar *sq_getlocal(HSQUIRRELVM v,SQUnsignedInteger level,SQUnsignedInteger idx)
+{
+	SQUnsignedInteger cstksize=v->_callsstacksize;
+	SQUnsignedInteger lvl=(cstksize-level)-1;
+	SQInteger stackbase=v->_stackbase;
+	if(lvl<cstksize){
+		for(SQUnsignedInteger i=0;i<level;i++){
+			SQVM::CallInfo &ci=v->_callsstack[(cstksize-i)-1];
+			stackbase-=ci._prevstkbase;
+		}
+		SQVM::CallInfo &ci=v->_callsstack[lvl];
+		if(type(ci._closure)!=OT_CLOSURE)
+			return NULL;
+		SQClosure *c=_closure(ci._closure);
+		SQFunctionProto *func=_funcproto(c->_function);
+		if(func->_noutervalues > (SQInteger)idx) {
+			v->Push(c->_outervalues[idx]);
+			return _stringval(func->_outervalues[idx]._name);
+		}
+		idx -= func->_noutervalues;
+		return func->GetLocal(v,stackbase,idx,(SQInteger)(ci._ip-func->_instructions)-1);
+	}
+	return NULL;
+}
+
+void sq_pushobject(HSQUIRRELVM v,HSQOBJECT obj)
+{
+	v->Push(SQObjectPtr(obj));
+}
+
+void sq_resetobject(HSQOBJECT *po)
+{
+	po->_unVal.pUserPointer=NULL;po->_type=OT_NULL;
+}
+
+SQRESULT sq_throwerror(HSQUIRRELVM v,const SQChar *err)
+{
+	v->_lasterror=SQString::Create(_ss(v),err);
+	return -1;
+}
+
+void sq_reseterror(HSQUIRRELVM v)
+{
+	v->_lasterror = _null_;
+}
+
+void sq_getlasterror(HSQUIRRELVM v)
+{
+	v->Push(v->_lasterror);
+}
+
+void sq_reservestack(HSQUIRRELVM v,SQInteger nsize)
+{
+	if (((SQUnsignedInteger)v->_top + nsize) > v->_stack.size()) {
+		v->_stack.resize(v->_stack.size() + ((v->_top + nsize) - v->_stack.size()));
+	}
+}
+
+SQRESULT sq_resume(HSQUIRRELVM v,SQBool retval,SQBool raiseerror)
+{
+	if(type(v->GetUp(-1))==OT_GENERATOR){
+		v->Push(_null_); //retval
+		if(!v->Execute(v->GetUp(-2),v->_top,0,v->_top,v->GetUp(-1),raiseerror,SQVM::ET_RESUME_GENERATOR))
+		{v->Raise_Error(v->_lasterror); return SQ_ERROR;}
+		if(!retval)
+			v->Pop();
+		return SQ_OK;
+	}
+	return sq_throwerror(v,_SC("only generators can be resumed"));
+}
+
+SQRESULT sq_call(HSQUIRRELVM v,SQInteger params,SQBool retval,SQBool raiseerror)
+{
+	SQObjectPtr res;
+	if(v->Call(v->GetUp(-(params+1)),params,v->_top-params,res,raiseerror?true:false)){
+		if(!v->_suspended) {
+			v->Pop(params);//pop closure and args
+		}
+		if(retval){
+			v->Push(res); return SQ_OK;
+		}
+		return SQ_OK;
+	}
+	else {
+		v->Pop(params);
+		return SQ_ERROR;
+	}
+	if(!v->_suspended)
+		v->Pop(params);
+	return sq_throwerror(v,_SC("call failed"));
+}
+
+SQRESULT sq_suspendvm(HSQUIRRELVM v)
+{
+	return v->Suspend();
+}
+
+SQRESULT sq_wakeupvm(HSQUIRRELVM v,SQBool wakeupret,SQBool retval,SQBool raiseerror)
+{
+	SQObjectPtr ret;
+	if(!v->_suspended)
+		return sq_throwerror(v,_SC("cannot resume a vm that is not running any code"));
+	if(wakeupret) {
+		v->GetAt(v->_stackbase+v->_suspended_target)=v->GetUp(-1); //retval
+		v->Pop();
+	} else v->GetAt(v->_stackbase+v->_suspended_target)=_null_;
+	if(!v->Execute(_null_,v->_top,-1,-1,ret,raiseerror,SQVM::ET_RESUME_VM))
+		return SQ_ERROR;
+	if(sq_getvmstate(v) == SQ_VMSTATE_IDLE) {
+		while (v->_top > 1) v->_stack[--v->_top] = _null_;
+	}
+	if(retval)
+		v->Push(ret);
+	return SQ_OK;
+}
+
+void sq_setreleasehook(HSQUIRRELVM v,SQInteger idx,SQRELEASEHOOK hook)
+{
+	if(sq_gettop(v) >= 1){
+		SQObjectPtr &ud=stack_get(v,idx);
+		switch( type(ud) ) {
+		case OT_USERDATA:	_userdata(ud)->_hook = hook;	break;
+		case OT_INSTANCE:	_instance(ud)->_hook = hook;	break;
+		case OT_CLASS:		_class(ud)->_hook = hook;		break;
+		default: break; //shutup compiler
+		}
+	}
+}
+
+void sq_setcompilererrorhandler(HSQUIRRELVM v,SQCOMPILERERROR f)
+{
+	_ss(v)->_compilererrorhandler = f;
+}
+
+SQRESULT sq_writeclosure(HSQUIRRELVM v,SQWRITEFUNC w,SQUserPointer up)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, -1, OT_CLOSURE,o);
+	unsigned short tag = SQ_BYTECODE_STREAM_TAG;
+	if(w(up,&tag,2) != 2)
+		return sq_throwerror(v,_SC("io error"));
+	if(!_closure(*o)->Save(v,up,w))
+		return SQ_ERROR;
+	return SQ_OK;
+}
+
+SQRESULT sq_readclosure(HSQUIRRELVM v,SQREADFUNC r,SQUserPointer up)
+{
+	SQObjectPtr closure;
+	
+	unsigned short tag;
+	if(r(up,&tag,2) != 2)
+		return sq_throwerror(v,_SC("io error"));
+	if(tag != SQ_BYTECODE_STREAM_TAG)
+		return sq_throwerror(v,_SC("invalid stream"));
+	if(!SQClosure::Load(v,up,r,closure))
+		return SQ_ERROR;
+	v->Push(closure);
+	return SQ_OK;
+}
+
+SQChar *sq_getscratchpad(HSQUIRRELVM v,SQInteger minsize)
+{
+	return _ss(v)->GetScratchPad(minsize);
+}
+
+SQInteger sq_collectgarbage(HSQUIRRELVM v)
+{
+#ifndef NO_GARBAGE_COLLECTOR
+	return _ss(v)->CollectGarbage(v);
+#else
+	return -1;
+#endif
+}
+
+const SQChar *sq_getfreevariable(HSQUIRRELVM v,SQInteger idx,SQUnsignedInteger nval)
+{
+	SQObjectPtr &self = stack_get(v,idx);
+	const SQChar *name = NULL;
+	if(type(self) == OT_CLOSURE) {
+		if(_closure(self)->_outervalues.size()>nval) {
+			v->Push(_closure(self)->_outervalues[nval]);
+			SQFunctionProto *fp = _funcproto(_closure(self)->_function);
+			SQOuterVar &ov = fp->_outervalues[nval];
+			name = _stringval(ov._name);
+		}
+	}
+	return name;
+}
+
+SQRESULT sq_setfreevariable(HSQUIRRELVM v,SQInteger idx,SQUnsignedInteger nval)
+{
+	SQObjectPtr &self=stack_get(v,idx);
+	switch(type(self))
+	{
+	case OT_CLOSURE:
+		if(_closure(self)->_outervalues.size()>nval){
+			_closure(self)->_outervalues[nval]=stack_get(v,-1);
+		}
+		else return sq_throwerror(v,_SC("invalid free var index"));
+		break;
+	case OT_NATIVECLOSURE:
+		if(_nativeclosure(self)->_outervalues.size()>nval){
+			_nativeclosure(self)->_outervalues[nval]=stack_get(v,-1);
+		}
+		else return sq_throwerror(v,_SC("invalid free var index"));
+		break;
+	default:
+		return sq_aux_invalidtype(v,type(self));
+	}
+	v->Pop(1);
+	return SQ_OK;
+}
+
+SQRESULT sq_setattributes(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_CLASS,o);
+	SQObjectPtr &key = stack_get(v,-2);
+	SQObjectPtr &val = stack_get(v,-1);
+	SQObjectPtr attrs;
+	if(type(key) == OT_NULL) {
+		attrs = _class(*o)->_attributes;
+		_class(*o)->_attributes = val;
+		v->Pop(2);
+		v->Push(attrs);
+		return SQ_OK;
+	}else if(_class(*o)->GetAttributes(key,attrs)) {
+		_class(*o)->SetAttributes(key,val);
+		v->Pop(2);
+		v->Push(attrs);
+		return SQ_OK;
+	}
+	return sq_throwerror(v,_SC("wrong index"));
+}
+
+SQRESULT sq_getattributes(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_CLASS,o);
+	SQObjectPtr &key = stack_get(v,-1);
+	SQObjectPtr attrs;
+	if(type(key) == OT_NULL) {
+		attrs = _class(*o)->_attributes;
+		v->Pop();
+		v->Push(attrs); 
+		return SQ_OK;
+	}
+	else if(_class(*o)->GetAttributes(key,attrs)) {
+		v->Pop();
+		v->Push(attrs);
+		return SQ_OK;
+	}
+	return sq_throwerror(v,_SC("wrong index"));
+}
+
+SQRESULT sq_getbase(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_CLASS,o);
+	if(_class(*o)->_base)
+		v->Push(SQObjectPtr(_class(*o)->_base));
+	else
+		v->Push(_null_);
+	return SQ_OK;
+}
+
+SQRESULT sq_getclass(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_INSTANCE,o);
+	v->Push(SQObjectPtr(_instance(*o)->_class));
+	return SQ_OK;
+}
+
+SQRESULT sq_createinstance(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr *o = NULL;
+	_GETSAFE_OBJ(v, idx, OT_CLASS,o);
+	v->Push(_class(*o)->CreateInstance());
+	return SQ_OK;
+}
+
+void sq_weakref(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObject &o=stack_get(v,idx);
+	if(ISREFCOUNTED(type(o))) {
+		v->Push(_refcounted(o)->GetWeakRef(type(o)));
+		return;
+	}
+	v->Push(o);
+}
+
+SQRESULT sq_getweakrefval(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr &o = stack_get(v,idx);
+	if(type(o) != OT_WEAKREF) {
+		return sq_throwerror(v,_SC("the object must be a weakref"));
+	}
+	v->Push(_weakref(o)->_obj);
+	return SQ_OK;
+}
+
+SQRESULT sq_getdefaultdelegate(HSQUIRRELVM v,SQObjectType t)
+{
+	SQSharedState *ss = _ss(v);
+	switch(t) {
+	case OT_TABLE: v->Push(ss->_table_default_delegate); break;
+	case OT_ARRAY: v->Push(ss->_array_default_delegate); break;
+	case OT_STRING: v->Push(ss->_string_default_delegate); break;
+	case OT_INTEGER: case OT_FLOAT: v->Push(ss->_number_default_delegate); break;
+	case OT_GENERATOR: v->Push(ss->_generator_default_delegate); break;
+	case OT_CLOSURE: case OT_NATIVECLOSURE: v->Push(ss->_closure_default_delegate); break;
+	case OT_THREAD: v->Push(ss->_thread_default_delegate); break;
+	case OT_CLASS: v->Push(ss->_class_default_delegate); break;
+	case OT_INSTANCE: v->Push(ss->_instance_default_delegate); break;
+	case OT_WEAKREF: v->Push(ss->_weakref_default_delegate); break;
+	default: return sq_throwerror(v,_SC("the type doesn't have a default delegate"));
+	}
+	return SQ_OK;
+}
+
+SQRESULT sq_next(HSQUIRRELVM v,SQInteger idx)
+{
+	SQObjectPtr o=stack_get(v,idx),&refpos = stack_get(v,-1),realkey,val;
+	if(type(o) == OT_GENERATOR) {
+		return sq_throwerror(v,_SC("cannot iterate a generator"));
+	}
+	int faketojump;
+	if(!v->FOREACH_OP(o,realkey,val,refpos,0,666,faketojump))
+		return SQ_ERROR;
+	if(faketojump != 666) {
+		v->Push(realkey);
+		v->Push(val);
+		return SQ_OK;
+	}
+	return SQ_ERROR;
+}
+
+struct BufState{
+	const SQChar *buf;
+	SQInteger ptr;
+	SQInteger size;
+};
+
+SQInteger buf_lexfeed(SQUserPointer file)
+{
+	BufState *buf=(BufState*)file;
+	if(buf->size<(buf->ptr+1))
+		return 0;
+	return buf->buf[buf->ptr++];
+}
+
+SQRESULT sq_compilebuffer(HSQUIRRELVM v,const SQChar *s,SQInteger size,const SQChar *sourcename,SQBool raiseerror) {
+	BufState buf;
+	buf.buf = s;
+	buf.size = size;
+	buf.ptr = 0;
+	return sq_compile(v, buf_lexfeed, &buf, sourcename, raiseerror);
+}
+
+void sq_move(HSQUIRRELVM dest,HSQUIRRELVM src,SQInteger idx)
+{
+	dest->Push(stack_get(src,idx));
+}
+
+void sq_setprintfunc(HSQUIRRELVM v, SQPRINTFUNCTION printfunc)
+{
+	_ss(v)->_printfunc = printfunc;
+}
+
+SQPRINTFUNCTION sq_getprintfunc(HSQUIRRELVM v)
+{
+	return _ss(v)->_printfunc;
+}
+
+void *sq_malloc(SQUnsignedInteger size)
+{
+	return SQ_MALLOC(size);
+}
+
+void *sq_realloc(void* p,SQUnsignedInteger oldsize,SQUnsignedInteger newsize)
+{
+	return SQ_REALLOC(p,oldsize,newsize);
+}
+
+void sq_free(void *p,SQUnsignedInteger size)
+{
+	SQ_FREE(p,size);
+}

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqarray.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqarray.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqarray.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,79 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQARRAY_H_
+#define _SQARRAY_H_
+
+struct SQArray : public CHAINABLE_OBJ
+{
+private:
+	SQArray(SQSharedState *ss,SQInteger nsize){_values.resize(nsize); INIT_CHAIN();ADD_TO_CHAIN(&_ss(this)->_gc_chain,this);}
+	~SQArray()
+	{
+		REMOVE_FROM_CHAIN(&_ss(this)->_gc_chain,this);
+	}
+public:
+	static SQArray* Create(SQSharedState *ss,SQInteger nInitialSize){
+		SQArray *newarray=(SQArray*)SQ_MALLOC(sizeof(SQArray));
+		new (newarray) SQArray(ss,nInitialSize);
+		return newarray;
+	}
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable **chain);
+#endif
+	void Finalize(){
+		_values.resize(0);
+	}
+	bool Get(const SQInteger nidx,SQObjectPtr &val)
+	{
+		if(nidx>=0 && nidx<(SQInteger)_values.size()){
+			SQObjectPtr &o = _values[nidx];
+			val = _realval(o);
+			return true;
+		}
+		else return false;
+	}
+	bool Set(const SQInteger nidx,const SQObjectPtr &val)
+	{
+		if(nidx>=0 && nidx<(SQInteger)_values.size()){
+			_values[nidx]=val;
+			return true;
+		}
+		else return false;
+	}
+	SQInteger Next(const SQObjectPtr &refpos,SQObjectPtr &outkey,SQObjectPtr &outval)
+	{
+		SQUnsignedInteger idx=TranslateIndex(refpos);
+		while(idx<_values.size()){
+			//first found
+			outkey=(SQInteger)idx;
+			SQObjectPtr &o = _values[idx];
+			outval = _realval(o);
+			//return idx for the next iteration
+			return ++idx;
+		}
+		//nothing to iterate anymore
+		return -1;
+	}
+	SQArray *Clone(){SQArray *anew=Create(_opt_ss(this),Size()); anew->_values.copy(_values); return anew; }
+	SQInteger Size() const {return _values.size();}
+	void Resize(SQInteger size,SQObjectPtr &fill = _null_) { _values.resize(size,fill); ShrinkIfNeeded(); }
+	void Reserve(SQInteger size) { _values.reserve(size); }
+	void Append(const SQObject &o){_values.push_back(o);}
+	void Extend(const SQArray *a);
+	SQObjectPtr &Top(){return _values.top();}
+	void Pop(){_values.pop_back(); ShrinkIfNeeded(); }
+	void Insert(const SQObject& idx,const SQObject &val){_values.insert((SQUnsignedInteger)tointeger(idx),val);}
+	void ShrinkIfNeeded() {
+		if(_values.size() <= _values.capacity()>>2) //shrink the array
+			_values.shrinktofit();
+	}
+	void Remove(SQUnsignedInteger idx){
+		_values.remove(idx);
+		ShrinkIfNeeded();
+	}
+	void Release()
+	{
+		sq_delete(this,SQArray);
+	}
+	SQObjectPtrVec _values;
+};
+#endif //_SQARRAY_H_

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqbaselib.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqbaselib.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqbaselib.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,900 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include "sqvm.h"
+#include "sqstring.h"
+#include "sqtable.h"
+#include "sqarray.h"
+#include "sqfuncproto.h"
+#include "sqclosure.h"
+#include "sqclass.h"
+#include <stdlib.h>
+#include <stdarg.h>
+#include <ctype.h>
+
+bool str2num(const SQChar *s,SQObjectPtr &res)
+{
+	SQChar *end;
+	if(scstrstr(s,_SC("."))){
+		SQFloat r = SQFloat(scstrtod(s,&end));
+		if(s == end) return false;
+		res = r;
+		return true;
+	}
+	else{
+		SQInteger r = SQInteger(scstrtol(s,&end,10));
+		if(s == end) return false;
+		res = r;
+		return true;
+	}
+}
+
+static SQInteger base_dummy(HSQUIRRELVM v)
+{
+	return 0;
+}
+
+#ifndef NO_GARBAGE_COLLECTOR
+static SQInteger base_collectgarbage(HSQUIRRELVM v)
+{
+	sq_pushinteger(v, sq_collectgarbage(v));
+	return 1;
+}
+#endif
+
+static SQInteger base_getroottable(HSQUIRRELVM v)
+{
+	v->Push(v->_roottable);
+	return 1;
+}
+
+static SQInteger base_getconsttable(HSQUIRRELVM v)
+{
+	v->Push(_ss(v)->_consts);
+	return 1;
+}
+
+
+static SQInteger base_setroottable(HSQUIRRELVM v)
+{
+	SQObjectPtr &o=stack_get(v,2);
+	if(SQ_FAILED(sq_setroottable(v))) return SQ_ERROR;
+	v->Push(o);
+	return 1;
+}
+
+static SQInteger base_setconsttable(HSQUIRRELVM v)
+{
+	SQObjectPtr &o=stack_get(v,2);
+	if(SQ_FAILED(sq_setconsttable(v))) return SQ_ERROR;
+	v->Push(o);
+	return 1;
+}
+
+static SQInteger base_seterrorhandler(HSQUIRRELVM v)
+{
+	sq_seterrorhandler(v);
+	return 0;
+}
+
+static SQInteger base_setdebughook(HSQUIRRELVM v)
+{
+	sq_setdebughook(v);
+	return 0;
+}
+
+static SQInteger base_enabledebuginfo(HSQUIRRELVM v)
+{
+	SQObjectPtr &o=stack_get(v,2);
+	sq_enabledebuginfo(v,(type(o) != OT_NULL)?1:0);
+	return 0;
+}
+
+static SQInteger base_getstackinfos(HSQUIRRELVM v)
+{
+	SQInteger level;
+	SQStackInfos si;
+	SQInteger seq = 0;
+	const SQChar *name = NULL;
+	sq_getinteger(v, -1, &level);
+	if (SQ_SUCCEEDED(sq_stackinfos(v, level, &si)))
+	{
+		const SQChar *fn = _SC("unknown");
+		const SQChar *src = _SC("unknown");
+		if(si.funcname)fn = si.funcname;
+		if(si.source)src = si.source;
+		sq_newtable(v);
+		sq_pushstring(v, _SC("func"), -1);
+		sq_pushstring(v, fn, -1);
+		sq_createslot(v, -3);
+		sq_pushstring(v, _SC("src"), -1);
+		sq_pushstring(v, src, -1);
+		sq_createslot(v, -3);
+		sq_pushstring(v, _SC("line"), -1);
+		sq_pushinteger(v, si.line);
+		sq_createslot(v, -3);
+		sq_pushstring(v, _SC("locals"), -1);
+		sq_newtable(v);
+		seq=0;
+		while ((name = sq_getlocal(v, level, seq))) {
+			sq_pushstring(v, name, -1);
+			sq_push(v, -2);
+			sq_createslot(v, -4);
+			sq_pop(v, 1);
+			seq++;
+		}
+		sq_createslot(v, -3);
+		return 1;
+	}
+
+	return 0;
+}
+
+static SQInteger base_assert(HSQUIRRELVM v)
+{
+	if(v->IsFalse(stack_get(v,2))){
+		return sq_throwerror(v,_SC("assertion failed"));
+	}
+	return 0;
+}
+
+static SQInteger get_slice_params(HSQUIRRELVM v,SQInteger &sidx,SQInteger &eidx,SQObjectPtr &o)
+{
+	SQInteger top = sq_gettop(v);
+	sidx=0;
+	eidx=0;
+	o=stack_get(v,1);
+	SQObjectPtr &start=stack_get(v,2);
+	if(type(start)!=OT_NULL && sq_isnumeric(start)){
+		sidx=tointeger(start);
+	}
+	if(top>2){
+		SQObjectPtr &end=stack_get(v,3);
+		if(sq_isnumeric(end)){
+			eidx=tointeger(end);
+		}
+	}
+	else {
+		eidx = sq_getsize(v,1);
+	}
+	return 1;
+}
+
+static SQInteger base_print(HSQUIRRELVM v)
+{
+	const SQChar *str;
+	sq_tostring(v,2);
+	sq_getstring(v,-1,&str);
+	if(_ss(v)->_printfunc) _ss(v)->_printfunc(v,_SC("%s"),str);
+	return 0;
+}
+
+static SQInteger base_compilestring(HSQUIRRELVM v)
+{
+	SQInteger nargs=sq_gettop(v);
+	const SQChar *src=NULL,*name=_SC("unnamedbuffer");
+	SQInteger size;
+	sq_getstring(v,2,&src);
+	size=sq_getsize(v,2);
+	if(nargs>2){
+		sq_getstring(v,3,&name);
+	}
+	if(SQ_SUCCEEDED(sq_compilebuffer(v,src,size,name,SQFalse)))
+		return 1;
+	else
+		return SQ_ERROR;
+}
+
+static SQInteger base_newthread(HSQUIRRELVM v)
+{
+	SQObjectPtr &func = stack_get(v,2);
+	SQInteger stksize = (_funcproto(_closure(func)->_function)->_stacksize << 1) +2;
+	HSQUIRRELVM newv = sq_newthread(v, (stksize < MIN_STACK_OVERHEAD + 2)? MIN_STACK_OVERHEAD + 2 : stksize);
+	sq_move(newv,v,-2);
+	return 1;
+}
+
+static SQInteger base_suspend(HSQUIRRELVM v)
+{
+	return sq_suspendvm(v);
+}
+
+static SQInteger base_array(HSQUIRRELVM v)
+{
+	SQArray *a;
+	SQObject &size = stack_get(v,2);
+	if(sq_gettop(v) > 2) {
+		a = SQArray::Create(_ss(v),0);
+		a->Resize(tointeger(size),stack_get(v,3));
+	}
+	else {
+		a = SQArray::Create(_ss(v),tointeger(size));
+	}
+	v->Push(a);
+	return 1;
+}
+
+static SQInteger base_type(HSQUIRRELVM v)
+{
+	SQObjectPtr &o = stack_get(v,2);
+	v->Push(SQString::Create(_ss(v),GetTypeName(o),-1));
+	return 1;
+}
+
+static SQRegFunction base_funcs[]={
+	//generic
+	{_SC("seterrorhandler"),base_seterrorhandler,2, NULL},
+	{_SC("setdebughook"),base_setdebughook,2, NULL},
+	{_SC("enabledebuginfo"),base_enabledebuginfo,2, NULL},
+	{_SC("getstackinfos"),base_getstackinfos,2, _SC(".n")},
+	{_SC("getroottable"),base_getroottable,1, NULL},
+	{_SC("setroottable"),base_setroottable,2, NULL},
+	{_SC("getconsttable"),base_getconsttable,1, NULL},
+	{_SC("setconsttable"),base_setconsttable,2, NULL},
+	{_SC("assert"),base_assert,2, NULL},
+	{_SC("print"),base_print,2, NULL},
+	{_SC("compilestring"),base_compilestring,-2, _SC(".ss")},
+	{_SC("newthread"),base_newthread,2, _SC(".c")},
+	{_SC("suspend"),base_suspend,-1, NULL},
+	{_SC("array"),base_array,-2, _SC(".n")},
+	{_SC("type"),base_type,2, NULL},
+	{_SC("dummy"),base_dummy,0,NULL},
+#ifndef NO_GARBAGE_COLLECTOR
+	{_SC("collectgarbage"),base_collectgarbage,1, _SC("t")},
+#endif
+	{0,0}
+};
+
+void sq_base_register(HSQUIRRELVM v)
+{
+	SQInteger i=0;
+	sq_pushroottable(v);
+	while(base_funcs[i].name!=0) {
+		sq_pushstring(v,base_funcs[i].name,-1);
+		sq_newclosure(v,base_funcs[i].f,0);
+		sq_setnativeclosurename(v,-1,base_funcs[i].name);
+		sq_setparamscheck(v,base_funcs[i].nparamscheck,base_funcs[i].typemask);
+		sq_createslot(v,-3);
+		i++;
+	}
+	sq_pushstring(v,_SC("_version_"),-1);
+	sq_pushstring(v,SQUIRREL_VERSION,-1);
+	sq_createslot(v,-3);
+	sq_pushstring(v,_SC("_charsize_"),-1);
+	sq_pushinteger(v,sizeof(SQChar));
+	sq_createslot(v,-3);
+	sq_pushstring(v,_SC("_intsize_"),-1);
+	sq_pushinteger(v,sizeof(SQInteger));
+	sq_createslot(v,-3);
+	sq_pop(v,1);
+}
+
+static SQInteger default_delegate_len(HSQUIRRELVM v)
+{
+	v->Push(SQInteger(sq_getsize(v,1)));
+	return 1;
+}
+
+static SQInteger default_delegate_tofloat(HSQUIRRELVM v)
+{
+	SQObjectPtr &o=stack_get(v,1);
+	switch(type(o)){
+	case OT_STRING:{
+		SQObjectPtr res;
+		if(str2num(_stringval(o),res)){
+			v->Push(SQObjectPtr(tofloat(res)));
+			break;
+		}}
+		return sq_throwerror(v, _SC("cannot convert the string"));
+		break;
+	case OT_INTEGER:case OT_FLOAT:
+		v->Push(SQObjectPtr(tofloat(o)));
+		break;
+	case OT_BOOL:
+		v->Push(SQObjectPtr((SQFloat)(_integer(o)?1:0)));
+		break;
+	default:
+		v->Push(_null_);
+		break;
+	}
+	return 1;
+}
+
+static SQInteger default_delegate_tointeger(HSQUIRRELVM v)
+{
+	SQObjectPtr &o=stack_get(v,1);
+	switch(type(o)){
+	case OT_STRING:{
+		SQObjectPtr res;
+		if(str2num(_stringval(o),res)){
+			v->Push(SQObjectPtr(tointeger(res)));
+			break;
+		}}
+		return sq_throwerror(v, _SC("cannot convert the string"));
+		break;
+	case OT_INTEGER:case OT_FLOAT:
+		v->Push(SQObjectPtr(tointeger(o)));
+		break;
+	case OT_BOOL:
+		v->Push(SQObjectPtr(_integer(o)?(SQInteger)1:(SQInteger)0));
+		break;
+	default:
+		v->Push(_null_);
+		break;
+	}
+	return 1;
+}
+
+static SQInteger default_delegate_tostring(HSQUIRRELVM v)
+{
+	sq_tostring(v,1);
+	return 1;
+}
+
+static SQInteger obj_delegate_weakref(HSQUIRRELVM v)
+{
+	sq_weakref(v,1);
+	return 1;
+}
+
+static SQInteger obj_clear(HSQUIRRELVM v)
+{
+	return sq_clear(v,-1);
+}
+
+
+static SQInteger number_delegate_tochar(HSQUIRRELVM v)
+{
+	SQObject &o=stack_get(v,1);
+	SQChar c = (SQChar)tointeger(o);
+	v->Push(SQString::Create(_ss(v),(const SQChar *)&c,1));
+	return 1;
+}
+
+
+/////////////////////////////////////////////////////////////////
+//TABLE DEFAULT DELEGATE
+
+static SQInteger table_rawdelete(HSQUIRRELVM v)
+{
+	if(SQ_FAILED(sq_rawdeleteslot(v,1,SQTrue)))
+		return SQ_ERROR;
+	return 1;
+}
+
+
+static SQInteger container_rawexists(HSQUIRRELVM v)
+{
+	if(SQ_SUCCEEDED(sq_rawget(v,-2))) {
+		sq_pushbool(v,SQTrue);
+		return 1;
+	}
+	sq_pushbool(v,SQFalse);
+	return 1;
+}
+
+static SQInteger table_rawset(HSQUIRRELVM v)
+{
+	return sq_rawset(v,-3);
+}
+
+
+static SQInteger table_rawget(HSQUIRRELVM v)
+{
+	return SQ_SUCCEEDED(sq_rawget(v,-2))?1:SQ_ERROR;
+}
+
+
+SQRegFunction SQSharedState::_table_default_delegate_funcz[]={
+	{_SC("len"),default_delegate_len,1, _SC("t")},
+	{_SC("rawget"),table_rawget,2, _SC("t")},
+	{_SC("rawset"),table_rawset,3, _SC("t")},
+	{_SC("rawdelete"),table_rawdelete,2, _SC("t")},
+	{_SC("rawin"),container_rawexists,2, _SC("t")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{_SC("clear"),obj_clear,1, _SC(".")},
+	{0,0}
+};
+
+//ARRAY DEFAULT DELEGATE///////////////////////////////////////
+
+static SQInteger array_append(HSQUIRRELVM v)
+{
+	return sq_arrayappend(v,-2);
+}
+
+static SQInteger array_extend(HSQUIRRELVM v)
+{
+	_array(stack_get(v,1))->Extend(_array(stack_get(v,2)));
+	return 0;
+}
+
+static SQInteger array_reverse(HSQUIRRELVM v)
+{
+	return sq_arrayreverse(v,-1);
+}
+
+static SQInteger array_pop(HSQUIRRELVM v)
+{
+	return SQ_SUCCEEDED(sq_arraypop(v,1,SQTrue))?1:SQ_ERROR;
+}
+
+static SQInteger array_top(HSQUIRRELVM v)
+{
+	SQObject &o=stack_get(v,1);
+	if(_array(o)->Size()>0){
+		v->Push(_array(o)->Top());
+		return 1;
+	}
+	else return sq_throwerror(v,_SC("top() on a empty array"));
+}
+
+static SQInteger array_insert(HSQUIRRELVM v)
+{
+	SQObject &o=stack_get(v,1);
+	SQObject &idx=stack_get(v,2);
+	SQObject &val=stack_get(v,3);
+	_array(o)->Insert(idx,val);
+	return 0;
+}
+
+static SQInteger array_remove(HSQUIRRELVM v)
+{
+	SQObject &o = stack_get(v, 1);
+	SQObject &idx = stack_get(v, 2);
+	if(!sq_isnumeric(idx)) return sq_throwerror(v, _SC("wrong type"));
+	SQObjectPtr val;
+	if(_array(o)->Get(tointeger(idx), val)) {
+		_array(o)->Remove(tointeger(idx));
+		v->Push(val);
+		return 1;
+	}
+	return sq_throwerror(v, _SC("idx out of range"));
+}
+
+static SQInteger array_resize(HSQUIRRELVM v)
+{
+	SQObject &o = stack_get(v, 1);
+	SQObject &nsize = stack_get(v, 2);
+	SQObjectPtr fill;
+	if(sq_isnumeric(nsize)) {
+		if(sq_gettop(v) > 2)
+			fill = stack_get(v, 3);
+		_array(o)->Resize(tointeger(nsize),fill);
+		return 0;
+	}
+	return sq_throwerror(v, _SC("size must be a number"));
+}
+
+
+//QSORT ala Sedgewick
+bool _qsort_compare(HSQUIRRELVM v,SQObjectPtr &arr,SQObjectPtr &a,SQObjectPtr &b,SQInteger func,SQInteger &ret)
+{
+	if(func < 0) {
+		if(!v->ObjCmp(a,b,ret)) return false;
+	}
+	else {
+		SQInteger top = sq_gettop(v);
+		sq_push(v, func);
+		sq_pushroottable(v);
+		v->Push(a);
+		v->Push(b);
+		if(SQ_FAILED(sq_call(v, 3, SQTrue, SQFalse))) {
+			v->Raise_Error(_SC("compare func failed"));
+			return false;
+		}
+		sq_getinteger(v, -1, &ret);
+		sq_settop(v, top);
+		return true;
+	}
+	return true;
+}
+//QSORT ala Sedgewick
+bool _qsort(HSQUIRRELVM v,SQObjectPtr &arr, SQInteger l, SQInteger r,SQInteger func)
+{
+	SQInteger i, j;
+	SQArray *a=_array(arr);
+	SQObjectPtr pivot,t;
+	if( l < r ){
+		pivot = a->_values[l];
+		i = l; j = r+1;
+		while(1){
+			SQInteger ret;
+			do { 
+				++i; 
+				if(i > r) break;
+				if(!_qsort_compare(v,arr,a->_values[i],pivot,func,ret))
+					return false;
+			} while( ret <= 0);
+			do {
+				--j; 
+				if(!_qsort_compare(v,arr,a->_values[j],pivot,func,ret))
+					return false;
+			}
+			while( ret > 0 );
+			if( i >= j ) break;
+			t = a->_values[i]; a->_values[i] = a->_values[j]; a->_values[j] = t;
+		}
+		t = a->_values[l]; a->_values[l] = a->_values[j]; a->_values[j] = t;
+		if(!_qsort( v, arr, l, j-1,func)) return false;
+		if(!_qsort( v, arr, j+1, r,func)) return false;
+	}
+	return true;
+}
+
+static SQInteger array_sort(HSQUIRRELVM v)
+{
+	SQInteger func = -1;
+	SQObjectPtr &o = stack_get(v,1);
+	SQObject &funcobj = stack_get(v,2);
+	if(_array(o)->Size() > 1) {
+		if(type(funcobj) == OT_CLOSURE || type(funcobj) == OT_NATIVECLOSURE) func = 2;
+		if(!_qsort(v, o, 0, _array(o)->Size()-1, func))
+			return SQ_ERROR;
+
+	}
+	return 0;
+}
+static SQInteger array_slice(HSQUIRRELVM v)
+{
+	SQInteger sidx,eidx;
+	SQObjectPtr o;
+	if(get_slice_params(v,sidx,eidx,o)==-1)return -1;
+	SQInteger alen = _array(o)->Size();
+	if(sidx < 0)sidx = alen + sidx;
+	if(eidx < 0)eidx = alen + eidx;
+	if(eidx < sidx)return sq_throwerror(v,_SC("wrong indexes"));
+	if(eidx > alen)return sq_throwerror(v,_SC("slice out of range"));
+	SQArray *arr=SQArray::Create(_ss(v),eidx-sidx);
+	SQObjectPtr t;
+	SQInteger count=0;
+	for(SQInteger i=sidx;i<eidx;i++){
+		_array(o)->Get(i,t);
+		arr->Set(count++,t);
+	}
+	v->Push(arr);
+	return 1;
+	
+}
+
+SQRegFunction SQSharedState::_array_default_delegate_funcz[]={
+	{_SC("len"),default_delegate_len,1, _SC("a")},
+	{_SC("append"),array_append,2, _SC("a")},
+	{_SC("extend"),array_extend,2, _SC("aa")},
+	{_SC("push"),array_append,2, _SC("a")},
+	{_SC("pop"),array_pop,1, _SC("a")},
+	{_SC("top"),array_top,1, _SC("a")},
+	{_SC("insert"),array_insert,3, _SC("an")},
+	{_SC("remove"),array_remove,2, _SC("an")},
+	{_SC("resize"),array_resize,-2, _SC("an")},
+	{_SC("reverse"),array_reverse,1, _SC("a")},
+	{_SC("sort"),array_sort,-1, _SC("ac")},
+	{_SC("slice"),array_slice,-1, _SC("ann")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{_SC("clear"),obj_clear,1, _SC(".")},
+	{0,0}
+};
+
+//STRING DEFAULT DELEGATE//////////////////////////
+static SQInteger string_slice(HSQUIRRELVM v)
+{
+	SQInteger sidx,eidx;
+	SQObjectPtr o;
+	if(SQ_FAILED(get_slice_params(v,sidx,eidx,o)))return -1;
+	SQInteger slen = _string(o)->_len;
+	if(sidx < 0)sidx = slen + sidx;
+	if(eidx < 0)eidx = slen + eidx;
+	if(eidx < sidx)	return sq_throwerror(v,_SC("wrong indexes"));
+	if(eidx > slen)	return sq_throwerror(v,_SC("slice out of range"));
+	v->Push(SQString::Create(_ss(v),&_stringval(o)[sidx],eidx-sidx));
+	return 1;
+}
+
+static SQInteger string_find(HSQUIRRELVM v)
+{
+	SQInteger top,start_idx=0;
+	const SQChar *str,*substr,*ret;
+	if(((top=sq_gettop(v))>1) && SQ_SUCCEEDED(sq_getstring(v,1,&str)) && SQ_SUCCEEDED(sq_getstring(v,2,&substr))){
+		if(top>2)sq_getinteger(v,3,&start_idx);
+		if((sq_getsize(v,1)>start_idx) && (start_idx>=0)){
+			ret=scstrstr(&str[start_idx],substr);
+			if(ret){
+				sq_pushinteger(v,(SQInteger)(ret-str));
+				return 1;
+			}
+		}
+		return 0;
+	}
+	return sq_throwerror(v,_SC("invalid param"));
+}
+
+#define STRING_TOFUNCZ(func) static SQInteger string_##func(HSQUIRRELVM v) \
+{ \
+	SQObject str=stack_get(v,1); \
+	SQInteger len=_string(str)->_len; \
+	const SQChar *sThis=_stringval(str); \
+	SQChar *sNew=(_ss(v)->GetScratchPad(rsl(len))); \
+	for(SQInteger i=0;i<len;i++) sNew[i]=func(sThis[i]); \
+	v->Push(SQString::Create(_ss(v),sNew,len)); \
+	return 1; \
+}
+
+
+STRING_TOFUNCZ(tolower)
+STRING_TOFUNCZ(toupper)
+
+SQRegFunction SQSharedState::_string_default_delegate_funcz[]={
+	{_SC("len"),default_delegate_len,1, _SC("s")},
+	{_SC("tointeger"),default_delegate_tointeger,1, _SC("s")},
+	{_SC("tofloat"),default_delegate_tofloat,1, _SC("s")},
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{_SC("slice"),string_slice,-1, _SC(" s n  n")},
+	{_SC("find"),string_find,-2, _SC("s s n ")},
+	{_SC("tolower"),string_tolower,1, _SC("s")},
+	{_SC("toupper"),string_toupper,1, _SC("s")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{0,0}
+};
+
+//INTEGER DEFAULT DELEGATE//////////////////////////
+SQRegFunction SQSharedState::_number_default_delegate_funcz[]={
+	{_SC("tointeger"),default_delegate_tointeger,1, _SC("n|b")},
+	{_SC("tofloat"),default_delegate_tofloat,1, _SC("n|b")},
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{_SC("tochar"),number_delegate_tochar,1, _SC("n|b")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{0,0}
+};
+
+//CLOSURE DEFAULT DELEGATE//////////////////////////
+static SQInteger closure_pcall(HSQUIRRELVM v)
+{
+	return SQ_SUCCEEDED(sq_call(v,sq_gettop(v)-1,SQTrue,SQFalse))?1:SQ_ERROR;
+}
+
+static SQInteger closure_call(HSQUIRRELVM v)
+{
+	return SQ_SUCCEEDED(sq_call(v,sq_gettop(v)-1,SQTrue,SQTrue))?1:SQ_ERROR;
+}
+
+static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
+{
+	SQArray *aparams=_array(stack_get(v,2));
+	SQInteger nparams=aparams->Size();
+	v->Push(stack_get(v,1));
+	for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
+	return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
+}
+
+static SQInteger closure_acall(HSQUIRRELVM v)
+{
+	return _closure_acall(v,SQTrue);
+}
+
+static SQInteger closure_pacall(HSQUIRRELVM v)
+{
+	return _closure_acall(v,SQFalse);
+}
+
+static SQInteger closure_bindenv(HSQUIRRELVM v)
+{
+	if(SQ_FAILED(sq_bindenv(v,1)))
+		return SQ_ERROR;
+	return 1;
+}
+
+static SQInteger closure_getinfos(HSQUIRRELVM v) {
+	SQObject o = stack_get(v,1);
+	SQTable *res = SQTable::Create(_ss(v),4);
+	if(type(o) == OT_CLOSURE) {
+		SQFunctionProto *f = _funcproto(_closure(o)->_function);
+		SQInteger nparams = f->_nparameters + (f->_varparams?1:0);
+		SQObjectPtr params = SQArray::Create(_ss(v),nparams);
+		for(SQInteger n = 0; n<f->_nparameters; n++) {
+			_array(params)->Set((SQInteger)n,f->_parameters[n]);
+		}
+		if(f->_varparams) {
+			_array(params)->Set(nparams-1,SQString::Create(_ss(v),_SC("..."),-1));
+		}
+		res->NewSlot(SQString::Create(_ss(v),_SC("native"),-1),false);
+		res->NewSlot(SQString::Create(_ss(v),_SC("name"),-1),f->_name);
+		res->NewSlot(SQString::Create(_ss(v),_SC("src"),-1),f->_sourcename);
+		res->NewSlot(SQString::Create(_ss(v),_SC("parameters"),-1),params);
+		res->NewSlot(SQString::Create(_ss(v),_SC("varargs"),-1),f->_varparams);
+	}
+	else { //OT_NATIVECLOSURE 
+		SQNativeClosure *nc = _nativeclosure(o);
+		res->NewSlot(SQString::Create(_ss(v),_SC("native"),-1),true);
+		res->NewSlot(SQString::Create(_ss(v),_SC("name"),-1),nc->_name);
+		res->NewSlot(SQString::Create(_ss(v),_SC("paramscheck"),-1),nc->_nparamscheck);
+		SQObjectPtr typecheck;
+		if(nc->_typecheck.size() > 0) {
+			typecheck =
+				SQArray::Create(_ss(v), nc->_typecheck.size());
+			for(SQUnsignedInteger n = 0; n<nc->_typecheck.size(); n++) {
+					_array(typecheck)->Set((SQInteger)n,nc->_typecheck[n]);
+			}
+		}
+		res->NewSlot(SQString::Create(_ss(v),_SC("typecheck"),-1),typecheck);
+	}
+	v->Push(res);
+	return 1;
+}
+
+
+SQRegFunction SQSharedState::_closure_default_delegate_funcz[]={
+	{_SC("call"),closure_call,-1, _SC("c")},
+	{_SC("pcall"),closure_pcall,-1, _SC("c")},
+	{_SC("acall"),closure_acall,2, _SC("ca")},
+	{_SC("pacall"),closure_pacall,2, _SC("ca")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{_SC("bindenv"),closure_bindenv,2, _SC("c x|y|t")},
+	{_SC("getinfos"),closure_getinfos,1, _SC("c")},
+	{0,0}
+};
+
+//GENERATOR DEFAULT DELEGATE
+static SQInteger generator_getstatus(HSQUIRRELVM v)
+{
+	SQObject &o=stack_get(v,1);
+	switch(_generator(o)->_state){
+		case SQGenerator::eSuspended:v->Push(SQString::Create(_ss(v),_SC("suspended")));break;
+		case SQGenerator::eRunning:v->Push(SQString::Create(_ss(v),_SC("running")));break;
+		case SQGenerator::eDead:v->Push(SQString::Create(_ss(v),_SC("dead")));break;
+	}
+	return 1;
+}
+
+SQRegFunction SQSharedState::_generator_default_delegate_funcz[]={
+	{_SC("getstatus"),generator_getstatus,1, _SC("g")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{0,0}
+};
+
+//THREAD DEFAULT DELEGATE
+
+static SQInteger thread_call(HSQUIRRELVM v)
+{
+	SQObjectPtr o = stack_get(v,1);
+	if(type(o) == OT_THREAD) {
+		SQInteger nparams = sq_gettop(v);
+		_thread(o)->Push(_thread(o)->_roottable);
+		for(SQInteger i = 2; i<(nparams+1); i++)
+			sq_move(_thread(o),v,i);
+		if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQFalse))) {
+			sq_move(v,_thread(o),-1);
+			return 1;
+		}
+		return SQ_ERROR;
+	}
+	return sq_throwerror(v,_SC("wrong parameter"));
+}
+
+static SQInteger thread_wakeup(HSQUIRRELVM v)
+{
+	SQObjectPtr o = stack_get(v,1);
+	if(type(o) == OT_THREAD) {
+		SQVM *thread = _thread(o);
+		SQInteger state = sq_getvmstate(thread);
+		if(state != SQ_VMSTATE_SUSPENDED) {
+			switch(state) {
+				case SQ_VMSTATE_IDLE:
+					return sq_throwerror(v,_SC("cannot wakeup a idle thread"));
+				break;
+				case SQ_VMSTATE_RUNNING:
+					return sq_throwerror(v,_SC("cannot wakeup a running thread"));
+				break;
+			}
+		}
+			
+		SQInteger wakeupret = sq_gettop(v)>1?1:0;
+		if(wakeupret) {
+			sq_move(thread,v,2);
+		}
+		if(SQ_SUCCEEDED(sq_wakeupvm(thread,wakeupret,1,SQFalse))) {
+			sq_move(v,thread,-1);
+			sq_pop(thread,1);
+			if(sq_getvmstate(thread) == SQ_VMSTATE_IDLE) {
+				sq_pop(thread,1);
+			}
+			return 1;
+		}
+		return SQ_ERROR;
+	}
+	return sq_throwerror(v,_SC("wrong parameter"));
+}
+
+static SQInteger thread_getstatus(HSQUIRRELVM v)
+{
+	SQObjectPtr &o = stack_get(v,1);
+	switch(sq_getvmstate(_thread(o))) {
+		case SQ_VMSTATE_IDLE:
+			sq_pushstring(v,_SC("idle"),-1);
+		break;
+		case SQ_VMSTATE_RUNNING:
+			sq_pushstring(v,_SC("running"),-1);
+		break;
+		case SQ_VMSTATE_SUSPENDED:
+			sq_pushstring(v,_SC("suspended"),-1);
+		break;
+		default:
+			return sq_throwerror(v,_SC("internal VM error"));
+	}
+	return 1;
+}
+
+SQRegFunction SQSharedState::_thread_default_delegate_funcz[] = {
+	{_SC("call"), thread_call, -1, _SC("v")},
+	{_SC("wakeup"), thread_wakeup, -1, _SC("v")},
+	{_SC("getstatus"), thread_getstatus, 1, _SC("v")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{0,0},
+};
+
+static SQInteger class_getattributes(HSQUIRRELVM v)
+{
+	if(SQ_SUCCEEDED(sq_getattributes(v,-2)))
+		return 1;
+	return SQ_ERROR;
+}
+
+static SQInteger class_setattributes(HSQUIRRELVM v)
+{
+	if(SQ_SUCCEEDED(sq_setattributes(v,-3)))
+		return 1;
+	return SQ_ERROR;
+}
+
+static SQInteger class_instance(HSQUIRRELVM v)
+{
+	if(SQ_SUCCEEDED(sq_createinstance(v,-1)))
+		return 1;
+	return SQ_ERROR;
+}
+
+SQRegFunction SQSharedState::_class_default_delegate_funcz[] = {
+	{_SC("getattributes"), class_getattributes, 2, _SC("y.")},
+	{_SC("setattributes"), class_setattributes, 3, _SC("y..")},
+	{_SC("rawin"),container_rawexists,2, _SC("y")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{_SC("instance"),class_instance,1, _SC("y")},
+	{0,0}
+};
+
+static SQInteger instance_getclass(HSQUIRRELVM v)
+{
+	if(SQ_SUCCEEDED(sq_getclass(v,1)))
+		return 1;
+	return SQ_ERROR;
+}
+
+SQRegFunction SQSharedState::_instance_default_delegate_funcz[] = {
+	{_SC("getclass"), instance_getclass, 1, _SC("x")},
+	{_SC("rawin"),container_rawexists,2, _SC("x")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{0,0}
+};
+
+static SQInteger weakref_ref(HSQUIRRELVM v)
+{
+	if(SQ_FAILED(sq_getweakrefval(v,1)))
+		return SQ_ERROR;
+	return 1;
+}
+
+SQRegFunction SQSharedState::_weakref_default_delegate_funcz[] = {
+	{_SC("ref"),weakref_ref,1, _SC("r")},
+	{_SC("weakref"),obj_delegate_weakref,1, NULL },
+	{_SC("tostring"),default_delegate_tostring,1, _SC(".")},
+	{0,0}
+};
+
+

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqclass.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqclass.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqclass.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,194 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include "sqvm.h"
+#include "sqtable.h"
+#include "sqclass.h"
+#include "sqclosure.h"
+
+SQClass::SQClass(SQSharedState *ss,SQClass *base)
+{
+	_base = base;
+	_typetag = 0;
+	_hook = NULL;
+	_udsize = 0;
+	_metamethods.resize(MT_LAST); //size it to max size
+	if(_base) {
+		_defaultvalues.copy(base->_defaultvalues);
+		_methods.copy(base->_methods);
+		_metamethods.copy(base->_metamethods);
+		__ObjAddRef(_base);
+	}
+	_members = base?base->_members->Clone() : SQTable::Create(ss,0);
+	__ObjAddRef(_members);
+	_locked = false;
+	INIT_CHAIN();
+	ADD_TO_CHAIN(&_sharedstate->_gc_chain, this);
+}
+
+void SQClass::Finalize() { 
+	_attributes = _null_;
+	_defaultvalues.resize(0);
+	_methods.resize(0);
+	_metamethods.resize(0);
+	__ObjRelease(_members);
+	if(_base) {
+		__ObjRelease(_base);
+	}
+}
+
+SQClass::~SQClass()
+{
+	REMOVE_FROM_CHAIN(&_sharedstate->_gc_chain, this);
+	Finalize();
+}
+
+bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)
+{
+	SQObjectPtr temp;
+	if(_locked) 
+		return false; //the class already has an instance so cannot be modified
+	if(_members->Get(key,temp) && _isfield(temp)) //overrides the default value
+	{
+		_defaultvalues[_member_idx(temp)].val = val;
+		return true;
+	}
+	if(type(val) == OT_CLOSURE || type(val) == OT_NATIVECLOSURE || bstatic) {
+		SQInteger mmidx;
+		if((type(val) == OT_CLOSURE || type(val) == OT_NATIVECLOSURE) && 
+			(mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {
+			_metamethods[mmidx] = val;
+		} 
+		else {
+			if(type(temp) == OT_NULL) {
+				SQClassMember m;
+				m.val = val;
+				_members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));
+				_methods.push_back(m);
+			}
+			else {
+				_methods[_member_idx(temp)].val = val;
+			}
+		}
+		return true;
+	}
+	SQClassMember m;
+	m.val = val;
+	_members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));
+	_defaultvalues.push_back(m);
+	return true;
+}
+
+SQInstance *SQClass::CreateInstance()
+{
+	if(!_locked) Lock();
+	return SQInstance::Create(_opt_ss(this),this);
+}
+
+SQInteger SQClass::Next(const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval)
+{
+	SQObjectPtr oval;
+	SQInteger idx = _members->Next(false,refpos,outkey,oval);
+	if(idx != -1) {
+		if(_ismethod(oval)) {
+			outval = _methods[_member_idx(oval)].val;
+		}
+		else {
+			SQObjectPtr &o = _defaultvalues[_member_idx(oval)].val;
+			outval = _realval(o);
+		}
+	}
+	return idx;
+}
+
+bool SQClass::SetAttributes(const SQObjectPtr &key,const SQObjectPtr &val)
+{
+	SQObjectPtr idx;
+	if(_members->Get(key,idx)) {
+		if(_isfield(idx))
+			_defaultvalues[_member_idx(idx)].attrs = val;
+		else
+			_methods[_member_idx(idx)].attrs = val;
+		return true;
+	}
+	return false;
+}
+
+bool SQClass::GetAttributes(const SQObjectPtr &key,SQObjectPtr &outval)
+{
+	SQObjectPtr idx;
+	if(_members->Get(key,idx)) {
+		outval = (_isfield(idx)?_defaultvalues[_member_idx(idx)].attrs:_methods[_member_idx(idx)].attrs);
+		return true;
+	}
+	return false;
+}
+
+///////////////////////////////////////////////////////////////////////
+void SQInstance::Init(SQSharedState *ss)
+{
+	_userpointer = NULL;
+	_hook = NULL;
+	__ObjAddRef(_class);
+	_delegate = _class->_members;
+	INIT_CHAIN();
+	ADD_TO_CHAIN(&_sharedstate->_gc_chain, this);
+}
+
+SQInstance::SQInstance(SQSharedState *ss, SQClass *c, SQInteger memsize)
+{
+	_memsize = memsize;
+	_class = c;
+	SQUnsignedInteger nvalues = _class->_defaultvalues.size();
+	for(SQUnsignedInteger n = 0; n < nvalues; n++) {
+		new (&_values[n]) SQObjectPtr(_class->_defaultvalues[n].val);
+	}
+	Init(ss);
+}
+
+SQInstance::SQInstance(SQSharedState *ss, SQInstance *i, SQInteger memsize)
+{
+	_memsize = memsize;
+	_class = i->_class;
+	SQUnsignedInteger nvalues = _class->_defaultvalues.size();
+	for(SQUnsignedInteger n = 0; n < nvalues; n++) {
+		new (&_values[n]) SQObjectPtr(i->_values[n]);
+	}
+	Init(ss);
+}
+
+void SQInstance::Finalize() 
+{
+	SQUnsignedInteger nvalues = _class->_defaultvalues.size();
+	__ObjRelease(_class);
+	for(SQUnsignedInteger i = 0; i < nvalues; i++) {
+		_values[i] = _null_;
+	}
+}
+
+SQInstance::~SQInstance()
+{
+	REMOVE_FROM_CHAIN(&_sharedstate->_gc_chain, this);
+	if(_class){ Finalize(); } //if _class is null it was already finalized by the GC
+}
+
+bool SQInstance::GetMetaMethod(SQVM *v,SQMetaMethod mm,SQObjectPtr &res)
+{
+	if(type(_class->_metamethods[mm]) != OT_NULL) {
+		res = _class->_metamethods[mm];
+		return true;
+	}
+	return false;
+}
+
+bool SQInstance::InstanceOf(SQClass *trg)
+{
+	SQClass *parent = _class;
+	while(parent != NULL) {
+		if(parent == trg)
+			return true;
+		parent = parent->_base;
+	}
+	return false;
+}

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqclass.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqclass.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqclass.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,152 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQCLASS_H_
+#define _SQCLASS_H_
+
+struct SQInstance;
+
+struct SQClassMember {
+	SQClassMember(){}
+	SQClassMember(const SQClassMember &o) {
+		val = o.val;
+		attrs = o.attrs;
+	}
+	SQObjectPtr val;
+	SQObjectPtr attrs;
+};
+
+typedef sqvector<SQClassMember> SQClassMemberVec;
+
+#define MEMBER_TYPE_METHOD 0x01000000
+#define MEMBER_TYPE_FIELD 0x02000000
+
+#define _ismethod(o) (_integer(o)&MEMBER_TYPE_METHOD)
+#define _isfield(o) (_integer(o)&MEMBER_TYPE_FIELD)
+#define _make_method_idx(i) ((SQInteger)(MEMBER_TYPE_METHOD|i))
+#define _make_field_idx(i) ((SQInteger)(MEMBER_TYPE_FIELD|i))
+#define _member_type(o) (_integer(o)&0xFF000000)
+#define _member_idx(o) (_integer(o)&0x00FFFFFF)
+
+struct SQClass : public CHAINABLE_OBJ
+{
+	SQClass(SQSharedState *ss,SQClass *base);
+public:
+	static SQClass* Create(SQSharedState *ss,SQClass *base) {
+		SQClass *newclass = (SQClass *)SQ_MALLOC(sizeof(SQClass));
+		new (newclass) SQClass(ss, base);
+		return newclass;
+	}
+	~SQClass();
+	bool NewSlot(SQSharedState *ss, const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic);
+	bool Get(const SQObjectPtr &key,SQObjectPtr &val) {
+		if(_members->Get(key,val)) {
+			if(_isfield(val)) {
+				SQObjectPtr &o = _defaultvalues[_member_idx(val)].val;
+				val = _realval(o);
+			}
+			else {
+				val = _methods[_member_idx(val)].val;
+			}
+			return true;
+		}
+		return false;
+	}
+	bool SetAttributes(const SQObjectPtr &key,const SQObjectPtr &val);
+	bool GetAttributes(const SQObjectPtr &key,SQObjectPtr &outval);
+	void Lock() { _locked = true; if(_base) _base->Lock(); }
+	void Release() { 
+		if (_hook) { _hook(_typetag,0);}
+		sq_delete(this, SQClass);	
+	}
+	void Finalize();
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable ** );
+#endif
+	SQInteger Next(const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval);
+	SQInstance *CreateInstance();
+	SQTable *_members;
+	SQClass *_base;
+	SQClassMemberVec _defaultvalues;
+	SQClassMemberVec _methods;
+	SQObjectPtrVec _metamethods;
+	SQObjectPtr _attributes;
+	SQUserPointer _typetag;
+	SQRELEASEHOOK _hook;
+	bool _locked;
+	SQInteger _udsize;
+};
+
+#define calcinstancesize(_theclass_) \
+	(_theclass_->_udsize + sizeof(SQInstance) + (sizeof(SQObjectPtr)*(_theclass_->_defaultvalues.size()>0?_theclass_->_defaultvalues.size()-1:0)))
+
+struct SQInstance : public SQDelegable 
+{
+	void Init(SQSharedState *ss);
+	SQInstance(SQSharedState *ss, SQClass *c, SQInteger memsize);
+	SQInstance(SQSharedState *ss, SQInstance *c, SQInteger memsize);
+public:
+	static SQInstance* Create(SQSharedState *ss,SQClass *theclass) {
+		
+		SQInteger size = calcinstancesize(theclass);
+		SQInstance *newinst = (SQInstance *)SQ_MALLOC(size);
+		new (newinst) SQInstance(ss, theclass,size);
+		if(theclass->_udsize) {
+			newinst->_userpointer = ((unsigned char *)newinst) + (size - theclass->_udsize);
+		}
+		return newinst;
+	}
+	SQInstance *Clone(SQSharedState *ss)
+	{
+		SQInteger size = calcinstancesize(_class);
+		SQInstance *newinst = (SQInstance *)SQ_MALLOC(size);
+		new (newinst) SQInstance(ss, this,size);
+		if(_class->_udsize) {
+			newinst->_userpointer = ((unsigned char *)newinst) + (size - _class->_udsize);
+		}
+		return newinst;
+	}
+	~SQInstance();
+	bool Get(const SQObjectPtr &key,SQObjectPtr &val)  {
+		if(_class->_members->Get(key,val)) {
+			if(_isfield(val)) {
+				SQObjectPtr &o = _values[_member_idx(val)];
+				val = _realval(o);
+			}
+			else {
+				val = _class->_methods[_member_idx(val)].val;
+			}
+			return true;
+		}
+		return false;
+	}
+	bool Set(const SQObjectPtr &key,const SQObjectPtr &val) {
+		SQObjectPtr idx;
+		if(_class->_members->Get(key,idx) && _isfield(idx)) {
+            _values[_member_idx(idx)] = val;
+			return true;
+		}
+		return false;
+	}
+	void Release() {
+		_uiRef++;
+		if (_hook) { _hook(_userpointer,0);}
+		_uiRef--;
+		if(_uiRef > 0) return;
+		SQInteger size = _memsize;
+		this->~SQInstance();
+		SQ_FREE(this, size);
+	}
+	void Finalize();
+#ifndef NO_GARBAGE_COLLECTOR 
+	void Mark(SQCollectable ** );
+#endif
+	bool InstanceOf(SQClass *trg);
+	bool GetMetaMethod(SQVM *v,SQMetaMethod mm,SQObjectPtr &res);
+
+	SQClass *_class;
+	SQUserPointer _userpointer;
+	SQRELEASEHOOK _hook;
+	SQInteger _memsize;
+	SQObjectPtr _values[1];
+};
+
+#endif //_SQCLASS_H_

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqclosure.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqclosure.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqclosure.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,122 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQCLOSURE_H_
+#define _SQCLOSURE_H_
+
+struct SQFunctionProto;
+
+struct SQClosure : public CHAINABLE_OBJ
+{
+private:
+	SQClosure(SQSharedState *ss,SQFunctionProto *func){_function=func; INIT_CHAIN();ADD_TO_CHAIN(&_ss(this)->_gc_chain,this);}
+public:
+	static SQClosure *Create(SQSharedState *ss,SQFunctionProto *func){
+		SQClosure *nc=(SQClosure*)SQ_MALLOC(sizeof(SQClosure));
+		new (nc) SQClosure(ss,func);
+		return nc;
+	}
+	void Release(){
+		sq_delete(this,SQClosure);
+	}
+	SQClosure *Clone()
+	{
+		SQClosure * ret = SQClosure::Create(_opt_ss(this),_funcproto(_function));
+		ret->_env = _env;
+		ret->_outervalues.copy(_outervalues);
+		ret->_defaultparams.copy(_defaultparams);
+		return ret;
+	}
+	~SQClosure()
+	{
+		REMOVE_FROM_CHAIN(&_ss(this)->_gc_chain,this);
+	}
+	bool Save(SQVM *v,SQUserPointer up,SQWRITEFUNC write);
+	static bool Load(SQVM *v,SQUserPointer up,SQREADFUNC read,SQObjectPtr &ret);
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable **chain);
+	void Finalize(){_outervalues.resize(0); }
+#endif
+	SQObjectPtr _env;
+	SQObjectPtr _function;
+	SQObjectPtrVec _outervalues;
+	SQObjectPtrVec _defaultparams;
+};
+//////////////////////////////////////////////
+struct SQGenerator : public CHAINABLE_OBJ 
+{
+	enum SQGeneratorState{eRunning,eSuspended,eDead};
+private:
+	SQGenerator(SQSharedState *ss,SQClosure *closure){_closure=closure;_state=eRunning;_ci._generator=NULL;INIT_CHAIN();ADD_TO_CHAIN(&_ss(this)->_gc_chain,this);}
+public:
+	static SQGenerator *Create(SQSharedState *ss,SQClosure *closure){
+		SQGenerator *nc=(SQGenerator*)SQ_MALLOC(sizeof(SQGenerator));
+		new (nc) SQGenerator(ss,closure);
+		return nc;
+	}
+	~SQGenerator()
+	{
+		REMOVE_FROM_CHAIN(&_ss(this)->_gc_chain,this);
+	}
+    void Kill(){
+		_state=eDead;
+		_stack.resize(0);
+		_closure=_null_;}
+	void Release(){
+		sq_delete(this,SQGenerator);
+	}
+	bool Yield(SQVM *v);
+	bool Resume(SQVM *v,SQInteger target);
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable **chain);
+	void Finalize(){_stack.resize(0);_closure=_null_;}
+#endif
+	SQObjectPtr _closure;
+	SQObjectPtrVec _stack;
+	SQObjectPtrVec _vargsstack;
+	SQVM::CallInfo _ci;
+	ExceptionsTraps _etraps;
+	SQGeneratorState _state;
+};
+
+struct SQNativeClosure : public CHAINABLE_OBJ
+{
+private:
+	SQNativeClosure(SQSharedState *ss,SQFUNCTION func){_function=func;INIT_CHAIN();ADD_TO_CHAIN(&_ss(this)->_gc_chain,this);	}
+public:
+	static SQNativeClosure *Create(SQSharedState *ss,SQFUNCTION func)
+	{
+		SQNativeClosure *nc=(SQNativeClosure*)SQ_MALLOC(sizeof(SQNativeClosure));
+		new (nc) SQNativeClosure(ss,func);
+		return nc;
+	}
+	SQNativeClosure *Clone()
+	{
+		SQNativeClosure * ret = SQNativeClosure::Create(_opt_ss(this),_function);
+		ret->_env = _env;
+		ret->_name = _name;
+		ret->_outervalues.copy(_outervalues);
+		ret->_typecheck.copy(_typecheck);
+		ret->_nparamscheck = _nparamscheck;
+		return ret;
+	}
+	~SQNativeClosure()
+	{
+		REMOVE_FROM_CHAIN(&_ss(this)->_gc_chain,this);
+	}
+	void Release(){
+		sq_delete(this,SQNativeClosure);
+	}
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable **chain);
+	void Finalize(){_outervalues.resize(0);}
+#endif
+	SQInteger _nparamscheck;
+	SQIntVec _typecheck;
+	SQObjectPtrVec _outervalues;
+	SQObjectPtr _env;
+	SQFUNCTION _function;
+	SQObjectPtr _name;
+};
+
+
+
+#endif //_SQCLOSURE_H_

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqcompiler.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqcompiler.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqcompiler.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,1339 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include <stdarg.h>
+#include <setjmp.h>
+#include "sqopcodes.h"
+#include "sqstring.h"
+#include "sqfuncproto.h"
+#include "sqcompiler.h"
+#include "sqfuncstate.h"
+#include "sqlexer.h"
+#include "sqvm.h"
+#include "sqtable.h"
+
+#define DEREF_NO_DEREF	-1
+#define DEREF_FIELD		-2
+
+struct ExpState
+{
+	ExpState()
+	{
+		_deref = DEREF_NO_DEREF;
+		_freevar = false;
+		_class_or_delete = false;
+		_funcarg = false;
+	}
+	bool _class_or_delete;
+	bool _funcarg;
+	bool _freevar;
+	SQInteger _deref;
+};
+
+typedef sqvector<ExpState> ExpStateVec;
+
+#define _exst (_expstates.top())
+
+#define BEGIN_BREAKBLE_BLOCK()	SQInteger __nbreaks__=_fs->_unresolvedbreaks.size(); \
+							SQInteger __ncontinues__=_fs->_unresolvedcontinues.size(); \
+							_fs->_breaktargets.push_back(0);_fs->_continuetargets.push_back(0);
+
+#define END_BREAKBLE_BLOCK(continue_target) {__nbreaks__=_fs->_unresolvedbreaks.size()-__nbreaks__; \
+					__ncontinues__=_fs->_unresolvedcontinues.size()-__ncontinues__; \
+					if(__ncontinues__>0)ResolveContinues(_fs,__ncontinues__,continue_target); \
+					if(__nbreaks__>0)ResolveBreaks(_fs,__nbreaks__); \
+					_fs->_breaktargets.pop_back();_fs->_continuetargets.pop_back();}
+
+class SQCompiler
+{
+public:
+	SQCompiler(SQVM *v, SQLEXREADFUNC rg, SQUserPointer up, const SQChar* sourcename, bool raiseerror, bool lineinfo)
+	{
+		_vm=v;
+		_lex.Init(_ss(v), rg, up,ThrowError,this);
+		_sourcename = SQString::Create(_ss(v), sourcename);
+		_lineinfo = lineinfo;_raiseerror = raiseerror;
+		compilererror = NULL;
+	}
+	static void ThrowError(void *ud, const SQChar *s) {
+		SQCompiler *c = (SQCompiler *)ud;
+		c->Error(s);
+	}
+	void Error(const SQChar *s, ...)
+	{
+		static SQChar temp[256];
+		va_list vl;
+		va_start(vl, s);
+		scvsprintf(temp, s, vl);
+		va_end(vl);
+		compilererror = temp;
+		longjmp(_errorjmp,1);
+	}
+	void Lex(){	_token = _lex.Lex();}
+	void PushExpState(){ _expstates.push_back(ExpState()); }
+	bool IsDerefToken(SQInteger tok)
+	{
+		switch(tok){
+		case _SC('='): case _SC('('): case TK_NEWSLOT:
+		case TK_MODEQ: case TK_MULEQ: case TK_DIVEQ: case TK_MINUSEQ: case TK_PLUSEQ: case TK_PLUSPLUS: case TK_MINUSMINUS: return true;
+		}
+		return false;
+	}
+	ExpState PopExpState()
+	{
+		ExpState ret = _expstates.top();
+		_expstates.pop_back();
+		return ret;
+	}
+	SQObject Expect(SQInteger tok)
+	{
+		
+		if(_token != tok) {
+			if(_token == TK_CONSTRUCTOR && tok == TK_IDENTIFIER) {
+				//ret = SQString::Create(_ss(_vm),_SC("constructor"));
+				//do nothing
+			}
+			else {
+				const SQChar *etypename;
+				if(tok > 255) {
+					switch(tok)
+					{
+					case TK_IDENTIFIER:
+						etypename = _SC("IDENTIFIER");
+						break;
+					case TK_STRING_LITERAL:
+						etypename = _SC("STRING_LITERAL");
+						break;
+					case TK_INTEGER:
+						etypename = _SC("INTEGER");
+						break;
+					case TK_FLOAT:
+						etypename = _SC("FLOAT");
+						break;
+					default:
+						etypename = _lex.Tok2Str(tok);
+					}
+					Error(_SC("expected '%s'"), etypename);
+				}
+				Error(_SC("expected '%c'"), tok);
+			}
+		}
+		SQObjectPtr ret;
+		switch(tok)
+		{
+		case TK_IDENTIFIER:
+			ret = _fs->CreateString(_lex._svalue);
+			break;
+		case TK_STRING_LITERAL:
+			ret = _fs->CreateString(_lex._svalue,_lex._longstr.size()-1);
+			break;
+		case TK_INTEGER:
+			ret = SQObjectPtr(_lex._nvalue);
+			break;
+		case TK_FLOAT:
+			ret = SQObjectPtr(_lex._fvalue);
+			break;
+		}
+		Lex();
+		return ret;
+	}
+	bool IsEndOfStatement() { return ((_lex._prevtoken == _SC('\n')) || (_token == SQUIRREL_EOB) || (_token == _SC('}')) || (_token == _SC(';'))); }
+	void OptionalSemicolon()
+	{
+		if(_token == _SC(';')) { Lex(); return; }
+		if(!IsEndOfStatement()) {
+			Error(_SC("end of statement expected (; or lf)"));
+		}
+	}
+	void MoveIfCurrentTargetIsLocal() {
+		SQInteger trg = _fs->TopTarget();
+		if(_fs->IsLocal(trg)) {
+			trg = _fs->PopTarget(); //no pops the target and move it
+			_fs->AddInstruction(_OP_MOVE, _fs->PushTarget(), trg);
+		}
+	}
+	bool Compile(SQObjectPtr &o)
+	{
+		_debugline = 1;
+		_debugop = 0;
+
+		SQFuncState funcstate(_ss(_vm), NULL,ThrowError,this);
+		funcstate._name = SQString::Create(_ss(_vm), _SC("main"));
+		_fs = &funcstate;
+		_fs->AddParameter(_fs->CreateString(_SC("this")));
+		_fs->_sourcename = _sourcename;
+		SQInteger stacksize = _fs->GetStackSize();
+		if(setjmp(_errorjmp) == 0) {
+			Lex();
+			while(_token > 0){
+				Statement();
+				if(_lex._prevtoken != _SC('}')) OptionalSemicolon();
+			}
+			CleanStack(stacksize);
+			_fs->AddLineInfos(_lex._currentline, _lineinfo, true);
+			_fs->AddInstruction(_OP_RETURN, 0xFF);
+			_fs->SetStackSize(0);
+			o =_fs->BuildProto();
+#ifdef _DEBUG_DUMP
+			_fs->Dump(_funcproto(o));
+#endif
+		}
+		else {
+			if(_raiseerror && _ss(_vm)->_compilererrorhandler) {
+				_ss(_vm)->_compilererrorhandler(_vm, compilererror, type(_sourcename) == OT_STRING?_stringval(_sourcename):_SC("unknown"),
+					_lex._currentline, _lex._currentcolumn);
+			}
+			_vm->_lasterror = SQString::Create(_ss(_vm), compilererror, -1);
+			return false;
+		}
+		return true;
+	}
+	void Statements()
+	{
+		while(_token != _SC('}') && _token != TK_DEFAULT && _token != TK_CASE) {
+			Statement();
+			if(_lex._prevtoken != _SC('}') && _lex._prevtoken != _SC(';')) OptionalSemicolon();
+		}
+	}
+	void Statement()
+	{
+		_fs->AddLineInfos(_lex._currentline, _lineinfo);
+		switch(_token){
+		case _SC(';'):	Lex();					break;
+		case TK_IF:		IfStatement();			break;
+		case TK_WHILE:		WhileStatement();		break;
+		case TK_DO:		DoWhileStatement();		break;
+		case TK_FOR:		ForStatement();			break;
+		case TK_FOREACH:	ForEachStatement();		break;
+		case TK_SWITCH:	SwitchStatement();		break;
+		case TK_LOCAL:		LocalDeclStatement();	break;
+		case TK_RETURN:
+		case TK_YIELD: {
+			SQOpcode op;
+			if(_token == TK_RETURN) {
+				op = _OP_RETURN;
+				
+			}
+			else {
+				op = _OP_YIELD;
+				_fs->_bgenerator = true;
+			}
+			Lex();
+			if(!IsEndOfStatement()) {
+				SQInteger retexp = _fs->GetCurrentPos()+1;
+				CommaExpr();
+				if(op == _OP_RETURN && _fs->_traps > 0)
+					_fs->AddInstruction(_OP_POPTRAP, _fs->_traps, 0);
+				_fs->_returnexp = retexp;
+				_fs->AddInstruction(op, 1, _fs->PopTarget());
+			}
+			else{ 
+				if(op == _OP_RETURN && _fs->_traps > 0)
+					_fs->AddInstruction(_OP_POPTRAP, _fs->_traps ,0);
+				_fs->_returnexp = -1;
+				_fs->AddInstruction(op, 0xFF); 
+			}
+			break;}
+		case TK_BREAK:
+			if(_fs->_breaktargets.size() <= 0)Error(_SC("'break' has to be in a loop block"));
+			if(_fs->_breaktargets.top() > 0){
+				_fs->AddInstruction(_OP_POPTRAP, _fs->_breaktargets.top(), 0);
+			}
+			_fs->AddInstruction(_OP_JMP, 0, -1234);
+			_fs->_unresolvedbreaks.push_back(_fs->GetCurrentPos());
+			Lex();
+			break;
+		case TK_CONTINUE:
+			if(_fs->_continuetargets.size() <= 0)Error(_SC("'continue' has to be in a loop block"));
+			if(_fs->_continuetargets.top() > 0) {
+				_fs->AddInstruction(_OP_POPTRAP, _fs->_continuetargets.top(), 0);
+			}
+			_fs->AddInstruction(_OP_JMP, 0, -1234);
+			_fs->_unresolvedcontinues.push_back(_fs->GetCurrentPos());
+			Lex();
+			break;
+		case TK_FUNCTION:
+			FunctionStatement();
+			break;
+		case TK_CLASS:
+			ClassStatement();
+			break;
+		case TK_ENUM:
+			EnumStatement();
+			break;
+		case _SC('{'):{
+				SQInteger stacksize = _fs->GetStackSize();
+				Lex();
+				Statements();
+				Expect(_SC('}'));
+				_fs->SetStackSize(stacksize);
+			}
+			break;
+		case TK_TRY:
+			TryCatchStatement();
+			break;
+		case TK_THROW:
+			Lex();
+			CommaExpr();
+			_fs->AddInstruction(_OP_THROW, _fs->PopTarget());
+			break;
+		case TK_CONST:
+			{
+			Lex();
+			SQObject id = Expect(TK_IDENTIFIER);
+			Expect('=');
+			SQObject val = ExpectScalar();
+			OptionalSemicolon();
+			SQTable *enums = _table(_ss(_vm)->_consts);
+			SQObjectPtr strongid = id; 
+			enums->NewSlot(strongid,SQObjectPtr(val));
+			strongid.Null();
+			}
+			break;
+		default:
+			CommaExpr();
+			_fs->PopTarget();
+			break;
+		}
+		_fs->SnoozeOpt();
+	}
+	void EmitDerefOp(SQOpcode op)
+	{
+		SQInteger val = _fs->PopTarget();
+		SQInteger key = _fs->PopTarget();
+		SQInteger src = _fs->PopTarget();
+        _fs->AddInstruction(op,_fs->PushTarget(),src,key,val);
+	}
+	void Emit2ArgsOP(SQOpcode op, SQInteger p3 = 0)
+	{
+		SQInteger p2 = _fs->PopTarget(); //src in OP_GET
+		SQInteger p1 = _fs->PopTarget(); //key in OP_GET
+		_fs->AddInstruction(op,_fs->PushTarget(), p1, p2, p3);
+	}
+	void EmitCompoundArith(SQInteger tok,bool deref)
+	{
+		SQInteger oper;
+		switch(tok){
+		case TK_MINUSEQ: oper = '-'; break;
+		case TK_PLUSEQ: oper = '+'; break;
+		case TK_MULEQ: oper = '*'; break;
+		case TK_DIVEQ: oper = '/'; break;
+		case TK_MODEQ: oper = '%'; break;
+		default: oper = 0; //shut up compiler
+			assert(0); break;
+		};
+		if(deref) {
+			SQInteger val = _fs->PopTarget();
+			SQInteger key = _fs->PopTarget();
+			SQInteger src = _fs->PopTarget();
+			//mixes dest obj and source val in the arg1(hack?)
+			_fs->AddInstruction(_OP_COMPARITH,_fs->PushTarget(),(src<<16)|val,key,oper);
+		}
+		else {
+			Emit2ArgsOP(_OP_COMPARITHL, oper);
+		}
+	}
+	void CommaExpr()
+	{
+		for(Expression();_token == ',';_fs->PopTarget(), Lex(), CommaExpr());
+	}
+	ExpState Expression(bool funcarg = false)
+	{
+		PushExpState();
+		_exst._class_or_delete = false;
+		_exst._funcarg = funcarg;
+		LogicalOrExp();
+		switch(_token)  {
+		case _SC('='):
+		case TK_NEWSLOT:
+		case TK_MINUSEQ:
+		case TK_PLUSEQ:
+		case TK_MULEQ:
+		case TK_DIVEQ:
+		case TK_MODEQ:
+		{
+				SQInteger op = _token;
+				SQInteger ds = _exst._deref;
+				bool freevar = _exst._freevar;
+				if(ds == DEREF_NO_DEREF) Error(_SC("can't assign expression"));
+				Lex(); Expression();
+
+				switch(op){
+				case TK_NEWSLOT:
+					if(freevar) Error(_SC("free variables cannot be modified"));
+					if(ds == DEREF_FIELD)
+						EmitDerefOp(_OP_NEWSLOT);
+					else //if _derefstate != DEREF_NO_DEREF && DEREF_FIELD so is the index of a local
+						Error(_SC("can't 'create' a local slot"));
+					break;
+				case _SC('='): //ASSIGN
+					if(freevar) Error(_SC("free variables cannot be modified"));
+					if(ds == DEREF_FIELD)
+						EmitDerefOp(_OP_SET);
+					else {//if _derefstate != DEREF_NO_DEREF && DEREF_FIELD so is the index of a local
+						SQInteger p2 = _fs->PopTarget(); //src in OP_GET
+						SQInteger p1 = _fs->TopTarget(); //key in OP_GET
+						_fs->AddInstruction(_OP_MOVE, p1, p2);
+					}
+					break;
+				case TK_MINUSEQ:
+				case TK_PLUSEQ:
+				case TK_MULEQ:
+				case TK_DIVEQ:
+				case TK_MODEQ:
+					EmitCompoundArith(op,ds == DEREF_FIELD);
+					break;
+				}
+			}
+			break;
+		case _SC('?'): {
+			Lex();
+			_fs->AddInstruction(_OP_JZ, _fs->PopTarget());
+			SQInteger jzpos = _fs->GetCurrentPos();
+			SQInteger trg = _fs->PushTarget();
+			Expression();
+			SQInteger first_exp = _fs->PopTarget();
+			if(trg != first_exp) _fs->AddInstruction(_OP_MOVE, trg, first_exp);
+			SQInteger endfirstexp = _fs->GetCurrentPos();
+			_fs->AddInstruction(_OP_JMP, 0, 0);
+			Expect(_SC(':'));
+			SQInteger jmppos = _fs->GetCurrentPos();
+			Expression();
+			SQInteger second_exp = _fs->PopTarget();
+			if(trg != second_exp) _fs->AddInstruction(_OP_MOVE, trg, second_exp);
+			_fs->SetIntructionParam(jmppos, 1, _fs->GetCurrentPos() - jmppos);
+			_fs->SetIntructionParam(jzpos, 1, endfirstexp - jzpos + 1);
+			_fs->SnoozeOpt();
+			}
+			break;
+		}
+		return PopExpState();
+	}
+	void BIN_EXP(SQOpcode op, void (SQCompiler::*f)(void),SQInteger op3 = 0)
+	{
+		Lex(); (this->*f)();
+		SQInteger op1 = _fs->PopTarget();SQInteger op2 = _fs->PopTarget();
+		_fs->AddInstruction(op, _fs->PushTarget(), op1, op2, op3);
+	}
+	void LogicalOrExp()
+	{
+		LogicalAndExp();
+		for(;;) if(_token == TK_OR) {
+			SQInteger first_exp = _fs->PopTarget();
+			SQInteger trg = _fs->PushTarget();
+			_fs->AddInstruction(_OP_OR, trg, 0, first_exp, 0);
+			SQInteger jpos = _fs->GetCurrentPos();
+			if(trg != first_exp) _fs->AddInstruction(_OP_MOVE, trg, first_exp);
+			Lex(); LogicalOrExp();
+			_fs->SnoozeOpt();
+			SQInteger second_exp = _fs->PopTarget();
+			if(trg != second_exp) _fs->AddInstruction(_OP_MOVE, trg, second_exp);
+			_fs->SnoozeOpt();
+			_fs->SetIntructionParam(jpos, 1, (_fs->GetCurrentPos() - jpos));
+			break;
+		}else return;
+	}
+	void LogicalAndExp()
+	{
+		BitwiseOrExp();
+		for(;;) switch(_token) {
+		case TK_AND: {
+			SQInteger first_exp = _fs->PopTarget();
+			SQInteger trg = _fs->PushTarget();
+			_fs->AddInstruction(_OP_AND, trg, 0, first_exp, 0);
+			SQInteger jpos = _fs->GetCurrentPos();
+			if(trg != first_exp) _fs->AddInstruction(_OP_MOVE, trg, first_exp);
+			Lex(); LogicalAndExp();
+			_fs->SnoozeOpt();
+			SQInteger second_exp = _fs->PopTarget();
+			if(trg != second_exp) _fs->AddInstruction(_OP_MOVE, trg, second_exp);
+			_fs->SnoozeOpt();
+			_fs->SetIntructionParam(jpos, 1, (_fs->GetCurrentPos() - jpos));
+			break;
+			}
+		case TK_IN: BIN_EXP(_OP_EXISTS, &SQCompiler::BitwiseOrExp); break;
+		case TK_INSTANCEOF: BIN_EXP(_OP_INSTANCEOF, &SQCompiler::BitwiseOrExp); break;
+		default:
+			return;
+		}
+	}
+	void BitwiseOrExp()
+	{
+		BitwiseXorExp();
+		for(;;) if(_token == _SC('|'))
+		{BIN_EXP(_OP_BITW, &SQCompiler::BitwiseXorExp,BW_OR);
+		}else return;
+	}
+	void BitwiseXorExp()
+	{
+		BitwiseAndExp();
+		for(;;) if(_token == _SC('^'))
+		{BIN_EXP(_OP_BITW, &SQCompiler::BitwiseAndExp,BW_XOR);
+		}else return;
+	}
+	void BitwiseAndExp()
+	{
+		CompExp();
+		for(;;) if(_token == _SC('&'))
+		{BIN_EXP(_OP_BITW, &SQCompiler::CompExp,BW_AND);
+		}else return;
+	}
+	void CompExp()
+	{
+		ShiftExp();
+		for(;;) switch(_token) {
+		case TK_EQ: BIN_EXP(_OP_EQ, &SQCompiler::ShiftExp); break;
+		case _SC('>'): BIN_EXP(_OP_CMP, &SQCompiler::ShiftExp,CMP_G); break;
+		case _SC('<'): BIN_EXP(_OP_CMP, &SQCompiler::ShiftExp,CMP_L); break;
+		case TK_GE: BIN_EXP(_OP_CMP, &SQCompiler::ShiftExp,CMP_GE); break;
+		case TK_LE: BIN_EXP(_OP_CMP, &SQCompiler::ShiftExp,CMP_LE); break;
+		case TK_NE: BIN_EXP(_OP_NE, &SQCompiler::ShiftExp); break;
+		default: return;	
+		}
+	}
+	void ShiftExp()
+	{
+		PlusExp();
+		for(;;) switch(_token) {
+		case TK_USHIFTR: BIN_EXP(_OP_BITW, &SQCompiler::PlusExp,BW_USHIFTR); break;
+		case TK_SHIFTL: BIN_EXP(_OP_BITW, &SQCompiler::PlusExp,BW_SHIFTL); break;
+		case TK_SHIFTR: BIN_EXP(_OP_BITW, &SQCompiler::PlusExp,BW_SHIFTR); break;
+		default: return;	
+		}
+	}
+	void PlusExp()
+	{
+		MultExp();
+		for(;;) switch(_token) {
+		case _SC('+'): case _SC('-'):
+			BIN_EXP(_OP_ARITH, &SQCompiler::MultExp,_token); break;
+		default: return;
+		}
+	}
+	
+	void MultExp()
+	{
+		PrefixedExpr();
+		for(;;) switch(_token) {
+		case _SC('*'): case _SC('/'): case _SC('%'):
+			BIN_EXP(_OP_ARITH, &SQCompiler::PrefixedExpr,_token); break;
+		default: return;
+		}
+	}
+	//if 'pos' != -1 the previous variable is a local variable
+	void PrefixedExpr()
+	{
+		SQInteger pos = Factor();
+		for(;;) {
+			switch(_token) {
+			case _SC('.'): {
+				pos = -1;
+				Lex(); 
+				if(_token == TK_PARENT) {
+					Lex();
+					if(!NeedGet())
+						Error(_SC("parent cannot be set"));
+					SQInteger src = _fs->PopTarget();
+					_fs->AddInstruction(_OP_GETPARENT, _fs->PushTarget(), src);
+				}
+				else {
+					_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetConstant(Expect(TK_IDENTIFIER)));
+					if(NeedGet()) Emit2ArgsOP(_OP_GET);
+				}
+				_exst._deref = DEREF_FIELD;
+				_exst._freevar = false;
+				}
+				break;
+			case _SC('['):
+				if(_lex._prevtoken == _SC('\n')) Error(_SC("cannot brake deref/or comma needed after [exp]=exp slot declaration"));
+				Lex(); Expression(); Expect(_SC(']')); 
+				pos = -1;
+				if(NeedGet()) Emit2ArgsOP(_OP_GET);
+				_exst._deref = DEREF_FIELD;
+				_exst._freevar = false;
+				break;
+			case TK_MINUSMINUS:
+			case TK_PLUSPLUS:
+			if(_exst._deref != DEREF_NO_DEREF && !IsEndOfStatement()) { 
+				SQInteger tok = _token; Lex();
+				if(pos < 0)
+					Emit2ArgsOP(_OP_PINC,tok == TK_MINUSMINUS?-1:1);
+				else {//if _derefstate != DEREF_NO_DEREF && DEREF_FIELD so is the index of a local
+					SQInteger src = _fs->PopTarget();
+					_fs->AddInstruction(_OP_PINCL, _fs->PushTarget(), src, 0, tok == TK_MINUSMINUS?-1:1);
+				}
+				
+			}
+			return;
+			break;	
+			case _SC('('): 
+				{
+				if(_exst._deref != DEREF_NO_DEREF) {
+					if(pos<0) {
+						SQInteger key = _fs->PopTarget(); //key
+						SQInteger table = _fs->PopTarget(); //table etc...
+						SQInteger closure = _fs->PushTarget();
+						SQInteger ttarget = _fs->PushTarget();
+						_fs->AddInstruction(_OP_PREPCALL, closure, key, table, ttarget);
+					}
+					else{
+						_fs->AddInstruction(_OP_MOVE, _fs->PushTarget(), 0);
+					}
+				}
+				else
+					_fs->AddInstruction(_OP_MOVE, _fs->PushTarget(), 0);
+				_exst._deref = DEREF_NO_DEREF;
+				Lex();
+				FunctionCallArgs();
+				 }
+				break;
+			default: return;
+			}
+		}
+	}
+	SQInteger Factor()
+	{
+		switch(_token)
+		{
+		case TK_STRING_LITERAL: {
+				//SQObjectPtr id(SQString::Create(_ss(_vm), _lex._svalue,_lex._longstr.size()-1));
+				_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetConstant(_fs->CreateString(_lex._svalue,_lex._longstr.size()-1)));
+				Lex(); 
+			}
+			break;
+		case TK_VARGC: Lex(); _fs->AddInstruction(_OP_VARGC, _fs->PushTarget()); break;
+		case TK_VARGV: { Lex();
+			Expect(_SC('['));
+			Expression();
+			Expect(_SC(']'));
+			SQInteger src = _fs->PopTarget();
+			_fs->AddInstruction(_OP_GETVARGV, _fs->PushTarget(), src);
+					   }
+			break;
+		case TK_IDENTIFIER:
+		case TK_CONSTRUCTOR:
+		case TK_THIS:{
+			_exst._freevar = false;
+			SQObject id;
+			SQObject constant;
+				switch(_token) {
+					case TK_IDENTIFIER: id = _fs->CreateString(_lex._svalue); break;
+					case TK_THIS: id = _fs->CreateString(_SC("this")); break;
+					case TK_CONSTRUCTOR: id = _fs->CreateString(_SC("constructor")); break;
+				}
+				SQInteger pos = -1;
+				Lex();
+				if((pos = _fs->GetLocalVariable(id)) == -1) {
+					//checks if is a free variable
+					if((pos = _fs->GetOuterVariable(id)) != -1) {
+						_exst._deref = _fs->PushTarget();
+						_fs->AddInstruction(_OP_LOADFREEVAR, _exst._deref ,pos);	
+						_exst._freevar = true;
+					}
+					else if(_fs->IsConstant(id,constant)) { //line 634
+						SQObjectPtr constval;
+						SQObject constid;
+						if(type(constant) == OT_TABLE) {
+							Expect('.'); constid = Expect(TK_IDENTIFIER);
+							if(!_table(constant)->Get(constid,constval)) {
+								constval.Null();
+								Error(_SC("invalid constant [%s.%s]"), _stringval(id),_stringval(constid));
+							}
+						}
+						else {
+							constval = constant;
+						}
+						_exst._deref = _fs->PushTarget();
+						SQObjectType ctype = type(constval);
+						if(ctype == OT_INTEGER && (_integer(constval) & (~0x7FFFFFFF)) == 0) {
+							_fs->AddInstruction(_OP_LOADINT, _exst._deref,_integer(constval));
+						}
+						else if(ctype == OT_FLOAT && sizeof(SQFloat) == sizeof(SQInt32)) {
+							SQFloat f = _float(constval);
+							_fs->AddInstruction(_OP_LOADFLOAT, _exst._deref,*((SQInt32 *)&f));
+						}
+						else {
+							_fs->AddInstruction(_OP_LOAD, _exst._deref, _fs->GetConstant(constval));
+						}
+
+						_exst._freevar = true;
+					}
+					else {
+						_fs->PushTarget(0);
+						_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetConstant(id));
+						if(NeedGet()) Emit2ArgsOP(_OP_GET);
+						_exst._deref = DEREF_FIELD;
+					}
+				}
+				
+				else{
+					_fs->PushTarget(pos);
+					_exst._deref = pos;
+				}
+				return _exst._deref;
+			}
+			break;
+		case TK_PARENT: Lex();_fs->AddInstruction(_OP_GETPARENT, _fs->PushTarget(), 0); break;
+		case TK_DOUBLE_COLON:  // "::"
+			_fs->AddInstruction(_OP_LOADROOTTABLE, _fs->PushTarget());
+			_exst._deref = DEREF_FIELD;
+			_token = _SC('.'); //hack
+			return -1;
+			break;
+		case TK_NULL: 
+			_fs->AddInstruction(_OP_LOADNULLS, _fs->PushTarget(),1);
+			Lex();
+			break;
+		case TK_INTEGER: {
+			if((_lex._nvalue & (~0x7FFFFFFF)) == 0) { //does it fit in 32 bits?
+				_fs->AddInstruction(_OP_LOADINT, _fs->PushTarget(),_lex._nvalue);
+			}
+			else {
+				_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetNumericConstant(_lex._nvalue));
+			}
+			Lex();
+						 }
+			break;
+		case TK_FLOAT:
+			if(sizeof(SQFloat) == sizeof(SQInt32)) {
+				_fs->AddInstruction(_OP_LOADFLOAT, _fs->PushTarget(),*((SQInt32 *)&_lex._fvalue));
+			}
+			else {
+				_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetNumericConstant(_lex._fvalue));
+			}
+			Lex();
+			break;
+		case TK_TRUE: case TK_FALSE:
+			_fs->AddInstruction(_OP_LOADBOOL, _fs->PushTarget(),_token == TK_TRUE?1:0);
+			Lex();
+			break;
+		case _SC('['): {
+				_fs->AddInstruction(_OP_NEWARRAY, _fs->PushTarget());
+				SQInteger apos = _fs->GetCurrentPos(),key = 0;
+				Lex();
+				while(_token != _SC(']')) {
+                    Expression(); 
+					if(_token == _SC(',')) Lex();
+					SQInteger val = _fs->PopTarget();
+					SQInteger array = _fs->TopTarget();
+					_fs->AddInstruction(_OP_APPENDARRAY, array, val);
+					key++;
+				}
+				_fs->SetIntructionParam(apos, 1, key);
+				Lex();
+			}
+			break;
+		case _SC('{'):{
+			_fs->AddInstruction(_OP_NEWTABLE, _fs->PushTarget());
+			Lex();ParseTableOrClass(_SC(','));
+				 }
+			break;
+		case TK_FUNCTION: FunctionExp(_token);break;
+		case TK_CLASS: Lex(); ClassExp();break;
+		case _SC('-'): UnaryOP(_OP_NEG); break;
+		case _SC('!'): UnaryOP(_OP_NOT); break;
+		case _SC('~'): UnaryOP(_OP_BWNOT); break;
+		case TK_TYPEOF : UnaryOP(_OP_TYPEOF); break;
+		case TK_RESUME : UnaryOP(_OP_RESUME); break;
+		case TK_CLONE : UnaryOP(_OP_CLONE); break;
+		case TK_MINUSMINUS : 
+		case TK_PLUSPLUS :PrefixIncDec(_token); break;
+		case TK_DELETE : DeleteExpr(); break;
+		case TK_DELEGATE : DelegateExpr(); break;
+		case _SC('('): Lex(); CommaExpr(); Expect(_SC(')'));
+			break;
+		default: Error(_SC("expression expected"));
+		}
+		return -1;
+	}
+	void UnaryOP(SQOpcode op)
+	{
+		Lex(); PrefixedExpr();
+		SQInteger src = _fs->PopTarget();
+		_fs->AddInstruction(op, _fs->PushTarget(), src);
+	}
+	bool NeedGet()
+	{
+		switch(_token) {
+		case _SC('='): case _SC('('): case TK_NEWSLOT: case TK_PLUSPLUS: case TK_MINUSMINUS:
+		case TK_PLUSEQ: case TK_MINUSEQ: case TK_MULEQ: case TK_DIVEQ: case TK_MODEQ:
+			return false;
+		}
+		return (!_exst._class_or_delete) || (_exst._class_or_delete && (_token == _SC('.') || _token == _SC('[')));
+	}
+	
+	void FunctionCallArgs()
+	{
+		SQInteger nargs = 1;//this
+		 while(_token != _SC(')')) {
+			 Expression(true);
+			 MoveIfCurrentTargetIsLocal();
+			 nargs++; 
+			 if(_token == _SC(',')){ 
+				 Lex(); 
+				 if(_token == ')') Error(_SC("expression expected, found ')'"));
+			 }
+		 }
+		 Lex();
+		 for(SQInteger i = 0; i < (nargs - 1); i++) _fs->PopTarget();
+		 SQInteger stackbase = _fs->PopTarget();
+		 SQInteger closure = _fs->PopTarget();
+         _fs->AddInstruction(_OP_CALL, _fs->PushTarget(), closure, stackbase, nargs);
+	}
+	void ParseTableOrClass(SQInteger separator,SQInteger terminator = '}')
+	{
+		SQInteger tpos = _fs->GetCurrentPos(),nkeys = 0;
+		
+		while(_token != terminator) {
+			bool hasattrs = false;
+			bool isstatic = false;
+			//check if is an attribute
+			if(separator == ';') {
+				if(_token == TK_ATTR_OPEN) {
+					_fs->AddInstruction(_OP_NEWTABLE, _fs->PushTarget()); Lex();
+					ParseTableOrClass(',',TK_ATTR_CLOSE);
+					hasattrs = true;
+				}
+				if(_token == TK_STATIC) {
+					isstatic = true;
+					Lex();
+				}
+			}
+			switch(_token) {
+				case TK_FUNCTION:
+				case TK_CONSTRUCTOR:{
+					SQInteger tk = _token;
+					Lex();
+					SQObject id = tk == TK_FUNCTION ? Expect(TK_IDENTIFIER) : _fs->CreateString(_SC("constructor"));
+					Expect(_SC('('));
+					_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetConstant(id));
+					CreateFunction(id);
+					_fs->AddInstruction(_OP_CLOSURE, _fs->PushTarget(), _fs->_functions.size() - 1, 0);
+								  }
+								  break;
+				case _SC('['):
+					Lex(); CommaExpr(); Expect(_SC(']'));
+					Expect(_SC('=')); Expression();
+					break;
+				default :
+					_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetConstant(Expect(TK_IDENTIFIER)));
+					Expect(_SC('=')); Expression();
+			}
+
+			if(_token == separator) Lex();//optional comma/semicolon
+			nkeys++;
+			SQInteger val = _fs->PopTarget();
+			SQInteger key = _fs->PopTarget();
+			SQInteger attrs = hasattrs ? _fs->PopTarget():-1;
+			assert(hasattrs && attrs == key-1 || !hasattrs);
+			unsigned char flags = (hasattrs?NEW_SLOT_ATTRIBUTES_FLAG:0)|(isstatic?NEW_SLOT_STATIC_FLAG:0);
+			SQInteger table = _fs->TopTarget(); //<<BECAUSE OF THIS NO COMMON EMIT FUNC IS POSSIBLE
+			_fs->AddInstruction(_OP_NEWSLOTA, flags, table, key, val);
+			//_fs->PopTarget();
+		}
+		if(separator == _SC(',')) //hack recognizes a table from the separator
+			_fs->SetIntructionParam(tpos, 1, nkeys);
+		Lex();
+	}
+	void LocalDeclStatement()
+	{
+		SQObject varname;
+		do {
+			Lex(); varname = Expect(TK_IDENTIFIER);
+			if(_token == _SC('=')) {
+				Lex(); Expression();
+				SQInteger src = _fs->PopTarget();
+				SQInteger dest = _fs->PushTarget();
+				if(dest != src) _fs->AddInstruction(_OP_MOVE, dest, src);
+			}
+			else{
+				_fs->AddInstruction(_OP_LOADNULLS, _fs->PushTarget(),1);
+			}
+			_fs->PopTarget();
+			_fs->PushLocalVariable(varname);
+		
+		} while(_token == _SC(','));
+	}
+	void IfStatement()
+	{
+		SQInteger jmppos;
+		bool haselse = false;
+		Lex(); Expect(_SC('(')); CommaExpr(); Expect(_SC(')'));
+		_fs->AddInstruction(_OP_JZ, _fs->PopTarget());
+		SQInteger jnepos = _fs->GetCurrentPos();
+		SQInteger stacksize = _fs->GetStackSize();
+		
+		Statement();
+		//
+		if(_token != _SC('}') && _token != TK_ELSE) OptionalSemicolon();
+		
+		CleanStack(stacksize);
+		SQInteger endifblock = _fs->GetCurrentPos();
+		if(_token == TK_ELSE){
+			haselse = true;
+			stacksize = _fs->GetStackSize();
+			_fs->AddInstruction(_OP_JMP);
+			jmppos = _fs->GetCurrentPos();
+			Lex();
+			Statement(); OptionalSemicolon();
+			CleanStack(stacksize);
+			_fs->SetIntructionParam(jmppos, 1, _fs->GetCurrentPos() - jmppos);
+		}
+		_fs->SetIntructionParam(jnepos, 1, endifblock - jnepos + (haselse?1:0));
+	}
+	void WhileStatement()
+	{
+		SQInteger jzpos, jmppos;
+		SQInteger stacksize = _fs->GetStackSize();
+		jmppos = _fs->GetCurrentPos();
+		Lex(); Expect(_SC('(')); CommaExpr(); Expect(_SC(')'));
+		
+		BEGIN_BREAKBLE_BLOCK();
+		_fs->AddInstruction(_OP_JZ, _fs->PopTarget());
+		jzpos = _fs->GetCurrentPos();
+		stacksize = _fs->GetStackSize();
+		
+		Statement();
+		
+		CleanStack(stacksize);
+		_fs->AddInstruction(_OP_JMP, 0, jmppos - _fs->GetCurrentPos() - 1);
+		_fs->SetIntructionParam(jzpos, 1, _fs->GetCurrentPos() - jzpos);
+		
+		END_BREAKBLE_BLOCK(jmppos);
+	}
+	void DoWhileStatement()
+	{
+		Lex();
+		SQInteger jzpos = _fs->GetCurrentPos();
+		SQInteger stacksize = _fs->GetStackSize();
+		BEGIN_BREAKBLE_BLOCK()
+		Statement();
+		CleanStack(stacksize);
+		Expect(TK_WHILE);
+		SQInteger continuetrg = _fs->GetCurrentPos();
+		Expect(_SC('(')); CommaExpr(); Expect(_SC(')'));
+		_fs->AddInstruction(_OP_JNZ, _fs->PopTarget(), jzpos - _fs->GetCurrentPos() - 1);
+		END_BREAKBLE_BLOCK(continuetrg);
+	}
+	void ForStatement()
+	{
+		Lex();
+		SQInteger stacksize = _fs->GetStackSize();
+		Expect(_SC('('));
+		if(_token == TK_LOCAL) LocalDeclStatement();
+		else if(_token != _SC(';')){
+			CommaExpr();
+			_fs->PopTarget();
+		}
+		Expect(_SC(';'));
+		_fs->SnoozeOpt();
+		SQInteger jmppos = _fs->GetCurrentPos();
+		SQInteger jzpos = -1;
+		if(_token != _SC(';')) { CommaExpr(); _fs->AddInstruction(_OP_JZ, _fs->PopTarget()); jzpos = _fs->GetCurrentPos(); }
+		Expect(_SC(';'));
+		_fs->SnoozeOpt();
+		SQInteger expstart = _fs->GetCurrentPos() + 1;
+		if(_token != _SC(')')) {
+			CommaExpr();
+			_fs->PopTarget();
+		}
+		Expect(_SC(')'));
+		_fs->SnoozeOpt();
+		SQInteger expend = _fs->GetCurrentPos();
+		SQInteger expsize = (expend - expstart) + 1;
+		SQInstructionVec exp;
+		if(expsize > 0) {
+			for(SQInteger i = 0; i < expsize; i++)
+				exp.push_back(_fs->GetInstruction(expstart + i));
+			_fs->PopInstructions(expsize);
+		}
+		BEGIN_BREAKBLE_BLOCK()
+		Statement();
+		SQInteger continuetrg = _fs->GetCurrentPos();
+		if(expsize > 0) {
+			for(SQInteger i = 0; i < expsize; i++)
+				_fs->AddInstruction(exp[i]);
+		}
+		_fs->AddInstruction(_OP_JMP, 0, jmppos - _fs->GetCurrentPos() - 1, 0);
+		if(jzpos>  0) _fs->SetIntructionParam(jzpos, 1, _fs->GetCurrentPos() - jzpos);
+		CleanStack(stacksize);
+		
+		END_BREAKBLE_BLOCK(continuetrg);
+	}
+	void ForEachStatement()
+	{
+		SQObject idxname, valname;
+		Lex(); Expect(_SC('(')); valname = Expect(TK_IDENTIFIER);
+		if(_token == _SC(',')) {
+			idxname = valname;
+			Lex(); valname = Expect(TK_IDENTIFIER);
+		}
+		else{
+			idxname = _fs->CreateString(_SC("@INDEX@"));
+		}
+		Expect(TK_IN);
+		
+		//save the stack size
+		SQInteger stacksize = _fs->GetStackSize();
+		//put the table in the stack(evaluate the table expression)
+		Expression(); Expect(_SC(')'));
+		SQInteger container = _fs->TopTarget();
+		//push the index local var
+		SQInteger indexpos = _fs->PushLocalVariable(idxname);
+		_fs->AddInstruction(_OP_LOADNULLS, indexpos,1);
+		//push the value local var
+		SQInteger valuepos = _fs->PushLocalVariable(valname);
+		_fs->AddInstruction(_OP_LOADNULLS, valuepos,1);
+		//push reference index
+		SQInteger itrpos = _fs->PushLocalVariable(_fs->CreateString(_SC("@ITERATOR@"))); //use invalid id to make it inaccessible
+		_fs->AddInstruction(_OP_LOADNULLS, itrpos,1);
+		SQInteger jmppos = _fs->GetCurrentPos();
+		_fs->AddInstruction(_OP_FOREACH, container, 0, indexpos);
+		SQInteger foreachpos = _fs->GetCurrentPos();
+		_fs->AddInstruction(_OP_POSTFOREACH, container, 0, indexpos);
+		//generate the statement code
+		BEGIN_BREAKBLE_BLOCK()
+		Statement();
+		_fs->AddInstruction(_OP_JMP, 0, jmppos - _fs->GetCurrentPos() - 1);
+		_fs->SetIntructionParam(foreachpos, 1, _fs->GetCurrentPos() - foreachpos);
+		_fs->SetIntructionParam(foreachpos + 1, 1, _fs->GetCurrentPos() - foreachpos);
+		//restore the local variable stack(remove index,val and ref idx)
+		CleanStack(stacksize);
+		END_BREAKBLE_BLOCK(foreachpos - 1);
+	}
+	void SwitchStatement()
+	{
+		Lex(); Expect(_SC('(')); CommaExpr(); Expect(_SC(')'));
+		Expect(_SC('{'));
+		SQInteger expr = _fs->TopTarget();
+		bool bfirst = true;
+		SQInteger tonextcondjmp = -1;
+		SQInteger skipcondjmp = -1;
+		SQInteger __nbreaks__ = _fs->_unresolvedbreaks.size();
+		_fs->_breaktargets.push_back(0);
+		while(_token == TK_CASE) {
+			//_fs->AddLineInfos(_lex._currentline, _lineinfo); think about this one
+			if(!bfirst) {
+				_fs->AddInstruction(_OP_JMP, 0, 0);
+				skipcondjmp = _fs->GetCurrentPos();
+				_fs->SetIntructionParam(tonextcondjmp, 1, _fs->GetCurrentPos() - tonextcondjmp);
+			}
+			//condition
+			Lex(); Expression(); Expect(_SC(':'));
+			SQInteger trg = _fs->PopTarget();
+			_fs->AddInstruction(_OP_EQ, trg, trg, expr);
+			_fs->AddInstruction(_OP_JZ, trg, 0);
+			//end condition
+			if(skipcondjmp != -1) {
+				_fs->SetIntructionParam(skipcondjmp, 1, (_fs->GetCurrentPos() - skipcondjmp));
+			}
+			tonextcondjmp = _fs->GetCurrentPos();
+			SQInteger stacksize = _fs->GetStackSize();
+			Statements();
+			_fs->SetStackSize(stacksize);
+			bfirst = false;
+		}
+		if(tonextcondjmp != -1)
+			_fs->SetIntructionParam(tonextcondjmp, 1, _fs->GetCurrentPos() - tonextcondjmp);
+		if(_token == TK_DEFAULT) {
+		//	_fs->AddLineInfos(_lex._currentline, _lineinfo);
+			Lex(); Expect(_SC(':'));
+			SQInteger stacksize = _fs->GetStackSize();
+			Statements();
+			_fs->SetStackSize(stacksize);
+		}
+		Expect(_SC('}'));
+		_fs->PopTarget();
+		__nbreaks__ = _fs->_unresolvedbreaks.size() - __nbreaks__;
+		if(__nbreaks__ > 0)ResolveBreaks(_fs, __nbreaks__);
+		_fs->_breaktargets.pop_back();
+		
+	}
+	void FunctionStatement()
+	{
+		SQObject id;
+		Lex(); id = Expect(TK_IDENTIFIER);
+		_fs->PushTarget(0);
+		_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetConstant(id));
+		if(_token == TK_DOUBLE_COLON) Emit2ArgsOP(_OP_GET);
+		
+		while(_token == TK_DOUBLE_COLON) {
+			Lex();
+			id = Expect(TK_IDENTIFIER);
+			_fs->AddInstruction(_OP_LOAD, _fs->PushTarget(), _fs->GetConstant(id));
+			if(_token == TK_DOUBLE_COLON) Emit2ArgsOP(_OP_GET);
+		}
+		Expect(_SC('('));
+		CreateFunction(id);
+		_fs->AddInstruction(_OP_CLOSURE, _fs->PushTarget(), _fs->_functions.size() - 1, 0);
+		EmitDerefOp(_OP_NEWSLOT);
+		_fs->PopTarget();
+	}
+	void ClassStatement()
+	{
+		ExpState es;
+		Lex(); PushExpState();
+		_exst._class_or_delete = true;
+		_exst._funcarg = false;
+		PrefixedExpr();
+		es = PopExpState();
+		if(es._deref == DEREF_NO_DEREF) Error(_SC("invalid class name"));
+		if(es._deref == DEREF_FIELD) {
+			ClassExp();
+			EmitDerefOp(_OP_NEWSLOT);
+			_fs->PopTarget();
+		}
+		else Error(_SC("cannot create a class in a local with the syntax(class <local>)"));
+	}
+	SQObject ExpectScalar()
+	{
+		SQObject val;
+		switch(_token) {
+			case TK_INTEGER:
+				val._type = OT_INTEGER;
+				val._unVal.nInteger = _lex._nvalue;
+				break;
+			case TK_FLOAT:
+				val._type = OT_FLOAT;
+				val._unVal.fFloat = _lex._fvalue;
+				break;
+			case TK_STRING_LITERAL:
+				val = _fs->CreateString(_lex._svalue,_lex._longstr.size()-1);
+				break;
+			default:
+			Error(_SC("scalar expected : integer,float or string"));
+		}
+		Lex();
+		return val;
+	}
+	void EnumStatement()
+	{
+		
+		Lex(); 
+		SQObject id = Expect(TK_IDENTIFIER);
+		Expect(_SC('{'));
+		
+		SQObject table = _fs->CreateTable();
+		SQInteger nval = 0;
+		while(_token != _SC('}')) {
+			SQObject key = Expect(TK_IDENTIFIER);
+			SQObject val;
+			if(_token == _SC('=')) {
+				Lex();
+				val = ExpectScalar();
+			}
+			else {
+				val._type = OT_INTEGER;
+				val._unVal.nInteger = nval++;
+			}
+			_table(table)->NewSlot(SQObjectPtr(key),SQObjectPtr(val));
+			if(_token == ',') Lex();
+		}
+		SQTable *enums = _table(_ss(_vm)->_consts);
+		SQObjectPtr strongid = id; 
+		/*SQObjectPtr dummy;
+		if(enums->Get(strongid,dummy)) {
+			dummy.Null(); strongid.Null();
+			Error(_SC("enumeration already exists"));
+		}*/
+		enums->NewSlot(SQObjectPtr(strongid),SQObjectPtr(table));
+		strongid.Null();
+		Lex();
+		
+	}
+	void TryCatchStatement()
+	{
+		SQObject exid;
+		Lex();
+		_fs->AddInstruction(_OP_PUSHTRAP,0,0);
+		_fs->_traps++;
+		if(_fs->_breaktargets.size()) _fs->_breaktargets.top()++;
+		if(_fs->_continuetargets.size()) _fs->_continuetargets.top()++;
+		SQInteger trappos = _fs->GetCurrentPos();
+		Statement();
+		_fs->_traps--;
+		_fs->AddInstruction(_OP_POPTRAP, 1, 0);
+		if(_fs->_breaktargets.size()) _fs->_breaktargets.top()--;
+		if(_fs->_continuetargets.size()) _fs->_continuetargets.top()--;
+		_fs->AddInstruction(_OP_JMP, 0, 0);
+		SQInteger jmppos = _fs->GetCurrentPos();
+		_fs->SetIntructionParam(trappos, 1, (_fs->GetCurrentPos() - trappos));
+		Expect(TK_CATCH); Expect(_SC('(')); exid = Expect(TK_IDENTIFIER); Expect(_SC(')'));
+		SQInteger stacksize = _fs->GetStackSize();
+		SQInteger ex_target = _fs->PushLocalVariable(exid);
+		_fs->SetIntructionParam(trappos, 0, ex_target);
+		Statement();
+		_fs->SetIntructionParams(jmppos, 0, (_fs->GetCurrentPos() - jmppos), 0);
+		CleanStack(stacksize);
+	}
+	void FunctionExp(SQInteger ftype)
+	{
+		Lex(); Expect(_SC('('));
+		CreateFunction(_null_);
+		_fs->AddInstruction(_OP_CLOSURE, _fs->PushTarget(), _fs->_functions.size() - 1, ftype == TK_FUNCTION?0:1);
+	}
+	void ClassExp()
+	{
+		SQInteger base = -1;
+		SQInteger attrs = -1;
+		if(_token == TK_EXTENDS) {
+			Lex(); Expression();
+			base = _fs->TopTarget();
+		}
+		if(_token == TK_ATTR_OPEN) {
+			Lex();
+			_fs->AddInstruction(_OP_NEWTABLE, _fs->PushTarget());
+			ParseTableOrClass(_SC(','),TK_ATTR_CLOSE);
+			attrs = _fs->TopTarget();
+		}
+		Expect(_SC('{'));
+		if(attrs != -1) _fs->PopTarget();
+		if(base != -1) _fs->PopTarget();
+		_fs->AddInstruction(_OP_CLASS, _fs->PushTarget(), base, attrs);
+		ParseTableOrClass(_SC(';'));
+	}
+	void DelegateExpr()
+	{
+		Lex(); CommaExpr();
+		Expect(_SC(':'));
+		CommaExpr();
+		SQInteger table = _fs->PopTarget(), delegate = _fs->PopTarget();
+		_fs->AddInstruction(_OP_DELEGATE, _fs->PushTarget(), table, delegate);
+	}
+	void DeleteExpr()
+	{
+		ExpState es;
+		Lex(); PushExpState();
+		_exst._class_or_delete = true;
+		_exst._funcarg = false;
+		PrefixedExpr();
+		es = PopExpState();
+		if(es._deref == DEREF_NO_DEREF) Error(_SC("can't delete an expression"));
+		if(es._deref == DEREF_FIELD) Emit2ArgsOP(_OP_DELETE);
+		else Error(_SC("cannot delete a local"));
+	}
+	void PrefixIncDec(SQInteger token)
+	{
+		ExpState es;
+		Lex(); PushExpState();
+		_exst._class_or_delete = true;
+		_exst._funcarg = false;
+		PrefixedExpr();
+		es = PopExpState();
+		if(es._deref == DEREF_FIELD) Emit2ArgsOP(_OP_INC,token == TK_MINUSMINUS?-1:1);
+		else {
+			SQInteger src = _fs->PopTarget();
+			_fs->AddInstruction(_OP_INCL, _fs->PushTarget(), src, 0, token == TK_MINUSMINUS?-1:1);
+		}
+	}
+	void CreateFunction(SQObject &name)
+	{
+		
+		SQFuncState *funcstate = _fs->PushChildState(_ss(_vm));
+		funcstate->_name = name;
+		SQObject paramname;
+		funcstate->AddParameter(_fs->CreateString(_SC("this")));
+		funcstate->_sourcename = _sourcename;
+		SQInteger defparams = 0;
+		while(_token!=_SC(')')) {
+			if(_token == TK_VARPARAMS) {
+				if(defparams > 0) Error(_SC("function with default parameters cannot have variable number of parameters"));
+				funcstate->_varparams = true;
+				Lex();
+				if(_token != _SC(')')) Error(_SC("expected ')'"));
+				break;
+			}
+			else {
+				paramname = Expect(TK_IDENTIFIER);
+				funcstate->AddParameter(paramname);
+				if(_token == _SC('=')) { 
+					Lex();
+					Expression();
+					funcstate->AddDefaultParam(_fs->TopTarget());
+					defparams++;
+				}
+				else {
+					if(defparams > 0) Error(_SC("expected '='"));
+				}
+				if(_token == _SC(',')) Lex();
+				else if(_token != _SC(')')) Error(_SC("expected ')' or ','"));
+			}
+		}
+		Expect(_SC(')'));
+		for(SQInteger n = 0; n < defparams; n++) {
+			_fs->PopTarget();
+		}
+		//outer values
+		if(_token == _SC(':')) {
+			Lex(); Expect(_SC('('));
+			while(_token != _SC(')')) {
+				paramname = Expect(TK_IDENTIFIER);
+				//outers are treated as implicit local variables
+				funcstate->AddOuterValue(paramname);
+				if(_token == _SC(',')) Lex();
+				else if(_token != _SC(')')) Error(_SC("expected ')' or ','"));
+			}
+			Lex();
+		}
+		
+		SQFuncState *currchunk = _fs;
+		_fs = funcstate;
+		Statement();
+		funcstate->AddLineInfos(_lex._prevtoken == _SC('\n')?_lex._lasttokenline:_lex._currentline, _lineinfo, true);
+        funcstate->AddInstruction(_OP_RETURN, -1);
+		funcstate->SetStackSize(0);
+		//_fs->->_stacksize = _fs->_stacksize;
+		SQFunctionProto *func = funcstate->BuildProto();
+#ifdef _DEBUG_DUMP
+		funcstate->Dump(func);
+#endif
+		_fs = currchunk;
+		_fs->_functions.push_back(func);
+		_fs->PopChildState();
+	}
+	void CleanStack(SQInteger stacksize)
+	{
+		if(_fs->GetStackSize() != stacksize)
+			_fs->SetStackSize(stacksize);
+	}
+	void ResolveBreaks(SQFuncState *funcstate, SQInteger ntoresolve)
+	{
+		while(ntoresolve > 0) {
+			SQInteger pos = funcstate->_unresolvedbreaks.back();
+			funcstate->_unresolvedbreaks.pop_back();
+			//set the jmp instruction
+			funcstate->SetIntructionParams(pos, 0, funcstate->GetCurrentPos() - pos, 0);
+			ntoresolve--;
+		}
+	}
+	void ResolveContinues(SQFuncState *funcstate, SQInteger ntoresolve, SQInteger targetpos)
+	{
+		while(ntoresolve > 0) {
+			SQInteger pos = funcstate->_unresolvedcontinues.back();
+			funcstate->_unresolvedcontinues.pop_back();
+			//set the jmp instruction
+			funcstate->SetIntructionParams(pos, 0, targetpos - pos, 0);
+			ntoresolve--;
+		}
+	}
+private:
+	SQInteger _token;
+	SQFuncState *_fs;
+	SQObjectPtr _sourcename;
+	SQLexer _lex;
+	bool _lineinfo;
+	bool _raiseerror;
+	SQInteger _debugline;
+	SQInteger _debugop;
+	ExpStateVec _expstates;
+	SQChar *compilererror;
+	jmp_buf _errorjmp;
+	SQVM *_vm;
+};
+
+bool Compile(SQVM *vm,SQLEXREADFUNC rg, SQUserPointer up, const SQChar *sourcename, SQObjectPtr &out, bool raiseerror, bool lineinfo)
+{
+	SQCompiler p(vm, rg, up, sourcename, raiseerror, lineinfo);
+	return p.Compile(out);
+}

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqcompiler.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqcompiler.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqcompiler.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,77 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQCOMPILER_H_
+#define _SQCOMPILER_H_
+
+struct SQVM;
+
+#define	TK_IDENTIFIER	258
+#define	TK_STRING_LITERAL	259
+#define	TK_INTEGER	260
+#define	TK_FLOAT	261
+#define	TK_DELEGATE	262
+#define	TK_DELETE	263
+#define	TK_EQ	264
+#define	TK_NE	265
+#define	TK_LE	266
+#define	TK_GE	267
+#define	TK_SWITCH	268
+#define	TK_ARROW	269
+#define	TK_AND	270
+#define	TK_OR	271
+#define	TK_IF	272
+#define	TK_ELSE	273
+#define	TK_WHILE	274
+#define	TK_BREAK	275
+#define	TK_FOR	276
+#define	TK_DO	277
+#define	TK_NULL	278
+#define	TK_FOREACH	279
+#define	TK_IN	280
+#define	TK_NEWSLOT	281
+#define	TK_MODULO	282
+#define	TK_LOCAL	283
+#define	TK_CLONE	284
+#define	TK_FUNCTION	285
+#define	TK_RETURN	286
+#define	TK_TYPEOF	287
+#define	TK_UMINUS	288
+#define	TK_PLUSEQ	289
+#define	TK_MINUSEQ	290
+#define	TK_CONTINUE	291
+#define TK_YIELD 292
+#define TK_TRY 293
+#define TK_CATCH 294
+#define TK_THROW 295
+#define TK_SHIFTL 296
+#define TK_SHIFTR 297
+#define TK_RESUME 298
+#define TK_DOUBLE_COLON 299
+#define TK_CASE 300
+#define TK_DEFAULT 301
+#define TK_THIS 302
+#define TK_PLUSPLUS 303
+#define TK_MINUSMINUS 304
+#define TK_PARENT 305
+#define TK_USHIFTR 306
+#define TK_CLASS 307
+#define TK_EXTENDS 308
+#define TK_CONSTRUCTOR 310
+#define TK_INSTANCEOF 311
+#define TK_VARPARAMS 312
+#define TK_VARGC 313
+#define TK_VARGV 314
+#define TK_TRUE 315
+#define TK_FALSE 316
+#define TK_MULEQ 317
+#define TK_DIVEQ 318
+#define TK_MODEQ 319
+#define TK_ATTR_OPEN 320
+#define TK_ATTR_CLOSE 321
+#define TK_STATIC 322
+#define TK_ENUM 323
+#define TK_CONST 324
+
+
+typedef void(*CompilerErrorFunc)(void *ud, const SQChar *s);
+bool Compile(SQVM *vm, SQLEXREADFUNC rg, SQUserPointer up, const SQChar *sourcename, SQObjectPtr &out, bool raiseerror, bool lineinfo);
+#endif //_SQCOMPILER_H_

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqdebug.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqdebug.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqdebug.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,99 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include <stdarg.h>
+#include "sqvm.h"
+#include "sqfuncproto.h"
+#include "sqclosure.h"
+#include "sqstring.h"
+
+SQRESULT sq_stackinfos(HSQUIRRELVM v, SQInteger level, SQStackInfos *si)
+{
+	SQInteger cssize = v->_callsstacksize;
+	if (cssize > level) {
+		memset(si, 0, sizeof(SQStackInfos));
+		SQVM::CallInfo &ci = v->_callsstack[cssize-level-1];
+		switch (type(ci._closure)) {
+		case OT_CLOSURE:{
+			SQFunctionProto *func = _funcproto(_closure(ci._closure)->_function);
+			if (type(func->_name) == OT_STRING)
+				si->funcname = _stringval(func->_name);
+			if (type(func->_sourcename) == OT_STRING)
+				si->source = _stringval(func->_sourcename);
+			si->line = func->GetLine(ci._ip);
+						}
+			break;
+		case OT_NATIVECLOSURE:
+			si->source = _SC("NATIVE");
+			si->funcname = _SC("unknown");
+			if(type(_nativeclosure(ci._closure)->_name) == OT_STRING)
+				si->funcname = _stringval(_nativeclosure(ci._closure)->_name);
+			si->line = -1;
+			break;
+		default: break; //shutup compiler
+		}
+		return SQ_OK;
+	}
+	return SQ_ERROR;
+}
+
+void SQVM::Raise_Error(const SQChar *s, ...)
+{
+	va_list vl;
+	va_start(vl, s);
+	scvsprintf(_sp(rsl((SQInteger)scstrlen(s)+(NUMBER_MAX_CHAR*2))), s, vl);
+	va_end(vl);
+	_lasterror = SQString::Create(_ss(this),_spval,-1);
+}
+
+void SQVM::Raise_Error(SQObjectPtr &desc)
+{
+	_lasterror = desc;
+}
+
+SQString *SQVM::PrintObjVal(const SQObject &o)
+{
+	switch(type(o)) {
+	case OT_STRING: return _string(o);
+	case OT_INTEGER:
+		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)), _SC("%d"), _integer(o));
+		return SQString::Create(_ss(this), _spval);
+		break;
+	case OT_FLOAT:
+		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)), _SC("%.14g"), _float(o));
+		return SQString::Create(_ss(this), _spval);
+		break;
+	default:
+		return SQString::Create(_ss(this), GetTypeName(o));
+	}
+}
+
+void SQVM::Raise_IdxError(SQObject &o)
+{
+	SQObjectPtr oval = PrintObjVal(o);
+	Raise_Error(_SC("the index '%.50s' does not exist"), _stringval(oval));
+}
+
+void SQVM::Raise_CompareError(const SQObject &o1, const SQObject &o2)
+{
+	SQObjectPtr oval1 = PrintObjVal(o1), oval2 = PrintObjVal(o2);
+	Raise_Error(_SC("comparsion between '%.50s' and '%.50s'"), _stringval(oval1), _stringval(oval2));
+}
+
+
+void SQVM::Raise_ParamTypeError(SQInteger nparam,SQInteger typemask,SQInteger type)
+{
+	SQObjectPtr exptypes = SQString::Create(_ss(this), _SC(""), -1);
+	SQInteger found = 0;	
+	for(SQInteger i=0; i<16; i++)
+	{
+		SQInteger mask = 0x00000001 << i;
+		if(typemask & (mask)) {
+			if(found>0) StringCat(exptypes,SQString::Create(_ss(this), _SC("|"), -1), exptypes);
+			found ++;
+			StringCat(exptypes,SQString::Create(_ss(this), IdType2Name((SQObjectType)mask), -1), exptypes);
+		}
+	}
+	Raise_Error(_SC("parameter %d has an invalid type '%s' ; expected: '%s'"), nparam, IdType2Name((SQObjectType)type), _stringval(exptypes));
+}

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqfuncproto.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqfuncproto.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqfuncproto.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,160 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQFUNCTION_H_
+#define _SQFUNCTION_H_
+
+#include "sqopcodes.h"
+
+enum SQOuterType {
+	otLOCAL = 0,
+	otSYMBOL = 1,
+	otOUTER = 2
+};
+
+struct SQOuterVar
+{
+	
+	SQOuterVar(){}
+	SQOuterVar(const SQObjectPtr &name,const SQObjectPtr &src,SQOuterType t)
+	{
+		_name = name;
+		_src=src;
+		_type=t;
+	}
+	SQOuterVar(const SQOuterVar &ov)
+	{
+		_type=ov._type;
+		_src=ov._src;
+		_name=ov._name;
+	}
+	SQOuterType _type;
+	SQObjectPtr _name;
+	SQObjectPtr _src;
+};
+
+struct SQLocalVarInfo
+{
+	SQLocalVarInfo():_start_op(0),_end_op(0){}
+	SQLocalVarInfo(const SQLocalVarInfo &lvi)
+	{
+		_name=lvi._name;
+		_start_op=lvi._start_op;
+		_end_op=lvi._end_op;
+		_pos=lvi._pos;
+	}
+	SQObjectPtr _name;
+	SQUnsignedInteger _start_op;
+	SQUnsignedInteger _end_op;
+	SQUnsignedInteger _pos;
+};
+
+struct SQLineInfo { SQInteger _line;SQInteger _op; };
+
+typedef sqvector<SQOuterVar> SQOuterVarVec;
+typedef sqvector<SQLocalVarInfo> SQLocalVarInfoVec;
+typedef sqvector<SQLineInfo> SQLineInfoVec;
+
+#define _FUNC_SIZE(ni,nl,nparams,nfuncs,nouters,nlineinf,localinf,defparams) (sizeof(SQFunctionProto) \
+		+((ni-1)*sizeof(SQInstruction))+(nl*sizeof(SQObjectPtr)) \
+		+(nparams*sizeof(SQObjectPtr))+(nfuncs*sizeof(SQObjectPtr)) \
+		+(nouters*sizeof(SQOuterVar))+(nlineinf*sizeof(SQLineInfo)) \
+		+(localinf*sizeof(SQLocalVarInfo))+(defparams*sizeof(SQInteger)))
+
+#define _CONSTRUCT_VECTOR(type,size,ptr) { \
+	for(SQInteger n = 0; n < size; n++) { \
+			new (&ptr[n]) type(); \
+		} \
+}
+
+#define _DESTRUCT_VECTOR(type,size,ptr) { \
+	for(SQInteger nl = 0; nl < size; nl++) { \
+			ptr[nl].~type(); \
+	} \
+}
+struct SQFunctionProto : public SQRefCounted
+{
+private:
+	SQFunctionProto(){
+	_stacksize=0;
+	_bgenerator=false;}
+public:
+	static SQFunctionProto *Create(SQInteger ninstructions,
+		SQInteger nliterals,SQInteger nparameters,
+		SQInteger nfunctions,SQInteger noutervalues,
+		SQInteger nlineinfos,SQInteger nlocalvarinfos,SQInteger ndefaultparams)
+	{
+		SQFunctionProto *f;
+		//I compact the whole class and members in a single memory allocation
+		f = (SQFunctionProto *)sq_vm_malloc(_FUNC_SIZE(ninstructions,nliterals,nparameters,nfunctions,noutervalues,nlineinfos,nlocalvarinfos,ndefaultparams));
+		new (f) SQFunctionProto;
+		f->_ninstructions = ninstructions;
+		f->_literals = (SQObjectPtr*)&f->_instructions[ninstructions];
+		f->_nliterals = nliterals;
+		f->_parameters = (SQObjectPtr*)&f->_literals[nliterals];
+		f->_nparameters = nparameters;
+		f->_functions = (SQObjectPtr*)&f->_parameters[nparameters];
+		f->_nfunctions = nfunctions;
+		f->_outervalues = (SQOuterVar*)&f->_functions[nfunctions];
+		f->_noutervalues = noutervalues;
+		f->_lineinfos = (SQLineInfo *)&f->_outervalues[noutervalues];
+		f->_nlineinfos = nlineinfos;
+		f->_localvarinfos = (SQLocalVarInfo *)&f->_lineinfos[nlineinfos];
+		f->_nlocalvarinfos = nlocalvarinfos;
+		f->_defaultparams = (SQInteger *)&f->_localvarinfos[nlocalvarinfos];
+		f->_ndefaultparams = ndefaultparams;
+
+		_CONSTRUCT_VECTOR(SQObjectPtr,f->_nliterals,f->_literals);
+		_CONSTRUCT_VECTOR(SQObjectPtr,f->_nparameters,f->_parameters);
+		_CONSTRUCT_VECTOR(SQObjectPtr,f->_nfunctions,f->_functions);
+		_CONSTRUCT_VECTOR(SQOuterVar,f->_noutervalues,f->_outervalues);
+		//_CONSTRUCT_VECTOR(SQLineInfo,f->_nlineinfos,f->_lineinfos); //not required are 2 integers
+		_CONSTRUCT_VECTOR(SQLocalVarInfo,f->_nlocalvarinfos,f->_localvarinfos);
+		return f;
+	}
+	void Release(){ 
+		_DESTRUCT_VECTOR(SQObjectPtr,_nliterals,_literals);
+		_DESTRUCT_VECTOR(SQObjectPtr,_nparameters,_parameters);
+		_DESTRUCT_VECTOR(SQObjectPtr,_nfunctions,_functions);
+		_DESTRUCT_VECTOR(SQOuterVar,_noutervalues,_outervalues);
+		//_DESTRUCT_VECTOR(SQLineInfo,_nlineinfos,_lineinfos); //not required are 2 integers
+		_DESTRUCT_VECTOR(SQLocalVarInfo,_nlocalvarinfos,_localvarinfos);
+		SQInteger size = _FUNC_SIZE(_ninstructions,_nliterals,_nparameters,_nfunctions,_noutervalues,_nlineinfos,_nlocalvarinfos,_ndefaultparams);
+		this->~SQFunctionProto();
+		sq_vm_free(this,size);
+	}
+	const SQChar* GetLocal(SQVM *v,SQUnsignedInteger stackbase,SQUnsignedInteger nseq,SQUnsignedInteger nop);
+	SQInteger GetLine(SQInstruction *curr);
+	bool Save(SQVM *v,SQUserPointer up,SQWRITEFUNC write);
+	static bool Load(SQVM *v,SQUserPointer up,SQREADFUNC read,SQObjectPtr &ret);
+
+	SQObjectPtr _sourcename;
+	SQObjectPtr _name;
+    SQInteger _stacksize;
+	bool _bgenerator;
+	bool _varparams;
+
+	SQInteger _nlocalvarinfos;
+	SQLocalVarInfo *_localvarinfos;
+
+	SQInteger _nlineinfos;
+	SQLineInfo *_lineinfos;
+
+	SQInteger _nliterals;
+	SQObjectPtr *_literals;
+
+	SQInteger _nparameters;
+	SQObjectPtr *_parameters;
+	
+	SQInteger _nfunctions;
+	SQObjectPtr *_functions;
+
+	SQInteger _noutervalues;
+	SQOuterVar *_outervalues;
+
+	SQInteger _ndefaultparams;
+	SQInteger *_defaultparams;
+	
+	SQInteger _ninstructions;
+	SQInstruction _instructions[1];
+};
+
+#endif //_SQFUNCTION_H_

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqfuncstate.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqfuncstate.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqfuncstate.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,567 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include "sqcompiler.h"
+#include "sqfuncproto.h"
+#include "sqstring.h"
+#include "sqtable.h"
+#include "sqopcodes.h"
+#include "sqfuncstate.h"
+
+#ifdef _DEBUG_DUMP
+SQInstructionDesc g_InstrDesc[]={
+	{_SC("_OP_LINE")},
+	{_SC("_OP_LOAD")},
+	{_SC("_OP_LOADINT")},
+	{_SC("_OP_LOADFLOAT")},
+	{_SC("_OP_DLOAD")},
+	{_SC("_OP_TAILCALL")},
+	{_SC("_OP_CALL")},
+	{_SC("_OP_PREPCALL")},
+	{_SC("_OP_PREPCALLK")},
+	{_SC("_OP_GETK")},
+	{_SC("_OP_MOVE")},
+	{_SC("_OP_NEWSLOT")},
+	{_SC("_OP_DELETE")},
+	{_SC("_OP_SET")},
+	{_SC("_OP_GET")},
+	{_SC("_OP_EQ")},
+	{_SC("_OP_NE")},
+	{_SC("_OP_ARITH")},
+	{_SC("_OP_BITW")},
+	{_SC("_OP_RETURN")},
+	{_SC("_OP_LOADNULLS")},
+	{_SC("_OP_LOADROOTTABLE")},
+	{_SC("_OP_LOADBOOL")},
+	{_SC("_OP_DMOVE")},
+	{_SC("_OP_JMP")},
+	{_SC("_OP_JNZ")},
+	{_SC("_OP_JZ")},
+	{_SC("_OP_LOADFREEVAR")},
+	{_SC("_OP_VARGC")},
+	{_SC("_OP_GETVARGV")},
+	{_SC("_OP_NEWTABLE")},
+	{_SC("_OP_NEWARRAY")},
+	{_SC("_OP_APPENDARRAY")},
+	{_SC("_OP_GETPARENT")},
+	{_SC("_OP_COMPARITH")},
+	{_SC("_OP_COMPARITHL")},
+	{_SC("_OP_INC")},
+	{_SC("_OP_INCL")},
+	{_SC("_OP_PINC")},
+	{_SC("_OP_PINCL")},
+	{_SC("_OP_CMP")},
+	{_SC("_OP_EXISTS")},
+	{_SC("_OP_INSTANCEOF")},
+	{_SC("_OP_AND")},
+	{_SC("_OP_OR")},
+	{_SC("_OP_NEG")},
+	{_SC("_OP_NOT")},
+	{_SC("_OP_BWNOT")},
+	{_SC("_OP_CLOSURE")},
+	{_SC("_OP_YIELD")},
+	{_SC("_OP_RESUME")},
+	{_SC("_OP_FOREACH")},
+	{_SC("_OP_POSTFOREACH")},
+	{_SC("_OP_DELEGATE")},
+	{_SC("_OP_CLONE")},
+	{_SC("_OP_TYPEOF")},
+	{_SC("_OP_PUSHTRAP")},
+	{_SC("_OP_POPTRAP")},
+	{_SC("_OP_THROW")},
+	{_SC("_OP_CLASS")},
+	{_SC("_OP_NEWSLOTA")}
+};
+#endif
+void DumpLiteral(SQObjectPtr &o)
+{
+	switch(type(o)){
+		case OT_STRING:	scprintf(_SC("\"%s\""),_stringval(o));break;
+		case OT_FLOAT: scprintf(_SC("{%f}"),_float(o));break;
+		case OT_INTEGER: scprintf(_SC("{%d}"),_integer(o));break;
+		case OT_BOOL: scprintf(_SC("%s"),_integer(o)?_SC("true"):_SC("false"));break;
+		default: scprintf(_SC("(%s %p)"),GetTypeName(o),_rawval(o));break; break; //shut up compiler
+	}
+}
+
+SQFuncState::SQFuncState(SQSharedState *ss,SQFuncState *parent,CompilerErrorFunc efunc,void *ed)
+{
+		_nliterals = 0;
+		_literals = SQTable::Create(ss,0);
+		_strings =  SQTable::Create(ss,0);
+		_sharedstate = ss;
+		_lastline = 0;
+		_optimization = true;
+		_parent = parent;
+		_stacksize = 0;
+		_traps = 0;
+		_returnexp = 0;
+		_varparams = false;
+		_errfunc = efunc;
+		_errtarget = ed;
+		_bgenerator = false;
+
+}
+
+void SQFuncState::Error(const SQChar *err)
+{
+	_errfunc(_errtarget,err);
+}
+
+#ifdef _DEBUG_DUMP
+void SQFuncState::Dump(SQFunctionProto *func)
+{
+	SQUnsignedInteger n=0,i;
+	SQInteger si;
+	scprintf(_SC("SQInstruction sizeof %d\n"),sizeof(SQInstruction));
+	scprintf(_SC("SQObject sizeof %d\n"),sizeof(SQObject));
+	scprintf(_SC("--------------------------------------------------------------------\n"));
+	scprintf(_SC("*****FUNCTION [%s]\n"),type(func->_name)==OT_STRING?_stringval(func->_name):_SC("unknown"));
+	scprintf(_SC("-----LITERALS\n"));
+	SQObjectPtr refidx,key,val;
+	SQInteger idx;
+	SQObjectPtrVec templiterals;
+	templiterals.resize(_nliterals);
+	while((idx=_table(_literals)->Next(false,refidx,key,val))!=-1) {
+		refidx=idx;
+		templiterals[_integer(val)]=key;
+	}
+	for(i=0;i<templiterals.size();i++){
+		scprintf(_SC("[%d] "),n);
+		DumpLiteral(templiterals[i]);
+		scprintf(_SC("\n"));
+		n++;
+	}
+	scprintf(_SC("-----PARAMS\n"));
+	if(_varparams)
+		scprintf(_SC("<<VARPARAMS>>\n"));
+	n=0;
+	for(i=0;i<_parameters.size();i++){
+		scprintf(_SC("[%d] "),n);
+		DumpLiteral(_parameters[i]);
+		scprintf(_SC("\n"));
+		n++;
+	}
+	scprintf(_SC("-----LOCALS\n"));
+	for(si=0;si<func->_nlocalvarinfos;si++){
+		SQLocalVarInfo lvi=func->_localvarinfos[si];
+		scprintf(_SC("[%d] %s \t%d %d\n"),lvi._pos,_stringval(lvi._name),lvi._start_op,lvi._end_op);
+		n++;
+	}
+	scprintf(_SC("-----LINE INFO\n"));
+	for(i=0;i<_lineinfos.size();i++){
+		SQLineInfo li=_lineinfos[i];
+		scprintf(_SC("op [%d] line [%d] \n"),li._op,li._line);
+		n++;
+	}
+	scprintf(_SC("-----dump\n"));
+	n=0;
+	for(i=0;i<_instructions.size();i++){
+		SQInstruction &inst=_instructions[i];
+		if(inst.op==_OP_LOAD || inst.op==_OP_DLOAD || inst.op==_OP_PREPCALLK || inst.op==_OP_GETK ){
+			
+			SQInteger lidx = inst._arg1;
+			scprintf(_SC("[%03d] %15s %d "),n,g_InstrDesc[inst.op].name,inst._arg0);
+			if(lidx >= 0xFFFFFFFF)
+				scprintf(_SC("null"));
+			else {
+				SQInteger refidx;
+				SQObjectPtr val,key,refo;
+				while(((refidx=_table(_literals)->Next(false,refo,key,val))!= -1) && (_integer(val) != lidx)) {
+					refo = refidx;	
+				}
+				DumpLiteral(key);
+			}
+			if(inst.op != _OP_DLOAD) {
+				scprintf(_SC(" %d %d \n"),inst._arg2,inst._arg3);
+			}
+			else {
+				scprintf(_SC(" %d "),inst._arg2);
+				lidx = inst._arg3;
+				if(lidx >= 0xFFFFFFFF)
+					scprintf(_SC("null"));
+				else {
+					SQInteger refidx;
+					SQObjectPtr val,key,refo;
+					while(((refidx=_table(_literals)->Next(false,refo,key,val))!= -1) && (_integer(val) != lidx)) {
+						refo = refidx;	
+				}
+				DumpLiteral(key);
+				scprintf(_SC("\n"));
+			}
+			}
+		}
+		else if(inst.op==_OP_LOADFLOAT) {
+			scprintf(_SC("[%03d] %15s %d %f %d %d\n"),n,g_InstrDesc[inst.op].name,inst._arg0,*((SQFloat*)&inst._arg1),inst._arg2,inst._arg3);
+		}
+		else if(inst.op==_OP_ARITH){
+			scprintf(_SC("[%03d] %15s %d %d %d %c\n"),n,g_InstrDesc[inst.op].name,inst._arg0,inst._arg1,inst._arg2,inst._arg3);
+		}
+		else 
+			scprintf(_SC("[%03d] %15s %d %d %d %d\n"),n,g_InstrDesc[inst.op].name,inst._arg0,inst._arg1,inst._arg2,inst._arg3);
+		n++;
+	}
+	scprintf(_SC("-----\n"));
+	scprintf(_SC("stack size[%d]\n"),func->_stacksize);
+	scprintf(_SC("--------------------------------------------------------------------\n\n"));
+}
+#endif
+
+SQInteger SQFuncState::GetNumericConstant(const SQInteger cons)
+{
+	return GetConstant(SQObjectPtr(cons));
+}
+
+SQInteger SQFuncState::GetNumericConstant(const SQFloat cons)
+{
+	return GetConstant(SQObjectPtr(cons));
+}
+
+SQInteger SQFuncState::GetConstant(const SQObject &cons)
+{
+	SQObjectPtr val;
+	if(!_table(_literals)->Get(cons,val))
+	{
+		val = _nliterals;
+		_table(_literals)->NewSlot(cons,val);
+		_nliterals++;
+		if(_nliterals > MAX_LITERALS) {
+			val.Null();
+			Error(_SC("internal compiler error: too many literals"));
+		}
+	}
+	return _integer(val);
+}
+
+void SQFuncState::SetIntructionParams(SQInteger pos,SQInteger arg0,SQInteger arg1,SQInteger arg2,SQInteger arg3)
+{
+	_instructions[pos]._arg0=(unsigned char)*((SQUnsignedInteger *)&arg0);
+	_instructions[pos]._arg1=(SQInt32)*((SQUnsignedInteger *)&arg1);
+	_instructions[pos]._arg2=(unsigned char)*((SQUnsignedInteger *)&arg2);
+	_instructions[pos]._arg3=(unsigned char)*((SQUnsignedInteger *)&arg3);
+}
+
+void SQFuncState::SetIntructionParam(SQInteger pos,SQInteger arg,SQInteger val)
+{
+	switch(arg){
+		case 0:_instructions[pos]._arg0=(unsigned char)*((SQUnsignedInteger *)&val);break;
+		case 1:case 4:_instructions[pos]._arg1=(SQInt32)*((SQUnsignedInteger *)&val);break;
+		case 2:_instructions[pos]._arg2=(unsigned char)*((SQUnsignedInteger *)&val);break;
+		case 3:_instructions[pos]._arg3=(unsigned char)*((SQUnsignedInteger *)&val);break;
+	};
+}
+
+SQInteger SQFuncState::AllocStackPos()
+{
+	SQInteger npos=_vlocals.size();
+	_vlocals.push_back(SQLocalVarInfo());
+	if(_vlocals.size()>((SQUnsignedInteger)_stacksize)) {
+		if(_stacksize>MAX_FUNC_STACKSIZE) Error(_SC("internal compiler error: too many locals"));
+		_stacksize=_vlocals.size();
+	}
+	return npos;
+}
+
+SQInteger SQFuncState::PushTarget(SQInteger n)
+{
+	if(n!=-1){
+		_targetstack.push_back(n);
+		return n;
+	}
+	n=AllocStackPos();
+	_targetstack.push_back(n);
+	return n;
+}
+
+SQInteger SQFuncState::GetUpTarget(SQInteger n){
+	return _targetstack[((_targetstack.size()-1)-n)];
+}
+
+SQInteger SQFuncState::TopTarget(){
+	return _targetstack.back();
+}
+SQInteger SQFuncState::PopTarget()
+{
+	SQInteger npos=_targetstack.back();
+	SQLocalVarInfo t=_vlocals[_targetstack.back()];
+	if(type(t._name)==OT_NULL){
+		_vlocals.pop_back();
+	}
+	_targetstack.pop_back();
+	return npos;
+}
+
+SQInteger SQFuncState::GetStackSize()
+{
+	return _vlocals.size();
+}
+
+void SQFuncState::SetStackSize(SQInteger n)
+{
+	SQInteger size=_vlocals.size();
+	while(size>n){
+		size--;
+		SQLocalVarInfo lvi=_vlocals.back();
+		if(type(lvi._name)!=OT_NULL){
+			lvi._end_op=GetCurrentPos();
+			_localvarinfos.push_back(lvi);
+		}
+		_vlocals.pop_back();
+	}
+}
+
+bool SQFuncState::IsConstant(const SQObject &name,SQObject &e)
+{
+	SQObjectPtr val;
+	if(_table(_sharedstate->_consts)->Get(name,val)) {
+		e = val;
+		return true;
+	}
+	return false;
+}
+
+bool SQFuncState::IsLocal(SQUnsignedInteger stkpos)
+{
+	if(stkpos>=_vlocals.size())return false;
+	else if(type(_vlocals[stkpos]._name)!=OT_NULL)return true;
+	return false;
+}
+
+SQInteger SQFuncState::PushLocalVariable(const SQObject &name)
+{
+	SQInteger pos=_vlocals.size();
+	SQLocalVarInfo lvi;
+	lvi._name=name;
+	lvi._start_op=GetCurrentPos()+1;
+	lvi._pos=_vlocals.size();
+	_vlocals.push_back(lvi);
+	if(_vlocals.size()>((SQUnsignedInteger)_stacksize))_stacksize=_vlocals.size();
+	
+	return pos;
+}
+
+SQInteger SQFuncState::GetLocalVariable(const SQObject &name)
+{
+	SQInteger locals=_vlocals.size();
+	while(locals>=1){
+		if(type(_vlocals[locals-1]._name)==OT_STRING && _string(_vlocals[locals-1]._name)==_string(name)){
+			return locals-1;
+		}
+		locals--;
+	}
+	return -1;
+}
+
+SQInteger SQFuncState::GetOuterVariable(const SQObject &name)
+{
+	SQInteger outers = _outervalues.size();
+	for(SQInteger i = 0; i<outers; i++) {
+		if(_string(_outervalues[i]._name) == _string(name))
+			return i;
+	}
+	return -1;
+}
+
+void SQFuncState::AddOuterValue(const SQObject &name)
+{
+	SQInteger pos=-1;
+	if(_parent) { 
+		pos = _parent->GetLocalVariable(name);
+		if(pos == -1) {
+			pos = _parent->GetOuterVariable(name);
+			if(pos != -1) {
+				_outervalues.push_back(SQOuterVar(name,SQObjectPtr(SQInteger(pos)),otOUTER)); //local
+				return;
+			}
+		}
+		else {
+			_outervalues.push_back(SQOuterVar(name,SQObjectPtr(SQInteger(pos)),otLOCAL)); //local
+			return;
+		}
+	}	
+	_outervalues.push_back(SQOuterVar(name,name,otSYMBOL)); //global
+}
+
+void SQFuncState::AddParameter(const SQObject &name)
+{
+	PushLocalVariable(name);
+	_parameters.push_back(name);
+}
+
+void SQFuncState::AddLineInfos(SQInteger line,bool lineop,bool force)
+{
+	if(_lastline!=line || force){
+		SQLineInfo li;
+		li._line=line;li._op=(GetCurrentPos()+1);
+		if(lineop)AddInstruction(_OP_LINE,0,line);
+		_lineinfos.push_back(li);
+		_lastline=line;
+	}
+}
+
+void SQFuncState::AddInstruction(SQInstruction &i)
+{
+	SQInteger size = _instructions.size();
+	if(size > 0 && _optimization){ //simple optimizer
+		SQInstruction &pi = _instructions[size-1];//previous instruction
+		switch(i.op) {
+		case _OP_RETURN:
+			if( _parent && i._arg0 != MAX_FUNC_STACKSIZE && pi.op == _OP_CALL && _returnexp < size-1) {
+				pi.op = _OP_TAILCALL;
+			}
+		break;
+		case _OP_GET:
+			if( pi.op == _OP_LOAD && pi._arg0 == i._arg2 && (!IsLocal(pi._arg0))){
+				pi._arg1 = pi._arg1;
+				pi._arg2 = (unsigned char)i._arg1;
+				pi.op = _OP_GETK;
+				pi._arg0 = i._arg0;
+				
+				return;
+			}
+		break;
+		case _OP_PREPCALL:
+			if( pi.op == _OP_LOAD  && pi._arg0 == i._arg1 && (!IsLocal(pi._arg0))){
+				pi.op = _OP_PREPCALLK;
+				pi._arg0 = i._arg0;
+				pi._arg1 = pi._arg1;
+				pi._arg2 = i._arg2;
+				pi._arg3 = i._arg3;
+				return;
+			}
+			break;
+		case _OP_APPENDARRAY:
+			if(pi.op == _OP_LOAD && pi._arg0 == i._arg1 && (!IsLocal(pi._arg0))){
+				pi.op = _OP_APPENDARRAY;
+				pi._arg0 = i._arg0;
+				pi._arg1 = pi._arg1;
+				pi._arg2 = MAX_FUNC_STACKSIZE;
+				pi._arg3 = MAX_FUNC_STACKSIZE;
+				return;
+			}
+			break;
+		case _OP_MOVE: 
+			if((pi.op == _OP_GET || pi.op == _OP_ARITH || pi.op == _OP_BITW) && (pi._arg0 == i._arg1))
+			{
+				pi._arg0 = i._arg0;
+				_optimization = false;
+				return;
+			}
+
+			if(pi.op == _OP_MOVE)
+			{
+				pi.op = _OP_DMOVE;
+				pi._arg2 = i._arg0;
+				pi._arg3 = (unsigned char)i._arg1;
+				return;
+			}
+			break;
+		case _OP_LOAD:
+			if(pi.op == _OP_LOAD && i._arg1 < 256) {
+				pi.op = _OP_DLOAD;
+				pi._arg2 = i._arg0;
+				pi._arg3 = (unsigned char)i._arg1;
+				return;
+			}
+			break;
+		case _OP_EQ:case _OP_NE:
+			if(pi.op == _OP_LOAD && pi._arg0 == i._arg1 && (!IsLocal(pi._arg0) ))
+			{
+				pi.op = i.op;
+				pi._arg0 = i._arg0;
+				pi._arg1 = pi._arg1;
+				pi._arg2 = i._arg2;
+				pi._arg3 = MAX_FUNC_STACKSIZE;
+				return;
+			}
+			break;
+		case _OP_LOADNULLS:
+			if((pi.op == _OP_LOADNULLS && pi._arg0+pi._arg1 == i._arg0)) {
+				
+				pi._arg1 = pi._arg1 + 1;
+				pi.op = _OP_LOADNULLS;
+				return;
+			}
+            break;
+		case _OP_LINE:
+			if(pi.op == _OP_LINE) {
+				_instructions.pop_back();
+				_lineinfos.pop_back();
+			}
+			break;
+		}
+	}
+	_optimization = true;
+	_instructions.push_back(i);
+}
+
+SQObject SQFuncState::CreateString(const SQChar *s,SQInteger len)
+{
+	SQObjectPtr ns(SQString::Create(_sharedstate,s,len));
+	_table(_strings)->NewSlot(ns,(SQInteger)1);
+	return ns;
+}
+
+SQObject SQFuncState::CreateTable()
+{
+	SQObjectPtr nt(SQTable::Create(_sharedstate,0));
+	_table(_strings)->NewSlot(nt,(SQInteger)1);
+	return nt;
+}
+
+SQFunctionProto *SQFuncState::BuildProto()
+{
+	SQFunctionProto *f=SQFunctionProto::Create(_instructions.size(),
+		_nliterals,_parameters.size(),_functions.size(),_outervalues.size(),
+		_lineinfos.size(),_localvarinfos.size(),_defaultparams.size());
+
+	SQObjectPtr refidx,key,val;
+	SQInteger idx;
+
+	f->_stacksize = _stacksize;
+	f->_sourcename = _sourcename;
+	f->_bgenerator = _bgenerator;
+	f->_name = _name;
+
+	while((idx=_table(_literals)->Next(false,refidx,key,val))!=-1) {
+		f->_literals[_integer(val)]=key;
+		refidx=idx;
+	}
+
+	for(SQUnsignedInteger nf = 0; nf < _functions.size(); nf++) f->_functions[nf] = _functions[nf];
+	for(SQUnsignedInteger np = 0; np < _parameters.size(); np++) f->_parameters[np] = _parameters[np];
+	for(SQUnsignedInteger no = 0; no < _outervalues.size(); no++) f->_outervalues[no] = _outervalues[no];
+	for(SQUnsignedInteger no = 0; no < _localvarinfos.size(); no++) f->_localvarinfos[no] = _localvarinfos[no];
+	for(SQUnsignedInteger no = 0; no < _lineinfos.size(); no++) f->_lineinfos[no] = _lineinfos[no];
+	for(SQUnsignedInteger no = 0; no < _defaultparams.size(); no++) f->_defaultparams[no] = _defaultparams[no];
+
+	memcpy(f->_instructions,&_instructions[0],_instructions.size()*sizeof(SQInstruction));
+
+	f->_varparams = _varparams;
+
+	return f;
+}
+
+SQFuncState *SQFuncState::PushChildState(SQSharedState *ss)
+{
+	SQFuncState *child = (SQFuncState *)sq_malloc(sizeof(SQFuncState));
+	new (child) SQFuncState(ss,this,_errfunc,_errtarget);
+	_childstates.push_back(child);
+	return child;
+}
+
+void SQFuncState::PopChildState()
+{
+	SQFuncState *child = _childstates.back();
+	sq_delete(child,SQFuncState);
+	_childstates.pop_back();
+}
+
+SQFuncState::~SQFuncState()
+{
+	while(_childstates.size() > 0)
+	{
+		PopChildState();
+	}
+}

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqfuncstate.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqfuncstate.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqfuncstate.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,85 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQFUNCSTATE_H_
+#define _SQFUNCSTATE_H_
+///////////////////////////////////
+#include "squtils.h"
+
+struct SQFuncState
+{
+	SQFuncState(SQSharedState *ss,SQFuncState *parent,CompilerErrorFunc efunc,void *ed);
+	~SQFuncState();
+#ifdef _DEBUG_DUMP
+	void Dump(SQFunctionProto *func);
+#endif
+	void Error(const SQChar *err);
+	SQFuncState *PushChildState(SQSharedState *ss);
+	void PopChildState();
+	void AddInstruction(SQOpcode _op,SQInteger arg0=0,SQInteger arg1=0,SQInteger arg2=0,SQInteger arg3=0){SQInstruction i(_op,arg0,arg1,arg2,arg3);AddInstruction(i);}
+	void AddInstruction(SQInstruction &i);
+	void SetIntructionParams(SQInteger pos,SQInteger arg0,SQInteger arg1,SQInteger arg2=0,SQInteger arg3=0);
+	void SetIntructionParam(SQInteger pos,SQInteger arg,SQInteger val);
+	SQInstruction &GetInstruction(SQInteger pos){return _instructions[pos];}
+	void PopInstructions(SQInteger size){for(SQInteger i=0;i<size;i++)_instructions.pop_back();}
+	void SetStackSize(SQInteger n);
+	void SnoozeOpt(){_optimization=false;}
+	void AddDefaultParam(SQInteger trg) { _defaultparams.push_back(trg); }
+	SQInteger GetDefaultParamCount() { return _defaultparams.size(); }
+	SQInteger GetCurrentPos(){return _instructions.size()-1;}
+	SQInteger GetNumericConstant(const SQInteger cons);
+	SQInteger GetNumericConstant(const SQFloat cons);
+	SQInteger PushLocalVariable(const SQObject &name);
+	void AddParameter(const SQObject &name);
+	void AddOuterValue(const SQObject &name);
+	SQInteger GetLocalVariable(const SQObject &name);
+	SQInteger GetOuterVariable(const SQObject &name);
+	SQInteger GenerateCode();
+	SQInteger GetStackSize();
+	SQInteger CalcStackFrameSize();
+	void AddLineInfos(SQInteger line,bool lineop,bool force=false);
+	SQFunctionProto *BuildProto();
+	SQInteger AllocStackPos();
+	SQInteger PushTarget(SQInteger n=-1);
+	SQInteger PopTarget();
+	SQInteger TopTarget();
+	SQInteger GetUpTarget(SQInteger n);
+	bool IsLocal(SQUnsignedInteger stkpos);
+	SQObject CreateString(const SQChar *s,SQInteger len = -1);
+	SQObject CreateTable();
+	bool IsConstant(const SQObject &name,SQObject &e);
+	SQInteger _returnexp;
+	SQLocalVarInfoVec _vlocals;
+	SQIntVec _targetstack;
+	SQInteger _stacksize;
+	bool _varparams;
+	bool _bgenerator;
+	SQIntVec _unresolvedbreaks;
+	SQIntVec _unresolvedcontinues;
+	SQObjectPtrVec _functions;
+	SQObjectPtrVec _parameters;
+	SQOuterVarVec _outervalues;
+	SQInstructionVec _instructions;
+	SQLocalVarInfoVec _localvarinfos;
+	SQObjectPtr _literals;
+	SQObjectPtr _strings;
+	SQObjectPtr _name;
+	SQObjectPtr _sourcename;
+	SQInteger _nliterals;
+	SQLineInfoVec _lineinfos;
+	SQFuncState *_parent;
+	SQIntVec _breaktargets;
+	SQIntVec _continuetargets;
+	SQIntVec _defaultparams;
+	SQInteger _lastline;
+	SQInteger _traps; //contains number of nested exception traps
+	bool _optimization;
+	SQSharedState *_sharedstate;
+	sqvector<SQFuncState*> _childstates;
+	SQInteger GetConstant(const SQObject &cons);
+private:
+	CompilerErrorFunc _errfunc;
+	void *_errtarget;
+};
+
+
+#endif //_SQFUNCSTATE_H_
+

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqlexer.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqlexer.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqlexer.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,476 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include <ctype.h>
+#include <stdlib.h>
+#include "sqtable.h"
+#include "sqstring.h"
+#include "sqcompiler.h"
+#include "sqlexer.h"
+
+#define CUR_CHAR (_currdata)
+#define RETURN_TOKEN(t) { _prevtoken = _curtoken; _curtoken = t; return t;}
+#define IS_EOB() (CUR_CHAR <= SQUIRREL_EOB)
+#define NEXT() {Next();_currentcolumn++;}
+#define INIT_TEMP_STRING() { _longstr.resize(0);}
+#define APPEND_CHAR(c) { _longstr.push_back(c);}
+#define TERMINATE_BUFFER() {_longstr.push_back(_SC('\0'));}
+#define ADD_KEYWORD(key,id) _keywords->NewSlot( SQString::Create(ss, _SC(#key)) ,SQInteger(id))
+
+SQLexer::SQLexer(){}
+SQLexer::~SQLexer()
+{
+	_keywords->Release();
+}
+
+void SQLexer::Init(SQSharedState *ss, SQLEXREADFUNC rg, SQUserPointer up,CompilerErrorFunc efunc,void *ed)
+{
+	_errfunc = efunc;
+	_errtarget = ed;
+	_sharedstate = ss;
+	_keywords = SQTable::Create(ss, 26);
+	ADD_KEYWORD(while, TK_WHILE);
+	ADD_KEYWORD(do, TK_DO);
+	ADD_KEYWORD(if, TK_IF);
+	ADD_KEYWORD(else, TK_ELSE);
+	ADD_KEYWORD(break, TK_BREAK);
+	ADD_KEYWORD(continue, TK_CONTINUE);
+	ADD_KEYWORD(return, TK_RETURN);
+	ADD_KEYWORD(null, TK_NULL);
+	ADD_KEYWORD(function, TK_FUNCTION);
+	ADD_KEYWORD(local, TK_LOCAL);
+	ADD_KEYWORD(for, TK_FOR);
+	ADD_KEYWORD(foreach, TK_FOREACH);
+	ADD_KEYWORD(in, TK_IN);
+	ADD_KEYWORD(typeof, TK_TYPEOF);
+	ADD_KEYWORD(delegate, TK_DELEGATE);
+	ADD_KEYWORD(delete, TK_DELETE);
+	ADD_KEYWORD(try, TK_TRY);
+	ADD_KEYWORD(catch, TK_CATCH);
+	ADD_KEYWORD(throw, TK_THROW);
+	ADD_KEYWORD(clone, TK_CLONE);
+	ADD_KEYWORD(yield, TK_YIELD);
+	ADD_KEYWORD(resume, TK_RESUME);
+	ADD_KEYWORD(switch, TK_SWITCH);
+	ADD_KEYWORD(case, TK_CASE);
+	ADD_KEYWORD(default, TK_DEFAULT);
+	ADD_KEYWORD(this, TK_THIS);
+	ADD_KEYWORD(parent,TK_PARENT);
+	ADD_KEYWORD(class,TK_CLASS);
+	ADD_KEYWORD(extends,TK_EXTENDS);
+	ADD_KEYWORD(constructor,TK_CONSTRUCTOR);
+	ADD_KEYWORD(instanceof,TK_INSTANCEOF);
+	ADD_KEYWORD(vargc,TK_VARGC);
+	ADD_KEYWORD(vargv,TK_VARGV);
+	ADD_KEYWORD(true,TK_TRUE);
+	ADD_KEYWORD(false,TK_FALSE);
+	ADD_KEYWORD(static,TK_STATIC);
+	ADD_KEYWORD(enum,TK_ENUM);
+	ADD_KEYWORD(const,TK_CONST);
+
+	_readf = rg;
+	_up = up;
+	_lasttokenline = _currentline = 1;
+	_currentcolumn = 0;
+	_prevtoken = -1;
+	Next();
+}
+
+void SQLexer::Error(const SQChar *err)
+{
+	_errfunc(_errtarget,err);
+}
+
+void SQLexer::Next()
+{
+	SQInteger t = _readf(_up);
+	if(t > MAX_CHAR) Error(_SC("Invalid character"));
+	if(t != 0) {
+		_currdata = (LexChar)t;
+		return;
+	}
+	_currdata = SQUIRREL_EOB;
+}
+
+const SQChar *SQLexer::Tok2Str(SQInteger tok)
+{
+	SQObjectPtr itr, key, val;
+	SQInteger nitr;
+	while((nitr = _keywords->Next(false,itr, key, val)) != -1) {
+		itr = (SQInteger)nitr;
+		if(((SQInteger)_integer(val)) == tok)
+			return _stringval(key);
+	}
+	return NULL;
+}
+
+void SQLexer::LexBlockComment()
+{
+	bool done = false;
+	while(!done) {
+		switch(CUR_CHAR) {
+			case _SC('*'): { NEXT(); if(CUR_CHAR == _SC('/')) { done = true; NEXT(); }}; continue;
+			case _SC('\n'): _currentline++; NEXT(); continue;
+			case SQUIRREL_EOB: Error(_SC("missing \"*/\" in comment"));
+			default: NEXT();
+		}
+	}
+}
+
+SQInteger SQLexer::Lex()
+{
+	_lasttokenline = _currentline;
+	while(CUR_CHAR != SQUIRREL_EOB) {
+		switch(CUR_CHAR){
+		case _SC('\t'): case _SC('\r'): case _SC(' '): NEXT(); continue;
+		case _SC('\n'):
+			_currentline++;
+			_prevtoken=_curtoken;
+			_curtoken=_SC('\n');
+			NEXT();
+			_currentcolumn=1;
+			continue;
+		case _SC('/'):
+			NEXT();
+			switch(CUR_CHAR){
+			case _SC('*'):
+				NEXT();
+				LexBlockComment();
+				continue;	
+			case _SC('/'):
+				do { NEXT(); } while (CUR_CHAR != _SC('\n') && (!IS_EOB()));
+				continue;
+			case _SC('='):
+				NEXT();
+				RETURN_TOKEN(TK_DIVEQ);
+				continue;
+			case _SC('>'):
+				NEXT();
+				RETURN_TOKEN(TK_ATTR_CLOSE);
+				continue;
+			default:
+				RETURN_TOKEN('/');
+			}
+		case _SC('='):
+			NEXT();
+			if (CUR_CHAR != _SC('=')){ RETURN_TOKEN('=') }
+			else { NEXT(); RETURN_TOKEN(TK_EQ); }
+		case _SC('<'):
+			NEXT();
+			if ( CUR_CHAR == _SC('=') ) { NEXT(); RETURN_TOKEN(TK_LE) }
+			else if ( CUR_CHAR == _SC('-') ) { NEXT(); RETURN_TOKEN(TK_NEWSLOT); }
+			else if ( CUR_CHAR == _SC('<') ) { NEXT(); RETURN_TOKEN(TK_SHIFTL); }
+			else if ( CUR_CHAR == _SC('/') ) { NEXT(); RETURN_TOKEN(TK_ATTR_OPEN); }
+			//else if ( CUR_CHAR == _SC('[') ) { NEXT(); ReadMultilineString(); RETURN_TOKEN(TK_STRING_LITERAL); }
+			else { RETURN_TOKEN('<') }
+		case _SC('>'):
+			NEXT();
+			if (CUR_CHAR == _SC('=')){ NEXT(); RETURN_TOKEN(TK_GE);}
+			else if(CUR_CHAR == _SC('>')){ 
+				NEXT(); 
+				if(CUR_CHAR == _SC('>')){
+					NEXT();
+					RETURN_TOKEN(TK_USHIFTR);
+				}
+				RETURN_TOKEN(TK_SHIFTR);
+			}
+			else { RETURN_TOKEN('>') }
+		case _SC('!'):
+			NEXT();
+			if (CUR_CHAR != _SC('=')){ RETURN_TOKEN('!')}
+			else { NEXT(); RETURN_TOKEN(TK_NE); }
+		case _SC('@'): {
+			SQInteger stype;
+			NEXT(); 
+			if(CUR_CHAR != _SC('"'))
+				Error(_SC("string expected"));
+			if((stype=ReadString('"',true))!=-1) {
+				RETURN_TOKEN(stype);
+			}
+			Error(_SC("error parsing the string"));
+					   }
+		case _SC('"'):
+		case _SC('\''): {
+			SQInteger stype;
+			if((stype=ReadString(CUR_CHAR,false))!=-1){
+				RETURN_TOKEN(stype);
+			}
+			Error(_SC("error parsing the string"));
+			}
+		case _SC('{'): case _SC('}'): case _SC('('): case _SC(')'): case _SC('['): case _SC(']'):
+		case _SC(';'): case _SC(','): case _SC('?'): case _SC('^'): case _SC('~'):
+			{SQInteger ret = CUR_CHAR;
+			NEXT(); RETURN_TOKEN(ret); }
+		case _SC('.'):
+			NEXT();
+			if (CUR_CHAR != _SC('.')){ RETURN_TOKEN('.') }
+			NEXT();
+			if (CUR_CHAR != _SC('.')){ Error(_SC("invalid token '..'")); }
+			NEXT();
+			RETURN_TOKEN(TK_VARPARAMS);
+		case _SC('&'):
+			NEXT();
+			if (CUR_CHAR != _SC('&')){ RETURN_TOKEN('&') }
+			else { NEXT(); RETURN_TOKEN(TK_AND); }
+		case _SC('|'):
+			NEXT();
+			if (CUR_CHAR != _SC('|')){ RETURN_TOKEN('|') }
+			else { NEXT(); RETURN_TOKEN(TK_OR); }
+		case _SC(':'):
+			NEXT();
+			if (CUR_CHAR != _SC(':')){ RETURN_TOKEN(':') }
+			else { NEXT(); RETURN_TOKEN(TK_DOUBLE_COLON); }
+		case _SC('*'):
+			NEXT();
+			if (CUR_CHAR == _SC('=')){ NEXT(); RETURN_TOKEN(TK_MULEQ);}
+			else RETURN_TOKEN('*');
+		case _SC('%'):
+			NEXT();
+			if (CUR_CHAR == _SC('=')){ NEXT(); RETURN_TOKEN(TK_MODEQ);}
+			else RETURN_TOKEN('%');
+		case _SC('-'):
+			NEXT();
+			if (CUR_CHAR == _SC('=')){ NEXT(); RETURN_TOKEN(TK_MINUSEQ);}
+			else if  (CUR_CHAR == _SC('-')){ NEXT(); RETURN_TOKEN(TK_MINUSMINUS);}
+			else RETURN_TOKEN('-');
+		case _SC('+'):
+			NEXT();
+			if (CUR_CHAR == _SC('=')){ NEXT(); RETURN_TOKEN(TK_PLUSEQ);}
+			else if (CUR_CHAR == _SC('+')){ NEXT(); RETURN_TOKEN(TK_PLUSPLUS);}
+			else RETURN_TOKEN('+');
+		case SQUIRREL_EOB:
+			return 0;
+		default:{
+				if (scisdigit(CUR_CHAR)) {
+					SQInteger ret = ReadNumber();
+					RETURN_TOKEN(ret);
+				}
+				else if (scisalpha(CUR_CHAR) || CUR_CHAR == _SC('_')) {
+					SQInteger t = ReadID();
+					RETURN_TOKEN(t);
+				}
+				else {
+					SQInteger c = CUR_CHAR;
+					if (sciscntrl((int)c)) Error(_SC("unexpected character(control)"));
+					NEXT();
+					RETURN_TOKEN(c);  
+				}
+				RETURN_TOKEN(0);
+			}
+		}
+	}
+	return 0;    
+}
+	
+SQInteger SQLexer::GetIDType(SQChar *s)
+{
+	SQObjectPtr t;
+	if(_keywords->Get(SQString::Create(_sharedstate, s), t)) {
+		return SQInteger(_integer(t));
+	}
+	return TK_IDENTIFIER;
+}
+
+
+SQInteger SQLexer::ReadString(SQInteger ndelim,bool verbatim)
+{
+	INIT_TEMP_STRING();
+	NEXT();
+	if(IS_EOB()) return -1;
+	for(;;) {
+		while(CUR_CHAR != ndelim) {
+			switch(CUR_CHAR) {
+			case SQUIRREL_EOB:
+				Error(_SC("unfinished string"));
+				return -1;
+			case _SC('\n'): 
+				if(!verbatim) Error(_SC("newline in a constant")); 
+				APPEND_CHAR(CUR_CHAR); NEXT(); 
+				_currentline++;
+				break;
+			case _SC('\\'):
+				if(verbatim) {
+					APPEND_CHAR('\\'); NEXT(); 
+				}
+				else {
+					NEXT();
+					switch(CUR_CHAR) {
+					case _SC('x'): NEXT(); {
+						if(!isxdigit(CUR_CHAR)) Error(_SC("hexadecimal number expected")); 
+						const SQInteger maxdigits = 4;
+						SQChar temp[maxdigits+1];
+						SQInteger n = 0;
+						while(isxdigit(CUR_CHAR) && n < maxdigits) {
+							temp[n] = CUR_CHAR;
+							n++;
+							NEXT();
+						}
+						temp[n] = 0;
+						SQChar *sTemp;
+						APPEND_CHAR((SQChar)scstrtoul(temp,&sTemp,16));
+					}
+				    break;
+					case _SC('t'): APPEND_CHAR(_SC('\t')); NEXT(); break;
+					case _SC('a'): APPEND_CHAR(_SC('\a')); NEXT(); break;
+					case _SC('b'): APPEND_CHAR(_SC('\b')); NEXT(); break;
+					case _SC('n'): APPEND_CHAR(_SC('\n')); NEXT(); break;
+					case _SC('r'): APPEND_CHAR(_SC('\r')); NEXT(); break;
+					case _SC('v'): APPEND_CHAR(_SC('\v')); NEXT(); break;
+					case _SC('f'): APPEND_CHAR(_SC('\f')); NEXT(); break;
+					case _SC('0'): APPEND_CHAR(_SC('\0')); NEXT(); break;
+					case _SC('\\'): APPEND_CHAR(_SC('\\')); NEXT(); break;
+					case _SC('"'): APPEND_CHAR(_SC('"')); NEXT(); break;
+					case _SC('\''): APPEND_CHAR(_SC('\'')); NEXT(); break;
+					default:
+						Error(_SC("unrecognised escaper char"));
+					break;
+					}
+				}
+				break;
+			default:
+				APPEND_CHAR(CUR_CHAR);
+				NEXT();
+			}
+		}
+		NEXT();
+		if(verbatim && CUR_CHAR == '"') { //double quotation
+			APPEND_CHAR(CUR_CHAR);
+			NEXT();
+		}
+		else {
+			break;
+		}
+	}
+	TERMINATE_BUFFER();
+	SQInteger len = _longstr.size()-1;
+	if(ndelim == _SC('\'')) {
+		if(len == 0) Error(_SC("empty constant"));
+		if(len > 1) Error(_SC("constant too long"));
+		_nvalue = _longstr[0];
+		return TK_INTEGER;
+	}
+	_svalue = &_longstr[0];
+	return TK_STRING_LITERAL;
+}
+
+void LexHexadecimal(const SQChar *s,SQUnsignedInteger *res)
+{
+	*res = 0;
+	while(*s != 0)
+	{
+		if(scisdigit(*s)) *res = (*res)*16+((*s++)-'0');
+		else if(scisxdigit(*s)) *res = (*res)*16+(toupper(*s++)-'A'+10);
+		else { assert(0); }
+	}
+}
+
+void LexInteger(const SQChar *s,SQUnsignedInteger *res)
+{
+	*res = 0;
+	while(*s != 0)
+	{
+		*res = (*res)*10+((*s++)-'0');
+	}
+}
+
+SQInteger scisodigit(SQInteger c) { return c >= _SC('0') && c <= _SC('7'); }
+
+void LexOctal(const SQChar *s,SQUnsignedInteger *res)
+{
+	*res = 0;
+	while(*s != 0)
+	{
+		if(scisodigit(*s)) *res = (*res)*8+((*s++)-'0');
+		else { assert(0); }
+	}
+}
+
+SQInteger isexponent(SQInteger c) { return c == 'e' || c=='E'; }
+
+
+#define MAX_HEX_DIGITS (sizeof(SQInteger)*2)
+SQInteger SQLexer::ReadNumber()
+{
+#define TINT 1
+#define TFLOAT 2
+#define THEX 3
+#define TSCIENTIFIC 4
+#define TOCTAL 5
+	SQInteger type = TINT, firstchar = CUR_CHAR;
+	SQChar *sTemp;
+	INIT_TEMP_STRING();
+	NEXT();
+	if(firstchar == _SC('0') && (toupper(CUR_CHAR) == _SC('X') || scisodigit(CUR_CHAR)) ) {
+		if(scisodigit(CUR_CHAR)) {
+			type = TOCTAL;
+			while(scisodigit(CUR_CHAR)) {
+				APPEND_CHAR(CUR_CHAR);
+				NEXT();
+			}
+			if(scisdigit(CUR_CHAR)) Error(_SC("invalid octal number"));
+		}
+		else {
+			NEXT();
+			type = THEX;
+			while(isxdigit(CUR_CHAR)) {
+				APPEND_CHAR(CUR_CHAR);
+				NEXT();
+			}
+			if(_longstr.size() > MAX_HEX_DIGITS) Error(_SC("too many digits for an Hex number"));
+		}
+	}
+	else {
+		APPEND_CHAR((int)firstchar);
+		while (CUR_CHAR == _SC('.') || scisdigit(CUR_CHAR) || isexponent(CUR_CHAR)) {
+            if(CUR_CHAR == _SC('.')) type = TFLOAT;
+			if(isexponent(CUR_CHAR)) {
+				if(type != TFLOAT) Error(_SC("invalid numeric format"));
+				type = TSCIENTIFIC;
+				APPEND_CHAR(CUR_CHAR);
+				NEXT();
+				if(CUR_CHAR == '+' || CUR_CHAR == '-'){
+					APPEND_CHAR(CUR_CHAR);
+					NEXT();
+				}
+				if(!scisdigit(CUR_CHAR)) Error(_SC("exponent expected"));
+			}
+			
+			APPEND_CHAR(CUR_CHAR);
+			NEXT();
+		}
+	}
+	TERMINATE_BUFFER();
+	switch(type) {
+	case TSCIENTIFIC:
+	case TFLOAT:
+		_fvalue = (SQFloat)scstrtod(&_longstr[0],&sTemp);
+		return TK_FLOAT;
+	case TINT:
+		LexInteger(&_longstr[0],(SQUnsignedInteger *)&_nvalue);
+		return TK_INTEGER;
+	case THEX:
+		LexHexadecimal(&_longstr[0],(SQUnsignedInteger *)&_nvalue);
+		return TK_INTEGER;
+	case TOCTAL:
+		LexOctal(&_longstr[0],(SQUnsignedInteger *)&_nvalue);
+		return TK_INTEGER;
+	}
+	return 0;
+}
+
+SQInteger SQLexer::ReadID()
+{
+	SQInteger res;
+	INIT_TEMP_STRING();
+	do {
+		APPEND_CHAR(CUR_CHAR);
+		NEXT();
+	} while(scisalnum(CUR_CHAR) || CUR_CHAR == _SC('_'));
+	TERMINATE_BUFFER();
+	res = GetIDType(&_longstr[0]);
+	if(res == TK_IDENTIFIER || res == TK_CONSTRUCTOR) {
+		_svalue = &_longstr[0];
+	}
+	return res;
+}

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqlexer.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqlexer.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqlexer.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,45 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQLEXER_H_
+#define _SQLEXER_H_
+
+#ifdef SQUNICODE
+typedef SQChar LexChar;
+#else
+typedef	unsigned char LexChar;
+#endif
+
+struct SQLexer
+{
+	SQLexer();
+	~SQLexer();
+	void Init(SQSharedState *ss,SQLEXREADFUNC rg,SQUserPointer up,CompilerErrorFunc efunc,void *ed);
+	void Error(const SQChar *err);
+	SQInteger Lex();
+	const SQChar *Tok2Str(SQInteger tok);
+private:
+	SQInteger GetIDType(SQChar *s);
+	SQInteger ReadString(SQInteger ndelim,bool verbatim);
+	SQInteger ReadNumber();
+	void LexBlockComment();
+	SQInteger ReadID();
+	void Next();
+	SQInteger _curtoken;
+	SQTable *_keywords;
+public:
+	SQInteger _prevtoken;
+	SQInteger _currentline;
+	SQInteger _lasttokenline;
+	SQInteger _currentcolumn;
+	const SQChar *_svalue;
+	SQInteger _nvalue;
+	SQFloat _fvalue;
+	SQLEXREADFUNC _readf;
+	SQUserPointer _up;
+	LexChar _currdata;
+	SQSharedState *_sharedstate;
+	sqvector<SQChar> _longstr;
+	CompilerErrorFunc _errfunc;
+	void *_errtarget;
+};
+
+#endif

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqmem.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqmem.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqmem.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,9 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+void *sq_vm_malloc(SQUnsignedInteger size){	return malloc(size); }
+
+void *sq_vm_realloc(void *p, SQUnsignedInteger oldsize, SQUnsignedInteger size){ return realloc(p, size); }
+
+void sq_vm_free(void *p, SQUnsignedInteger size){	free(p); }

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqobject.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqobject.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqobject.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,586 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include "sqvm.h"
+#include "sqstring.h"
+#include "sqarray.h"
+#include "sqtable.h"
+#include "squserdata.h"
+#include "sqfuncproto.h"
+#include "sqclass.h"
+#include "sqclosure.h"
+
+
+const SQChar *IdType2Name(SQObjectType type)
+{
+	switch(_RAW_TYPE(type))
+	{
+	case _RT_NULL:return _SC("null");
+	case _RT_INTEGER:return _SC("integer");
+	case _RT_FLOAT:return _SC("float");
+	case _RT_BOOL:return _SC("bool");
+	case _RT_STRING:return _SC("string");
+	case _RT_TABLE:return _SC("table");
+	case _RT_ARRAY:return _SC("array");
+	case _RT_GENERATOR:return _SC("generator");
+	case _RT_CLOSURE:
+	case _RT_NATIVECLOSURE:
+		return _SC("function");
+	case _RT_USERDATA:
+	case _RT_USERPOINTER:
+		return _SC("userdata");
+	case _RT_THREAD: return _SC("thread");
+	case _RT_FUNCPROTO: return _SC("function");
+	case _RT_CLASS: return _SC("class");
+	case _RT_INSTANCE: return _SC("instance");
+	case _RT_WEAKREF: return _SC("weakref");
+	default:
+		return NULL;
+	}
+}
+
+const SQChar *GetTypeName(const SQObjectPtr &obj1)
+{
+	return IdType2Name(type(obj1));	
+}
+
+SQString *SQString::Create(SQSharedState *ss,const SQChar *s,SQInteger len)
+{
+	SQString *str=ADD_STRING(ss,s,len);
+	str->_sharedstate=ss;
+	return str;
+}
+
+void SQString::Release()
+{
+	REMOVE_STRING(_sharedstate,this);
+}
+
+SQInteger SQString::Next(const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval)
+{
+	SQInteger idx = (SQInteger)TranslateIndex(refpos);
+	while(idx < _len){
+		outkey = (SQInteger)idx;
+		outval = SQInteger(_val[idx]);
+		//return idx for the next iteration
+		return ++idx;
+	}
+	//nothing to iterate anymore
+	return -1;
+}
+
+SQUnsignedInteger TranslateIndex(const SQObjectPtr &idx)
+{
+	switch(type(idx)){
+		case OT_NULL:
+			return 0;
+		case OT_INTEGER:
+			return (SQUnsignedInteger)_integer(idx);
+		default: assert(0); break;
+	}
+	return 0;
+}
+
+SQWeakRef *SQRefCounted::GetWeakRef(SQObjectType type)
+{
+	if(!_weakref) {
+		sq_new(_weakref,SQWeakRef);
+		_weakref->_obj._type = type;
+		_weakref->_obj._unVal.pRefCounted = this;
+	}
+	return _weakref;
+}
+
+SQRefCounted::~SQRefCounted()
+{
+	if(_weakref) {
+		_weakref->_obj._type = OT_NULL;
+		_weakref->_obj._unVal.pRefCounted = NULL;
+	}
+}
+
+void SQWeakRef::Release() { 
+	if(ISREFCOUNTED(_obj._type)) { 
+		_obj._unVal.pRefCounted->_weakref = NULL;
+	} 
+	sq_delete(this,SQWeakRef);
+}
+
+bool SQDelegable::GetMetaMethod(SQVM *v,SQMetaMethod mm,SQObjectPtr &res) {
+	if(_delegate) {
+		return _delegate->Get((*_ss(v)->_metamethods)[mm],res);
+	}
+	return false;
+}
+
+bool SQDelegable::SetDelegate(SQTable *mt)
+{
+	SQTable *temp = mt;
+	while (temp) {
+		if (temp->_delegate == this) return false; //cycle detected
+		temp = temp->_delegate;
+	}
+	if (mt)	__ObjAddRef(mt);
+	__ObjRelease(_delegate);
+	_delegate = mt;
+	return true;
+}
+
+bool SQGenerator::Yield(SQVM *v)
+{
+	if(_state==eSuspended) { v->Raise_Error(_SC("internal vm error, yielding dead generator"));  return false;}
+	if(_state==eDead) { v->Raise_Error(_SC("internal vm error, yielding a dead generator")); return false; }
+	SQInteger size = v->_top-v->_stackbase;
+	_ci=*v->ci;
+	_stack.resize(size);
+	for(SQInteger n =0; n<size; n++) {
+		_stack._vals[n] = v->_stack[v->_stackbase+n];
+		v->_stack[v->_stackbase+n] = _null_;
+	}
+	SQInteger nvargs = v->ci->_vargs.size;
+	SQInteger vargsbase = v->ci->_vargs.base;
+	for(SQInteger j = nvargs - 1; j >= 0; j--) {
+		_vargsstack.push_back(v->_vargsstack[vargsbase+j]);
+	}
+	_ci._generator=NULL;
+	for(SQInteger i=0;i<_ci._etraps;i++) {
+		_etraps.push_back(v->_etraps.top());
+		v->_etraps.pop_back();
+	}
+	_state=eSuspended;
+	return true;
+}
+
+bool SQGenerator::Resume(SQVM *v,SQInteger target)
+{
+	SQInteger size=_stack.size();
+	if(_state==eDead){ v->Raise_Error(_SC("resuming dead generator")); return false; }
+	if(_state==eRunning){ v->Raise_Error(_SC("resuming active generator")); return false; }
+	SQInteger prevtop=v->_top-v->_stackbase;
+	PUSH_CALLINFO(v,_ci);
+	SQInteger oldstackbase=v->_stackbase;
+	v->_stackbase = v->_top;
+	v->ci->_target = (SQInt32)target;
+	v->ci->_generator = this;
+	v->ci->_vargs.size = (unsigned short)_vargsstack.size();
+	
+	for(SQInteger i=0;i<_ci._etraps;i++) {
+		v->_etraps.push_back(_etraps.top());
+		_etraps.pop_back();
+	}
+	for(SQInteger n =0; n<size; n++) {
+		v->_stack[v->_stackbase+n] = _stack._vals[n];
+		_stack._vals[0] = _null_;
+	}
+	while(_vargsstack.size()) {
+		v->_vargsstack.push_back(_vargsstack.back());
+		_vargsstack.pop_back();
+	}
+	v->ci->_vargs.base = (unsigned short)(v->_vargsstack.size() - v->ci->_vargs.size);
+	v->_top=v->_stackbase+size;
+	v->ci->_prevtop = (SQInt32)prevtop;
+	v->ci->_prevstkbase = (SQInt32)(v->_stackbase - oldstackbase);
+	_state=eRunning;
+	if (type(v->_debughook) != OT_NULL && _rawval(v->_debughook) != _rawval(v->ci->_closure))
+		v->CallDebugHook(_SC('c'));
+
+	return true;
+}
+
+void SQArray::Extend(const SQArray *a){
+	SQInteger xlen;
+	if((xlen=a->Size()))
+		for(SQInteger i=0;i<xlen;i++)
+			Append(a->_values[i]);
+}
+
+const SQChar* SQFunctionProto::GetLocal(SQVM *vm,SQUnsignedInteger stackbase,SQUnsignedInteger nseq,SQUnsignedInteger nop)
+{
+	SQUnsignedInteger nvars=_nlocalvarinfos;
+	const SQChar *res=NULL; 
+	if(nvars>=nseq){
+ 		for(SQUnsignedInteger i=0;i<nvars;i++){
+			if(_localvarinfos[i]._start_op<=nop && _localvarinfos[i]._end_op>=nop)
+			{
+				if(nseq==0){
+					vm->Push(vm->_stack[stackbase+_localvarinfos[i]._pos]);
+					res=_stringval(_localvarinfos[i]._name);
+					break;
+				}
+				nseq--;
+			}
+		}
+	}
+	return res;
+}
+
+SQInteger SQFunctionProto::GetLine(SQInstruction *curr)
+{
+	SQInteger op = (SQInteger)(curr-_instructions);
+	SQInteger line=_lineinfos[0]._line;
+	for(SQInteger i=1;i<_nlineinfos;i++){
+		if(_lineinfos[i]._op>=op)
+			return line;
+		line=_lineinfos[i]._line;
+	}
+	return line;
+}
+
+#define _CHECK_IO(exp)  { if(!exp)return false; }
+bool SafeWrite(HSQUIRRELVM v,SQWRITEFUNC write,SQUserPointer up,SQUserPointer dest,SQInteger size)
+{
+	if(write(up,dest,size) != size) {
+		v->Raise_Error(_SC("io error (write function failure)"));
+		return false;
+	}
+	return true;
+}
+
+bool SafeRead(HSQUIRRELVM v,SQWRITEFUNC read,SQUserPointer up,SQUserPointer dest,SQInteger size)
+{
+	if(size && read(up,dest,size) != size) {
+		v->Raise_Error(_SC("io error, read function failure, the origin stream could be corrupted/trucated"));
+		return false;
+	}
+	return true;
+}
+
+bool WriteTag(HSQUIRRELVM v,SQWRITEFUNC write,SQUserPointer up,SQInteger tag)
+{
+	return SafeWrite(v,write,up,&tag,sizeof(tag));
+}
+
+bool CheckTag(HSQUIRRELVM v,SQWRITEFUNC read,SQUserPointer up,SQInteger tag)
+{
+	SQInteger t;
+	_CHECK_IO(SafeRead(v,read,up,&t,sizeof(t)));
+	if(t != tag){
+		v->Raise_Error(_SC("invalid or corrupted closure stream"));
+		return false;
+	}
+	return true;
+}
+
+bool WriteObject(HSQUIRRELVM v,SQUserPointer up,SQWRITEFUNC write,SQObjectPtr &o)
+{
+	_CHECK_IO(SafeWrite(v,write,up,&type(o),sizeof(SQObjectType)));
+	switch(type(o)){
+	case OT_STRING:
+		_CHECK_IO(SafeWrite(v,write,up,&_string(o)->_len,sizeof(SQInteger)));
+		_CHECK_IO(SafeWrite(v,write,up,_stringval(o),rsl(_string(o)->_len)));
+		break;
+	case OT_INTEGER:
+		_CHECK_IO(SafeWrite(v,write,up,&_integer(o),sizeof(SQInteger)));break;
+	case OT_FLOAT:
+		_CHECK_IO(SafeWrite(v,write,up,&_float(o),sizeof(SQFloat)));break;
+	case OT_NULL:
+		break;
+	default:
+		v->Raise_Error(_SC("cannot serialize a %s"),GetTypeName(o));
+		return false;
+	}
+	return true;
+}
+
+bool ReadObject(HSQUIRRELVM v,SQUserPointer up,SQREADFUNC read,SQObjectPtr &o)
+{
+	SQObjectType t;
+	_CHECK_IO(SafeRead(v,read,up,&t,sizeof(SQObjectType)));
+	switch(t){
+	case OT_STRING:{
+		SQInteger len;
+		_CHECK_IO(SafeRead(v,read,up,&len,sizeof(SQInteger)));
+		_CHECK_IO(SafeRead(v,read,up,_ss(v)->GetScratchPad(rsl(len)),rsl(len)));
+		o=SQString::Create(_ss(v),_ss(v)->GetScratchPad(-1),len);
+				   }
+		break;
+	case OT_INTEGER:{
+		SQInteger i;
+		_CHECK_IO(SafeRead(v,read,up,&i,sizeof(SQInteger))); o = i; break;
+					}
+	case OT_FLOAT:{
+		SQFloat f;
+		_CHECK_IO(SafeRead(v,read,up,&f,sizeof(SQFloat))); o = f; break;
+				  }
+	case OT_NULL:
+		o=_null_;
+		break;
+	default:
+		v->Raise_Error(_SC("cannot serialize a %s"),IdType2Name(t));
+		return false;
+	}
+	return true;
+}
+
+bool SQClosure::Save(SQVM *v,SQUserPointer up,SQWRITEFUNC write)
+{
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_HEAD));
+	_CHECK_IO(WriteTag(v,write,up,sizeof(SQChar)));
+	_CHECK_IO(_funcproto(_function)->Save(v,up,write));
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_TAIL));
+	return true;
+}
+
+bool SQClosure::Load(SQVM *v,SQUserPointer up,SQREADFUNC read,SQObjectPtr &ret)
+{
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_HEAD));
+	_CHECK_IO(CheckTag(v,read,up,sizeof(SQChar)));
+	SQObjectPtr func;
+	_CHECK_IO(SQFunctionProto::Load(v,up,read,func));
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_TAIL));
+	ret = SQClosure::Create(_ss(v),_funcproto(func));
+	return true;
+}
+
+bool SQFunctionProto::Save(SQVM *v,SQUserPointer up,SQWRITEFUNC write)
+{
+	SQInteger i,nliterals = _nliterals,nparameters = _nparameters;
+	SQInteger noutervalues = _noutervalues,nlocalvarinfos = _nlocalvarinfos;
+	SQInteger nlineinfos=_nlineinfos,ninstructions = _ninstructions,nfunctions=_nfunctions;
+	SQInteger ndefaultparams = _ndefaultparams;
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(WriteObject(v,up,write,_sourcename));
+	_CHECK_IO(WriteObject(v,up,write,_name));
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeWrite(v,write,up,&nliterals,sizeof(nliterals)));
+	_CHECK_IO(SafeWrite(v,write,up,&nparameters,sizeof(nparameters)));
+	_CHECK_IO(SafeWrite(v,write,up,&noutervalues,sizeof(noutervalues)));
+	_CHECK_IO(SafeWrite(v,write,up,&nlocalvarinfos,sizeof(nlocalvarinfos)));
+	_CHECK_IO(SafeWrite(v,write,up,&nlineinfos,sizeof(nlineinfos)));
+	_CHECK_IO(SafeWrite(v,write,up,&ndefaultparams,sizeof(ndefaultparams)));
+	_CHECK_IO(SafeWrite(v,write,up,&ninstructions,sizeof(ninstructions)));
+	_CHECK_IO(SafeWrite(v,write,up,&nfunctions,sizeof(nfunctions)));
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	for(i=0;i<nliterals;i++){
+		_CHECK_IO(WriteObject(v,up,write,_literals[i]));
+	}
+
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	for(i=0;i<nparameters;i++){
+		_CHECK_IO(WriteObject(v,up,write,_parameters[i]));
+	}
+
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	for(i=0;i<noutervalues;i++){
+		_CHECK_IO(SafeWrite(v,write,up,&_outervalues[i]._type,sizeof(SQUnsignedInteger)));
+		_CHECK_IO(WriteObject(v,up,write,_outervalues[i]._src));
+		_CHECK_IO(WriteObject(v,up,write,_outervalues[i]._name));
+	}
+
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	for(i=0;i<nlocalvarinfos;i++){
+		SQLocalVarInfo &lvi=_localvarinfos[i];
+		_CHECK_IO(WriteObject(v,up,write,lvi._name));
+		_CHECK_IO(SafeWrite(v,write,up,&lvi._pos,sizeof(SQUnsignedInteger)));
+		_CHECK_IO(SafeWrite(v,write,up,&lvi._start_op,sizeof(SQUnsignedInteger)));
+		_CHECK_IO(SafeWrite(v,write,up,&lvi._end_op,sizeof(SQUnsignedInteger)));
+	}
+
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeWrite(v,write,up,_lineinfos,sizeof(SQLineInfo)*nlineinfos));
+
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeWrite(v,write,up,_defaultparams,sizeof(SQInteger)*ndefaultparams));
+
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeWrite(v,write,up,_instructions,sizeof(SQInstruction)*ninstructions));
+
+	_CHECK_IO(WriteTag(v,write,up,SQ_CLOSURESTREAM_PART));
+	for(i=0;i<nfunctions;i++){
+		_CHECK_IO(_funcproto(_functions[i])->Save(v,up,write));
+	}
+	_CHECK_IO(SafeWrite(v,write,up,&_stacksize,sizeof(_stacksize)));
+	_CHECK_IO(SafeWrite(v,write,up,&_bgenerator,sizeof(_bgenerator)));
+	_CHECK_IO(SafeWrite(v,write,up,&_varparams,sizeof(_varparams)));
+	return true;
+}
+
+bool SQFunctionProto::Load(SQVM *v,SQUserPointer up,SQREADFUNC read,SQObjectPtr &ret)
+{
+	SQInteger i, nliterals,nparameters;
+	SQInteger noutervalues ,nlocalvarinfos ;
+	SQInteger nlineinfos,ninstructions ,nfunctions,ndefaultparams ;
+	SQObjectPtr sourcename, name;
+	SQObjectPtr o;
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(ReadObject(v, up, read, sourcename));
+	_CHECK_IO(ReadObject(v, up, read, name));
+	
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeRead(v,read,up, &nliterals, sizeof(nliterals)));
+	_CHECK_IO(SafeRead(v,read,up, &nparameters, sizeof(nparameters)));
+	_CHECK_IO(SafeRead(v,read,up, &noutervalues, sizeof(noutervalues)));
+	_CHECK_IO(SafeRead(v,read,up, &nlocalvarinfos, sizeof(nlocalvarinfos)));
+	_CHECK_IO(SafeRead(v,read,up, &nlineinfos, sizeof(nlineinfos)));
+	_CHECK_IO(SafeRead(v,read,up, &ndefaultparams, sizeof(ndefaultparams)));
+	_CHECK_IO(SafeRead(v,read,up, &ninstructions, sizeof(ninstructions)));
+	_CHECK_IO(SafeRead(v,read,up, &nfunctions, sizeof(nfunctions)));
+	
+
+	SQFunctionProto *f = SQFunctionProto::Create(ninstructions,nliterals,nparameters,
+			nfunctions,noutervalues,nlineinfos,nlocalvarinfos,ndefaultparams);
+	SQObjectPtr proto = f; //gets a ref in case of failure
+	f->_sourcename = sourcename;
+	f->_name = name;
+
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+
+	for(i = 0;i < nliterals; i++){
+		_CHECK_IO(ReadObject(v, up, read, o));
+		f->_literals[i] = o;
+	}
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+
+	for(i = 0; i < nparameters; i++){
+		_CHECK_IO(ReadObject(v, up, read, o));
+		f->_parameters[i] = o;
+	}
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+
+	for(i = 0; i < noutervalues; i++){
+		SQUnsignedInteger type;
+		SQObjectPtr name;
+		_CHECK_IO(SafeRead(v,read,up, &type, sizeof(SQUnsignedInteger)));
+		_CHECK_IO(ReadObject(v, up, read, o));
+		_CHECK_IO(ReadObject(v, up, read, name));
+		f->_outervalues[i] = SQOuterVar(name,o, (SQOuterType)type);
+	}
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+
+	for(i = 0; i < nlocalvarinfos; i++){
+		SQLocalVarInfo lvi;
+		_CHECK_IO(ReadObject(v, up, read, lvi._name));
+		_CHECK_IO(SafeRead(v,read,up, &lvi._pos, sizeof(SQUnsignedInteger)));
+		_CHECK_IO(SafeRead(v,read,up, &lvi._start_op, sizeof(SQUnsignedInteger)));
+		_CHECK_IO(SafeRead(v,read,up, &lvi._end_op, sizeof(SQUnsignedInteger)));
+		f->_localvarinfos[i] = lvi;
+	}
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeRead(v,read,up, f->_lineinfos, sizeof(SQLineInfo)*nlineinfos));
+
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeRead(v,read,up, f->_defaultparams, sizeof(SQInteger)*ndefaultparams));
+
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+	_CHECK_IO(SafeRead(v,read,up, f->_instructions, sizeof(SQInstruction)*ninstructions));
+
+	_CHECK_IO(CheckTag(v,read,up,SQ_CLOSURESTREAM_PART));
+	for(i = 0; i < nfunctions; i++){
+		_CHECK_IO(_funcproto(o)->Load(v, up, read, o));
+		f->_functions[i] = o;
+	}
+	_CHECK_IO(SafeRead(v,read,up, &f->_stacksize, sizeof(f->_stacksize)));
+	_CHECK_IO(SafeRead(v,read,up, &f->_bgenerator, sizeof(f->_bgenerator)));
+	_CHECK_IO(SafeRead(v,read,up, &f->_varparams, sizeof(f->_varparams)));
+	
+	ret = f;
+	return true;
+}
+
+#ifndef NO_GARBAGE_COLLECTOR
+
+#define START_MARK() 	if(!(_uiRef&MARK_FLAG)){ \
+		_uiRef|=MARK_FLAG;
+
+#define END_MARK() RemoveFromChain(&_sharedstate->_gc_chain, this); \
+		AddToChain(chain, this); }
+
+void SQVM::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		SQSharedState::MarkObject(_lasterror,chain);
+		SQSharedState::MarkObject(_errorhandler,chain);
+		SQSharedState::MarkObject(_debughook,chain);
+		SQSharedState::MarkObject(_roottable, chain);
+		SQSharedState::MarkObject(temp_reg, chain);
+		for(SQUnsignedInteger i = 0; i < _stack.size(); i++) SQSharedState::MarkObject(_stack[i], chain);
+		for(SQUnsignedInteger j = 0; j < _vargsstack.size(); j++) SQSharedState::MarkObject(_vargsstack[j], chain);
+		for(SQInteger k = 0; k < _callsstacksize; k++) SQSharedState::MarkObject(_callsstack[k]._closure, chain);
+	END_MARK()
+}
+
+void SQArray::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		SQInteger len = _values.size();
+		for(SQInteger i = 0;i < len; i++) SQSharedState::MarkObject(_values[i], chain);
+	END_MARK()
+}
+void SQTable::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		if(_delegate) _delegate->Mark(chain);
+		SQInteger len = _numofnodes;
+		for(SQInteger i = 0; i < len; i++){
+			SQSharedState::MarkObject(_nodes[i].key, chain);
+			SQSharedState::MarkObject(_nodes[i].val, chain);
+		}
+	END_MARK()
+}
+
+void SQClass::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		_members->Mark(chain);
+		if(_base) _base->Mark(chain);
+		SQSharedState::MarkObject(_attributes, chain);
+		for(SQUnsignedInteger i =0; i< _defaultvalues.size(); i++) {
+			SQSharedState::MarkObject(_defaultvalues[i].val, chain);
+			SQSharedState::MarkObject(_defaultvalues[i].attrs, chain);
+		}
+		for(SQUnsignedInteger j =0; j< _methods.size(); j++) {
+			SQSharedState::MarkObject(_methods[j].val, chain);
+			SQSharedState::MarkObject(_methods[j].attrs, chain);
+		}
+		for(SQUnsignedInteger k =0; k< _metamethods.size(); k++) {
+			SQSharedState::MarkObject(_metamethods[k], chain);
+		}
+	END_MARK()
+}
+
+void SQInstance::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		_class->Mark(chain);
+		SQUnsignedInteger nvalues = _class->_defaultvalues.size();
+		for(SQUnsignedInteger i =0; i< nvalues; i++) {
+			SQSharedState::MarkObject(_values[i], chain);
+		}
+	END_MARK()
+}
+
+void SQGenerator::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		for(SQUnsignedInteger i = 0; i < _stack.size(); i++) SQSharedState::MarkObject(_stack[i], chain);
+		for(SQUnsignedInteger j = 0; j < _vargsstack.size(); j++) SQSharedState::MarkObject(_vargsstack[j], chain);
+		SQSharedState::MarkObject(_closure, chain);
+	END_MARK()
+}
+
+void SQClosure::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		for(SQUnsignedInteger i = 0; i < _outervalues.size(); i++) SQSharedState::MarkObject(_outervalues[i], chain);
+		for(SQUnsignedInteger i = 0; i < _defaultparams.size(); i++) SQSharedState::MarkObject(_defaultparams[i], chain);
+	END_MARK()
+}
+
+void SQNativeClosure::Mark(SQCollectable **chain)
+{
+	START_MARK()
+		for(SQUnsignedInteger i = 0; i < _outervalues.size(); i++) SQSharedState::MarkObject(_outervalues[i], chain);
+	END_MARK()
+}
+
+void SQUserData::Mark(SQCollectable **chain){
+	START_MARK()
+		if(_delegate) _delegate->Mark(chain);
+	END_MARK()
+}
+
+void SQCollectable::UnMark() { _uiRef&=~MARK_FLAG; }
+
+#endif
+

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqobject.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqobject.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqobject.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,352 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQOBJECT_H_
+#define _SQOBJECT_H_
+
+#include "squtils.h"
+
+#define SQ_CLOSURESTREAM_HEAD (('S'<<24)|('Q'<<16)|('I'<<8)|('R'))
+#define SQ_CLOSURESTREAM_PART (('P'<<24)|('A'<<16)|('R'<<8)|('T'))
+#define SQ_CLOSURESTREAM_TAIL (('T'<<24)|('A'<<16)|('I'<<8)|('L'))
+
+struct SQSharedState;
+
+enum SQMetaMethod{
+	MT_ADD=0,
+	MT_SUB=1,
+	MT_MUL=2,
+	MT_DIV=3,
+	MT_UNM=4,
+	MT_MODULO=5,
+	MT_SET=6,
+	MT_GET=7,
+	MT_TYPEOF=8,
+	MT_NEXTI=9,
+	MT_CMP=10,
+	MT_CALL=11,
+	MT_CLONED=12,
+	MT_NEWSLOT=13,
+	MT_DELSLOT=14,
+	MT_TOSTRING=15,
+	MT_NEWMEMBER=16,
+	MT_INHERITED=17,
+	MT_LAST = 18
+};
+
+#define MM_ADD		_SC("_add")
+#define MM_SUB		_SC("_sub")
+#define MM_MUL		_SC("_mul")
+#define MM_DIV		_SC("_div")
+#define MM_UNM		_SC("_unm")
+#define MM_MODULO	_SC("_modulo")
+#define MM_SET		_SC("_set")
+#define MM_GET		_SC("_get")
+#define MM_TYPEOF	_SC("_typeof")
+#define MM_NEXTI	_SC("_nexti")
+#define MM_CMP		_SC("_cmp")
+#define MM_CALL		_SC("_call")
+#define MM_CLONED	_SC("_cloned")
+#define MM_NEWSLOT	_SC("_newslot")
+#define MM_DELSLOT	_SC("_delslot")
+#define MM_TOSTRING	_SC("_tostring")
+#define MM_NEWMEMBER _SC("_newmember")
+#define MM_INHERITED _SC("_inherited")
+
+#define MINPOWER2 4
+
+struct SQRefCounted
+{
+	SQRefCounted() { _uiRef = 0; _weakref = NULL; }
+	virtual ~SQRefCounted();
+	SQWeakRef *GetWeakRef(SQObjectType type);
+	SQUnsignedInteger _uiRef;
+	struct SQWeakRef *_weakref;
+	virtual void Release()=0;
+};
+
+struct SQWeakRef : SQRefCounted
+{
+	void Release();
+	SQObject _obj;
+};
+
+#define _realval(o) (type((o)) != OT_WEAKREF?(SQObject)o:_weakref(o)->_obj)
+
+struct SQObjectPtr;
+
+#define __AddRef(type,unval) if(ISREFCOUNTED(type))	\
+		{ \
+			unval.pRefCounted->_uiRef++; \
+		}  
+
+#define __Release(type,unval) if(ISREFCOUNTED(type) && ((--unval.pRefCounted->_uiRef)<=0))	\
+		{	\
+			unval.pRefCounted->Release();	\
+		}
+
+#define __ObjRelease(obj) { \
+	if((obj)) {	\
+		(obj)->_uiRef--; \
+		if((obj)->_uiRef == 0) \
+			(obj)->Release(); \
+		(obj) = NULL;	\
+	} \
+}
+
+#define __ObjAddRef(obj) { \
+	(obj)->_uiRef++; \
+}
+
+#define type(obj) ((obj)._type)
+#define is_delegable(t) (type(t)&SQOBJECT_DELEGABLE)
+#define raw_type(obj) _RAW_TYPE((obj)._type)
+
+#define _integer(obj) ((obj)._unVal.nInteger)
+#define _float(obj) ((obj)._unVal.fFloat)
+#define _string(obj) ((obj)._unVal.pString)
+#define _table(obj) ((obj)._unVal.pTable)
+#define _array(obj) ((obj)._unVal.pArray)
+#define _closure(obj) ((obj)._unVal.pClosure)
+#define _generator(obj) ((obj)._unVal.pGenerator)
+#define _nativeclosure(obj) ((obj)._unVal.pNativeClosure)
+#define _userdata(obj) ((obj)._unVal.pUserData)
+#define _userpointer(obj) ((obj)._unVal.pUserPointer)
+#define _thread(obj) ((obj)._unVal.pThread)
+#define _funcproto(obj) ((obj)._unVal.pFunctionProto)
+#define _class(obj) ((obj)._unVal.pClass)
+#define _instance(obj) ((obj)._unVal.pInstance)
+#define _delegable(obj) ((SQDelegable *)(obj)._unVal.pDelegable)
+#define _weakref(obj) ((obj)._unVal.pWeakRef)
+#define _refcounted(obj) ((obj)._unVal.pRefCounted)
+#define _rawval(obj) ((obj)._unVal.pRefCounted)
+
+#define _stringval(obj) (obj)._unVal.pString->_val
+#define _userdataval(obj) (obj)._unVal.pUserData->_val
+
+#define tofloat(num) ((type(num)==OT_INTEGER)?(SQFloat)_integer(num):_float(num))
+#define tointeger(num) ((type(num)==OT_FLOAT)?(SQInteger)_float(num):_integer(num))
+/////////////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////////////
+struct SQObjectPtr : public SQObject
+{
+	SQObjectPtr()
+	{
+		_type=OT_NULL;
+		_unVal.pUserPointer=NULL;
+	}
+	SQObjectPtr(const SQObjectPtr &o)
+	{
+		_type=o._type;
+		_unVal=o._unVal;
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(const SQObject &o)
+	{
+		_type=o._type;
+		_unVal=o._unVal;
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQTable *pTable)
+	{
+		_type=OT_TABLE;
+		_unVal.pTable=pTable;
+		assert(_unVal.pTable);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQClass *pClass)
+	{
+		_type=OT_CLASS;
+		_unVal.pClass=pClass;
+		assert(_unVal.pClass);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQInstance *pInstance)
+	{
+		_type=OT_INSTANCE;
+		_unVal.pInstance=pInstance;
+		assert(_unVal.pInstance);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQArray *pArray)
+	{
+		_type=OT_ARRAY;
+		_unVal.pArray=pArray;
+		assert(_unVal.pArray);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQClosure *pClosure)
+	{
+		_type=OT_CLOSURE;
+		_unVal.pClosure=pClosure;
+		assert(_unVal.pClosure);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQGenerator *pGenerator)
+	{
+		_type=OT_GENERATOR;
+		_unVal.pGenerator=pGenerator;
+		assert(_unVal.pGenerator);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQNativeClosure *pNativeClosure)
+	{
+		_type=OT_NATIVECLOSURE;
+		_unVal.pNativeClosure=pNativeClosure;
+		assert(_unVal.pNativeClosure);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQString *pString)
+	{
+		_type=OT_STRING;
+		_unVal.pString=pString;
+		assert(_unVal.pString);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQUserData *pUserData)
+	{
+		_type=OT_USERDATA;
+		_unVal.pUserData=pUserData;
+		assert(_unVal.pUserData);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQVM *pThread)
+	{
+		_type=OT_THREAD;
+		_unVal.pThread=pThread;
+		assert(_unVal.pThread);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQWeakRef *pWeakRef)
+	{
+		_type=OT_WEAKREF;
+		_unVal.pWeakRef=pWeakRef;
+		assert(_unVal.pWeakRef);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQFunctionProto *pFunctionProto)
+	{
+		_type=OT_FUNCPROTO;
+		_unVal.pFunctionProto=pFunctionProto;
+		assert(_unVal.pFunctionProto);
+		__AddRef(_type,_unVal);
+	}
+	SQObjectPtr(SQInteger nInteger)
+	{
+		_unVal.pUserPointer=NULL;
+		_type=OT_INTEGER;
+		_unVal.nInteger=nInteger;
+	}
+	SQObjectPtr(SQFloat fFloat)
+	{
+		_unVal.pUserPointer=NULL;
+		_type=OT_FLOAT;
+		_unVal.fFloat=fFloat;
+	}
+	SQObjectPtr(bool bBool)
+	{
+		_unVal.pUserPointer=NULL;
+		_type = OT_BOOL;
+		_unVal.nInteger = bBool?1:0;
+	}
+	SQObjectPtr(SQUserPointer pUserPointer)
+	{
+		_type=OT_USERPOINTER;
+		_unVal.pUserPointer=pUserPointer;
+	}
+	~SQObjectPtr()
+	{
+		__Release(_type,_unVal);
+	}
+	inline void Null()
+	{
+		SQObjectType tOldType;
+		SQObjectValue unOldVal;
+		tOldType = _type;
+		unOldVal = _unVal;
+		_type = OT_NULL;
+		_unVal.pUserPointer = NULL;
+		__Release(tOldType,unOldVal);
+	}
+	inline SQObjectPtr& operator=(SQInteger i)
+	{ 
+		__Release(_type,_unVal);
+		_unVal.nInteger = i;
+		_type = OT_INTEGER;
+		return *this;
+	}
+	inline SQObjectPtr& operator=(SQFloat f)
+	{ 
+		__Release(_type,_unVal);
+		_unVal.fFloat = f;
+		_type = OT_FLOAT;
+		return *this;
+	}
+	inline SQObjectPtr& operator=(const SQObjectPtr& obj)
+	{ 
+		SQObjectType tOldType;
+		SQObjectValue unOldVal;
+		tOldType=_type;
+		unOldVal=_unVal;
+		_unVal = obj._unVal;
+		_type = obj._type;
+		__AddRef(_type,_unVal);
+		__Release(tOldType,unOldVal);
+		return *this;
+	}
+	inline SQObjectPtr& operator=(const SQObject& obj)
+	{ 
+		SQObjectType tOldType;
+		SQObjectValue unOldVal;
+		tOldType=_type;
+		unOldVal=_unVal;
+		_unVal = obj._unVal;
+		_type = obj._type;
+		__AddRef(_type,_unVal);
+		__Release(tOldType,unOldVal);
+		return *this;
+	}
+	private:
+		SQObjectPtr(const SQChar *){} //safety
+};
+/////////////////////////////////////////////////////////////////////////////////////
+#ifndef NO_GARBAGE_COLLECTOR
+#define MARK_FLAG 0x80000000
+struct SQCollectable : public SQRefCounted {
+	SQCollectable *_next;
+	SQCollectable *_prev;
+	SQSharedState *_sharedstate;
+	virtual void Release()=0;
+	virtual void Mark(SQCollectable **chain)=0;
+	void UnMark();
+	virtual void Finalize()=0;
+	static void AddToChain(SQCollectable **chain,SQCollectable *c);
+	static void RemoveFromChain(SQCollectable **chain,SQCollectable *c);
+};
+
+
+#define ADD_TO_CHAIN(chain,obj) AddToChain(chain,obj)
+#define REMOVE_FROM_CHAIN(chain,obj) {if(!(_uiRef&MARK_FLAG))RemoveFromChain(chain,obj);}
+#define CHAINABLE_OBJ SQCollectable
+#define INIT_CHAIN() {_next=NULL;_prev=NULL;_sharedstate=ss;}
+#else
+
+#define ADD_TO_CHAIN(chain,obj) ((void)0)
+#define REMOVE_FROM_CHAIN(chain,obj) ((void)0)
+#define CHAINABLE_OBJ SQRefCounted
+#define INIT_CHAIN() ((void)0)
+#endif
+
+struct SQDelegable : public CHAINABLE_OBJ {
+	bool SetDelegate(SQTable *m);
+	virtual bool GetMetaMethod(SQVM *v,SQMetaMethod mm,SQObjectPtr &res);
+	SQTable *_delegate;
+};
+
+SQUnsignedInteger TranslateIndex(const SQObjectPtr &idx);
+typedef sqvector<SQObjectPtr> SQObjectPtrVec;
+typedef sqvector<SQInteger> SQIntVec;
+const SQChar *GetTypeName(const SQObjectPtr &obj1);
+const SQChar *IdType2Name(SQObjectType type);
+
+
+
+#endif //_SQOBJECT_H_

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqopcodes.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqopcodes.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqopcodes.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,115 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQOPCODES_H_
+#define _SQOPCODES_H_
+
+#define MAX_FUNC_STACKSIZE 0xFF
+#define MAX_LITERALS ((SQInteger)0x7FFFFFFF)
+
+enum BitWiseOP {
+	BW_AND = 0,
+	BW_OR = 2,	
+	BW_XOR = 3,
+	BW_SHIFTL = 4,
+	BW_SHIFTR = 5,
+	BW_USHIFTR = 6
+};
+
+enum CmpOP {
+	CMP_G = 0,
+	CMP_GE = 2,	
+	CMP_L = 3,
+	CMP_LE = 4
+};
+enum SQOpcode
+{
+	_OP_LINE=				0x00,	
+	_OP_LOAD=				0x01,
+	_OP_LOADINT=			0x02,
+	_OP_LOADFLOAT=			0x03,
+	_OP_DLOAD=				0x04,
+	_OP_TAILCALL=			0x05,	
+	_OP_CALL=				0x06,	
+	_OP_PREPCALL=			0x07,	
+	_OP_PREPCALLK=			0x08,	
+	_OP_GETK=				0x09,	
+	_OP_MOVE=				0x0A,	
+	_OP_NEWSLOT=			0x0B,	
+	_OP_DELETE=				0x0C,	
+	_OP_SET=				0x0D,	
+	_OP_GET=				0x0E,
+	_OP_EQ=					0x0F,
+	_OP_NE=					0x10,
+	_OP_ARITH=				0x11,
+	_OP_BITW=				0x12,
+	_OP_RETURN=				0x13,	
+	_OP_LOADNULLS=			0x14,	
+	_OP_LOADROOTTABLE=		0x15,
+	_OP_LOADBOOL=			0x16,
+	_OP_DMOVE=				0x17,	
+	_OP_JMP=				0x18,	
+	_OP_JNZ=				0x19,	
+	_OP_JZ=					0x1A,	
+	_OP_LOADFREEVAR=		0x1B,	
+	_OP_VARGC=				0x1C,	
+	_OP_GETVARGV=			0x1D,	
+	_OP_NEWTABLE=			0x1E,	
+	_OP_NEWARRAY=			0x1F,	
+	_OP_APPENDARRAY=		0x20,	
+	_OP_GETPARENT=			0x21,	
+	_OP_COMPARITH=			0x22,	
+	_OP_COMPARITHL=			0x23,	
+	_OP_INC=				0x24,	
+	_OP_INCL=				0x25,	
+	_OP_PINC=				0x26,	
+	_OP_PINCL=				0x27,	
+	_OP_CMP=				0x28,
+	_OP_EXISTS=				0x29,	
+	_OP_INSTANCEOF=			0x2A,
+	_OP_AND=				0x2B,
+	_OP_OR=					0x2C,
+	_OP_NEG=				0x2D,
+	_OP_NOT=				0x2E,
+	_OP_BWNOT=				0x2F,	
+	_OP_CLOSURE=			0x30,	
+	_OP_YIELD=				0x31,	
+	_OP_RESUME=				0x32,
+	_OP_FOREACH=			0x33,
+	_OP_POSTFOREACH=		0x34,
+	_OP_DELEGATE=			0x35,
+	_OP_CLONE=				0x36,
+	_OP_TYPEOF=				0x37,
+	_OP_PUSHTRAP=			0x38,
+	_OP_POPTRAP=			0x39,
+	_OP_THROW=				0x3A,
+	_OP_CLASS=				0x3B,
+	_OP_NEWSLOTA=			0x3C,
+};							  
+
+struct SQInstructionDesc {	  
+	const SQChar *name;		  
+};							  
+
+struct SQInstruction 
+{
+	SQInstruction(){};
+	SQInstruction(SQOpcode _op,SQInteger a0=0,SQInteger a1=0,SQInteger a2=0,SQInteger a3=0)
+	{	op = _op;
+		_arg0 = (unsigned char)a0;_arg1 = (SQInt32)a1;
+		_arg2 = (unsigned char)a2;_arg3 = (unsigned char)a3;
+	}
+    
+	
+	SQInt32 _arg1;
+	unsigned char op;
+	unsigned char _arg0;
+	unsigned char _arg2;
+	unsigned char _arg3;
+};
+
+#include "squtils.h"
+typedef sqvector<SQInstruction> SQInstructionVec;
+
+#define NEW_SLOT_ATTRIBUTES_FLAG	0x01
+#define NEW_SLOT_STATIC_FLAG		0x02
+
+#endif // _SQOPCODES_H_

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqpcheader.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqpcheader.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqpcheader.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,19 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQPCHEADER_H_
+#define _SQPCHEADER_H_
+
+#if defined(_MSC_VER) && defined(_DEBUG)
+#include <crtdbg.h>
+#endif 
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <new>
+//squirrel stuff
+#include <squirrel.h>
+#include "sqobject.h"
+#include "sqstate.h"
+
+#endif //_SQPCHEADER_H_

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqstate.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqstate.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqstate.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,572 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include "sqopcodes.h"
+#include "sqvm.h"
+#include "sqfuncproto.h"
+#include "sqclosure.h"
+#include "sqstring.h"
+#include "sqtable.h"
+#include "sqarray.h"
+#include "squserdata.h"
+#include "sqclass.h"
+
+SQObjectPtr _null_;
+SQObjectPtr _true_(true);
+SQObjectPtr _false_(false);
+SQObjectPtr _one_((SQInteger)1);
+SQObjectPtr _minusone_((SQInteger)-1);
+
+SQSharedState::SQSharedState()
+{
+	_compilererrorhandler = NULL;
+	_printfunc = NULL;
+	_debuginfo = false;
+	_notifyallexceptions = false;
+}
+
+#define newsysstring(s) {	\
+	_systemstrings->push_back(SQString::Create(this,s));	\
+	}
+
+#define newmetamethod(s) {	\
+	_metamethods->push_back(SQString::Create(this,s));	\
+	_table(_metamethodsmap)->NewSlot(_metamethods->back(),(SQInteger)(_metamethods->size()-1)); \
+	}
+
+bool CompileTypemask(SQIntVec &res,const SQChar *typemask)
+{
+	SQInteger i = 0;
+	
+	SQInteger mask = 0;
+	while(typemask[i] != 0) {
+		
+		switch(typemask[i]){
+				case 'o': mask |= _RT_NULL; break;
+				case 'i': mask |= _RT_INTEGER; break;
+				case 'f': mask |= _RT_FLOAT; break;
+				case 'n': mask |= (_RT_FLOAT | _RT_INTEGER); break;
+				case 's': mask |= _RT_STRING; break;
+				case 't': mask |= _RT_TABLE; break;
+				case 'a': mask |= _RT_ARRAY; break;
+				case 'u': mask |= _RT_USERDATA; break;
+				case 'c': mask |= (_RT_CLOSURE | _RT_NATIVECLOSURE); break;
+				case 'b': mask |= _RT_BOOL; break;
+				case 'g': mask |= _RT_GENERATOR; break;
+				case 'p': mask |= _RT_USERPOINTER; break;
+				case 'v': mask |= _RT_THREAD; break;
+				case 'x': mask |= _RT_INSTANCE; break;
+				case 'y': mask |= _RT_CLASS; break;
+				case 'r': mask |= _RT_WEAKREF; break;
+				case '.': mask = -1; res.push_back(mask); i++; mask = 0; continue;
+				case ' ': i++; continue; //ignores spaces
+				default:
+					return false;
+		}
+		i++;
+		if(typemask[i] == '|') { 
+			i++; 
+			if(typemask[i] == 0)
+				return false;
+			continue; 
+		}
+		res.push_back(mask);
+		mask = 0;
+		
+	}
+	return true;
+}
+
+SQTable *CreateDefaultDelegate(SQSharedState *ss,SQRegFunction *funcz)
+{
+	SQInteger i=0;
+	SQTable *t=SQTable::Create(ss,0);
+	while(funcz[i].name!=0){
+		SQNativeClosure *nc = SQNativeClosure::Create(ss,funcz[i].f);
+		nc->_nparamscheck = funcz[i].nparamscheck;
+		nc->_name = SQString::Create(ss,funcz[i].name);
+		if(funcz[i].typemask && !CompileTypemask(nc->_typecheck,funcz[i].typemask))
+			return NULL;
+		t->NewSlot(SQString::Create(ss,funcz[i].name),nc);
+		i++;
+	}
+	return t;
+}
+
+void SQSharedState::Init()
+{	
+	_scratchpad=NULL;
+	_scratchpadsize=0;
+#ifndef NO_GARBAGE_COLLECTOR
+	_gc_chain=NULL;
+#endif
+	sq_new(_stringtable,StringTable);
+	sq_new(_metamethods,SQObjectPtrVec);
+	sq_new(_systemstrings,SQObjectPtrVec);
+	sq_new(_types,SQObjectPtrVec);
+	_metamethodsmap = SQTable::Create(this,MT_LAST-1);
+	//adding type strings to avoid memory trashing
+	//types names
+	newsysstring(_SC("null"));
+	newsysstring(_SC("table"));
+	newsysstring(_SC("array"));
+	newsysstring(_SC("closure"));
+	newsysstring(_SC("string"));
+	newsysstring(_SC("userdata"));
+	newsysstring(_SC("integer"));
+	newsysstring(_SC("float"));
+	newsysstring(_SC("userpointer"));
+	newsysstring(_SC("function"));
+	newsysstring(_SC("generator"));
+	newsysstring(_SC("thread"));
+	newsysstring(_SC("class"));
+	newsysstring(_SC("instance"));
+	newsysstring(_SC("bool"));
+	//meta methods
+	newmetamethod(MM_ADD);
+	newmetamethod(MM_SUB);
+	newmetamethod(MM_MUL);
+	newmetamethod(MM_DIV);
+	newmetamethod(MM_UNM);
+	newmetamethod(MM_MODULO);
+	newmetamethod(MM_SET);
+	newmetamethod(MM_GET);
+	newmetamethod(MM_TYPEOF);
+	newmetamethod(MM_NEXTI);
+	newmetamethod(MM_CMP);
+	newmetamethod(MM_CALL);
+	newmetamethod(MM_CLONED);
+	newmetamethod(MM_NEWSLOT);
+	newmetamethod(MM_DELSLOT);
+	newmetamethod(MM_TOSTRING);
+	newmetamethod(MM_NEWMEMBER);
+	newmetamethod(MM_INHERITED);
+
+	_constructoridx = SQString::Create(this,_SC("constructor"));
+	_registry = SQTable::Create(this,0);
+	_consts = SQTable::Create(this,0);
+	_table_default_delegate = CreateDefaultDelegate(this,_table_default_delegate_funcz);
+	_array_default_delegate = CreateDefaultDelegate(this,_array_default_delegate_funcz);
+	_string_default_delegate = CreateDefaultDelegate(this,_string_default_delegate_funcz);
+	_number_default_delegate = CreateDefaultDelegate(this,_number_default_delegate_funcz);
+	_closure_default_delegate = CreateDefaultDelegate(this,_closure_default_delegate_funcz);
+	_generator_default_delegate = CreateDefaultDelegate(this,_generator_default_delegate_funcz);
+	_thread_default_delegate = CreateDefaultDelegate(this,_thread_default_delegate_funcz);
+	_class_default_delegate = CreateDefaultDelegate(this,_class_default_delegate_funcz);
+	_instance_default_delegate = CreateDefaultDelegate(this,_instance_default_delegate_funcz);
+	_weakref_default_delegate = CreateDefaultDelegate(this,_weakref_default_delegate_funcz);
+
+}
+
+SQSharedState::~SQSharedState()
+{
+	_constructoridx = _null_;
+	_table(_registry)->Finalize();
+	_table(_consts)->Finalize();
+	_table(_metamethodsmap)->Finalize();
+	_registry = _null_;
+	_consts = _null_;
+	_metamethodsmap = _null_;
+	while(!_systemstrings->empty()) {
+		_systemstrings->back()=_null_;
+		_systemstrings->pop_back();
+	}
+	_thread(_root_vm)->Finalize();
+	_root_vm = _null_;
+	_table_default_delegate = _null_;
+	_array_default_delegate = _null_;
+	_string_default_delegate = _null_;
+	_number_default_delegate = _null_;
+	_closure_default_delegate = _null_;
+	_generator_default_delegate = _null_;
+	_thread_default_delegate = _null_;
+	_class_default_delegate = _null_;
+	_instance_default_delegate = _null_;
+	_weakref_default_delegate = _null_;
+	_refs_table.Finalize();
+#ifndef NO_GARBAGE_COLLECTOR
+	SQCollectable *t = _gc_chain;
+	SQCollectable *nx = NULL;
+	while(t) {
+		t->_uiRef++;
+		t->Finalize();
+		nx = t->_next;
+		if(--t->_uiRef == 0)
+			t->Release();
+		t=nx;
+	}
+	assert(_gc_chain==NULL); //just to proove a theory
+	while(_gc_chain){
+		_gc_chain->_uiRef++;
+		_gc_chain->Release();
+	}
+#endif
+
+	sq_delete(_types,SQObjectPtrVec);
+	sq_delete(_systemstrings,SQObjectPtrVec);
+	sq_delete(_metamethods,SQObjectPtrVec);
+	sq_delete(_stringtable,StringTable);
+	if(_scratchpad)SQ_FREE(_scratchpad,_scratchpadsize);
+}
+
+
+SQInteger SQSharedState::GetMetaMethodIdxByName(const SQObjectPtr &name)
+{
+	if(type(name) != OT_STRING)
+		return -1;
+	SQObjectPtr ret;
+	if(_table(_metamethodsmap)->Get(name,ret)) {
+		return _integer(ret);
+	}
+	return -1;
+}
+
+#ifndef NO_GARBAGE_COLLECTOR
+
+void SQSharedState::MarkObject(SQObjectPtr &o,SQCollectable **chain)
+{
+	switch(type(o)){
+	case OT_TABLE:_table(o)->Mark(chain);break;
+	case OT_ARRAY:_array(o)->Mark(chain);break;
+	case OT_USERDATA:_userdata(o)->Mark(chain);break;
+	case OT_CLOSURE:_closure(o)->Mark(chain);break;
+	case OT_NATIVECLOSURE:_nativeclosure(o)->Mark(chain);break;
+	case OT_GENERATOR:_generator(o)->Mark(chain);break;
+	case OT_THREAD:_thread(o)->Mark(chain);break;
+	case OT_CLASS:_class(o)->Mark(chain);break;
+	case OT_INSTANCE:_instance(o)->Mark(chain);break;
+	default: break; //shutup compiler
+	}
+}
+
+
+SQInteger SQSharedState::CollectGarbage(SQVM *vm)
+{
+	SQInteger n=0;
+	SQCollectable *tchain=NULL;
+	SQVM *vms = _thread(_root_vm);
+	
+	vms->Mark(&tchain);
+	SQInteger x = _table(_thread(_root_vm)->_roottable)->CountUsed();
+	_refs_table.Mark(&tchain);
+	MarkObject(_registry,&tchain);
+	MarkObject(_consts,&tchain);
+	MarkObject(_metamethodsmap,&tchain);
+	MarkObject(_table_default_delegate,&tchain);
+	MarkObject(_array_default_delegate,&tchain);
+	MarkObject(_string_default_delegate,&tchain);
+	MarkObject(_number_default_delegate,&tchain);
+	MarkObject(_generator_default_delegate,&tchain);
+	MarkObject(_thread_default_delegate,&tchain);
+	MarkObject(_closure_default_delegate,&tchain);
+	MarkObject(_class_default_delegate,&tchain);
+	MarkObject(_instance_default_delegate,&tchain);
+	MarkObject(_weakref_default_delegate,&tchain);
+	
+	SQCollectable *t = _gc_chain;
+	SQCollectable *nx = NULL;
+	while(t) {
+		t->_uiRef++;
+		t->Finalize();
+		nx = t->_next;
+		if(--t->_uiRef == 0)
+			t->Release();
+		t = nx;
+		n++;
+	}
+
+	t = tchain;
+	while(t) {
+		t->UnMark();
+		t = t->_next;
+	}
+	_gc_chain = tchain;
+	SQInteger z = _table(_thread(_root_vm)->_roottable)->CountUsed();
+	assert(z == x);
+	return n;
+}
+#endif
+
+#ifndef NO_GARBAGE_COLLECTOR
+void SQCollectable::AddToChain(SQCollectable **chain,SQCollectable *c)
+{
+    c->_prev = NULL;
+	c->_next = *chain;
+	if(*chain) (*chain)->_prev = c;
+	*chain = c;
+}
+
+void SQCollectable::RemoveFromChain(SQCollectable **chain,SQCollectable *c)
+{
+	if(c->_prev) c->_prev->_next = c->_next;
+	else *chain = c->_next;
+	if(c->_next)
+		c->_next->_prev = c->_prev;
+	c->_next = NULL;
+	c->_prev = NULL;
+}
+#endif
+
+SQChar* SQSharedState::GetScratchPad(SQInteger size)
+{
+	SQInteger newsize;
+	if(size>0) {
+		if(_scratchpadsize < size) {
+			newsize = size + (size>>1);
+			_scratchpad = (SQChar *)SQ_REALLOC(_scratchpad,_scratchpadsize,newsize);
+			_scratchpadsize = newsize;
+
+		}else if(_scratchpadsize >= (size<<5)) {
+			newsize = _scratchpadsize >> 1;
+			_scratchpad = (SQChar *)SQ_REALLOC(_scratchpad,_scratchpadsize,newsize);
+			_scratchpadsize = newsize;
+		}
+	}
+	return _scratchpad;
+}
+
+RefTable::RefTable()
+{
+	AllocNodes(4);
+}
+
+void RefTable::Finalize()
+{
+	RefNode *nodes = _nodes;
+	for(SQUnsignedInteger n = 0; n < _numofslots; n++) {
+		nodes->obj = _null_;
+		nodes++;
+	}
+}
+
+RefTable::~RefTable()
+{
+	SQ_FREE(_buckets,(_numofslots * sizeof(RefNode *)) + (_numofslots * sizeof(RefNode)));
+}
+
+#ifndef NO_GARBAGE_COLLECTOR
+void RefTable::Mark(SQCollectable **chain)
+{
+	RefNode *nodes = (RefNode *)_nodes;
+	for(SQUnsignedInteger n = 0; n < _numofslots; n++) {
+		if(type(nodes->obj) != OT_NULL) {
+			SQSharedState::MarkObject(nodes->obj,chain);
+		}
+		nodes++;
+	}
+}
+#endif
+
+void RefTable::AddRef(SQObject &obj)
+{
+	SQHash mainpos;
+	RefNode *prev;
+	RefNode *ref = Get(obj,mainpos,&prev,true);
+	ref->refs++;
+}
+
+SQBool RefTable::Release(SQObject &obj)
+{
+	SQHash mainpos;
+	RefNode *prev;
+	RefNode *ref = Get(obj,mainpos,&prev,false);
+	if(ref) {
+		if(--ref->refs == 0) {
+			SQObjectPtr o = ref->obj;
+			if(prev) {
+				prev->next = ref->next;
+			}
+			else {
+				_buckets[mainpos] = ref->next;
+			}
+			ref->next = _freelist;
+			_freelist = ref;
+			_slotused--;
+			ref->obj = _null_;
+			//<<FIXME>>test for shrink?
+			return SQTrue;
+		}
+	}
+	else {
+		assert(0);
+	}
+	return SQFalse;
+}
+
+void RefTable::Resize(SQUnsignedInteger size)
+{
+	RefNode **oldbucks = _buckets;
+	RefNode *t = _nodes;
+	SQUnsignedInteger oldnumofslots = _numofslots;
+	AllocNodes(size);
+	//rehash
+	SQUnsignedInteger nfound = 0;
+	for(SQUnsignedInteger n = 0; n < oldnumofslots; n++) {
+		if(type(t->obj) != OT_NULL) {
+			//add back;
+			assert(t->refs != 0);
+			RefNode *nn = Add(::HashObj(t->obj)&(_numofslots-1),t->obj);
+			nn->refs = t->refs; 
+			t->obj = _null_;
+			nfound++;
+		}
+		t++;
+	}
+	assert(nfound == oldnumofslots);
+	SQ_FREE(oldbucks,(oldnumofslots * sizeof(RefNode *)) + (oldnumofslots * sizeof(RefNode)));
+}
+
+RefTable::RefNode *RefTable::Add(SQHash mainpos,SQObject &obj)
+{
+	RefNode *t = _buckets[mainpos];
+	RefNode *newnode = _freelist;
+	newnode->obj = obj;
+	_buckets[mainpos] = newnode;
+	_freelist = _freelist->next;
+	newnode->next = t;
+	assert(newnode->refs == 0);
+	_slotused++;
+	return newnode;
+}
+
+RefTable::RefNode *RefTable::Get(SQObject &obj,SQHash &mainpos,RefNode **prev,bool add)
+{
+	RefNode *ref;
+	mainpos = ::HashObj(obj)&(_numofslots-1);
+	*prev = NULL;
+	for (ref = _buckets[mainpos]; ref; ) {
+		if(_rawval(ref->obj) == _rawval(obj) && type(ref->obj) == type(obj))
+			break;
+		*prev = ref;
+		ref = ref->next;
+	}
+	if(ref == NULL && add) {
+		if(_numofslots == _slotused) {
+			assert(_freelist == 0);
+			Resize(_numofslots*2);
+			mainpos = ::HashObj(obj)&(_numofslots-1);
+		}
+		ref = Add(mainpos,obj);
+	}
+	return ref;
+}
+
+void RefTable::AllocNodes(SQUnsignedInteger size)
+{
+	RefNode **bucks;
+	RefNode *nodes;
+	bucks = (RefNode **)SQ_MALLOC((size * sizeof(RefNode *)) + (size * sizeof(RefNode)));
+	nodes = (RefNode *)&bucks[size];
+	RefNode *temp = nodes;
+	SQUnsignedInteger n;
+	for(n = 0; n < size - 1; n++) {
+		bucks[n] = NULL;
+		temp->refs = 0;
+		new (&temp->obj) SQObjectPtr;
+		temp->next = temp+1;
+		temp++;
+	}
+	bucks[n] = NULL;
+	temp->refs = 0;
+	new (&temp->obj) SQObjectPtr;
+	temp->next = NULL;
+	_freelist = nodes;
+	_nodes = nodes;
+	_buckets = bucks;
+	_slotused = 0;
+	_numofslots = size;
+}
+//////////////////////////////////////////////////////////////////////////
+//StringTable
+/*
+* The following code is based on Lua 4.0 (Copyright 1994-2002 Tecgraf, PUC-Rio.)
+* http://www.lua.org/copyright.html#4
+* http://www.lua.org/source/4.0.1/src_lstring.c.html
+*/
+
+StringTable::StringTable()
+{
+	AllocNodes(4);
+	_slotused = 0;
+}
+
+StringTable::~StringTable()
+{
+	SQ_FREE(_strings,sizeof(SQString*)*_numofslots);
+	_strings = NULL;
+}
+
+void StringTable::AllocNodes(SQInteger size)
+{
+	_numofslots = size;
+	_strings = (SQString**)SQ_MALLOC(sizeof(SQString*)*_numofslots);
+	memset(_strings,0,sizeof(SQString*)*_numofslots);
+}
+
+SQString *StringTable::Add(const SQChar *news,SQInteger len)
+{
+	if(len<0)
+		len = (SQInteger)scstrlen(news);
+	SQHash h = ::_hashstr(news,len)&(_numofslots-1);
+	SQString *s;
+	for (s = _strings[h]; s; s = s->_next){
+		if(s->_len == len && (!memcmp(news,s->_val,rsl(len))))
+			return s; //found
+	}
+
+	SQString *t=(SQString *)SQ_MALLOC(rsl(len)+sizeof(SQString));
+	new (t) SQString;
+	memcpy(t->_val,news,rsl(len));
+	t->_val[len] = _SC('\0');
+	t->_len = len;
+	t->_hash = ::_hashstr(news,len);
+	t->_next = _strings[h];
+	_strings[h] = t;
+	_slotused++;
+	if (_slotused > _numofslots)  /* too crowded? */
+		Resize(_numofslots*2);
+	return t;
+}
+
+void StringTable::Resize(SQInteger size)
+{
+	SQInteger oldsize=_numofslots;
+	SQString **oldtable=_strings;
+	AllocNodes(size);
+	for (SQInteger i=0; i<oldsize; i++){
+		SQString *p = oldtable[i];
+		while(p){
+			SQString *next = p->_next;
+			SQHash h = p->_hash&(_numofslots-1);
+			p->_next = _strings[h];
+			_strings[h] = p;
+			p = next;
+		}
+	}
+	SQ_FREE(oldtable,oldsize*sizeof(SQString*));
+}
+
+void StringTable::Remove(SQString *bs)
+{
+	SQString *s;
+	SQString *prev=NULL;
+	SQHash h = bs->_hash&(_numofslots - 1);
+	
+	for (s = _strings[h]; s; ){
+		if(s == bs){
+			if(prev)
+				prev->_next = s->_next;
+			else
+				_strings[h] = s->_next;
+			_slotused--;
+			SQInteger slen = s->_len;
+			s->~SQString();
+			SQ_FREE(s,sizeof(SQString) + rsl(slen));
+			return;
+		}
+		prev = s;
+		s = s->_next;
+	}
+	assert(0);//if this fail something is wrong
+}

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqstate.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqstate.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqstate.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,143 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQSTATE_H_
+#define _SQSTATE_H_
+
+#include "squtils.h"
+#include "sqobject.h"
+struct SQString;
+struct SQTable;
+//max number of character for a printed number
+#define NUMBER_MAX_CHAR 50
+
+struct StringTable
+{
+	StringTable();
+	~StringTable();
+	SQString *Add(const SQChar *,SQInteger len);
+	void Remove(SQString *);
+private:
+	void Resize(SQInteger size);
+	void AllocNodes(SQInteger size);
+	SQString **_strings;
+	SQUnsignedInteger _numofslots;
+	SQUnsignedInteger _slotused;
+};
+
+struct RefTable {
+	struct RefNode {
+		SQObjectPtr obj;
+		SQUnsignedInteger refs;
+		struct RefNode *next;
+	};
+	RefTable();
+	~RefTable();
+	void AddRef(SQObject &obj);
+	SQBool Release(SQObject &obj);
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable **chain);
+#endif
+	void Finalize();
+private:
+	RefNode *Get(SQObject &obj,SQHash &mainpos,RefNode **prev,bool add);
+	RefNode *Add(SQHash mainpos,SQObject &obj);
+	void Resize(SQUnsignedInteger size);
+	void AllocNodes(SQUnsignedInteger size);
+	SQUnsignedInteger _numofslots;
+	SQUnsignedInteger _slotused;
+	RefNode *_nodes;
+	RefNode *_freelist;
+	RefNode **_buckets;
+};
+
+#define ADD_STRING(ss,str,len) ss->_stringtable->Add(str,len)
+#define REMOVE_STRING(ss,bstr) ss->_stringtable->Remove(bstr)
+
+struct SQObjectPtr;
+
+struct SQSharedState
+{
+	SQSharedState();
+	~SQSharedState();
+	void Init();
+public:
+	SQChar* GetScratchPad(SQInteger size);
+	SQInteger GetMetaMethodIdxByName(const SQObjectPtr &name);
+#ifndef NO_GARBAGE_COLLECTOR
+	SQInteger CollectGarbage(SQVM *vm); 
+	static void MarkObject(SQObjectPtr &o,SQCollectable **chain);
+#endif
+	SQObjectPtrVec *_metamethods;
+	SQObjectPtr _metamethodsmap;
+	SQObjectPtrVec *_systemstrings;
+	SQObjectPtrVec *_types;
+	StringTable *_stringtable;
+	RefTable _refs_table;
+	SQObjectPtr _registry;
+	SQObjectPtr _consts;
+	SQObjectPtr _constructoridx;
+#ifndef NO_GARBAGE_COLLECTOR
+	SQCollectable *_gc_chain;
+#endif
+	SQObjectPtr _root_vm;
+	SQObjectPtr _table_default_delegate;
+	static SQRegFunction _table_default_delegate_funcz[];
+	SQObjectPtr _array_default_delegate;
+	static SQRegFunction _array_default_delegate_funcz[];
+	SQObjectPtr _string_default_delegate;
+	static SQRegFunction _string_default_delegate_funcz[];
+	SQObjectPtr _number_default_delegate;
+	static SQRegFunction _number_default_delegate_funcz[];
+	SQObjectPtr _generator_default_delegate;
+	static SQRegFunction _generator_default_delegate_funcz[];
+	SQObjectPtr _closure_default_delegate;
+	static SQRegFunction _closure_default_delegate_funcz[];
+	SQObjectPtr _thread_default_delegate;
+	static SQRegFunction _thread_default_delegate_funcz[];
+	SQObjectPtr _class_default_delegate;
+	static SQRegFunction _class_default_delegate_funcz[];
+	SQObjectPtr _instance_default_delegate;
+	static SQRegFunction _instance_default_delegate_funcz[];
+	SQObjectPtr _weakref_default_delegate;
+	static SQRegFunction _weakref_default_delegate_funcz[];
+	
+	SQCOMPILERERROR _compilererrorhandler;
+	SQPRINTFUNCTION _printfunc;
+	bool _debuginfo;
+	bool _notifyallexceptions;
+private:
+	SQChar *_scratchpad;
+	SQInteger _scratchpadsize;
+};
+
+#define _sp(s) (_sharedstate->GetScratchPad(s))
+#define _spval (_sharedstate->GetScratchPad(-1))
+
+#define _table_ddel		_table(_sharedstate->_table_default_delegate) 
+#define _array_ddel		_table(_sharedstate->_array_default_delegate) 
+#define _string_ddel	_table(_sharedstate->_string_default_delegate) 
+#define _number_ddel	_table(_sharedstate->_number_default_delegate) 
+#define _generator_ddel	_table(_sharedstate->_generator_default_delegate) 
+#define _closure_ddel	_table(_sharedstate->_closure_default_delegate) 
+#define _thread_ddel	_table(_sharedstate->_thread_default_delegate) 
+#define _class_ddel		_table(_sharedstate->_class_default_delegate) 
+#define _instance_ddel	_table(_sharedstate->_instance_default_delegate) 
+#define _weakref_ddel	_table(_sharedstate->_weakref_default_delegate) 
+
+#ifdef SQUNICODE //rsl REAL STRING LEN
+#define rsl(l) ((l)<<1)
+#else
+#define rsl(l) (l)
+#endif
+
+extern SQObjectPtr _null_;
+extern SQObjectPtr _true_;
+extern SQObjectPtr _false_;
+extern SQObjectPtr _one_;
+extern SQObjectPtr _minusone_;
+
+bool CompileTypemask(SQIntVec &res,const SQChar *typemask);
+
+void *sq_vm_malloc(SQUnsignedInteger size);
+void *sq_vm_realloc(void *p,SQUnsignedInteger oldsize,SQUnsignedInteger size);
+void sq_vm_free(void *p,SQUnsignedInteger size);
+#endif //_SQSTATE_H_

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqstring.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqstring.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqstring.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,31 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQSTRING_H_
+#define _SQSTRING_H_
+
+inline SQHash _hashstr (const SQChar *s, size_t l)
+{
+		SQHash h = (SQHash)l;  /* seed */
+		size_t step = (l>>5)|1;  /* if string is too long, don't hash all its chars */
+		for (; l>=step; l-=step)
+			h = h ^ ((h<<5)+(h>>2)+(unsigned short)*(s++));
+		return h;
+}
+
+struct SQString : public SQRefCounted
+{
+	SQString(){}
+	~SQString(){}
+public:
+	static SQString *Create(SQSharedState *ss, const SQChar *, SQInteger len = -1 );
+	SQInteger Next(const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval);
+	void Release();
+	SQSharedState *_sharedstate;
+	SQString *_next; //chain for the string table
+	SQInteger _len;
+	SQHash _hash;
+	SQChar _val[1];
+};
+
+
+
+#endif //_SQSTRING_H_

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqtable.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqtable.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqtable.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,196 @@
+/*
+see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include "sqvm.h"
+#include "sqtable.h"
+#include "sqfuncproto.h"
+#include "sqclosure.h"
+
+SQTable::SQTable(SQSharedState *ss,SQInteger nInitialSize)
+{
+	SQInteger pow2size=MINPOWER2;
+	while(nInitialSize>pow2size)pow2size=pow2size<<1;
+	AllocNodes(pow2size);
+	_usednodes = 0;
+	_delegate = NULL;
+	INIT_CHAIN();
+	ADD_TO_CHAIN(&_sharedstate->_gc_chain,this);
+}
+
+void SQTable::Remove(const SQObjectPtr &key)
+{
+	
+	_HashNode *n = _Get(key, HashObj(key) & (_numofnodes - 1));
+	if (n) {
+		n->val = n->key = _null_;
+		_usednodes--;
+		Rehash(false);
+	}
+}
+
+void SQTable::AllocNodes(SQInteger nSize)
+{
+	_HashNode *nodes=(_HashNode *)SQ_MALLOC(sizeof(_HashNode)*nSize);
+	for(SQInteger i=0;i<nSize;i++){
+		new (&nodes[i]) _HashNode;
+		nodes[i].next=NULL;
+	}
+	_numofnodes=nSize;
+	_nodes=nodes;
+	_firstfree=&_nodes[_numofnodes-1];
+}
+
+void SQTable::Rehash(bool force)
+{
+	SQInteger oldsize=_numofnodes;
+	//prevent problems with the integer division
+	if(oldsize<4)oldsize=4;
+	_HashNode *nold=_nodes;
+	SQInteger nelems=CountUsed();
+	if (nelems >= oldsize-oldsize/4)  /* using more than 3/4? */
+		AllocNodes(oldsize*2);
+	else if (nelems <= oldsize/4 &&  /* less than 1/4? */
+		oldsize > MINPOWER2)
+		AllocNodes(oldsize/2);
+	else if(force)
+		AllocNodes(oldsize);
+	else
+		return;
+	_usednodes = 0;
+	for (SQInteger i=0; i<oldsize; i++) {
+		_HashNode *old = nold+i;
+		if (type(old->key) != OT_NULL)
+			NewSlot(old->key,old->val);
+	}
+	for(SQInteger k=0;k<oldsize;k++) 
+		nold[k].~_HashNode();
+	SQ_FREE(nold,oldsize*sizeof(_HashNode));
+}
+
+SQTable *SQTable::Clone()
+{
+	SQTable *nt=Create(_opt_ss(this),_numofnodes);
+	SQInteger ridx=0;
+	SQObjectPtr key,val;
+	while((ridx=Next(true,ridx,key,val))!=-1){
+		nt->NewSlot(key,val);
+	}
+	nt->SetDelegate(_delegate);
+	return nt;
+}
+
+bool SQTable::Get(const SQObjectPtr &key,SQObjectPtr &val)
+{
+	if(type(key) == OT_NULL)
+		return false;
+	_HashNode *n = _Get(key, HashObj(key) & (_numofnodes - 1));
+	if (n) {
+		val = _realval(n->val);
+		return true;
+	}
+	return false;
+}
+bool SQTable::NewSlot(const SQObjectPtr &key,const SQObjectPtr &val)
+{
+	assert(type(key) != OT_NULL);
+	SQHash h = HashObj(key) & (_numofnodes - 1);
+	_HashNode *n = _Get(key, h);
+	if (n) {
+		n->val = val;
+		return false;
+	}
+	_HashNode *mp = &_nodes[h];
+	n = mp;
+
+
+	//key not found I'll insert it
+	//main pos is not free
+
+	if(type(mp->key) != OT_NULL) {
+		n = _firstfree;  /* get a free place */
+		SQHash mph = HashObj(mp->key) & (_numofnodes - 1);
+		_HashNode *othern;  /* main position of colliding node */
+		
+		if (mp > n && (othern = &_nodes[mph]) != mp){
+			/* yes; move colliding node into free position */
+			while (othern->next != mp){
+				assert(othern->next != NULL);
+				othern = othern->next;  /* find previous */
+			}
+			othern->next = n;  /* redo the chain with `n' in place of `mp' */
+			n->key = mp->key;
+			n->val = mp->val;/* copy colliding node into free pos. (mp->next also goes) */
+			n->next = mp->next;
+			mp->key = _null_;
+			mp->val = _null_;
+			mp->next = NULL;  /* now `mp' is free */
+		}
+		else{
+			/* new node will go into free position */
+			n->next = mp->next;  /* chain new position */
+			mp->next = n;
+			mp = n;
+		}
+	}
+	mp->key = key;
+
+	for (;;) {  /* correct `firstfree' */
+		if (type(_firstfree->key) == OT_NULL && _firstfree->next == NULL) {
+			mp->val = val;
+			_usednodes++;
+			return true;  /* OK; table still has a free place */
+		}
+		else if (_firstfree == _nodes) break;  /* cannot decrement from here */
+		else (_firstfree)--;
+	}
+	Rehash(true);
+	return NewSlot(key, val);
+}
+
+SQInteger SQTable::Next(bool getweakrefs,const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval)
+{
+	SQInteger idx = (SQInteger)TranslateIndex(refpos);
+	while (idx < _numofnodes) {
+		if(type(_nodes[idx].key) != OT_NULL) {
+			//first found
+			_HashNode &n = _nodes[idx];
+			outkey = n.key;
+			outval = getweakrefs?(SQObject)n.val:_realval(n.val);
+			//return idx for the next iteration
+			return ++idx;
+		}
+		++idx;
+	}
+	//nothing to iterate anymore
+	return -1;
+}
+
+
+bool SQTable::Set(const SQObjectPtr &key, const SQObjectPtr &val)
+{
+	_HashNode *n = _Get(key, HashObj(key) & (_numofnodes - 1));
+	if (n) {
+		n->val = val;
+		return true;
+	}
+	return false;
+}
+
+void SQTable::_ClearNodes()
+{
+	for(SQInteger i = 0;i < _numofnodes; i++) { _nodes[i].key = _null_; _nodes[i].val = _null_; }
+}
+
+void SQTable::Finalize()
+{
+	_ClearNodes();
+	SetDelegate(NULL);
+}
+
+void SQTable::Clear()
+{
+	_ClearNodes();
+	_usednodes = 0;
+	Rehash(true);
+}

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqtable.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqtable.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqtable.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,91 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQTABLE_H_
+#define _SQTABLE_H_
+/*
+* The following code is based on Lua 4.0 (Copyright 1994-2002 Tecgraf, PUC-Rio.)
+* http://www.lua.org/copyright.html#4
+* http://www.lua.org/source/4.0.1/src_ltable.c.html
+*/
+
+#include "sqstring.h"
+
+
+#define hashptr(p)  ((SQHash)(((SQInteger)p) >> 3))
+
+inline SQHash HashObj(const SQObjectPtr &key)
+{
+	switch(type(key)) {
+		case OT_STRING:		return _string(key)->_hash;
+		case OT_FLOAT:		return (SQHash)((SQInteger)_float(key));
+		case OT_BOOL: case OT_INTEGER:	return (SQHash)((SQInteger)_integer(key));
+		default:			return hashptr(key._unVal.pRefCounted);
+	}
+}
+
+struct SQTable : public SQDelegable 
+{
+private:
+	struct _HashNode
+	{
+		_HashNode() { next = NULL; }
+		SQObjectPtr val;
+		SQObjectPtr key;
+		_HashNode *next;
+	};
+	_HashNode *_firstfree;
+	_HashNode *_nodes;
+	SQInteger _numofnodes;
+	SQInteger _usednodes;
+	
+///////////////////////////
+	void AllocNodes(SQInteger nSize);
+	void Rehash(bool force);
+	SQTable(SQSharedState *ss, SQInteger nInitialSize);
+	void _ClearNodes();
+public:
+	static SQTable* Create(SQSharedState *ss,SQInteger nInitialSize)
+	{
+		SQTable *newtable = (SQTable*)SQ_MALLOC(sizeof(SQTable));
+		new (newtable) SQTable(ss, nInitialSize);
+		newtable->_delegate = NULL;
+		return newtable;
+	}
+	void Finalize();
+	SQTable *Clone();
+	~SQTable()
+	{
+		SetDelegate(NULL);
+		REMOVE_FROM_CHAIN(&_sharedstate->_gc_chain, this);
+		for (SQInteger i = 0; i < _numofnodes; i++) _nodes[i].~_HashNode();
+		SQ_FREE(_nodes, _numofnodes * sizeof(_HashNode));
+	}
+#ifndef NO_GARBAGE_COLLECTOR 
+	void Mark(SQCollectable **chain);
+#endif
+	inline _HashNode *_Get(const SQObjectPtr &key,SQHash hash)
+	{
+		_HashNode *n = &_nodes[hash];
+		do{
+			if(_rawval(n->key) == _rawval(key) && type(n->key) == type(key)){
+				return n;
+			}
+		}while((n = n->next));
+		return NULL;
+	}
+	bool Get(const SQObjectPtr &key,SQObjectPtr &val);
+	void Remove(const SQObjectPtr &key);
+	bool Set(const SQObjectPtr &key, const SQObjectPtr &val);
+	//returns true if a new slot has been created false if it was already present
+	bool NewSlot(const SQObjectPtr &key,const SQObjectPtr &val);
+	SQInteger Next(bool getweakrefs,const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval);
+	
+	SQInteger CountUsed(){ return _usednodes;}
+	void Clear();
+	void Release()
+	{
+		sq_delete(this, SQTable);
+	}
+	
+};
+
+#endif //_SQTABLE_H_

Added: trunk/windstille/lib/SQUIRREL2/squirrel/squirrel.dsp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/squirrel.dsp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/squirrel.dsp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,302 @@
+# Microsoft Developer Studio Project File - Name="squirrel" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=squirrel - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "squirrel.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "squirrel.mak" CFG="squirrel - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "squirrel - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "squirrel - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_LocalPath ".."
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /D "GARBAGE_COLLECTOR" /YX /FD /c
+# ADD BASE RSC /l 0x410 /d "NDEBUG"
+# ADD RSC /l 0x410 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"..\lib\squirrel.lib"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /D "GARBAGE_COLLECTOR" /YX /FD /GZ /c
+# ADD BASE RSC /l 0x410 /d "_DEBUG"
+# ADD RSC /l 0x410 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"..\lib\squirrel.lib"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "squirrel - Win32 Release"
+# Name "squirrel - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\sqapi.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqbaselib.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqcompiler.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqdebug.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqfuncstate.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqlexer.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqmem.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqobject.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstate.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqtable.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqclass.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqvm.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\sqarray.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqclosure.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqcompiler.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqfuncproto.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqfuncstate.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqlexer.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqobject.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqopcodes.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqpcheader.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstate.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstring.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqtable.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\squserdata.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\squtils.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqclass.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqvm.h
+# End Source File
+# End Group
+# End Target
+# End Project

Added: trunk/windstille/lib/SQUIRREL2/squirrel/squserdata.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/squserdata.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/squserdata.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,38 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQUSERDATA_H_
+#define _SQUSERDATA_H_
+
+struct SQUserData : SQDelegable
+{
+	SQUserData(SQSharedState *ss){ _delegate = 0; _hook = NULL; INIT_CHAIN(); ADD_TO_CHAIN(&_ss(this)->_gc_chain, this); }
+	~SQUserData()
+	{
+		REMOVE_FROM_CHAIN(&_ss(this)->_gc_chain, this);
+		SetDelegate(NULL);
+	}
+	static SQUserData* Create(SQSharedState *ss, SQInteger size)
+	{
+		SQUserData* ud = (SQUserData*)SQ_MALLOC(sizeof(SQUserData)+(size-1));
+		new (ud) SQUserData(ss);
+		ud->_size = size;
+		ud->_typetag = 0;
+		return ud;
+	}
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable **chain);
+	void Finalize(){SetDelegate(NULL);}
+#endif
+	void Release() {
+		if (_hook) _hook(_val,_size);
+		SQInteger tsize = _size - 1;
+		this->~SQUserData();
+		SQ_FREE(this, sizeof(SQUserData) + tsize);
+	}
+		
+	SQInteger _size;
+	SQRELEASEHOOK _hook;
+	SQUserPointer _typetag;
+	SQChar _val[1];
+};
+
+#endif //_SQUSERDATA_H_

Added: trunk/windstille/lib/SQUIRREL2/squirrel/squtils.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/squtils.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/squtils.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,104 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQUTILS_H_
+#define _SQUTILS_H_
+
+#define sq_new(__ptr,__type) {__ptr=(__type *)sq_vm_malloc(sizeof(__type));new (__ptr) __type;}
+#define sq_delete(__ptr,__type) {__ptr->~__type();sq_vm_free(__ptr,sizeof(__type));}
+#define SQ_MALLOC(__size) sq_vm_malloc((__size));
+#define SQ_FREE(__ptr,__size) sq_vm_free((__ptr),(__size));
+#define SQ_REALLOC(__ptr,__oldsize,__size) sq_vm_realloc((__ptr),(__oldsize),(__size));
+
+//sqvector mini vector class, supports objects by value
+template<typename T> class sqvector
+{
+public:
+	sqvector()
+	{
+		_vals = NULL;
+		_size = 0;
+		_allocated = 0;
+	}
+	sqvector(const sqvector<T>& v)
+	{
+		copy(v);
+	}
+	void copy(const sqvector<T>& v)
+	{
+		resize(v._size);
+		for(SQUnsignedInteger i = 0; i < v._size; i++) {
+			new ((void *)&_vals[i]) T(v._vals[i]);
+		}
+		_size = v._size;
+	}
+	~sqvector()
+	{
+		if(_allocated) {
+			for(SQUnsignedInteger i = 0; i < _size; i++)
+				_vals[i].~T();
+			SQ_FREE(_vals, (_allocated * sizeof(T)));
+		}
+	}
+	void reserve(SQUnsignedInteger newsize) { _realloc(newsize); }
+	void resize(SQUnsignedInteger newsize, const T& fill = T())
+	{
+		if(newsize > _allocated)
+			_realloc(newsize);
+		if(newsize > _size) {
+			while(_size < newsize) {
+				new ((void *)&_vals[_size]) T(fill);
+				_size++;
+			}
+		}
+		else{
+			for(SQUnsignedInteger i = newsize; i < _size; i++) {
+				_vals[i].~T();
+			}
+			_size = newsize;
+		}
+	}
+	void shrinktofit() { if(_size > 4) { _realloc(_size); } }
+	T& top() const { return _vals[_size - 1]; }
+	inline SQUnsignedInteger size() const { return _size; }
+	bool empty() const { return (_size <= 0); }
+	inline T &push_back(const T& val = T())
+	{
+		if(_allocated <= _size)
+			_realloc(_size * 2);
+		return *(new ((void *)&_vals[_size++]) T(val));
+	}
+	inline void pop_back()
+	{
+		_size--; _vals[_size].~T();
+	}
+	void insert(SQUnsignedInteger idx, const T& val)
+	{
+		resize(_size + 1);
+		for(SQUnsignedInteger i = _size - 1; i > idx; i--) {
+			_vals[i] = _vals[i - 1];
+		}
+    	_vals[idx] = val;
+	}
+	void remove(SQUnsignedInteger idx)
+	{
+		_vals[idx].~T();
+		if(idx < (_size - 1)) {
+			memcpy(&_vals[idx], &_vals[idx+1], sizeof(T) * (_size - idx - 1));
+		}
+		_size--;
+	}
+	SQUnsignedInteger capacity() { return _allocated; }
+	inline T &back() const { return _vals[_size - 1]; }
+	inline T& operator[](SQUnsignedInteger pos) const{ return _vals[pos]; }
+	T* _vals;
+private:
+	void _realloc(SQUnsignedInteger newsize)
+	{
+		newsize = (newsize > 0)?newsize:4;
+		_vals = (T*)SQ_REALLOC(_vals, _allocated * sizeof(T), newsize * sizeof(T));
+		_allocated = newsize;
+	}
+	SQUnsignedInteger _size;
+	SQUnsignedInteger _allocated;
+};
+
+#endif //_SQUTILS_H_

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqvm.cpp
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqvm.cpp	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqvm.cpp	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,1484 @@
+/*
+	see copyright notice in squirrel.h
+*/
+#include "sqpcheader.h"
+#include <math.h>
+#include <stdlib.h>
+#include "sqopcodes.h"
+#include "sqfuncproto.h"
+#include "sqvm.h"
+#include "sqclosure.h"
+#include "sqstring.h"
+#include "sqtable.h"
+#include "squserdata.h"
+#include "sqarray.h"
+#include "sqclass.h"
+
+#define TOP() (_stack._vals[_top-1])
+
+bool SQVM::BW_OP(SQUnsignedInteger op,SQObjectPtr &trg,const SQObjectPtr &o1,const SQObjectPtr &o2)
+{
+	SQInteger res;
+	SQInteger i1 = _integer(o1), i2 = _integer(o2);
+	if((type(o1)==OT_INTEGER) && (type(o2)==OT_INTEGER))
+	{
+		switch(op) {
+			case BW_AND:	res = i1 & i2; break;
+			case BW_OR:		res = i1 | i2; break;
+			case BW_XOR:	res = i1 ^ i2; break;
+			case BW_SHIFTL:	res = i1 << i2; break;
+			case BW_SHIFTR:	res = i1 >> i2; break;
+			case BW_USHIFTR:res = (SQInteger)(*((SQUnsignedInteger*)&i1) >> i2); break;
+			default: { Raise_Error(_SC("internal vm error bitwise op failed")); return false; }
+		}
+	} 
+	else { Raise_Error(_SC("bitwise op between '%s' and '%s'"),GetTypeName(o1),GetTypeName(o2)); return false;}
+	trg = res;
+	return true;
+}
+
+bool SQVM::ARITH_OP(SQUnsignedInteger op,SQObjectPtr &trg,const SQObjectPtr &o1,const SQObjectPtr &o2)
+{
+	if(sq_isnumeric(o1) && sq_isnumeric(o2)) {
+			if((type(o1)==OT_INTEGER) && (type(o2)==OT_INTEGER)) {
+				SQInteger res, i1 = _integer(o1), i2 = _integer(o2);
+				switch(op) {
+				case '+': res = i1 + i2; break;
+				case '-': res = i1 - i2; break;
+				case '/': if(i2 == 0) { Raise_Error(_SC("division by zero")); return false; }
+					res = i1 / i2; 
+					break;
+				case '*': res = i1 * i2; break;
+				case '%': res = i1 % i2; break;
+				default: res = 0xDEADBEEF;
+				}
+				trg = res;
+			}else{
+				SQFloat res, f1 = tofloat(o1), f2 = tofloat(o2);
+				switch(op) {
+				case '+': res = f1 + f2; break;
+				case '-': res = f1 - f2; break;
+				case '/': res = f1 / f2; break;
+				case '*': res = f1 * f2; break;
+				case '%': res = SQFloat(fmod((double)f1,(double)f2)); break;
+				default: res = 0x0f;
+				}
+				trg = res;
+			}	
+		} else {
+			if(op == '+' &&	(type(o1) == OT_STRING || type(o2) == OT_STRING)){
+					if(!StringCat(o1, o2, trg)) return false;
+			}
+			else if(!ArithMetaMethod(op,o1,o2,trg)) { 
+				Raise_Error(_SC("arith op %c on between '%s' and '%s'"),op,GetTypeName(o1),GetTypeName(o2)); return false; 
+			}
+		}
+		return true;
+}
+
+SQVM::SQVM(SQSharedState *ss)
+{
+	_sharedstate=ss;
+	_suspended = SQFalse;
+	_suspended_target=-1;
+	_suspended_root = SQFalse;
+	_suspended_traps=-1;
+	_foreignptr=NULL;
+	_nnativecalls=0;
+	_lasterror = _null_;
+	_errorhandler = _null_;
+	_debughook = _null_;
+	ci = NULL;
+	INIT_CHAIN();ADD_TO_CHAIN(&_ss(this)->_gc_chain,this);
+}
+
+void SQVM::Finalize()
+{
+	_roottable = _null_;
+	_lasterror = _null_;
+	_errorhandler = _null_;
+	_debughook = _null_;
+	temp_reg = _null_;
+	_callstackdata.resize(0);
+	SQInteger size=_stack.size();
+	for(SQInteger i=0;i<size;i++)
+		_stack[i]=_null_;
+}
+
+SQVM::~SQVM()
+{
+	Finalize();
+	//sq_free(_callsstack,_alloccallsstacksize*sizeof(CallInfo));
+	REMOVE_FROM_CHAIN(&_ss(this)->_gc_chain,this);
+}
+
+bool SQVM::ArithMetaMethod(SQInteger op,const SQObjectPtr &o1,const SQObjectPtr &o2,SQObjectPtr &dest)
+{
+	SQMetaMethod mm;
+	switch(op){
+		case _SC('+'): mm=MT_ADD; break;
+		case _SC('-'): mm=MT_SUB; break;
+		case _SC('/'): mm=MT_DIV; break;
+		case _SC('*'): mm=MT_MUL; break;
+		case _SC('%'): mm=MT_MODULO; break;
+		default: mm = MT_ADD; assert(0); break; //shutup compiler
+	}
+	if(is_delegable(o1) && _delegable(o1)->_delegate) {
+		Push(o1);Push(o2);
+		return CallMetaMethod(_delegable(o1),mm,2,dest);
+	}
+	return false;
+}
+
+bool SQVM::NEG_OP(SQObjectPtr &trg,const SQObjectPtr &o)
+{
+	
+	switch(type(o)) {
+	case OT_INTEGER:
+		trg = -_integer(o);
+		return true;
+	case OT_FLOAT:
+		trg = -_float(o);
+		return true;
+	case OT_TABLE:
+	case OT_USERDATA:
+	case OT_INSTANCE:
+		if(_delegable(o)->_delegate) {
+			Push(o);
+			if(CallMetaMethod(_delegable(o), MT_UNM, 1, temp_reg)) {
+				trg = temp_reg;
+				return true;
+			}
+		}
+	default:break; //shutup compiler
+	}
+	Raise_Error(_SC("attempt to negate a %s"), GetTypeName(o));
+	return false;
+}
+
+#define _RET_SUCCEED(exp) { result = (exp); return true; } 
+bool SQVM::ObjCmp(const SQObjectPtr &o1,const SQObjectPtr &o2,SQInteger &result)
+{
+	if(type(o1)==type(o2)){
+		if(_userpointer(o1)==_userpointer(o2))_RET_SUCCEED(0);
+		SQObjectPtr res;
+		switch(type(o1)){
+		case OT_STRING:
+			_RET_SUCCEED(scstrcmp(_stringval(o1),_stringval(o2)));
+		case OT_INTEGER:
+			_RET_SUCCEED(_integer(o1)-_integer(o2));
+		case OT_FLOAT:
+			_RET_SUCCEED((_float(o1)<_float(o2))?-1:1);
+		case OT_TABLE:
+		case OT_USERDATA:
+		case OT_INSTANCE:
+			if(_delegable(o1)->_delegate) {
+				Push(o1);Push(o2);
+				if(CallMetaMethod(_delegable(o1),MT_CMP,2,res)) break;
+			}
+			//continues through (no break needed)
+		default: 
+			_RET_SUCCEED( _userpointer(o1) < _userpointer(o2)?-1:1 );
+		}
+		if(type(res)!=OT_INTEGER) { Raise_CompareError(o1,o2); return false; }
+			_RET_SUCCEED(_integer(res));
+		
+	}
+	else{
+		if(sq_isnumeric(o1) && sq_isnumeric(o2)){
+			if((type(o1)==OT_INTEGER) && (type(o2)==OT_FLOAT)) { 
+				if( _integer(o1)==_float(o2) ) { _RET_SUCCEED(0); }
+				else if( _integer(o1)<_float(o2) ) { _RET_SUCCEED(-1); }
+				_RET_SUCCEED(1);
+			}
+			else{
+				if( _float(o1)==_integer(o2) ) { _RET_SUCCEED(0); }
+				else if( _float(o1)<_integer(o2) ) { _RET_SUCCEED(-1); }
+				_RET_SUCCEED(1);
+			}
+		}
+		else if(type(o1)==OT_NULL) {_RET_SUCCEED(-1);}
+		else if(type(o2)==OT_NULL) {_RET_SUCCEED(1);}
+		else { Raise_CompareError(o1,o2); return false; }
+		
+	}
+	assert(0);
+	_RET_SUCCEED(0); //cannot happen
+}
+
+bool SQVM::CMP_OP(CmpOP op, const SQObjectPtr &o1,const SQObjectPtr &o2,SQObjectPtr &res)
+{
+	SQInteger r;
+	if(ObjCmp(o1,o2,r)) {
+		switch(op) {
+			case CMP_G: res = (r > 0)?_true_:_false_; return true;
+			case CMP_GE: res = (r >= 0)?_true_:_false_; return true;
+			case CMP_L: res = (r < 0)?_true_:_false_; return true;
+			case CMP_LE: res = (r <= 0)?_true_:_false_; return true;
+			
+		}
+		assert(0);
+	}
+	return false;
+}
+
+void SQVM::ToString(const SQObjectPtr &o,SQObjectPtr &res)
+{
+	switch(type(o)) {
+	case OT_STRING:
+		res = o;
+		return;
+	case OT_FLOAT:
+		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)),_SC("%g"),_float(o));
+		break;
+	case OT_INTEGER:
+		scsprintf(_sp(rsl(NUMBER_MAX_CHAR+1)),_SC("%d"),_integer(o));
+		break;
+	case OT_BOOL:
+		scsprintf(_sp(rsl(6)),_integer(o)?_SC("true"):_SC("false"));
+		break;
+	case OT_TABLE:
+	case OT_USERDATA:
+	case OT_INSTANCE:
+		if(_delegable(o)->_delegate) {
+			Push(o);
+			if(CallMetaMethod(_delegable(o),MT_TOSTRING,1,res)) {
+				if(type(res) == OT_STRING)
+					return;
+				//else keeps going to the default
+			}
+		}
+	default:
+		scsprintf(_sp(rsl(sizeof(void*)+20)),_SC("(%s : 0x%p)"),GetTypeName(o),(void*)_rawval(o));
+	}
+	res = SQString::Create(_ss(this),_spval);
+}
+
+
+bool SQVM::StringCat(const SQObjectPtr &str,const SQObjectPtr &obj,SQObjectPtr &dest)
+{
+	SQObjectPtr a, b;
+	ToString(str, a);
+	ToString(obj, b);
+	SQInteger l = _string(a)->_len , ol = _string(b)->_len;
+	SQChar *s = _sp(rsl(l + ol + 1));
+	memcpy(s, _stringval(a), rsl(l)); 
+	memcpy(s + l, _stringval(b), rsl(ol));
+	dest = SQString::Create(_ss(this), _spval, l + ol);
+	return true;
+}
+
+void SQVM::TypeOf(const SQObjectPtr &obj1,SQObjectPtr &dest)
+{
+	if(is_delegable(obj1) && _delegable(obj1)->_delegate) {
+		Push(obj1);
+		if(CallMetaMethod(_delegable(obj1),MT_TYPEOF,1,dest))
+			return;
+	}
+	dest = SQString::Create(_ss(this),GetTypeName(obj1));
+}
+
+bool SQVM::Init(SQVM *friendvm, SQInteger stacksize)
+{
+	_stack.resize(stacksize);
+	//_callsstack.reserve(4);
+	_alloccallsstacksize = 4;
+	_callstackdata.resize(_alloccallsstacksize);
+	_callsstacksize = 0;
+	_callsstack = &_callstackdata[0];
+	//_callsstack = (CallInfo*)sq_malloc(_alloccallsstacksize*sizeof(CallInfo));
+	_stackbase = 0;
+	_top = 0;
+	if(!friendvm) 
+		_roottable = SQTable::Create(_ss(this), 0);
+	else {
+		_roottable = friendvm->_roottable;
+		_errorhandler = friendvm->_errorhandler;
+		_debughook = friendvm->_debughook;
+	}
+	
+	sq_base_register(this);
+	return true;
+}
+
+extern SQInstructionDesc g_InstrDesc[];
+
+bool SQVM::StartCall(SQClosure *closure,SQInteger target,SQInteger args,SQInteger stackbase,bool tailcall)
+{
+	SQFunctionProto *func = _funcproto(closure->_function);
+	
+	const SQInteger paramssize = func->_nparameters;
+	const SQInteger newtop = stackbase + func->_stacksize;
+	SQInteger nargs = args;
+	if (paramssize != nargs) {
+		SQInteger ndef = func->_ndefaultparams;
+		if(ndef && nargs < paramssize) {
+			SQInteger diff = paramssize - nargs;
+			for(SQInteger n = ndef - diff; n < ndef; n++) {
+				_stack._vals[stackbase + (nargs++)] = closure->_defaultparams[n];
+			}
+		}
+		else if(func->_varparams)
+		{
+			if (nargs < paramssize) {
+				Raise_Error(_SC("wrong number of parameters"));
+				return false;
+			}
+			for(SQInteger n = 0; n < nargs - paramssize; n++) {
+				_vargsstack.push_back(_stack._vals[stackbase+paramssize+n]);
+				_stack._vals[stackbase+paramssize+n] = _null_;
+			}
+		}
+		else {
+			Raise_Error(_SC("wrong number of parameters"));
+			return false;
+		}
+	}
+
+	if(type(closure->_env) == OT_WEAKREF) {
+		_stack._vals[stackbase] = _weakref(closure->_env)->_obj;
+	}
+
+	if (!tailcall) {
+		CallInfo lc;
+		lc._generator = NULL;
+		lc._etraps = 0;
+		lc._prevstkbase = (SQInt32) ( stackbase - _stackbase );
+		lc._target = (SQInt32) target;
+		lc._prevtop = (SQInt32) (_top - _stackbase);
+		lc._ncalls = 1;
+		lc._root = SQFalse;
+		PUSH_CALLINFO(this, lc);
+	}
+	else {
+		ci->_ncalls++;
+	}
+	ci->_vargs.size = (SQInt32)(nargs - paramssize);
+	ci->_vargs.base = (SQInt32)(_vargsstack.size()-(ci->_vargs.size));
+	ci->_closure = closure;
+	ci->_literals = func->_literals;
+	ci->_ip = func->_instructions;
+	//grows the stack if needed
+	if (((SQUnsignedInteger)newtop + (func->_stacksize<<1)) > _stack.size()) {
+		_stack.resize(_stack.size() + (func->_stacksize<<1));
+	}
+		
+	_top = newtop;
+	_stackbase = stackbase;
+	if (type(_debughook) != OT_NULL && _rawval(_debughook) != _rawval(ci->_closure))
+		CallDebugHook(_SC('c'));
+	return true;
+}
+
+bool SQVM::Return(SQInteger _arg0, SQInteger _arg1, SQObjectPtr &retval)
+{
+	if (type(_debughook) != OT_NULL && _rawval(_debughook) != _rawval(ci->_closure))
+		for(SQInteger i=0;i<ci->_ncalls;i++)
+			CallDebugHook(_SC('r'));
+			
+	SQBool broot = ci->_root;
+	SQInteger last_top = _top;
+	SQInteger target = ci->_target;
+	SQInteger oldstackbase = _stackbase;
+	_stackbase -= ci->_prevstkbase;
+	_top = _stackbase + ci->_prevtop;
+	if(ci->_vargs.size) PopVarArgs(ci->_vargs);
+	POP_CALLINFO(this);
+	if (broot) {
+		if (_arg0 != MAX_FUNC_STACKSIZE) retval = _stack._vals[oldstackbase+_arg1];
+		else retval = _null_;
+	}
+	else {
+		if(target != -1) { //-1 is when a class contructor ret value has to be ignored
+			if (_arg0 != MAX_FUNC_STACKSIZE)
+				STK(target) = _stack._vals[oldstackbase+_arg1];
+			else
+				STK(target) = _null_;
+		}
+	}
+
+	while (last_top >= _top) _stack._vals[last_top--].Null();
+	assert(oldstackbase >= _stackbase); 
+	return broot?true:false;
+}
+
+#define _RET_ON_FAIL(exp) { if(!exp) return false; }
+
+bool SQVM::LOCAL_INC(SQInteger op,SQObjectPtr &target, SQObjectPtr &a, SQObjectPtr &incr)
+{
+	_RET_ON_FAIL(ARITH_OP( op , target, a, incr));
+	a = target;
+	return true;
+}
+
+bool SQVM::PLOCAL_INC(SQInteger op,SQObjectPtr &target, SQObjectPtr &a, SQObjectPtr &incr)
+{
+ 	SQObjectPtr trg;
+	_RET_ON_FAIL(ARITH_OP( op , trg, a, incr));
+	target = a;
+	a = trg;
+	return true;
+}
+
+bool SQVM::DerefInc(SQInteger op,SQObjectPtr &target, SQObjectPtr &self, SQObjectPtr &key, SQObjectPtr &incr, bool postfix)
+{
+	SQObjectPtr tmp, tself = self, tkey = key;
+	if (!Get(tself, tkey, tmp, false, true)) { Raise_IdxError(tkey); return false; }
+	_RET_ON_FAIL(ARITH_OP( op , target, tmp, incr))
+	Set(tself, tkey, target,true);
+	if (postfix) target = tmp;
+	return true;
+}
+
+#define arg0 (_i_._arg0)
+#define arg1 (_i_._arg1)
+#define sarg1 (*((SQInt32 *)&_i_._arg1))
+#define arg2 (_i_._arg2)
+#define arg3 (_i_._arg3)
+#define sarg3 ((SQInteger)*((signed char *)&_i_._arg3))
+
+SQRESULT SQVM::Suspend()
+{
+	if (_suspended)
+		return sq_throwerror(this, _SC("cannot suspend an already suspended vm"));
+	if (_nnativecalls!=2)
+		return sq_throwerror(this, _SC("cannot suspend through native calls/metamethods"));
+	return SQ_SUSPEND_FLAG;
+}
+
+void SQVM::PopVarArgs(VarArgs &vargs)
+{
+	for(SQInteger n = 0; n< vargs.size; n++)
+		_vargsstack.pop_back();
+}
+
+#define _FINISH(howmuchtojump) {jump = howmuchtojump; return true; }
+bool SQVM::FOREACH_OP(SQObjectPtr &o1,SQObjectPtr &o2,SQObjectPtr 
+&o3,SQObjectPtr &o4,SQInteger arg_2,int exitpos,int &jump)
+{
+	SQInteger nrefidx;
+	switch(type(o1)) {
+	case OT_TABLE:
+		if((nrefidx = _table(o1)->Next(false,o4, o2, o3)) == -1) _FINISH(exitpos);
+		o4 = (SQInteger)nrefidx; _FINISH(1);
+	case OT_ARRAY:
+		if((nrefidx = _array(o1)->Next(o4, o2, o3)) == -1) _FINISH(exitpos);
+		o4 = (SQInteger) nrefidx; _FINISH(1);
+	case OT_STRING:
+		if((nrefidx = _string(o1)->Next(o4, o2, o3)) == -1)_FINISH(exitpos);
+		o4 = (SQInteger)nrefidx; _FINISH(1);
+	case OT_CLASS:
+		if((nrefidx = _class(o1)->Next(o4, o2, o3)) == -1)_FINISH(exitpos);
+		o4 = (SQInteger)nrefidx; _FINISH(1);
+	case OT_USERDATA:
+	case OT_INSTANCE:
+		if(_delegable(o1)->_delegate) {
+			SQObjectPtr itr;
+			Push(o1);
+			Push(o4);
+			if(CallMetaMethod(_delegable(o1), MT_NEXTI, 2, itr)){
+				o4 = o2 = itr;
+				if(type(itr) == OT_NULL) _FINISH(exitpos);
+				if(!Get(o1, itr, o3, false,false)) {
+					Raise_Error(_SC("_nexti returned an invalid idx"));
+					return false;
+				}
+				_FINISH(1);
+			}
+			Raise_Error(_SC("_nexti failed"));
+			return false;
+		}
+		break;
+	case OT_GENERATOR:
+		if(_generator(o1)->_state == SQGenerator::eDead) _FINISH(exitpos);
+		if(_generator(o1)->_state == SQGenerator::eSuspended) {
+			SQInteger idx = 0;
+			if(type(o4) == OT_INTEGER) {
+				idx = _integer(o4) + 1;
+			}
+			o2 = idx;
+			o4 = idx;
+			_generator(o1)->Resume(this, arg_2+1);
+			_FINISH(0);
+		}
+	default: 
+		Raise_Error(_SC("cannot iterate %s"), GetTypeName(o1));
+	}
+	return false; //cannot be hit(just to avoid warnings)
+}
+
+bool SQVM::DELEGATE_OP(SQObjectPtr &trg,SQObjectPtr &o1,SQObjectPtr &o2)
+{
+	if(type(o1) != OT_TABLE) { Raise_Error(_SC("delegating a '%s'"), GetTypeName(o1)); return false; }
+	switch(type(o2)) {
+	case OT_TABLE:
+		if(!_table(o1)->SetDelegate(_table(o2))){
+			Raise_Error(_SC("delegate cycle detected"));
+			return false;
+		}
+		break;
+	case OT_NULL:
+		_table(o1)->SetDelegate(NULL);
+		break;
+	default:
+		Raise_Error(_SC("using '%s' as delegate"), GetTypeName(o2));
+		return false;
+		break;
+	}
+	trg = o1;
+	return true;
+}
+#define COND_LITERAL (arg3!=0?ci->_literals[arg1]:STK(arg1))
+
+#define _GUARD(exp) { if(!exp) { Raise_Error(_lasterror); SQ_THROW();} }
+
+#define SQ_THROW() { goto exception_trap; }
+
+bool SQVM::CLOSURE_OP(SQObjectPtr &target, SQFunctionProto *func)
+{
+	SQInteger nouters;
+	SQClosure *closure = SQClosure::Create(_ss(this), func);
+	if((nouters = func->_noutervalues)) {
+		closure->_outervalues.reserve(nouters);
+		for(SQInteger i = 0; i<nouters; i++) {
+			SQOuterVar &v = func->_outervalues[i];
+			switch(v._type){
+			case otSYMBOL:
+				closure->_outervalues.push_back(_null_);
+				if(!Get(_stack._vals[_stackbase]/*STK(0)*/, v._src, closure->_outervalues.top(), false,true))
+				{Raise_IdxError(v._src); return false; }
+				break;
+			case otLOCAL:
+				closure->_outervalues.push_back(_stack._vals[_stackbase+_integer(v._src)]);
+				break;
+			case otOUTER:
+				closure->_outervalues.push_back(_closure(ci->_closure)->_outervalues[_integer(v._src)]);
+				break;
+			}
+		}
+	}
+	SQInteger ndefparams;
+	if((ndefparams = func->_ndefaultparams)) {
+		closure->_defaultparams.reserve(ndefparams);
+		for(SQInteger i = 0; i < ndefparams; i++) {
+			SQInteger spos = func->_defaultparams[i];
+			closure->_defaultparams.push_back(_stack._vals[_stackbase + spos]);
+		}
+	}
+	target = closure;
+	return true;
+
+}
+
+bool SQVM::GETVARGV_OP(SQObjectPtr &target,SQObjectPtr &index,CallInfo *ci)
+{
+	if(ci->_vargs.size == 0) {
+		Raise_Error(_SC("the function doesn't have var args"));
+		return false;
+	}
+	if(!sq_isnumeric(index)){
+		Raise_Error(_SC("indexing 'vargv' with %s"),GetTypeName(index));
+		return false;
+	}
+	SQInteger idx = tointeger(index);
+	if(idx < 0 || idx >= ci->_vargs.size){ Raise_Error(_SC("vargv index out of range")); return false; }
+	target = _vargsstack[ci->_vargs.base+idx];
+	return true;
+}
+
+bool SQVM::CLASS_OP(SQObjectPtr &target,SQInteger baseclass,SQInteger attributes)
+{
+	SQClass *base = NULL;
+	SQObjectPtr attrs;
+	if(baseclass != -1) {
+		if(type(_stack._vals[_stackbase+baseclass]) != OT_CLASS) { Raise_Error(_SC("trying to inherit from a %s"),GetTypeName(_stack._vals[_stackbase+baseclass])); return false; }
+		base = _class(_stack._vals[_stackbase + baseclass]);
+	}
+	if(attributes != MAX_FUNC_STACKSIZE) {
+		attrs = _stack._vals[_stackbase+attributes];
+	}
+	target = SQClass::Create(_ss(this),base);
+	if(type(_class(target)->_metamethods[MT_INHERITED]) != OT_NULL) {
+		int nparams = 2;
+		SQObjectPtr ret;
+		Push(target); Push(attrs);
+		Call(_class(target)->_metamethods[MT_INHERITED],nparams,_top - nparams, ret, false);
+		Pop(nparams);
+	}
+	_class(target)->_attributes = attrs;
+	return true;
+}
+
+
+
+bool SQVM::IsEqual(SQObjectPtr &o1,SQObjectPtr &o2,bool &res)
+{
+	if(type(o1) == type(o2)) {
+		res = ((_userpointer(o1) == _userpointer(o2)?true:false));
+	}
+	else {
+		if(sq_isnumeric(o1) && sq_isnumeric(o2)) {
+			SQInteger cmpres;
+			if(!ObjCmp(o1, o2,cmpres)) return false;
+			res = (cmpres == 0);
+		}
+		else {
+			res = false;
+		}
+	}
+	return true;
+}
+
+bool SQVM::IsFalse(SQObjectPtr &o)
+{
+	if((type(o) & SQOBJECT_CANBEFALSE) && ( (type(o) == OT_FLOAT) && (_float(o) == SQFloat(0.0)) )
+		|| (_integer(o) == 0) ) { //OT_NULL|OT_INTEGER|OT_BOOL
+		return true;
+	}
+	return false;
+}
+
+bool SQVM::GETPARENT_OP(SQObjectPtr &o,SQObjectPtr &target)
+{
+	switch(type(o)) {
+		case OT_TABLE: target = _table(o)->_delegate?SQObjectPtr(_table(o)->_delegate):_null_;
+			break;
+		case OT_CLASS: target = _class(o)->_base?_class(o)->_base:_null_;
+			break;
+		default:
+			Raise_Error(_SC("the %s type doesn't have a parent slot"), GetTypeName(o));
+			return false;
+	}
+	return true;
+}
+
+bool SQVM::Execute(SQObjectPtr &closure, SQInteger target, SQInteger nargs, SQInteger stackbase,SQObjectPtr &outres, SQBool raiseerror,ExecutionType et)
+{
+	if ((_nnativecalls + 1) > MAX_NATIVE_CALLS) { Raise_Error(_SC("Native stack overflow")); return false; }
+	_nnativecalls++;
+	AutoDec ad(&_nnativecalls);
+	SQInteger traps = 0;
+	//temp_reg vars for OP_CALL
+	SQInteger ct_target;
+	SQInteger ct_stackbase;
+	bool ct_tailcall; 
+
+	switch(et) {
+		case ET_CALL: 
+			if(!StartCall(_closure(closure), _top - nargs, nargs, stackbase, false)) { 
+				//call the handler if there are no calls in the stack, if not relies on the previous node
+				if(ci == NULL) CallErrorHandler(_lasterror);
+				return false;
+			}
+			ci->_root = SQTrue;
+			break;
+		case ET_RESUME_GENERATOR: _generator(closure)->Resume(this, target); ci->_root = SQTrue; traps += ci->_etraps; break;
+		case ET_RESUME_VM:
+			traps = _suspended_traps;
+			ci->_root = _suspended_root;
+			ci->_vargs = _suspend_varargs;
+			_suspended = SQFalse;
+			break;
+	}
+	
+exception_restore:
+	//
+	{
+		for(;;)
+		{
+			const SQInstruction &_i_ = *ci->_ip++;
+			//dumpstack(_stackbase);
+			//scprintf("\n[%d] %s %d %d %d %d\n",ci->_ip-ci->_iv->_vals,g_InstrDesc[_i_.op].name,arg0,arg1,arg2,arg3);
+			switch(_i_.op)
+			{
+			case _OP_LINE:
+				if(type(_debughook) != OT_NULL && _rawval(_debughook) != _rawval(ci->_closure))
+					CallDebugHook(_SC('l'),arg1);
+				continue;
+			case _OP_LOAD: TARGET = ci->_literals[arg1]; continue;
+			case _OP_LOADINT: TARGET = (SQInteger)arg1; continue;
+			case _OP_LOADFLOAT: TARGET = *((SQFloat *)&arg1); continue;
+			case _OP_DLOAD: TARGET = ci->_literals[arg1]; STK(arg2) = ci->_literals[arg3];continue;
+			case _OP_TAILCALL:
+				temp_reg = STK(arg1);
+				if (type(temp_reg) == OT_CLOSURE){ 
+					ct_tailcall = true;
+					if(ci->_vargs.size) PopVarArgs(ci->_vargs);
+					for (SQInteger i = 0; i < arg3; i++) STK(i) = STK(arg2 + i);
+					ct_target = ci->_target;
+					ct_stackbase = _stackbase;
+					goto common_call;
+				}
+			case _OP_CALL: {
+					ct_tailcall = false;
+					ct_target = arg0;
+					temp_reg = STK(arg1);
+					ct_stackbase = _stackbase+arg2;
+
+common_call:
+					SQObjectPtr clo = temp_reg;
+					SQInteger last_top = _top;
+					switch (type(clo)) {
+					case OT_CLOSURE:{
+						_GUARD(StartCall(_closure(clo), ct_target, arg3, ct_stackbase, ct_tailcall));
+						if (_funcproto(_closure(clo)->_function)->_bgenerator) {
+							SQGenerator *gen = SQGenerator::Create(_ss(this), _closure(clo));
+							_GUARD(gen->Yield(this));
+							Return(1, ct_target, clo);
+							STK(ct_target) = gen;
+							while (last_top >= _top) _stack._vals[last_top--].Null();
+							continue;
+						}
+						}
+						continue;
+					case OT_NATIVECLOSURE: {
+						bool suspend;
+						_GUARD(CallNative(_nativeclosure(clo), arg3, ct_stackbase, clo,suspend));
+						if(suspend){
+							_suspended = SQTrue;
+							_suspended_target = ct_target;
+							_suspended_root = ci->_root;
+							_suspended_traps = traps;
+							_suspend_varargs = ci->_vargs;
+							outres = clo;
+							return true;
+						}
+						if(ct_target != -1) { //skip return value for constructors
+							STK(ct_target) = clo;
+						}
+										   }
+						continue;
+					case OT_CLASS:{
+						SQObjectPtr inst;
+						_GUARD(CreateClassInstance(_class(clo),inst,temp_reg));
+						STK(ct_target) = inst;
+						ct_target = -1; //fakes return value target so that is not overwritten by the constructor
+						if(type(temp_reg) != OT_NULL) {
+							_stack._vals[ct_stackbase] = inst;
+							goto common_call; //hard core spaghetti code(reissues the OP_CALL to invoke the constructor)
+						}
+						}
+						break;
+					case OT_TABLE:
+					case OT_USERDATA:
+					case OT_INSTANCE:
+						{
+						Push(clo);
+						for (SQInteger i = 0; i < arg3; i++) Push(STK(arg2 + i));
+						if (_delegable(clo) && CallMetaMethod(_delegable(clo), MT_CALL, arg3+1, clo)){
+							STK(ct_target) = clo;
+							break;
+						}
+						Raise_Error(_SC("attempt to call '%s'"), GetTypeName(clo));
+						SQ_THROW();
+					  }
+					default:
+						Raise_Error(_SC("attempt to call '%s'"), GetTypeName(clo));
+						SQ_THROW();
+					}
+				}
+				  continue;
+			case _OP_PREPCALL:
+			case _OP_PREPCALLK:
+				{
+					SQObjectPtr &key = _i_.op == _OP_PREPCALLK?(ci->_literals)[arg1]:STK(arg1);
+					SQObjectPtr &o = STK(arg2);
+					if (!Get(o, key, temp_reg,false,true)) {
+						if(type(o) == OT_CLASS) { //hack?
+							if(_class_ddel->Get(key,temp_reg)) {
+								STK(arg3) = o;
+								TARGET = temp_reg;
+								continue;
+							}
+						}
+						{ Raise_IdxError(key); SQ_THROW();}
+					}
+
+					STK(arg3) = type(o) == OT_CLASS?STK(0):o;
+					TARGET = temp_reg;
+				}
+				continue;
+			case _OP_GETK:
+				if (!Get(STK(arg2), ci->_literals[arg1], temp_reg, false,true)) { Raise_IdxError(ci->_literals[arg1]); SQ_THROW();}
+				TARGET = temp_reg;
+				continue;
+			case _OP_MOVE: TARGET = STK(arg1); continue;
+			case _OP_NEWSLOT:
+				_GUARD(NewSlot(STK(arg1), STK(arg2), STK(arg3),false));
+				if(arg0 != arg3) TARGET = STK(arg3);
+				continue;
+			case _OP_DELETE: _GUARD(DeleteSlot(STK(arg1), STK(arg2), TARGET)); continue;
+			case _OP_SET:
+				if (!Set(STK(arg1), STK(arg2), STK(arg3),true)) { Raise_IdxError(STK(arg2)); SQ_THROW(); }
+				if (arg0 != arg3) TARGET = STK(arg3);
+				continue;
+			case _OP_GET:
+				if (!Get(STK(arg1), STK(arg2), temp_reg, false,true)) { Raise_IdxError(STK(arg2)); SQ_THROW(); }
+				TARGET = temp_reg;
+				continue;
+			case _OP_EQ:{
+				bool res;
+				if(!IsEqual(STK(arg2),COND_LITERAL,res)) { SQ_THROW(); }
+				TARGET = res?_true_:_false_;
+				}continue;
+			case _OP_NE:{ 
+				bool res;
+				if(!IsEqual(STK(arg2),COND_LITERAL,res)) { SQ_THROW(); }
+				TARGET = (!res)?_true_:_false_;
+				} continue;
+			case _OP_ARITH: _GUARD(ARITH_OP( arg3 , temp_reg, STK(arg2), STK(arg1))); TARGET = temp_reg; continue;
+			case _OP_BITW:	_GUARD(BW_OP( arg3,TARGET,STK(arg2),STK(arg1))); continue;
+			case _OP_RETURN:
+				if(ci->_generator) {
+					ci->_generator->Kill();
+				}
+				if(Return(arg0, arg1, temp_reg)){
+					assert(traps==0);
+					outres = temp_reg;
+					return true;
+				}
+				continue;
+			case _OP_LOADNULLS:{ for(SQInt32 n=0; n < arg1; n++) STK(arg0+n) = _null_; }continue;
+			case _OP_LOADROOTTABLE:	TARGET = _roottable; continue;
+			case _OP_LOADBOOL: TARGET = arg1?_true_:_false_; continue;
+			case _OP_DMOVE: STK(arg0) = STK(arg1); STK(arg2) = STK(arg3); continue;
+			case _OP_JMP: ci->_ip += (sarg1); continue;
+			case _OP_JNZ: if(!IsFalse(STK(arg0))) ci->_ip+=(sarg1); continue;
+			case _OP_JZ: if(IsFalse(STK(arg0))) ci->_ip+=(sarg1); continue;
+			case _OP_LOADFREEVAR: TARGET = _closure(ci->_closure)->_outervalues[arg1]; continue;
+			case _OP_VARGC: TARGET = SQInteger(ci->_vargs.size); continue;
+			case _OP_GETVARGV: 
+				if(!GETVARGV_OP(TARGET,STK(arg1),ci)) { SQ_THROW(); } 
+				continue;
+			case _OP_NEWTABLE: TARGET = SQTable::Create(_ss(this), arg1); continue;
+			case _OP_NEWARRAY: TARGET = SQArray::Create(_ss(this), 0); _array(TARGET)->Reserve(arg1); continue;
+			case _OP_APPENDARRAY: _array(STK(arg0))->Append(COND_LITERAL);	continue;
+			case _OP_GETPARENT: _GUARD(GETPARENT_OP(STK(arg1),TARGET)); continue;
+			case _OP_COMPARITH: _GUARD(DerefInc(arg3, TARGET, STK((((SQUnsignedInteger)arg1&0xFFFF0000)>>16)), STK(arg2), STK(arg1&0x0000FFFF), false)); continue;
+			case _OP_COMPARITHL: _GUARD(LOCAL_INC(arg3, TARGET, STK(arg1), STK(arg2))); continue;
+			case _OP_INC: {SQObjectPtr o(sarg3); _GUARD(DerefInc('+',TARGET, STK(arg1), STK(arg2), o, false));} continue;
+			case _OP_INCL: {SQObjectPtr o(sarg3); _GUARD(LOCAL_INC('+',TARGET, STK(arg1), o));} continue;
+			case _OP_PINC: {SQObjectPtr o(sarg3); _GUARD(DerefInc('+',TARGET, STK(arg1), STK(arg2), o, true));} continue;
+			case _OP_PINCL:	{SQObjectPtr o(sarg3); _GUARD(PLOCAL_INC('+',TARGET, STK(arg1), o));} continue;
+			case _OP_CMP:	_GUARD(CMP_OP((CmpOP)arg3,STK(arg2),STK(arg1),TARGET))	continue;
+			case _OP_EXISTS: TARGET = Get(STK(arg1), STK(arg2), temp_reg, true,false)?_true_:_false_;continue;
+			case _OP_INSTANCEOF: 
+				if(type(STK(arg1)) != OT_CLASS || type(STK(arg2)) != OT_INSTANCE)
+				{Raise_Error(_SC("cannot apply instanceof between a %s and a %s"),GetTypeName(STK(arg1)),GetTypeName(STK(arg2))); SQ_THROW();}
+				TARGET = _instance(STK(arg2))->InstanceOf(_class(STK(arg1)))?_true_:_false_;
+				continue;
+			case _OP_AND: 
+				if(IsFalse(STK(arg2))) {
+					TARGET = STK(arg2);
+					ci->_ip += (sarg1);
+				}
+				continue;
+			case _OP_OR:
+				if(!IsFalse(STK(arg2))) {
+					TARGET = STK(arg2);
+					ci->_ip += (sarg1);
+				}
+				continue;
+			case _OP_NEG: _GUARD(NEG_OP(TARGET,STK(arg1))); continue;
+			case _OP_NOT: TARGET = (IsFalse(STK(arg1))?_true_:_false_); continue;
+			case _OP_BWNOT:
+				if(type(STK(arg1)) == OT_INTEGER) {
+					SQInteger t = _integer(STK(arg1));
+					TARGET = SQInteger(~t);
+					continue;
+				}
+				Raise_Error(_SC("attempt to perform a bitwise op on a %s"), GetTypeName(STK(arg1)));
+				SQ_THROW();
+			case _OP_CLOSURE: {
+				SQClosure *c = ci->_closure._unVal.pClosure;
+				SQFunctionProto *fp = c->_function._unVal.pFunctionProto;
+				if(!CLOSURE_OP(TARGET,fp->_functions[arg1]._unVal.pFunctionProto)) { SQ_THROW(); }
+				continue;
+			}
+			case _OP_YIELD:{
+				if(ci->_generator) {
+					if(sarg1 != MAX_FUNC_STACKSIZE) temp_reg = STK(arg1);
+					_GUARD(ci->_generator->Yield(this));
+					traps -= ci->_etraps;
+					if(sarg1 != MAX_FUNC_STACKSIZE) STK(arg1) = temp_reg;
+				}
+				else { Raise_Error(_SC("trying to yield a '%s',only genenerator can be yielded"), GetTypeName(ci->_generator)); SQ_THROW();}
+				if(Return(arg0, arg1, temp_reg)){
+					assert(traps == 0);
+					outres = temp_reg;
+					return true;
+				}
+					
+				}
+				continue;
+			case _OP_RESUME:
+				if(type(STK(arg1)) != OT_GENERATOR){ Raise_Error(_SC("trying to resume a '%s',only genenerator can be resumed"), GetTypeName(STK(arg1))); SQ_THROW();}
+				_GUARD(_generator(STK(arg1))->Resume(this, arg0));
+				traps += ci->_etraps;
+                continue;
+			case _OP_FOREACH:{ int tojump;
+				_GUARD(FOREACH_OP(STK(arg0),STK(arg2),STK(arg2+1),STK(arg2+2),arg2,sarg1,tojump));
+				ci->_ip += tojump; }
+				continue;
+			case _OP_POSTFOREACH:
+				assert(type(STK(arg0)) == OT_GENERATOR);
+				if(_generator(STK(arg0))->_state == SQGenerator::eDead) 
+					ci->_ip += (sarg1 - 1);
+				continue;
+			case _OP_DELEGATE: _GUARD(DELEGATE_OP(TARGET,STK(arg1),STK(arg2))); continue;
+			case _OP_CLONE:
+				if(!Clone(STK(arg1), TARGET))
+				{ Raise_Error(_SC("cloning a %s"), GetTypeName(STK(arg1))); SQ_THROW();}
+				continue;
+			case _OP_TYPEOF: TypeOf(STK(arg1), TARGET); continue;
+			case _OP_PUSHTRAP:{
+				SQInstruction *_iv = _funcproto(_closure(ci->_closure)->_function)->_instructions;
+				_etraps.push_back(SQExceptionTrap(_top,_stackbase, &_iv[(ci->_ip-_iv)+arg1], arg0)); traps++;
+				ci->_etraps++;
+							  }
+				continue;
+			case _OP_POPTRAP: {
+				for(SQInteger i = 0; i < arg0; i++) {
+					_etraps.pop_back(); traps--;
+					ci->_etraps--;
+				}
+							  }
+				continue;
+			case _OP_THROW:	Raise_Error(TARGET); SQ_THROW(); continue;
+			case _OP_CLASS: _GUARD(CLASS_OP(TARGET,arg1,arg2)); continue;
+			case _OP_NEWSLOTA:
+				bool bstatic = (arg0&NEW_SLOT_STATIC_FLAG)?true:false;
+				if(type(STK(arg1)) == OT_CLASS) {
+					if(type(_class(STK(arg1))->_metamethods[MT_NEWMEMBER]) != OT_NULL ) {
+						Push(STK(arg1)); Push(STK(arg2)); Push(STK(arg3));
+						Push((arg0&NEW_SLOT_ATTRIBUTES_FLAG) ? STK(arg2-1) : _null_);
+						int nparams = 4;
+						if(Call(_class(STK(arg1))->_metamethods[MT_NEWMEMBER], nparams, _top - nparams, temp_reg,SQFalse)) {
+							Pop(nparams);
+							continue;
+						}
+					}
+				}
+				_GUARD(NewSlot(STK(arg1), STK(arg2), STK(arg3),bstatic));
+				if((arg0&NEW_SLOT_ATTRIBUTES_FLAG)) {
+					_class(STK(arg1))->SetAttributes(STK(arg2),STK(arg2-1));
+				}
+				continue;
+			}
+			
+		}
+	}
+exception_trap:
+	{
+		SQObjectPtr currerror = _lasterror;
+//		dumpstack(_stackbase);
+		SQInteger n = 0;
+		SQInteger last_top = _top;
+		if(ci) {
+			if(_ss(this)->_notifyallexceptions) CallErrorHandler(currerror);
+
+			if(traps) {
+				do {
+					if(ci->_etraps > 0) {
+						SQExceptionTrap &et = _etraps.top();
+						ci->_ip = et._ip;
+						_top = et._stacksize;
+						_stackbase = et._stackbase;
+						_stack._vals[_stackbase+et._extarget] = currerror;
+						_etraps.pop_back(); traps--; ci->_etraps--;
+						while(last_top >= _top) _stack._vals[last_top--].Null();
+						goto exception_restore;
+					}
+					//if is a native closure
+					if(type(ci->_closure) != OT_CLOSURE && n)
+						break;
+					if(ci->_generator) ci->_generator->Kill();
+					PopVarArgs(ci->_vargs);
+					POP_CALLINFO(this);
+					n++;
+				} while(_callsstacksize);
+			}
+			else {
+				//call the hook
+				if(raiseerror && !_ss(this)->_notifyallexceptions)
+					CallErrorHandler(currerror);
+			}
+			//remove call stack until a C function is found or the cstack is empty
+			if(ci) do {
+				SQBool exitafterthisone = ci->_root;
+				if(ci->_generator) ci->_generator->Kill();
+				_stackbase -= ci->_prevstkbase;
+				_top = _stackbase + ci->_prevtop;
+				PopVarArgs(ci->_vargs);
+				POP_CALLINFO(this);
+				if( (ci && type(ci->_closure) != OT_CLOSURE) || exitafterthisone) break;
+			} while(_callsstacksize);
+
+			while(last_top >= _top) _stack._vals[last_top--].Null();
+		}
+		_lasterror = currerror;
+		return false;
+	}
+	assert(0);
+}
+
+bool SQVM::CreateClassInstance(SQClass *theclass, SQObjectPtr &inst, SQObjectPtr &constructor)
+{
+	inst = theclass->CreateInstance();
+	if(!theclass->Get(_ss(this)->_constructoridx,constructor)) {
+		//if(!Call(constr,nargs,stackbase,constr,false))
+		//	return false;
+		constructor = _null_;
+	}
+	return true;
+}
+
+void SQVM::CallErrorHandler(SQObjectPtr &error)
+{
+	if(type(_errorhandler) != OT_NULL) {
+		SQObjectPtr out;
+		Push(_roottable); Push(error);
+		Call(_errorhandler, 2, _top-2, out,SQFalse);
+		Pop(2);
+	}
+}
+
+void SQVM::CallDebugHook(SQInteger type,SQInteger forcedline)
+{
+	SQObjectPtr temp_reg;
+	SQInteger nparams=5;
+	SQFunctionProto *func=_funcproto(_closure(ci->_closure)->_function);
+	Push(_roottable); Push(type); Push(func->_sourcename); Push(forcedline?forcedline:func->GetLine(ci->_ip)); Push(func->_name);
+	Call(_debughook,nparams,_top-nparams,temp_reg,SQFalse);
+	Pop(nparams);
+}
+
+bool SQVM::CallNative(SQNativeClosure *nclosure,SQInteger nargs,SQInteger stackbase,SQObjectPtr &retval,bool &suspend)
+{
+	if (_nnativecalls + 1 > MAX_NATIVE_CALLS) { Raise_Error(_SC("Native stack overflow")); return false; }
+	SQInteger nparamscheck = nclosure->_nparamscheck;
+	if(((nparamscheck > 0) && (nparamscheck != nargs))
+		|| ((nparamscheck < 0) && (nargs < (-nparamscheck)))) {
+		Raise_Error(_SC("wrong number of parameters"));
+		return false;
+		}
+
+	SQInteger tcs;
+	if((tcs = nclosure->_typecheck.size())) {
+		for(SQInteger i = 0; i < nargs && i < tcs; i++)
+			if((nclosure->_typecheck._vals[i] != -1) && !(type(_stack._vals[stackbase+i]) & nclosure->_typecheck[i])) {
+                Raise_ParamTypeError(i,nclosure->_typecheck._vals[i],type(_stack._vals[stackbase+i]));
+				return false;
+			}
+	}
+	_nnativecalls++;
+	if ((_top + MIN_STACK_OVERHEAD) > (SQInteger)_stack.size()) {
+		_stack.resize(_stack.size() + (MIN_STACK_OVERHEAD<<1));
+	}
+	SQInteger oldtop = _top;
+	SQInteger oldstackbase = _stackbase;
+	_top = stackbase + nargs;
+	CallInfo lci;
+	lci._closure = nclosure;
+	lci._generator = NULL;
+	lci._etraps = 0;
+	lci._prevstkbase = (SQInt32) (stackbase - _stackbase);
+	lci._ncalls = 1;
+	lci._prevtop = (SQInt32) (oldtop - oldstackbase);
+	PUSH_CALLINFO(this, lci);
+	_stackbase = stackbase;
+	//push free variables
+	SQInteger outers = nclosure->_outervalues.size();
+	for (SQInteger i = 0; i < outers; i++) {
+		Push(nclosure->_outervalues[i]);
+	}
+
+	if(type(nclosure->_env) == OT_WEAKREF) {
+		_stack[stackbase] = _weakref(nclosure->_env)->_obj;
+	}
+
+	
+	SQInteger ret = (nclosure->_function)(this);
+	_nnativecalls--;
+	suspend = false;
+	if( ret == SQ_SUSPEND_FLAG) suspend = true;
+	else if (ret < 0) { 
+		_stackbase = oldstackbase;
+		_top = oldtop;
+		POP_CALLINFO(this);
+		Raise_Error(_lasterror);
+		return false;
+	}
+	
+	if (ret != 0){ retval = TOP(); }
+	else { retval = _null_; }
+	_stackbase = oldstackbase;
+	_top = oldtop;
+	POP_CALLINFO(this);
+	return true;
+}
+
+bool SQVM::Get(const SQObjectPtr &self,const SQObjectPtr &key,SQObjectPtr &dest,bool raw, bool fetchroot)
+{
+	switch(type(self)){
+	case OT_TABLE:
+		if(_table(self)->Get(key,dest))return true;
+		break;
+	case OT_ARRAY:
+		if(sq_isnumeric(key)){
+			return _array(self)->Get(tointeger(key),dest);
+		}
+		break;
+	case OT_INSTANCE:
+		if(_instance(self)->Get(key,dest)) return true;
+		break;
+	default:break; //shut up compiler
+	}
+	if(FallBackGet(self,key,dest,raw)) return true;
+
+	if(fetchroot) {
+		if(_rawval(STK(0)) == _rawval(self) &&
+			type(STK(0)) == type(self)) {
+				return _table(_roottable)->Get(key,dest);
+		}
+	}
+	return false;
+}
+
+bool SQVM::FallBackGet(const SQObjectPtr &self,const SQObjectPtr &key,SQObjectPtr &dest,bool raw)
+{
+	switch(type(self)){
+	case OT_CLASS: 
+		return _class(self)->Get(key,dest);
+		break;
+	case OT_TABLE:
+	case OT_USERDATA:
+        //delegation
+		if(_delegable(self)->_delegate) {
+			if(Get(SQObjectPtr(_delegable(self)->_delegate),key,dest,raw,false))
+				return true;	
+			if(raw)return false;
+			Push(self);Push(key);
+			if(CallMetaMethod(_delegable(self),MT_GET,2,dest))
+				return true;
+		}
+		if(type(self) == OT_TABLE) {
+			if(raw) return false;
+			return _table_ddel->Get(key,dest);
+		}
+		return false;
+		break;
+	case OT_ARRAY:
+		if(raw)return false;
+		return _array_ddel->Get(key,dest);
+	case OT_STRING:
+		if(sq_isnumeric(key)){
+			SQInteger n=tointeger(key);
+			if(abs((int)n)<_string(self)->_len){
+				if(n<0)n=_string(self)->_len-n;
+				dest=SQInteger(_stringval(self)[n]);
+				return true;
+			}
+			return false;
+		}
+		else {
+			if(raw)return false;
+			return _string_ddel->Get(key,dest);
+		}
+		break;
+	case OT_INSTANCE:
+		if(raw)return false;
+		Push(self);Push(key);
+		if(!CallMetaMethod(_delegable(self),MT_GET,2,dest)) {
+			return _instance_ddel->Get(key,dest);
+		}
+		return true;
+	case OT_INTEGER:case OT_FLOAT:case OT_BOOL: 
+		if(raw)return false;
+		return _number_ddel->Get(key,dest);
+	case OT_GENERATOR: 
+		if(raw)return false;
+		return _generator_ddel->Get(key,dest);
+	case OT_CLOSURE: case OT_NATIVECLOSURE:	
+		if(raw)return false;
+		return _closure_ddel->Get(key,dest);
+	case OT_THREAD:
+		if(raw)return false;
+		return  _thread_ddel->Get(key,dest);
+	case OT_WEAKREF:
+		if(raw)return false;
+		return  _weakref_ddel->Get(key,dest);
+	default:return false;
+	}
+	return false;
+}
+
+bool SQVM::Set(const SQObjectPtr &self,const SQObjectPtr &key,const SQObjectPtr &val,bool fetchroot)
+{
+	switch(type(self)){
+	case OT_TABLE:
+		if(_table(self)->Set(key,val))
+			return true;
+		if(_table(self)->_delegate) {
+			if(Set(_table(self)->_delegate,key,val,false)) {
+				return true;
+			}
+		}
+		//keeps going
+	case OT_USERDATA:
+		if(_delegable(self)->_delegate) {
+			SQObjectPtr t;
+			Push(self);Push(key);Push(val);
+			if(CallMetaMethod(_delegable(self),MT_SET,3,t)) return true;
+		}
+		break;
+	case OT_INSTANCE:{
+		if(_instance(self)->Set(key,val))
+			return true;
+		SQObjectPtr t;
+		Push(self);Push(key);Push(val);
+		if(CallMetaMethod(_delegable(self),MT_SET,3,t)) return true;
+		}
+		break;
+	case OT_ARRAY:
+		if(!sq_isnumeric(key)) {Raise_Error(_SC("indexing %s with %s"),GetTypeName(self),GetTypeName(key)); return false; }
+		return _array(self)->Set(tointeger(key),val);
+	default:
+		Raise_Error(_SC("trying to set '%s'"),GetTypeName(self));
+		return false;
+	}
+	if(fetchroot) {
+		if(_rawval(STK(0)) == _rawval(self) &&
+			type(STK(0)) == type(self)) {
+				return _table(_roottable)->Set(key,val);
+			}
+	}
+	return false;
+}
+
+bool SQVM::Clone(const SQObjectPtr &self,SQObjectPtr &target)
+{
+	SQObjectPtr temp_reg;
+	SQObjectPtr newobj;
+	switch(type(self)){
+	case OT_TABLE:
+		newobj = _table(self)->Clone();
+		goto cloned_mt;
+	case OT_INSTANCE:
+		newobj = _instance(self)->Clone(_ss(this));
+cloned_mt:
+		if(_delegable(newobj)->_delegate){
+			Push(newobj);
+			Push(self);
+			CallMetaMethod(_delegable(newobj),MT_CLONED,2,temp_reg);
+		}
+		target = newobj;
+		return true;
+	case OT_ARRAY: 
+		target = _array(self)->Clone();
+		return true;
+	default: return false;
+	}
+}
+
+bool SQVM::NewSlot(const SQObjectPtr &self,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)
+{
+	if(type(key) == OT_NULL) { Raise_Error(_SC("null cannot be used as index")); return false; }
+	switch(type(self)) {
+	case OT_TABLE: {
+		bool rawcall = true;
+		if(_table(self)->_delegate) {
+			SQObjectPtr res;
+			if(!_table(self)->Get(key,res)) {
+				Push(self);Push(key);Push(val);
+				rawcall = !CallMetaMethod(_table(self),MT_NEWSLOT,3,res);
+			}
+		}
+		if(rawcall) _table(self)->NewSlot(key,val); //cannot fail
+		
+		break;}
+	case OT_INSTANCE: {
+		SQObjectPtr res;
+		Push(self);Push(key);Push(val);
+		if(!CallMetaMethod(_instance(self),MT_NEWSLOT,3,res)) {
+			Raise_Error(_SC("class instances do not support the new slot operator"));
+			return false;
+		}
+		break;}
+	case OT_CLASS: 
+		if(!_class(self)->NewSlot(_ss(this),key,val,bstatic)) {
+			if(_class(self)->_locked) {
+				Raise_Error(_SC("trying to modify a class that has already been instantiated"));
+				return false;
+			}
+			else {
+				SQObjectPtr oval = PrintObjVal(key);
+				Raise_Error(_SC("the property '%s' already exists"),_stringval(oval));
+				return false;
+			}
+		}
+		break;
+	default:
+		Raise_Error(_SC("indexing %s with %s"),GetTypeName(self),GetTypeName(key));
+		return false;
+		break;
+	}
+	return true;
+}
+
+bool SQVM::DeleteSlot(const SQObjectPtr &self,const SQObjectPtr &key,SQObjectPtr &res)
+{
+	switch(type(self)) {
+	case OT_TABLE:
+	case OT_INSTANCE:
+	case OT_USERDATA: {
+		SQObjectPtr t;
+		bool handled = false;
+		if(_delegable(self)->_delegate) {
+			Push(self);Push(key);
+			handled = CallMetaMethod(_delegable(self),MT_DELSLOT,2,t);
+		}
+
+		if(!handled) {
+			if(type(self) == OT_TABLE) {
+				if(_table(self)->Get(key,t)) {
+					_table(self)->Remove(key);
+				}
+				else {
+					Raise_IdxError((SQObject &)key);
+					return false;
+				}
+			}
+			else {
+				Raise_Error(_SC("cannot delete a slot from %s"),GetTypeName(self));
+				return false;
+			}
+		}
+		res = t;
+				}
+		break;
+	default:
+		Raise_Error(_SC("attempt to delete a slot from a %s"),GetTypeName(self));
+		return false;
+	}
+	return true;
+}
+
+bool SQVM::Call(SQObjectPtr &closure,SQInteger nparams,SQInteger stackbase,SQObjectPtr &outres,SQBool raiseerror)
+{
+#ifdef _DEBUG
+SQInteger prevstackbase = _stackbase;
+#endif
+	switch(type(closure)) {
+	case OT_CLOSURE:
+		return Execute(closure, _top - nparams, nparams, stackbase,outres,raiseerror);
+		break;
+	case OT_NATIVECLOSURE:{
+		bool suspend;
+		return CallNative(_nativeclosure(closure), nparams, stackbase, outres,suspend);
+		
+						  }
+		break;
+	case OT_CLASS: {
+		SQObjectPtr constr;
+		SQObjectPtr temp;
+		CreateClassInstance(_class(closure),outres,constr);
+		if(type(constr) != OT_NULL) {
+			_stack[stackbase] = outres;
+			return Call(constr,nparams,stackbase,temp,raiseerror);
+		}
+		return true;
+				   }
+		break;
+	default:
+		return false;
+	}
+#ifdef _DEBUG
+	if(!_suspended) {
+		assert(_stackbase == prevstackbase);
+	}
+#endif
+	return true;
+}
+
+bool SQVM::CallMetaMethod(SQDelegable *del,SQMetaMethod mm,SQInteger nparams,SQObjectPtr &outres)
+{
+	SQObjectPtr closure;
+	if(del->GetMetaMethod(this, mm, closure)) {
+		if(Call(closure, nparams, _top - nparams, outres, SQFalse)) {
+			Pop(nparams);
+			return true;
+		}
+	}
+	Pop(nparams);
+	return false;
+}
+
+void SQVM::Remove(SQInteger n) {
+	n = (n >= 0)?n + _stackbase - 1:_top + n;
+	for(SQInteger i = n; i < _top; i++){
+		_stack[i] = _stack[i+1];
+	}
+	_stack[_top] = _null_;
+	_top--;
+}
+
+void SQVM::Pop() {
+	_stack[--_top] = _null_;
+}
+
+void SQVM::Pop(SQInteger n) {
+	for(SQInteger i = 0; i < n; i++){
+		_stack[--_top] = _null_;
+	}
+}
+
+void SQVM::Push(const SQObjectPtr &o) { _stack[_top++] = o; }
+SQObjectPtr &SQVM::Top() { return _stack[_top-1]; }
+SQObjectPtr &SQVM::PopGet() { return _stack[--_top]; }
+SQObjectPtr &SQVM::GetUp(SQInteger n) { return _stack[_top+n]; }
+SQObjectPtr &SQVM::GetAt(SQInteger n) { return _stack[n]; }
+
+#ifdef _DEBUG_DUMP
+void SQVM::dumpstack(SQInteger stackbase,bool dumpall)
+{
+	SQInteger size=dumpall?_stack.size():_top;
+	SQInteger n=0;
+	scprintf(_SC("\n>>>>stack dump<<<<\n"));
+	CallInfo &ci=_callsstack[_callsstacksize-1];
+	scprintf(_SC("IP: %p\n"),ci._ip);
+	scprintf(_SC("prev stack base: %d\n"),ci._prevstkbase);
+	scprintf(_SC("prev top: %d\n"),ci._prevtop);
+	for(SQInteger i=0;i<size;i++){
+		SQObjectPtr &obj=_stack[i];	
+		if(stackbase==i)scprintf(_SC(">"));else scprintf(_SC(" "));
+		scprintf(_SC("[%d]:"),n);
+		switch(type(obj)){
+		case OT_FLOAT:			scprintf(_SC("FLOAT %.3f"),_float(obj));break;
+		case OT_INTEGER:		scprintf(_SC("INTEGER %d"),_integer(obj));break;
+		case OT_BOOL:			scprintf(_SC("BOOL %s"),_integer(obj)?"true":"false");break;
+		case OT_STRING:			scprintf(_SC("STRING %s"),_stringval(obj));break;
+		case OT_NULL:			scprintf(_SC("NULL"));	break;
+		case OT_TABLE:			scprintf(_SC("TABLE %p[%p]"),_table(obj),_table(obj)->_delegate);break;
+		case OT_ARRAY:			scprintf(_SC("ARRAY %p"),_array(obj));break;
+		case OT_CLOSURE:		scprintf(_SC("CLOSURE [%p]"),_closure(obj));break;
+		case OT_NATIVECLOSURE:	scprintf(_SC("NATIVECLOSURE"));break;
+		case OT_USERDATA:		scprintf(_SC("USERDATA %p[%p]"),_userdataval(obj),_userdata(obj)->_delegate);break;
+		case OT_GENERATOR:		scprintf(_SC("GENERATOR %p"),_generator(obj));break;
+		case OT_THREAD:			scprintf(_SC("THREAD [%p]"),_thread(obj));break;
+		case OT_USERPOINTER:	scprintf(_SC("USERPOINTER %p"),_userpointer(obj));break;
+		case OT_CLASS:			scprintf(_SC("CLASS %p"),_class(obj));break;
+		case OT_INSTANCE:		scprintf(_SC("INSTANCE %p"),_instance(obj));break;
+		case OT_WEAKREF:		scprintf(_SC("WEAKERF %p"),_weakref(obj));break;
+		default:
+			assert(0);
+			break;
+		};
+		scprintf(_SC("\n"));
+		++n;
+	}
+}
+
+
+
+#endif

Added: trunk/windstille/lib/SQUIRREL2/squirrel/sqvm.h
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel/sqvm.h	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel/sqvm.h	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,204 @@
+/*	see copyright notice in squirrel.h */
+#ifndef _SQVM_H_
+#define _SQVM_H_
+
+#include "sqopcodes.h"
+#include "sqobject.h"
+#define MAX_NATIVE_CALLS 100
+#define MIN_STACK_OVERHEAD 10
+
+#define SQ_SUSPEND_FLAG -666
+//base lib
+void sq_base_register(HSQUIRRELVM v);
+
+struct SQExceptionTrap{
+	SQExceptionTrap() {}
+	SQExceptionTrap(SQInteger ss, SQInteger stackbase,SQInstruction *ip, SQInteger ex_target){ _stacksize = ss; _stackbase = stackbase; _ip = ip; _extarget = ex_target;}
+	SQExceptionTrap(const SQExceptionTrap &et) { (*this) = et;	}
+	SQInteger _stackbase;
+	SQInteger _stacksize;
+	SQInstruction *_ip;
+	SQInteger _extarget;
+};
+
+#define _INLINE 
+
+#define STK(a) _stack._vals[_stackbase+(a)]
+#define TARGET _stack._vals[_stackbase+arg0]
+
+typedef sqvector<SQExceptionTrap> ExceptionsTraps;
+
+struct SQVM : public CHAINABLE_OBJ
+{
+	struct VarArgs {
+		VarArgs() { size = 0; base = 0; }
+		unsigned short size;
+		unsigned short base;
+	};
+
+	struct CallInfo{
+		//CallInfo() { _generator._type = OT_NULL;}
+		SQInstruction *_ip;
+		SQObjectPtr *_literals;
+		SQObjectPtr _closure;
+		SQGenerator *_generator;
+		SQInt32 _etraps;
+		SQInt32 _prevstkbase;
+		SQInt32 _prevtop;
+		SQInt32 _target;
+		SQInt32 _ncalls;
+		SQBool _root;
+		VarArgs _vargs;
+	};
+	
+typedef sqvector<CallInfo> CallInfoVec;
+public:
+	enum ExecutionType { ET_CALL, ET_RESUME_GENERATOR, ET_RESUME_VM };
+	SQVM(SQSharedState *ss);
+	~SQVM();
+	bool Init(SQVM *friendvm, SQInteger stacksize);
+	bool Execute(SQObjectPtr &func, SQInteger target, SQInteger nargs, SQInteger stackbase, SQObjectPtr &outres, SQBool raiseerror, ExecutionType et = ET_CALL);
+	//starts a native call return when the NATIVE closure returns
+	bool CallNative(SQNativeClosure *nclosure, SQInteger nargs, SQInteger stackbase, SQObjectPtr &retval,bool &suspend);
+	//starts a SQUIRREL call in the same "Execution loop"
+	bool StartCall(SQClosure *closure, SQInteger target, SQInteger nargs, SQInteger stackbase, bool tailcall);
+	bool CreateClassInstance(SQClass *theclass, SQObjectPtr &inst, SQObjectPtr &constructor);
+	//call a generic closure pure SQUIRREL or NATIVE
+	bool Call(SQObjectPtr &closure, SQInteger nparams, SQInteger stackbase, SQObjectPtr &outres,SQBool raiseerror);
+	SQRESULT Suspend();
+
+	void CallDebugHook(SQInteger type,SQInteger forcedline=0);
+	void CallErrorHandler(SQObjectPtr &e);
+	bool Get(const SQObjectPtr &self, const SQObjectPtr &key, SQObjectPtr &dest, bool raw, bool fetchroot);
+	bool FallBackGet(const SQObjectPtr &self,const SQObjectPtr &key,SQObjectPtr &dest,bool raw);
+	bool Set(const SQObjectPtr &self, const SQObjectPtr &key, const SQObjectPtr &val, bool fetchroot);
+	bool NewSlot(const SQObjectPtr &self, const SQObjectPtr &key, const SQObjectPtr &val,bool bstatic);
+	bool DeleteSlot(const SQObjectPtr &self, const SQObjectPtr &key, SQObjectPtr &res);
+	bool Clone(const SQObjectPtr &self, SQObjectPtr &target);
+	bool ObjCmp(const SQObjectPtr &o1, const SQObjectPtr &o2,SQInteger &res);
+	bool StringCat(const SQObjectPtr &str, const SQObjectPtr &obj, SQObjectPtr &dest);
+	bool IsEqual(SQObjectPtr &o1,SQObjectPtr &o2,bool &res);
+	void ToString(const SQObjectPtr &o,SQObjectPtr &res);
+	SQString *PrintObjVal(const SQObject &o);
+
+ 
+	void Raise_Error(const SQChar *s, ...);
+	void Raise_Error(SQObjectPtr &desc);
+	void Raise_IdxError(SQObject &o);
+	void Raise_CompareError(const SQObject &o1, const SQObject &o2);
+	void Raise_ParamTypeError(SQInteger nparam,SQInteger typemask,SQInteger type);
+
+	void TypeOf(const SQObjectPtr &obj1, SQObjectPtr &dest);
+	bool CallMetaMethod(SQDelegable *del, SQMetaMethod mm, SQInteger nparams, SQObjectPtr &outres);
+	bool ArithMetaMethod(SQInteger op, const SQObjectPtr &o1, const SQObjectPtr &o2, SQObjectPtr &dest);
+	bool Return(SQInteger _arg0, SQInteger _arg1, SQObjectPtr &retval);
+	//new stuff
+	_INLINE bool ARITH_OP(SQUnsignedInteger op,SQObjectPtr &trg,const SQObjectPtr &o1,const SQObjectPtr &o2);
+	_INLINE bool BW_OP(SQUnsignedInteger op,SQObjectPtr &trg,const SQObjectPtr &o1,const SQObjectPtr &o2);
+	_INLINE bool NEG_OP(SQObjectPtr &trg,const SQObjectPtr &o1);
+	_INLINE bool CMP_OP(CmpOP op, const SQObjectPtr &o1,const SQObjectPtr &o2,SQObjectPtr &res);
+	bool CLOSURE_OP(SQObjectPtr &target, SQFunctionProto *func);
+	bool GETVARGV_OP(SQObjectPtr &target,SQObjectPtr &idx,CallInfo *ci);
+	bool CLASS_OP(SQObjectPtr &target,SQInteger base,SQInteger attrs);
+	bool GETPARENT_OP(SQObjectPtr &o,SQObjectPtr &target);
+	//return true if the loop is finished
+	bool FOREACH_OP(SQObjectPtr &o1,SQObjectPtr &o2,SQObjectPtr &o3,SQObjectPtr &o4,SQInteger arg_2,int exitpos,int &jump);
+	bool DELEGATE_OP(SQObjectPtr &trg,SQObjectPtr &o1,SQObjectPtr &o2);
+	_INLINE bool LOCAL_INC(SQInteger op,SQObjectPtr &target, SQObjectPtr &a, SQObjectPtr &incr);
+	_INLINE bool PLOCAL_INC(SQInteger op,SQObjectPtr &target, SQObjectPtr &a, SQObjectPtr &incr);
+	_INLINE bool DerefInc(SQInteger op,SQObjectPtr &target, SQObjectPtr &self, SQObjectPtr &key, SQObjectPtr &incr, bool postfix);
+	void PopVarArgs(VarArgs &vargs);
+#ifdef _DEBUG_DUMP
+	void dumpstack(SQInteger stackbase=-1, bool dumpall = false);
+#endif
+
+#ifndef NO_GARBAGE_COLLECTOR
+	void Mark(SQCollectable **chain);
+#endif
+	void Finalize();
+	void GrowCallStack() {
+		SQInteger newsize = _alloccallsstacksize*2;
+		_callstackdata.resize(newsize);
+		_callsstack = &_callstackdata[0];
+		_alloccallsstacksize = newsize;
+	}
+	void Release(){ sq_delete(this,SQVM); } //does nothing
+////////////////////////////////////////////////////////////////////////////
+	//stack functions for the api
+	void Remove(SQInteger n);
+
+	bool IsFalse(SQObjectPtr &o);
+	
+	void Pop();
+	void Pop(SQInteger n);
+	void Push(const SQObjectPtr &o);
+	SQObjectPtr &Top();
+	SQObjectPtr &PopGet();
+	SQObjectPtr &GetUp(SQInteger n);
+	SQObjectPtr &GetAt(SQInteger n);
+
+	SQObjectPtrVec _stack;
+	SQObjectPtrVec _vargsstack;
+	SQInteger _top;
+	SQInteger _stackbase;
+	SQObjectPtr _roottable;
+	SQObjectPtr _lasterror;
+	SQObjectPtr _errorhandler;
+	SQObjectPtr _debughook;
+
+	SQObjectPtr temp_reg;
+	
+
+	CallInfo* _callsstack;
+	SQInteger _callsstacksize;
+	SQInteger _alloccallsstacksize;
+	sqvector<CallInfo>  _callstackdata;
+
+	ExceptionsTraps _etraps;
+	CallInfo *ci;
+	void *_foreignptr;
+	//VMs sharing the same state
+	SQSharedState *_sharedstate;
+	SQInteger _nnativecalls;
+	//suspend infos
+	SQBool _suspended;
+	SQBool _suspended_root;
+	SQInteger _suspended_target;
+	SQInteger _suspended_traps;
+	VarArgs _suspend_varargs;
+};
+
+struct AutoDec{
+	AutoDec(SQInteger *n) { _n = n; }
+	~AutoDec() { (*_n)--; }
+	SQInteger *_n;
+};
+
+inline SQObjectPtr &stack_get(HSQUIRRELVM v,SQInteger idx){return ((idx>=0)?(v->GetAt(idx+v->_stackbase-1)):(v->GetUp(idx)));}
+
+#define _ss(_vm_) (_vm_)->_sharedstate
+
+#ifndef NO_GARBAGE_COLLECTOR
+#define _opt_ss(_vm_) (_vm_)->_sharedstate
+#else
+#define _opt_ss(_vm_) NULL
+#endif
+
+#define PUSH_CALLINFO(v,nci){ \
+	if(v->_callsstacksize == v->_alloccallsstacksize) { \
+		v->GrowCallStack(); \
+	} \
+	v->ci = &v->_callsstack[v->_callsstacksize]; \
+	*(v->ci) = nci; \
+	v->_callsstacksize++; \
+}
+
+#define POP_CALLINFO(v){ \
+	v->_callsstacksize--; \
+	v->ci->_closure.Null(); \
+	if(v->_callsstacksize)	\
+		v->ci = &v->_callsstack[v->_callsstacksize-1] ; \
+	else	\
+		v->ci = NULL; \
+}
+#endif //_SQVM_H_

Added: trunk/windstille/lib/SQUIRREL2/squirrel.dsw
===================================================================
--- trunk/windstille/lib/SQUIRREL2/squirrel.dsw	2008-06-27 10:48:29 UTC (rev 2269)
+++ trunk/windstille/lib/SQUIRREL2/squirrel.dsw	2008-06-27 10:49:53 UTC (rev 2270)
@@ -0,0 +1,77 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "sq"=.\sq\sq.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+    begin source code control
+    .
+    end source code control
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name sqlibs
+    End Project Dependency
+    Begin Project Dependency
+    Project_Dep_Name squirrel
+    End Project Dependency
+    Begin Project Dependency
+    Project_Dep_Name sqstdlib
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "sqstdlib"=.\sqstdlib\sqstdlib.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+    begin source code control
+    "$/squirrel", HAAAAAAA
+    .
+    end source code control
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "squirrel"=.\squirrel\squirrel.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+    begin source code control
+    "$/squirrel", HAAAAAAA
+    .
+    end source code control
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+    begin source code control
+    "$/squirrel", HAAAAAAA
+    .
+    end source code control
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+



